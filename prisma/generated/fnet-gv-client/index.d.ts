
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model accountingentrytb
 * 
 */
export type accountingentrytb = $Result.DefaultSelection<Prisma.$accountingentrytbPayload>
/**
 * Model anonymoustb
 * 
 */
export type anonymoustb = $Result.DefaultSelection<Prisma.$anonymoustbPayload>
/**
 * Model applicationrenttb
 * 
 */
export type applicationrenttb = $Result.DefaultSelection<Prisma.$applicationrenttbPayload>
/**
 * Model applicationtb
 * 
 */
export type applicationtb = $Result.DefaultSelection<Prisma.$applicationtbPayload>
/**
 * Model blacklisttb
 * 
 */
export type blacklisttb = $Result.DefaultSelection<Prisma.$blacklisttbPayload>
/**
 * Model changepcdetailtb
 * 
 */
export type changepcdetailtb = $Result.DefaultSelection<Prisma.$changepcdetailtbPayload>
/**
 * Model clientatb
 * 
 */
export type clientatb = $Result.DefaultSelection<Prisma.$clientatbPayload>
/**
 * Model clientsystb
 * 
 */
export type clientsystb = $Result.DefaultSelection<Prisma.$clientsystbPayload>
/**
 * Model combodetailtb
 * 
 */
export type combodetailtb = $Result.DefaultSelection<Prisma.$combodetailtbPayload>
/**
 * Model combodonatetb
 * 
 */
export type combodonatetb = $Result.DefaultSelection<Prisma.$combodonatetbPayload>
/**
 * Model combotb
 * 
 */
export type combotb = $Result.DefaultSelection<Prisma.$combotbPayload>
/**
 * Model combousagetb
 * 
 */
export type combousagetb = $Result.DefaultSelection<Prisma.$combousagetbPayload>
/**
 * Model convertunittb
 * 
 */
export type convertunittb = $Result.DefaultSelection<Prisma.$convertunittbPayload>
/**
 * Model dptb
 * 
 */
export type dptb = $Result.DefaultSelection<Prisma.$dptbPayload>
/**
 * Model freetimedetailtb
 * 
 */
export type freetimedetailtb = $Result.DefaultSelection<Prisma.$freetimedetailtbPayload>
/**
 * Model functiontb
 * 
 */
export type functiontb = $Result.DefaultSelection<Prisma.$functiontbPayload>
/**
 * Model gamefoldertb
 * 
 */
export type gamefoldertb = $Result.DefaultSelection<Prisma.$gamefoldertbPayload>
/**
 * Model gamelisttb
 * 
 */
export type gamelisttb = $Result.DefaultSelection<Prisma.$gamelisttbPayload>
/**
 * Model hptb
 * 
 */
export type hptb = $Result.DefaultSelection<Prisma.$hptbPayload>
/**
 * Model intoptiontb
 * 
 */
export type intoptiontb = $Result.DefaultSelection<Prisma.$intoptiontbPayload>
/**
 * Model inventorytb
 * 
 */
export type inventorytb = $Result.DefaultSelection<Prisma.$inventorytbPayload>
/**
 * Model legalapptb
 * 
 */
export type legalapptb = $Result.DefaultSelection<Prisma.$legalapptbPayload>
/**
 * Model machinegrouptb
 * 
 */
export type machinegrouptb = $Result.DefaultSelection<Prisma.$machinegrouptbPayload>
/**
 * Model paymenttb
 * 
 */
export type paymenttb = $Result.DefaultSelection<Prisma.$paymenttbPayload>
/**
 * Model paymentwaittb
 * 
 */
export type paymentwaittb = $Result.DefaultSelection<Prisma.$paymentwaittbPayload>
/**
 * Model priceapprenttb
 * 
 */
export type priceapprenttb = $Result.DefaultSelection<Prisma.$priceapprenttbPayload>
/**
 * Model priceapprentusetb
 * 
 */
export type priceapprentusetb = $Result.DefaultSelection<Prisma.$priceapprentusetbPayload>
/**
 * Model pricedetailtb
 * 
 */
export type pricedetailtb = $Result.DefaultSelection<Prisma.$pricedetailtbPayload>
/**
 * Model pricelisttb
 * 
 */
export type pricelisttb = $Result.DefaultSelection<Prisma.$pricelisttbPayload>
/**
 * Model pricemachinetb
 * 
 */
export type pricemachinetb = $Result.DefaultSelection<Prisma.$pricemachinetbPayload>
/**
 * Model printertb
 * 
 */
export type printertb = $Result.DefaultSelection<Prisma.$printertbPayload>
/**
 * Model printservicetb
 * 
 */
export type printservicetb = $Result.DefaultSelection<Prisma.$printservicetbPayload>
/**
 * Model processtb
 * 
 */
export type processtb = $Result.DefaultSelection<Prisma.$processtbPayload>
/**
 * Model rechargecarddetailtb
 * 
 */
export type rechargecarddetailtb = $Result.DefaultSelection<Prisma.$rechargecarddetailtbPayload>
/**
 * Model rechargecardtb
 * 
 */
export type rechargecardtb = $Result.DefaultSelection<Prisma.$rechargecardtbPayload>
/**
 * Model reportdaily
 * 
 */
export type reportdaily = $Result.DefaultSelection<Prisma.$reportdailyPayload>
/**
 * Model reportmonthly
 * 
 */
export type reportmonthly = $Result.DefaultSelection<Prisma.$reportmonthlyPayload>
/**
 * Model righttb
 * 
 */
export type righttb = $Result.DefaultSelection<Prisma.$righttbPayload>
/**
 * Model serverlogtb
 * 
 */
export type serverlogtb = $Result.DefaultSelection<Prisma.$serverlogtbPayload>
/**
 * Model servicedetailtb
 * 
 */
export type servicedetailtb = $Result.DefaultSelection<Prisma.$servicedetailtbPayload>
/**
 * Model servicegiftsbag
 * 
 */
export type servicegiftsbag = $Result.DefaultSelection<Prisma.$servicegiftsbagPayload>
/**
 * Model servicegrouptb
 * 
 */
export type servicegrouptb = $Result.DefaultSelection<Prisma.$servicegrouptbPayload>
/**
 * Model serviceinfologtb
 * 
 */
export type serviceinfologtb = $Result.DefaultSelection<Prisma.$serviceinfologtbPayload>
/**
 * Model serviceinfotb
 * 
 */
export type serviceinfotb = $Result.DefaultSelection<Prisma.$serviceinfotbPayload>
/**
 * Model servicetb
 * 
 */
export type servicetb = $Result.DefaultSelection<Prisma.$servicetbPayload>
/**
 * Model serviceunittb
 * 
 */
export type serviceunittb = $Result.DefaultSelection<Prisma.$serviceunittbPayload>
/**
 * Model servicevisit
 * 
 */
export type servicevisit = $Result.DefaultSelection<Prisma.$servicevisitPayload>
/**
 * Model settingtb
 * 
 */
export type settingtb = $Result.DefaultSelection<Prisma.$settingtbPayload>
/**
 * Model softwaretb
 * 
 */
export type softwaretb = $Result.DefaultSelection<Prisma.$softwaretbPayload>
/**
 * Model specappdetailtb
 * 
 */
export type specappdetailtb = $Result.DefaultSelection<Prisma.$specappdetailtbPayload>
/**
 * Model standardservicetb
 * 
 */
export type standardservicetb = $Result.DefaultSelection<Prisma.$standardservicetbPayload>
/**
 * Model stocktakingtb
 * 
 */
export type stocktakingtb = $Result.DefaultSelection<Prisma.$stocktakingtbPayload>
/**
 * Model supports
 * 
 */
export type supports = $Result.DefaultSelection<Prisma.$supportsPayload>
/**
 * Model systemfunctiontb
 * 
 */
export type systemfunctiontb = $Result.DefaultSelection<Prisma.$systemfunctiontbPayload>
/**
 * Model systemlogtb
 * 
 */
export type systemlogtb = $Result.DefaultSelection<Prisma.$systemlogtbPayload>
/**
 * Model trackappdetailtb
 * 
 */
export type trackappdetailtb = $Result.DefaultSelection<Prisma.$trackappdetailtbPayload>
/**
 * Model trackapptb
 * 
 */
export type trackapptb = $Result.DefaultSelection<Prisma.$trackapptbPayload>
/**
 * Model trackguitb
 * 
 */
export type trackguitb = $Result.DefaultSelection<Prisma.$trackguitbPayload>
/**
 * Model transferdetailtb
 * 
 */
export type transferdetailtb = $Result.DefaultSelection<Prisma.$transferdetailtbPayload>
/**
 * Model usagetimetb
 * 
 */
export type usagetimetb = $Result.DefaultSelection<Prisma.$usagetimetbPayload>
/**
 * Model usertb
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type usertb = $Result.DefaultSelection<Prisma.$usertbPayload>
/**
 * Model versiontb
 * 
 */
export type versiontb = $Result.DefaultSelection<Prisma.$versiontbPayload>
/**
 * Model wallettb
 * 
 */
export type wallettb = $Result.DefaultSelection<Prisma.$wallettbPayload>
/**
 * Model webhistorytb
 * 
 */
export type webhistorytb = $Result.DefaultSelection<Prisma.$webhistorytbPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accountingentrytbs
 * const accountingentrytbs = await prisma.accountingentrytb.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accountingentrytbs
   * const accountingentrytbs = await prisma.accountingentrytb.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.accountingentrytb`: Exposes CRUD operations for the **accountingentrytb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accountingentrytbs
    * const accountingentrytbs = await prisma.accountingentrytb.findMany()
    * ```
    */
  get accountingentrytb(): Prisma.accountingentrytbDelegate<ExtArgs>;

  /**
   * `prisma.anonymoustb`: Exposes CRUD operations for the **anonymoustb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anonymoustbs
    * const anonymoustbs = await prisma.anonymoustb.findMany()
    * ```
    */
  get anonymoustb(): Prisma.anonymoustbDelegate<ExtArgs>;

  /**
   * `prisma.applicationrenttb`: Exposes CRUD operations for the **applicationrenttb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicationrenttbs
    * const applicationrenttbs = await prisma.applicationrenttb.findMany()
    * ```
    */
  get applicationrenttb(): Prisma.applicationrenttbDelegate<ExtArgs>;

  /**
   * `prisma.applicationtb`: Exposes CRUD operations for the **applicationtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicationtbs
    * const applicationtbs = await prisma.applicationtb.findMany()
    * ```
    */
  get applicationtb(): Prisma.applicationtbDelegate<ExtArgs>;

  /**
   * `prisma.blacklisttb`: Exposes CRUD operations for the **blacklisttb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blacklisttbs
    * const blacklisttbs = await prisma.blacklisttb.findMany()
    * ```
    */
  get blacklisttb(): Prisma.blacklisttbDelegate<ExtArgs>;

  /**
   * `prisma.changepcdetailtb`: Exposes CRUD operations for the **changepcdetailtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Changepcdetailtbs
    * const changepcdetailtbs = await prisma.changepcdetailtb.findMany()
    * ```
    */
  get changepcdetailtb(): Prisma.changepcdetailtbDelegate<ExtArgs>;

  /**
   * `prisma.clientatb`: Exposes CRUD operations for the **clientatb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientatbs
    * const clientatbs = await prisma.clientatb.findMany()
    * ```
    */
  get clientatb(): Prisma.clientatbDelegate<ExtArgs>;

  /**
   * `prisma.clientsystb`: Exposes CRUD operations for the **clientsystb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientsystbs
    * const clientsystbs = await prisma.clientsystb.findMany()
    * ```
    */
  get clientsystb(): Prisma.clientsystbDelegate<ExtArgs>;

  /**
   * `prisma.combodetailtb`: Exposes CRUD operations for the **combodetailtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Combodetailtbs
    * const combodetailtbs = await prisma.combodetailtb.findMany()
    * ```
    */
  get combodetailtb(): Prisma.combodetailtbDelegate<ExtArgs>;

  /**
   * `prisma.combodonatetb`: Exposes CRUD operations for the **combodonatetb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Combodonatetbs
    * const combodonatetbs = await prisma.combodonatetb.findMany()
    * ```
    */
  get combodonatetb(): Prisma.combodonatetbDelegate<ExtArgs>;

  /**
   * `prisma.combotb`: Exposes CRUD operations for the **combotb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Combotbs
    * const combotbs = await prisma.combotb.findMany()
    * ```
    */
  get combotb(): Prisma.combotbDelegate<ExtArgs>;

  /**
   * `prisma.combousagetb`: Exposes CRUD operations for the **combousagetb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Combousagetbs
    * const combousagetbs = await prisma.combousagetb.findMany()
    * ```
    */
  get combousagetb(): Prisma.combousagetbDelegate<ExtArgs>;

  /**
   * `prisma.convertunittb`: Exposes CRUD operations for the **convertunittb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Convertunittbs
    * const convertunittbs = await prisma.convertunittb.findMany()
    * ```
    */
  get convertunittb(): Prisma.convertunittbDelegate<ExtArgs>;

  /**
   * `prisma.dptb`: Exposes CRUD operations for the **dptb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dptbs
    * const dptbs = await prisma.dptb.findMany()
    * ```
    */
  get dptb(): Prisma.dptbDelegate<ExtArgs>;

  /**
   * `prisma.freetimedetailtb`: Exposes CRUD operations for the **freetimedetailtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Freetimedetailtbs
    * const freetimedetailtbs = await prisma.freetimedetailtb.findMany()
    * ```
    */
  get freetimedetailtb(): Prisma.freetimedetailtbDelegate<ExtArgs>;

  /**
   * `prisma.functiontb`: Exposes CRUD operations for the **functiontb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Functiontbs
    * const functiontbs = await prisma.functiontb.findMany()
    * ```
    */
  get functiontb(): Prisma.functiontbDelegate<ExtArgs>;

  /**
   * `prisma.gamefoldertb`: Exposes CRUD operations for the **gamefoldertb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gamefoldertbs
    * const gamefoldertbs = await prisma.gamefoldertb.findMany()
    * ```
    */
  get gamefoldertb(): Prisma.gamefoldertbDelegate<ExtArgs>;

  /**
   * `prisma.gamelisttb`: Exposes CRUD operations for the **gamelisttb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gamelisttbs
    * const gamelisttbs = await prisma.gamelisttb.findMany()
    * ```
    */
  get gamelisttb(): Prisma.gamelisttbDelegate<ExtArgs>;

  /**
   * `prisma.hptb`: Exposes CRUD operations for the **hptb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hptbs
    * const hptbs = await prisma.hptb.findMany()
    * ```
    */
  get hptb(): Prisma.hptbDelegate<ExtArgs>;

  /**
   * `prisma.intoptiontb`: Exposes CRUD operations for the **intoptiontb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Intoptiontbs
    * const intoptiontbs = await prisma.intoptiontb.findMany()
    * ```
    */
  get intoptiontb(): Prisma.intoptiontbDelegate<ExtArgs>;

  /**
   * `prisma.inventorytb`: Exposes CRUD operations for the **inventorytb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventorytbs
    * const inventorytbs = await prisma.inventorytb.findMany()
    * ```
    */
  get inventorytb(): Prisma.inventorytbDelegate<ExtArgs>;

  /**
   * `prisma.legalapptb`: Exposes CRUD operations for the **legalapptb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Legalapptbs
    * const legalapptbs = await prisma.legalapptb.findMany()
    * ```
    */
  get legalapptb(): Prisma.legalapptbDelegate<ExtArgs>;

  /**
   * `prisma.machinegrouptb`: Exposes CRUD operations for the **machinegrouptb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Machinegrouptbs
    * const machinegrouptbs = await prisma.machinegrouptb.findMany()
    * ```
    */
  get machinegrouptb(): Prisma.machinegrouptbDelegate<ExtArgs>;

  /**
   * `prisma.paymenttb`: Exposes CRUD operations for the **paymenttb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paymenttbs
    * const paymenttbs = await prisma.paymenttb.findMany()
    * ```
    */
  get paymenttb(): Prisma.paymenttbDelegate<ExtArgs>;

  /**
   * `prisma.paymentwaittb`: Exposes CRUD operations for the **paymentwaittb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paymentwaittbs
    * const paymentwaittbs = await prisma.paymentwaittb.findMany()
    * ```
    */
  get paymentwaittb(): Prisma.paymentwaittbDelegate<ExtArgs>;

  /**
   * `prisma.priceapprenttb`: Exposes CRUD operations for the **priceapprenttb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Priceapprenttbs
    * const priceapprenttbs = await prisma.priceapprenttb.findMany()
    * ```
    */
  get priceapprenttb(): Prisma.priceapprenttbDelegate<ExtArgs>;

  /**
   * `prisma.priceapprentusetb`: Exposes CRUD operations for the **priceapprentusetb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Priceapprentusetbs
    * const priceapprentusetbs = await prisma.priceapprentusetb.findMany()
    * ```
    */
  get priceapprentusetb(): Prisma.priceapprentusetbDelegate<ExtArgs>;

  /**
   * `prisma.pricedetailtb`: Exposes CRUD operations for the **pricedetailtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pricedetailtbs
    * const pricedetailtbs = await prisma.pricedetailtb.findMany()
    * ```
    */
  get pricedetailtb(): Prisma.pricedetailtbDelegate<ExtArgs>;

  /**
   * `prisma.pricelisttb`: Exposes CRUD operations for the **pricelisttb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pricelisttbs
    * const pricelisttbs = await prisma.pricelisttb.findMany()
    * ```
    */
  get pricelisttb(): Prisma.pricelisttbDelegate<ExtArgs>;

  /**
   * `prisma.pricemachinetb`: Exposes CRUD operations for the **pricemachinetb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pricemachinetbs
    * const pricemachinetbs = await prisma.pricemachinetb.findMany()
    * ```
    */
  get pricemachinetb(): Prisma.pricemachinetbDelegate<ExtArgs>;

  /**
   * `prisma.printertb`: Exposes CRUD operations for the **printertb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Printertbs
    * const printertbs = await prisma.printertb.findMany()
    * ```
    */
  get printertb(): Prisma.printertbDelegate<ExtArgs>;

  /**
   * `prisma.printservicetb`: Exposes CRUD operations for the **printservicetb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Printservicetbs
    * const printservicetbs = await prisma.printservicetb.findMany()
    * ```
    */
  get printservicetb(): Prisma.printservicetbDelegate<ExtArgs>;

  /**
   * `prisma.processtb`: Exposes CRUD operations for the **processtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Processtbs
    * const processtbs = await prisma.processtb.findMany()
    * ```
    */
  get processtb(): Prisma.processtbDelegate<ExtArgs>;

  /**
   * `prisma.rechargecarddetailtb`: Exposes CRUD operations for the **rechargecarddetailtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rechargecarddetailtbs
    * const rechargecarddetailtbs = await prisma.rechargecarddetailtb.findMany()
    * ```
    */
  get rechargecarddetailtb(): Prisma.rechargecarddetailtbDelegate<ExtArgs>;

  /**
   * `prisma.rechargecardtb`: Exposes CRUD operations for the **rechargecardtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rechargecardtbs
    * const rechargecardtbs = await prisma.rechargecardtb.findMany()
    * ```
    */
  get rechargecardtb(): Prisma.rechargecardtbDelegate<ExtArgs>;

  /**
   * `prisma.reportdaily`: Exposes CRUD operations for the **reportdaily** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reportdailies
    * const reportdailies = await prisma.reportdaily.findMany()
    * ```
    */
  get reportdaily(): Prisma.reportdailyDelegate<ExtArgs>;

  /**
   * `prisma.reportmonthly`: Exposes CRUD operations for the **reportmonthly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reportmonthlies
    * const reportmonthlies = await prisma.reportmonthly.findMany()
    * ```
    */
  get reportmonthly(): Prisma.reportmonthlyDelegate<ExtArgs>;

  /**
   * `prisma.righttb`: Exposes CRUD operations for the **righttb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Righttbs
    * const righttbs = await prisma.righttb.findMany()
    * ```
    */
  get righttb(): Prisma.righttbDelegate<ExtArgs>;

  /**
   * `prisma.serverlogtb`: Exposes CRUD operations for the **serverlogtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Serverlogtbs
    * const serverlogtbs = await prisma.serverlogtb.findMany()
    * ```
    */
  get serverlogtb(): Prisma.serverlogtbDelegate<ExtArgs>;

  /**
   * `prisma.servicedetailtb`: Exposes CRUD operations for the **servicedetailtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicedetailtbs
    * const servicedetailtbs = await prisma.servicedetailtb.findMany()
    * ```
    */
  get servicedetailtb(): Prisma.servicedetailtbDelegate<ExtArgs>;

  /**
   * `prisma.servicegiftsbag`: Exposes CRUD operations for the **servicegiftsbag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicegiftsbags
    * const servicegiftsbags = await prisma.servicegiftsbag.findMany()
    * ```
    */
  get servicegiftsbag(): Prisma.servicegiftsbagDelegate<ExtArgs>;

  /**
   * `prisma.servicegrouptb`: Exposes CRUD operations for the **servicegrouptb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicegrouptbs
    * const servicegrouptbs = await prisma.servicegrouptb.findMany()
    * ```
    */
  get servicegrouptb(): Prisma.servicegrouptbDelegate<ExtArgs>;

  /**
   * `prisma.serviceinfologtb`: Exposes CRUD operations for the **serviceinfologtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Serviceinfologtbs
    * const serviceinfologtbs = await prisma.serviceinfologtb.findMany()
    * ```
    */
  get serviceinfologtb(): Prisma.serviceinfologtbDelegate<ExtArgs>;

  /**
   * `prisma.serviceinfotb`: Exposes CRUD operations for the **serviceinfotb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Serviceinfotbs
    * const serviceinfotbs = await prisma.serviceinfotb.findMany()
    * ```
    */
  get serviceinfotb(): Prisma.serviceinfotbDelegate<ExtArgs>;

  /**
   * `prisma.servicetb`: Exposes CRUD operations for the **servicetb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicetbs
    * const servicetbs = await prisma.servicetb.findMany()
    * ```
    */
  get servicetb(): Prisma.servicetbDelegate<ExtArgs>;

  /**
   * `prisma.serviceunittb`: Exposes CRUD operations for the **serviceunittb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Serviceunittbs
    * const serviceunittbs = await prisma.serviceunittb.findMany()
    * ```
    */
  get serviceunittb(): Prisma.serviceunittbDelegate<ExtArgs>;

  /**
   * `prisma.servicevisit`: Exposes CRUD operations for the **servicevisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicevisits
    * const servicevisits = await prisma.servicevisit.findMany()
    * ```
    */
  get servicevisit(): Prisma.servicevisitDelegate<ExtArgs>;

  /**
   * `prisma.settingtb`: Exposes CRUD operations for the **settingtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settingtbs
    * const settingtbs = await prisma.settingtb.findMany()
    * ```
    */
  get settingtb(): Prisma.settingtbDelegate<ExtArgs>;

  /**
   * `prisma.softwaretb`: Exposes CRUD operations for the **softwaretb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Softwaretbs
    * const softwaretbs = await prisma.softwaretb.findMany()
    * ```
    */
  get softwaretb(): Prisma.softwaretbDelegate<ExtArgs>;

  /**
   * `prisma.specappdetailtb`: Exposes CRUD operations for the **specappdetailtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specappdetailtbs
    * const specappdetailtbs = await prisma.specappdetailtb.findMany()
    * ```
    */
  get specappdetailtb(): Prisma.specappdetailtbDelegate<ExtArgs>;

  /**
   * `prisma.standardservicetb`: Exposes CRUD operations for the **standardservicetb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Standardservicetbs
    * const standardservicetbs = await prisma.standardservicetb.findMany()
    * ```
    */
  get standardservicetb(): Prisma.standardservicetbDelegate<ExtArgs>;

  /**
   * `prisma.stocktakingtb`: Exposes CRUD operations for the **stocktakingtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocktakingtbs
    * const stocktakingtbs = await prisma.stocktakingtb.findMany()
    * ```
    */
  get stocktakingtb(): Prisma.stocktakingtbDelegate<ExtArgs>;

  /**
   * `prisma.supports`: Exposes CRUD operations for the **supports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supports
    * const supports = await prisma.supports.findMany()
    * ```
    */
  get supports(): Prisma.supportsDelegate<ExtArgs>;

  /**
   * `prisma.systemfunctiontb`: Exposes CRUD operations for the **systemfunctiontb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Systemfunctiontbs
    * const systemfunctiontbs = await prisma.systemfunctiontb.findMany()
    * ```
    */
  get systemfunctiontb(): Prisma.systemfunctiontbDelegate<ExtArgs>;

  /**
   * `prisma.systemlogtb`: Exposes CRUD operations for the **systemlogtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Systemlogtbs
    * const systemlogtbs = await prisma.systemlogtb.findMany()
    * ```
    */
  get systemlogtb(): Prisma.systemlogtbDelegate<ExtArgs>;

  /**
   * `prisma.trackappdetailtb`: Exposes CRUD operations for the **trackappdetailtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trackappdetailtbs
    * const trackappdetailtbs = await prisma.trackappdetailtb.findMany()
    * ```
    */
  get trackappdetailtb(): Prisma.trackappdetailtbDelegate<ExtArgs>;

  /**
   * `prisma.trackapptb`: Exposes CRUD operations for the **trackapptb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trackapptbs
    * const trackapptbs = await prisma.trackapptb.findMany()
    * ```
    */
  get trackapptb(): Prisma.trackapptbDelegate<ExtArgs>;

  /**
   * `prisma.trackguitb`: Exposes CRUD operations for the **trackguitb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trackguitbs
    * const trackguitbs = await prisma.trackguitb.findMany()
    * ```
    */
  get trackguitb(): Prisma.trackguitbDelegate<ExtArgs>;

  /**
   * `prisma.transferdetailtb`: Exposes CRUD operations for the **transferdetailtb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transferdetailtbs
    * const transferdetailtbs = await prisma.transferdetailtb.findMany()
    * ```
    */
  get transferdetailtb(): Prisma.transferdetailtbDelegate<ExtArgs>;

  /**
   * `prisma.usagetimetb`: Exposes CRUD operations for the **usagetimetb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usagetimetbs
    * const usagetimetbs = await prisma.usagetimetb.findMany()
    * ```
    */
  get usagetimetb(): Prisma.usagetimetbDelegate<ExtArgs>;

  /**
   * `prisma.usertb`: Exposes CRUD operations for the **usertb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usertbs
    * const usertbs = await prisma.usertb.findMany()
    * ```
    */
  get usertb(): Prisma.usertbDelegate<ExtArgs>;

  /**
   * `prisma.versiontb`: Exposes CRUD operations for the **versiontb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Versiontbs
    * const versiontbs = await prisma.versiontb.findMany()
    * ```
    */
  get versiontb(): Prisma.versiontbDelegate<ExtArgs>;

  /**
   * `prisma.wallettb`: Exposes CRUD operations for the **wallettb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallettbs
    * const wallettbs = await prisma.wallettb.findMany()
    * ```
    */
  get wallettb(): Prisma.wallettbDelegate<ExtArgs>;

  /**
   * `prisma.webhistorytb`: Exposes CRUD operations for the **webhistorytb** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhistorytbs
    * const webhistorytbs = await prisma.webhistorytb.findMany()
    * ```
    */
  get webhistorytb(): Prisma.webhistorytbDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    accountingentrytb: 'accountingentrytb',
    anonymoustb: 'anonymoustb',
    applicationrenttb: 'applicationrenttb',
    applicationtb: 'applicationtb',
    blacklisttb: 'blacklisttb',
    changepcdetailtb: 'changepcdetailtb',
    clientatb: 'clientatb',
    clientsystb: 'clientsystb',
    combodetailtb: 'combodetailtb',
    combodonatetb: 'combodonatetb',
    combotb: 'combotb',
    combousagetb: 'combousagetb',
    convertunittb: 'convertunittb',
    dptb: 'dptb',
    freetimedetailtb: 'freetimedetailtb',
    functiontb: 'functiontb',
    gamefoldertb: 'gamefoldertb',
    gamelisttb: 'gamelisttb',
    hptb: 'hptb',
    intoptiontb: 'intoptiontb',
    inventorytb: 'inventorytb',
    legalapptb: 'legalapptb',
    machinegrouptb: 'machinegrouptb',
    paymenttb: 'paymenttb',
    paymentwaittb: 'paymentwaittb',
    priceapprenttb: 'priceapprenttb',
    priceapprentusetb: 'priceapprentusetb',
    pricedetailtb: 'pricedetailtb',
    pricelisttb: 'pricelisttb',
    pricemachinetb: 'pricemachinetb',
    printertb: 'printertb',
    printservicetb: 'printservicetb',
    processtb: 'processtb',
    rechargecarddetailtb: 'rechargecarddetailtb',
    rechargecardtb: 'rechargecardtb',
    reportdaily: 'reportdaily',
    reportmonthly: 'reportmonthly',
    righttb: 'righttb',
    serverlogtb: 'serverlogtb',
    servicedetailtb: 'servicedetailtb',
    servicegiftsbag: 'servicegiftsbag',
    servicegrouptb: 'servicegrouptb',
    serviceinfologtb: 'serviceinfologtb',
    serviceinfotb: 'serviceinfotb',
    servicetb: 'servicetb',
    serviceunittb: 'serviceunittb',
    servicevisit: 'servicevisit',
    settingtb: 'settingtb',
    softwaretb: 'softwaretb',
    specappdetailtb: 'specappdetailtb',
    standardservicetb: 'standardservicetb',
    stocktakingtb: 'stocktakingtb',
    supports: 'supports',
    systemfunctiontb: 'systemfunctiontb',
    systemlogtb: 'systemlogtb',
    trackappdetailtb: 'trackappdetailtb',
    trackapptb: 'trackapptb',
    trackguitb: 'trackguitb',
    transferdetailtb: 'transferdetailtb',
    usagetimetb: 'usagetimetb',
    usertb: 'usertb',
    versiontb: 'versiontb',
    wallettb: 'wallettb',
    webhistorytb: 'webhistorytb'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "accountingentrytb" | "anonymoustb" | "applicationrenttb" | "applicationtb" | "blacklisttb" | "changepcdetailtb" | "clientatb" | "clientsystb" | "combodetailtb" | "combodonatetb" | "combotb" | "combousagetb" | "convertunittb" | "dptb" | "freetimedetailtb" | "functiontb" | "gamefoldertb" | "gamelisttb" | "hptb" | "intoptiontb" | "inventorytb" | "legalapptb" | "machinegrouptb" | "paymenttb" | "paymentwaittb" | "priceapprenttb" | "priceapprentusetb" | "pricedetailtb" | "pricelisttb" | "pricemachinetb" | "printertb" | "printservicetb" | "processtb" | "rechargecarddetailtb" | "rechargecardtb" | "reportdaily" | "reportmonthly" | "righttb" | "serverlogtb" | "servicedetailtb" | "servicegiftsbag" | "servicegrouptb" | "serviceinfologtb" | "serviceinfotb" | "servicetb" | "serviceunittb" | "servicevisit" | "settingtb" | "softwaretb" | "specappdetailtb" | "standardservicetb" | "stocktakingtb" | "supports" | "systemfunctiontb" | "systemlogtb" | "trackappdetailtb" | "trackapptb" | "trackguitb" | "transferdetailtb" | "usagetimetb" | "usertb" | "versiontb" | "wallettb" | "webhistorytb"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      accountingentrytb: {
        payload: Prisma.$accountingentrytbPayload<ExtArgs>
        fields: Prisma.accountingentrytbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountingentrytbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountingentrytbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountingentrytbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountingentrytbPayload>
          }
          findFirst: {
            args: Prisma.accountingentrytbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountingentrytbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountingentrytbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountingentrytbPayload>
          }
          findMany: {
            args: Prisma.accountingentrytbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountingentrytbPayload>[]
          }
          create: {
            args: Prisma.accountingentrytbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountingentrytbPayload>
          }
          createMany: {
            args: Prisma.accountingentrytbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accountingentrytbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountingentrytbPayload>
          }
          update: {
            args: Prisma.accountingentrytbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountingentrytbPayload>
          }
          deleteMany: {
            args: Prisma.accountingentrytbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountingentrytbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accountingentrytbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountingentrytbPayload>
          }
          aggregate: {
            args: Prisma.AccountingentrytbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountingentrytb>
          }
          groupBy: {
            args: Prisma.accountingentrytbGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountingentrytbGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountingentrytbCountArgs<ExtArgs>
            result: $Utils.Optional<AccountingentrytbCountAggregateOutputType> | number
          }
        }
      }
      anonymoustb: {
        payload: Prisma.$anonymoustbPayload<ExtArgs>
        fields: Prisma.anonymoustbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.anonymoustbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anonymoustbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.anonymoustbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anonymoustbPayload>
          }
          findFirst: {
            args: Prisma.anonymoustbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anonymoustbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.anonymoustbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anonymoustbPayload>
          }
          findMany: {
            args: Prisma.anonymoustbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anonymoustbPayload>[]
          }
          create: {
            args: Prisma.anonymoustbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anonymoustbPayload>
          }
          createMany: {
            args: Prisma.anonymoustbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.anonymoustbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anonymoustbPayload>
          }
          update: {
            args: Prisma.anonymoustbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anonymoustbPayload>
          }
          deleteMany: {
            args: Prisma.anonymoustbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.anonymoustbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.anonymoustbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anonymoustbPayload>
          }
          aggregate: {
            args: Prisma.AnonymoustbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnonymoustb>
          }
          groupBy: {
            args: Prisma.anonymoustbGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnonymoustbGroupByOutputType>[]
          }
          count: {
            args: Prisma.anonymoustbCountArgs<ExtArgs>
            result: $Utils.Optional<AnonymoustbCountAggregateOutputType> | number
          }
        }
      }
      applicationrenttb: {
        payload: Prisma.$applicationrenttbPayload<ExtArgs>
        fields: Prisma.applicationrenttbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationrenttbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationrenttbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationrenttbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationrenttbPayload>
          }
          findFirst: {
            args: Prisma.applicationrenttbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationrenttbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationrenttbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationrenttbPayload>
          }
          findMany: {
            args: Prisma.applicationrenttbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationrenttbPayload>[]
          }
          create: {
            args: Prisma.applicationrenttbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationrenttbPayload>
          }
          createMany: {
            args: Prisma.applicationrenttbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.applicationrenttbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationrenttbPayload>
          }
          update: {
            args: Prisma.applicationrenttbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationrenttbPayload>
          }
          deleteMany: {
            args: Prisma.applicationrenttbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicationrenttbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.applicationrenttbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationrenttbPayload>
          }
          aggregate: {
            args: Prisma.ApplicationrenttbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationrenttb>
          }
          groupBy: {
            args: Prisma.applicationrenttbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationrenttbGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicationrenttbCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationrenttbCountAggregateOutputType> | number
          }
        }
      }
      applicationtb: {
        payload: Prisma.$applicationtbPayload<ExtArgs>
        fields: Prisma.applicationtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicationtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicationtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtbPayload>
          }
          findFirst: {
            args: Prisma.applicationtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicationtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtbPayload>
          }
          findMany: {
            args: Prisma.applicationtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtbPayload>[]
          }
          create: {
            args: Prisma.applicationtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtbPayload>
          }
          createMany: {
            args: Prisma.applicationtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.applicationtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtbPayload>
          }
          update: {
            args: Prisma.applicationtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtbPayload>
          }
          deleteMany: {
            args: Prisma.applicationtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicationtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.applicationtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicationtbPayload>
          }
          aggregate: {
            args: Prisma.ApplicationtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicationtb>
          }
          groupBy: {
            args: Prisma.applicationtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicationtbCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationtbCountAggregateOutputType> | number
          }
        }
      }
      blacklisttb: {
        payload: Prisma.$blacklisttbPayload<ExtArgs>
        fields: Prisma.blacklisttbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blacklisttbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blacklisttbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blacklisttbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blacklisttbPayload>
          }
          findFirst: {
            args: Prisma.blacklisttbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blacklisttbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blacklisttbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blacklisttbPayload>
          }
          findMany: {
            args: Prisma.blacklisttbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blacklisttbPayload>[]
          }
          create: {
            args: Prisma.blacklisttbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blacklisttbPayload>
          }
          createMany: {
            args: Prisma.blacklisttbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.blacklisttbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blacklisttbPayload>
          }
          update: {
            args: Prisma.blacklisttbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blacklisttbPayload>
          }
          deleteMany: {
            args: Prisma.blacklisttbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blacklisttbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.blacklisttbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blacklisttbPayload>
          }
          aggregate: {
            args: Prisma.BlacklisttbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlacklisttb>
          }
          groupBy: {
            args: Prisma.blacklisttbGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlacklisttbGroupByOutputType>[]
          }
          count: {
            args: Prisma.blacklisttbCountArgs<ExtArgs>
            result: $Utils.Optional<BlacklisttbCountAggregateOutputType> | number
          }
        }
      }
      changepcdetailtb: {
        payload: Prisma.$changepcdetailtbPayload<ExtArgs>
        fields: Prisma.changepcdetailtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.changepcdetailtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$changepcdetailtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.changepcdetailtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$changepcdetailtbPayload>
          }
          findFirst: {
            args: Prisma.changepcdetailtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$changepcdetailtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.changepcdetailtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$changepcdetailtbPayload>
          }
          findMany: {
            args: Prisma.changepcdetailtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$changepcdetailtbPayload>[]
          }
          create: {
            args: Prisma.changepcdetailtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$changepcdetailtbPayload>
          }
          createMany: {
            args: Prisma.changepcdetailtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.changepcdetailtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$changepcdetailtbPayload>
          }
          update: {
            args: Prisma.changepcdetailtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$changepcdetailtbPayload>
          }
          deleteMany: {
            args: Prisma.changepcdetailtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.changepcdetailtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.changepcdetailtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$changepcdetailtbPayload>
          }
          aggregate: {
            args: Prisma.ChangepcdetailtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangepcdetailtb>
          }
          groupBy: {
            args: Prisma.changepcdetailtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangepcdetailtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.changepcdetailtbCountArgs<ExtArgs>
            result: $Utils.Optional<ChangepcdetailtbCountAggregateOutputType> | number
          }
        }
      }
      clientatb: {
        payload: Prisma.$clientatbPayload<ExtArgs>
        fields: Prisma.clientatbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientatbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientatbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientatbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientatbPayload>
          }
          findFirst: {
            args: Prisma.clientatbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientatbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientatbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientatbPayload>
          }
          findMany: {
            args: Prisma.clientatbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientatbPayload>[]
          }
          create: {
            args: Prisma.clientatbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientatbPayload>
          }
          createMany: {
            args: Prisma.clientatbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clientatbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientatbPayload>
          }
          update: {
            args: Prisma.clientatbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientatbPayload>
          }
          deleteMany: {
            args: Prisma.clientatbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientatbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clientatbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientatbPayload>
          }
          aggregate: {
            args: Prisma.ClientatbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientatb>
          }
          groupBy: {
            args: Prisma.clientatbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientatbGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientatbCountArgs<ExtArgs>
            result: $Utils.Optional<ClientatbCountAggregateOutputType> | number
          }
        }
      }
      clientsystb: {
        payload: Prisma.$clientsystbPayload<ExtArgs>
        fields: Prisma.clientsystbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientsystbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsystbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientsystbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsystbPayload>
          }
          findFirst: {
            args: Prisma.clientsystbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsystbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientsystbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsystbPayload>
          }
          findMany: {
            args: Prisma.clientsystbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsystbPayload>[]
          }
          create: {
            args: Prisma.clientsystbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsystbPayload>
          }
          createMany: {
            args: Prisma.clientsystbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clientsystbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsystbPayload>
          }
          update: {
            args: Prisma.clientsystbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsystbPayload>
          }
          deleteMany: {
            args: Prisma.clientsystbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientsystbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clientsystbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsystbPayload>
          }
          aggregate: {
            args: Prisma.ClientsystbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientsystb>
          }
          groupBy: {
            args: Prisma.clientsystbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientsystbGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientsystbCountArgs<ExtArgs>
            result: $Utils.Optional<ClientsystbCountAggregateOutputType> | number
          }
        }
      }
      combodetailtb: {
        payload: Prisma.$combodetailtbPayload<ExtArgs>
        fields: Prisma.combodetailtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.combodetailtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodetailtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.combodetailtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodetailtbPayload>
          }
          findFirst: {
            args: Prisma.combodetailtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodetailtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.combodetailtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodetailtbPayload>
          }
          findMany: {
            args: Prisma.combodetailtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodetailtbPayload>[]
          }
          create: {
            args: Prisma.combodetailtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodetailtbPayload>
          }
          createMany: {
            args: Prisma.combodetailtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.combodetailtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodetailtbPayload>
          }
          update: {
            args: Prisma.combodetailtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodetailtbPayload>
          }
          deleteMany: {
            args: Prisma.combodetailtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.combodetailtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.combodetailtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodetailtbPayload>
          }
          aggregate: {
            args: Prisma.CombodetailtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombodetailtb>
          }
          groupBy: {
            args: Prisma.combodetailtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombodetailtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.combodetailtbCountArgs<ExtArgs>
            result: $Utils.Optional<CombodetailtbCountAggregateOutputType> | number
          }
        }
      }
      combodonatetb: {
        payload: Prisma.$combodonatetbPayload<ExtArgs>
        fields: Prisma.combodonatetbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.combodonatetbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodonatetbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.combodonatetbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodonatetbPayload>
          }
          findFirst: {
            args: Prisma.combodonatetbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodonatetbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.combodonatetbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodonatetbPayload>
          }
          findMany: {
            args: Prisma.combodonatetbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodonatetbPayload>[]
          }
          create: {
            args: Prisma.combodonatetbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodonatetbPayload>
          }
          createMany: {
            args: Prisma.combodonatetbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.combodonatetbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodonatetbPayload>
          }
          update: {
            args: Prisma.combodonatetbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodonatetbPayload>
          }
          deleteMany: {
            args: Prisma.combodonatetbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.combodonatetbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.combodonatetbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combodonatetbPayload>
          }
          aggregate: {
            args: Prisma.CombodonatetbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombodonatetb>
          }
          groupBy: {
            args: Prisma.combodonatetbGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombodonatetbGroupByOutputType>[]
          }
          count: {
            args: Prisma.combodonatetbCountArgs<ExtArgs>
            result: $Utils.Optional<CombodonatetbCountAggregateOutputType> | number
          }
        }
      }
      combotb: {
        payload: Prisma.$combotbPayload<ExtArgs>
        fields: Prisma.combotbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.combotbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combotbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.combotbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combotbPayload>
          }
          findFirst: {
            args: Prisma.combotbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combotbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.combotbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combotbPayload>
          }
          findMany: {
            args: Prisma.combotbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combotbPayload>[]
          }
          create: {
            args: Prisma.combotbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combotbPayload>
          }
          createMany: {
            args: Prisma.combotbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.combotbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combotbPayload>
          }
          update: {
            args: Prisma.combotbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combotbPayload>
          }
          deleteMany: {
            args: Prisma.combotbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.combotbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.combotbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combotbPayload>
          }
          aggregate: {
            args: Prisma.CombotbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombotb>
          }
          groupBy: {
            args: Prisma.combotbGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombotbGroupByOutputType>[]
          }
          count: {
            args: Prisma.combotbCountArgs<ExtArgs>
            result: $Utils.Optional<CombotbCountAggregateOutputType> | number
          }
        }
      }
      combousagetb: {
        payload: Prisma.$combousagetbPayload<ExtArgs>
        fields: Prisma.combousagetbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.combousagetbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combousagetbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.combousagetbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combousagetbPayload>
          }
          findFirst: {
            args: Prisma.combousagetbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combousagetbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.combousagetbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combousagetbPayload>
          }
          findMany: {
            args: Prisma.combousagetbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combousagetbPayload>[]
          }
          create: {
            args: Prisma.combousagetbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combousagetbPayload>
          }
          createMany: {
            args: Prisma.combousagetbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.combousagetbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combousagetbPayload>
          }
          update: {
            args: Prisma.combousagetbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combousagetbPayload>
          }
          deleteMany: {
            args: Prisma.combousagetbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.combousagetbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.combousagetbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$combousagetbPayload>
          }
          aggregate: {
            args: Prisma.CombousagetbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombousagetb>
          }
          groupBy: {
            args: Prisma.combousagetbGroupByArgs<ExtArgs>
            result: $Utils.Optional<CombousagetbGroupByOutputType>[]
          }
          count: {
            args: Prisma.combousagetbCountArgs<ExtArgs>
            result: $Utils.Optional<CombousagetbCountAggregateOutputType> | number
          }
        }
      }
      convertunittb: {
        payload: Prisma.$convertunittbPayload<ExtArgs>
        fields: Prisma.convertunittbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.convertunittbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$convertunittbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.convertunittbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$convertunittbPayload>
          }
          findFirst: {
            args: Prisma.convertunittbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$convertunittbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.convertunittbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$convertunittbPayload>
          }
          findMany: {
            args: Prisma.convertunittbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$convertunittbPayload>[]
          }
          create: {
            args: Prisma.convertunittbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$convertunittbPayload>
          }
          createMany: {
            args: Prisma.convertunittbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.convertunittbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$convertunittbPayload>
          }
          update: {
            args: Prisma.convertunittbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$convertunittbPayload>
          }
          deleteMany: {
            args: Prisma.convertunittbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.convertunittbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.convertunittbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$convertunittbPayload>
          }
          aggregate: {
            args: Prisma.ConvertunittbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConvertunittb>
          }
          groupBy: {
            args: Prisma.convertunittbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConvertunittbGroupByOutputType>[]
          }
          count: {
            args: Prisma.convertunittbCountArgs<ExtArgs>
            result: $Utils.Optional<ConvertunittbCountAggregateOutputType> | number
          }
        }
      }
      dptb: {
        payload: Prisma.$dptbPayload<ExtArgs>
        fields: Prisma.dptbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dptbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dptbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dptbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dptbPayload>
          }
          findFirst: {
            args: Prisma.dptbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dptbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dptbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dptbPayload>
          }
          findMany: {
            args: Prisma.dptbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dptbPayload>[]
          }
          create: {
            args: Prisma.dptbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dptbPayload>
          }
          createMany: {
            args: Prisma.dptbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.dptbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dptbPayload>
          }
          update: {
            args: Prisma.dptbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dptbPayload>
          }
          deleteMany: {
            args: Prisma.dptbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dptbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dptbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dptbPayload>
          }
          aggregate: {
            args: Prisma.DptbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDptb>
          }
          groupBy: {
            args: Prisma.dptbGroupByArgs<ExtArgs>
            result: $Utils.Optional<DptbGroupByOutputType>[]
          }
          count: {
            args: Prisma.dptbCountArgs<ExtArgs>
            result: $Utils.Optional<DptbCountAggregateOutputType> | number
          }
        }
      }
      freetimedetailtb: {
        payload: Prisma.$freetimedetailtbPayload<ExtArgs>
        fields: Prisma.freetimedetailtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.freetimedetailtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freetimedetailtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.freetimedetailtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freetimedetailtbPayload>
          }
          findFirst: {
            args: Prisma.freetimedetailtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freetimedetailtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.freetimedetailtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freetimedetailtbPayload>
          }
          findMany: {
            args: Prisma.freetimedetailtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freetimedetailtbPayload>[]
          }
          create: {
            args: Prisma.freetimedetailtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freetimedetailtbPayload>
          }
          createMany: {
            args: Prisma.freetimedetailtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.freetimedetailtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freetimedetailtbPayload>
          }
          update: {
            args: Prisma.freetimedetailtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freetimedetailtbPayload>
          }
          deleteMany: {
            args: Prisma.freetimedetailtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.freetimedetailtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.freetimedetailtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$freetimedetailtbPayload>
          }
          aggregate: {
            args: Prisma.FreetimedetailtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreetimedetailtb>
          }
          groupBy: {
            args: Prisma.freetimedetailtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreetimedetailtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.freetimedetailtbCountArgs<ExtArgs>
            result: $Utils.Optional<FreetimedetailtbCountAggregateOutputType> | number
          }
        }
      }
      functiontb: {
        payload: Prisma.$functiontbPayload<ExtArgs>
        fields: Prisma.functiontbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.functiontbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functiontbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.functiontbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functiontbPayload>
          }
          findFirst: {
            args: Prisma.functiontbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functiontbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.functiontbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functiontbPayload>
          }
          findMany: {
            args: Prisma.functiontbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functiontbPayload>[]
          }
          create: {
            args: Prisma.functiontbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functiontbPayload>
          }
          createMany: {
            args: Prisma.functiontbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.functiontbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functiontbPayload>
          }
          update: {
            args: Prisma.functiontbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functiontbPayload>
          }
          deleteMany: {
            args: Prisma.functiontbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.functiontbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.functiontbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$functiontbPayload>
          }
          aggregate: {
            args: Prisma.FunctiontbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunctiontb>
          }
          groupBy: {
            args: Prisma.functiontbGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunctiontbGroupByOutputType>[]
          }
          count: {
            args: Prisma.functiontbCountArgs<ExtArgs>
            result: $Utils.Optional<FunctiontbCountAggregateOutputType> | number
          }
        }
      }
      gamefoldertb: {
        payload: Prisma.$gamefoldertbPayload<ExtArgs>
        fields: Prisma.gamefoldertbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gamefoldertbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamefoldertbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gamefoldertbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamefoldertbPayload>
          }
          findFirst: {
            args: Prisma.gamefoldertbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamefoldertbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gamefoldertbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamefoldertbPayload>
          }
          findMany: {
            args: Prisma.gamefoldertbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamefoldertbPayload>[]
          }
          create: {
            args: Prisma.gamefoldertbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamefoldertbPayload>
          }
          createMany: {
            args: Prisma.gamefoldertbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.gamefoldertbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamefoldertbPayload>
          }
          update: {
            args: Prisma.gamefoldertbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamefoldertbPayload>
          }
          deleteMany: {
            args: Prisma.gamefoldertbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gamefoldertbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gamefoldertbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamefoldertbPayload>
          }
          aggregate: {
            args: Prisma.GamefoldertbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGamefoldertb>
          }
          groupBy: {
            args: Prisma.gamefoldertbGroupByArgs<ExtArgs>
            result: $Utils.Optional<GamefoldertbGroupByOutputType>[]
          }
          count: {
            args: Prisma.gamefoldertbCountArgs<ExtArgs>
            result: $Utils.Optional<GamefoldertbCountAggregateOutputType> | number
          }
        }
      }
      gamelisttb: {
        payload: Prisma.$gamelisttbPayload<ExtArgs>
        fields: Prisma.gamelisttbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.gamelisttbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamelisttbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.gamelisttbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamelisttbPayload>
          }
          findFirst: {
            args: Prisma.gamelisttbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamelisttbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.gamelisttbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamelisttbPayload>
          }
          findMany: {
            args: Prisma.gamelisttbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamelisttbPayload>[]
          }
          create: {
            args: Prisma.gamelisttbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamelisttbPayload>
          }
          createMany: {
            args: Prisma.gamelisttbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.gamelisttbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamelisttbPayload>
          }
          update: {
            args: Prisma.gamelisttbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamelisttbPayload>
          }
          deleteMany: {
            args: Prisma.gamelisttbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.gamelisttbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.gamelisttbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$gamelisttbPayload>
          }
          aggregate: {
            args: Prisma.GamelisttbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGamelisttb>
          }
          groupBy: {
            args: Prisma.gamelisttbGroupByArgs<ExtArgs>
            result: $Utils.Optional<GamelisttbGroupByOutputType>[]
          }
          count: {
            args: Prisma.gamelisttbCountArgs<ExtArgs>
            result: $Utils.Optional<GamelisttbCountAggregateOutputType> | number
          }
        }
      }
      hptb: {
        payload: Prisma.$hptbPayload<ExtArgs>
        fields: Prisma.hptbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hptbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hptbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hptbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hptbPayload>
          }
          findFirst: {
            args: Prisma.hptbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hptbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hptbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hptbPayload>
          }
          findMany: {
            args: Prisma.hptbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hptbPayload>[]
          }
          create: {
            args: Prisma.hptbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hptbPayload>
          }
          createMany: {
            args: Prisma.hptbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hptbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hptbPayload>
          }
          update: {
            args: Prisma.hptbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hptbPayload>
          }
          deleteMany: {
            args: Prisma.hptbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hptbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hptbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hptbPayload>
          }
          aggregate: {
            args: Prisma.HptbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHptb>
          }
          groupBy: {
            args: Prisma.hptbGroupByArgs<ExtArgs>
            result: $Utils.Optional<HptbGroupByOutputType>[]
          }
          count: {
            args: Prisma.hptbCountArgs<ExtArgs>
            result: $Utils.Optional<HptbCountAggregateOutputType> | number
          }
        }
      }
      intoptiontb: {
        payload: Prisma.$intoptiontbPayload<ExtArgs>
        fields: Prisma.intoptiontbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.intoptiontbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intoptiontbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.intoptiontbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intoptiontbPayload>
          }
          findFirst: {
            args: Prisma.intoptiontbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intoptiontbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.intoptiontbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intoptiontbPayload>
          }
          findMany: {
            args: Prisma.intoptiontbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intoptiontbPayload>[]
          }
          create: {
            args: Prisma.intoptiontbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intoptiontbPayload>
          }
          createMany: {
            args: Prisma.intoptiontbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.intoptiontbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intoptiontbPayload>
          }
          update: {
            args: Prisma.intoptiontbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intoptiontbPayload>
          }
          deleteMany: {
            args: Prisma.intoptiontbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.intoptiontbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.intoptiontbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$intoptiontbPayload>
          }
          aggregate: {
            args: Prisma.IntoptiontbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntoptiontb>
          }
          groupBy: {
            args: Prisma.intoptiontbGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntoptiontbGroupByOutputType>[]
          }
          count: {
            args: Prisma.intoptiontbCountArgs<ExtArgs>
            result: $Utils.Optional<IntoptiontbCountAggregateOutputType> | number
          }
        }
      }
      inventorytb: {
        payload: Prisma.$inventorytbPayload<ExtArgs>
        fields: Prisma.inventorytbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventorytbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventorytbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventorytbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventorytbPayload>
          }
          findFirst: {
            args: Prisma.inventorytbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventorytbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventorytbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventorytbPayload>
          }
          findMany: {
            args: Prisma.inventorytbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventorytbPayload>[]
          }
          create: {
            args: Prisma.inventorytbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventorytbPayload>
          }
          createMany: {
            args: Prisma.inventorytbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.inventorytbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventorytbPayload>
          }
          update: {
            args: Prisma.inventorytbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventorytbPayload>
          }
          deleteMany: {
            args: Prisma.inventorytbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventorytbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.inventorytbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventorytbPayload>
          }
          aggregate: {
            args: Prisma.InventorytbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventorytb>
          }
          groupBy: {
            args: Prisma.inventorytbGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventorytbGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventorytbCountArgs<ExtArgs>
            result: $Utils.Optional<InventorytbCountAggregateOutputType> | number
          }
        }
      }
      legalapptb: {
        payload: Prisma.$legalapptbPayload<ExtArgs>
        fields: Prisma.legalapptbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.legalapptbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$legalapptbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.legalapptbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$legalapptbPayload>
          }
          findFirst: {
            args: Prisma.legalapptbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$legalapptbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.legalapptbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$legalapptbPayload>
          }
          findMany: {
            args: Prisma.legalapptbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$legalapptbPayload>[]
          }
          create: {
            args: Prisma.legalapptbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$legalapptbPayload>
          }
          createMany: {
            args: Prisma.legalapptbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.legalapptbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$legalapptbPayload>
          }
          update: {
            args: Prisma.legalapptbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$legalapptbPayload>
          }
          deleteMany: {
            args: Prisma.legalapptbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.legalapptbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.legalapptbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$legalapptbPayload>
          }
          aggregate: {
            args: Prisma.LegalapptbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLegalapptb>
          }
          groupBy: {
            args: Prisma.legalapptbGroupByArgs<ExtArgs>
            result: $Utils.Optional<LegalapptbGroupByOutputType>[]
          }
          count: {
            args: Prisma.legalapptbCountArgs<ExtArgs>
            result: $Utils.Optional<LegalapptbCountAggregateOutputType> | number
          }
        }
      }
      machinegrouptb: {
        payload: Prisma.$machinegrouptbPayload<ExtArgs>
        fields: Prisma.machinegrouptbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.machinegrouptbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinegrouptbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.machinegrouptbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinegrouptbPayload>
          }
          findFirst: {
            args: Prisma.machinegrouptbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinegrouptbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.machinegrouptbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinegrouptbPayload>
          }
          findMany: {
            args: Prisma.machinegrouptbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinegrouptbPayload>[]
          }
          create: {
            args: Prisma.machinegrouptbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinegrouptbPayload>
          }
          createMany: {
            args: Prisma.machinegrouptbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.machinegrouptbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinegrouptbPayload>
          }
          update: {
            args: Prisma.machinegrouptbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinegrouptbPayload>
          }
          deleteMany: {
            args: Prisma.machinegrouptbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.machinegrouptbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.machinegrouptbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$machinegrouptbPayload>
          }
          aggregate: {
            args: Prisma.MachinegrouptbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMachinegrouptb>
          }
          groupBy: {
            args: Prisma.machinegrouptbGroupByArgs<ExtArgs>
            result: $Utils.Optional<MachinegrouptbGroupByOutputType>[]
          }
          count: {
            args: Prisma.machinegrouptbCountArgs<ExtArgs>
            result: $Utils.Optional<MachinegrouptbCountAggregateOutputType> | number
          }
        }
      }
      paymenttb: {
        payload: Prisma.$paymenttbPayload<ExtArgs>
        fields: Prisma.paymenttbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymenttbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymenttbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttbPayload>
          }
          findFirst: {
            args: Prisma.paymenttbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymenttbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttbPayload>
          }
          findMany: {
            args: Prisma.paymenttbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttbPayload>[]
          }
          create: {
            args: Prisma.paymenttbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttbPayload>
          }
          createMany: {
            args: Prisma.paymenttbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymenttbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttbPayload>
          }
          update: {
            args: Prisma.paymenttbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttbPayload>
          }
          deleteMany: {
            args: Prisma.paymenttbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymenttbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymenttbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymenttbPayload>
          }
          aggregate: {
            args: Prisma.PaymenttbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymenttb>
          }
          groupBy: {
            args: Prisma.paymenttbGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymenttbGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymenttbCountArgs<ExtArgs>
            result: $Utils.Optional<PaymenttbCountAggregateOutputType> | number
          }
        }
      }
      paymentwaittb: {
        payload: Prisma.$paymentwaittbPayload<ExtArgs>
        fields: Prisma.paymentwaittbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentwaittbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentwaittbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentwaittbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentwaittbPayload>
          }
          findFirst: {
            args: Prisma.paymentwaittbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentwaittbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentwaittbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentwaittbPayload>
          }
          findMany: {
            args: Prisma.paymentwaittbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentwaittbPayload>[]
          }
          create: {
            args: Prisma.paymentwaittbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentwaittbPayload>
          }
          createMany: {
            args: Prisma.paymentwaittbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymentwaittbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentwaittbPayload>
          }
          update: {
            args: Prisma.paymentwaittbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentwaittbPayload>
          }
          deleteMany: {
            args: Prisma.paymentwaittbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentwaittbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentwaittbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentwaittbPayload>
          }
          aggregate: {
            args: Prisma.PaymentwaittbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentwaittb>
          }
          groupBy: {
            args: Prisma.paymentwaittbGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentwaittbGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentwaittbCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentwaittbCountAggregateOutputType> | number
          }
        }
      }
      priceapprenttb: {
        payload: Prisma.$priceapprenttbPayload<ExtArgs>
        fields: Prisma.priceapprenttbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.priceapprenttbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprenttbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.priceapprenttbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprenttbPayload>
          }
          findFirst: {
            args: Prisma.priceapprenttbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprenttbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.priceapprenttbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprenttbPayload>
          }
          findMany: {
            args: Prisma.priceapprenttbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprenttbPayload>[]
          }
          create: {
            args: Prisma.priceapprenttbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprenttbPayload>
          }
          createMany: {
            args: Prisma.priceapprenttbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.priceapprenttbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprenttbPayload>
          }
          update: {
            args: Prisma.priceapprenttbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprenttbPayload>
          }
          deleteMany: {
            args: Prisma.priceapprenttbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.priceapprenttbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.priceapprenttbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprenttbPayload>
          }
          aggregate: {
            args: Prisma.PriceapprenttbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceapprenttb>
          }
          groupBy: {
            args: Prisma.priceapprenttbGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceapprenttbGroupByOutputType>[]
          }
          count: {
            args: Prisma.priceapprenttbCountArgs<ExtArgs>
            result: $Utils.Optional<PriceapprenttbCountAggregateOutputType> | number
          }
        }
      }
      priceapprentusetb: {
        payload: Prisma.$priceapprentusetbPayload<ExtArgs>
        fields: Prisma.priceapprentusetbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.priceapprentusetbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprentusetbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.priceapprentusetbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprentusetbPayload>
          }
          findFirst: {
            args: Prisma.priceapprentusetbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprentusetbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.priceapprentusetbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprentusetbPayload>
          }
          findMany: {
            args: Prisma.priceapprentusetbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprentusetbPayload>[]
          }
          create: {
            args: Prisma.priceapprentusetbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprentusetbPayload>
          }
          createMany: {
            args: Prisma.priceapprentusetbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.priceapprentusetbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprentusetbPayload>
          }
          update: {
            args: Prisma.priceapprentusetbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprentusetbPayload>
          }
          deleteMany: {
            args: Prisma.priceapprentusetbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.priceapprentusetbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.priceapprentusetbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$priceapprentusetbPayload>
          }
          aggregate: {
            args: Prisma.PriceapprentusetbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceapprentusetb>
          }
          groupBy: {
            args: Prisma.priceapprentusetbGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceapprentusetbGroupByOutputType>[]
          }
          count: {
            args: Prisma.priceapprentusetbCountArgs<ExtArgs>
            result: $Utils.Optional<PriceapprentusetbCountAggregateOutputType> | number
          }
        }
      }
      pricedetailtb: {
        payload: Prisma.$pricedetailtbPayload<ExtArgs>
        fields: Prisma.pricedetailtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pricedetailtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricedetailtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pricedetailtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricedetailtbPayload>
          }
          findFirst: {
            args: Prisma.pricedetailtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricedetailtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pricedetailtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricedetailtbPayload>
          }
          findMany: {
            args: Prisma.pricedetailtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricedetailtbPayload>[]
          }
          create: {
            args: Prisma.pricedetailtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricedetailtbPayload>
          }
          createMany: {
            args: Prisma.pricedetailtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pricedetailtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricedetailtbPayload>
          }
          update: {
            args: Prisma.pricedetailtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricedetailtbPayload>
          }
          deleteMany: {
            args: Prisma.pricedetailtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pricedetailtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pricedetailtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricedetailtbPayload>
          }
          aggregate: {
            args: Prisma.PricedetailtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricedetailtb>
          }
          groupBy: {
            args: Prisma.pricedetailtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricedetailtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.pricedetailtbCountArgs<ExtArgs>
            result: $Utils.Optional<PricedetailtbCountAggregateOutputType> | number
          }
        }
      }
      pricelisttb: {
        payload: Prisma.$pricelisttbPayload<ExtArgs>
        fields: Prisma.pricelisttbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pricelisttbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricelisttbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pricelisttbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricelisttbPayload>
          }
          findFirst: {
            args: Prisma.pricelisttbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricelisttbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pricelisttbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricelisttbPayload>
          }
          findMany: {
            args: Prisma.pricelisttbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricelisttbPayload>[]
          }
          create: {
            args: Prisma.pricelisttbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricelisttbPayload>
          }
          createMany: {
            args: Prisma.pricelisttbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pricelisttbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricelisttbPayload>
          }
          update: {
            args: Prisma.pricelisttbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricelisttbPayload>
          }
          deleteMany: {
            args: Prisma.pricelisttbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pricelisttbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pricelisttbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricelisttbPayload>
          }
          aggregate: {
            args: Prisma.PricelisttbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricelisttb>
          }
          groupBy: {
            args: Prisma.pricelisttbGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricelisttbGroupByOutputType>[]
          }
          count: {
            args: Prisma.pricelisttbCountArgs<ExtArgs>
            result: $Utils.Optional<PricelisttbCountAggregateOutputType> | number
          }
        }
      }
      pricemachinetb: {
        payload: Prisma.$pricemachinetbPayload<ExtArgs>
        fields: Prisma.pricemachinetbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pricemachinetbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricemachinetbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pricemachinetbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricemachinetbPayload>
          }
          findFirst: {
            args: Prisma.pricemachinetbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricemachinetbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pricemachinetbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricemachinetbPayload>
          }
          findMany: {
            args: Prisma.pricemachinetbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricemachinetbPayload>[]
          }
          create: {
            args: Prisma.pricemachinetbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricemachinetbPayload>
          }
          createMany: {
            args: Prisma.pricemachinetbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pricemachinetbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricemachinetbPayload>
          }
          update: {
            args: Prisma.pricemachinetbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricemachinetbPayload>
          }
          deleteMany: {
            args: Prisma.pricemachinetbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pricemachinetbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pricemachinetbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pricemachinetbPayload>
          }
          aggregate: {
            args: Prisma.PricemachinetbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricemachinetb>
          }
          groupBy: {
            args: Prisma.pricemachinetbGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricemachinetbGroupByOutputType>[]
          }
          count: {
            args: Prisma.pricemachinetbCountArgs<ExtArgs>
            result: $Utils.Optional<PricemachinetbCountAggregateOutputType> | number
          }
        }
      }
      printertb: {
        payload: Prisma.$printertbPayload<ExtArgs>
        fields: Prisma.printertbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.printertbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printertbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.printertbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printertbPayload>
          }
          findFirst: {
            args: Prisma.printertbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printertbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.printertbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printertbPayload>
          }
          findMany: {
            args: Prisma.printertbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printertbPayload>[]
          }
          create: {
            args: Prisma.printertbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printertbPayload>
          }
          createMany: {
            args: Prisma.printertbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.printertbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printertbPayload>
          }
          update: {
            args: Prisma.printertbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printertbPayload>
          }
          deleteMany: {
            args: Prisma.printertbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.printertbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.printertbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printertbPayload>
          }
          aggregate: {
            args: Prisma.PrintertbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrintertb>
          }
          groupBy: {
            args: Prisma.printertbGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrintertbGroupByOutputType>[]
          }
          count: {
            args: Prisma.printertbCountArgs<ExtArgs>
            result: $Utils.Optional<PrintertbCountAggregateOutputType> | number
          }
        }
      }
      printservicetb: {
        payload: Prisma.$printservicetbPayload<ExtArgs>
        fields: Prisma.printservicetbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.printservicetbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printservicetbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.printservicetbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printservicetbPayload>
          }
          findFirst: {
            args: Prisma.printservicetbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printservicetbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.printservicetbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printservicetbPayload>
          }
          findMany: {
            args: Prisma.printservicetbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printservicetbPayload>[]
          }
          create: {
            args: Prisma.printservicetbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printservicetbPayload>
          }
          createMany: {
            args: Prisma.printservicetbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.printservicetbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printservicetbPayload>
          }
          update: {
            args: Prisma.printservicetbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printservicetbPayload>
          }
          deleteMany: {
            args: Prisma.printservicetbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.printservicetbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.printservicetbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$printservicetbPayload>
          }
          aggregate: {
            args: Prisma.PrintservicetbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrintservicetb>
          }
          groupBy: {
            args: Prisma.printservicetbGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrintservicetbGroupByOutputType>[]
          }
          count: {
            args: Prisma.printservicetbCountArgs<ExtArgs>
            result: $Utils.Optional<PrintservicetbCountAggregateOutputType> | number
          }
        }
      }
      processtb: {
        payload: Prisma.$processtbPayload<ExtArgs>
        fields: Prisma.processtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.processtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$processtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.processtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$processtbPayload>
          }
          findFirst: {
            args: Prisma.processtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$processtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.processtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$processtbPayload>
          }
          findMany: {
            args: Prisma.processtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$processtbPayload>[]
          }
          create: {
            args: Prisma.processtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$processtbPayload>
          }
          createMany: {
            args: Prisma.processtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.processtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$processtbPayload>
          }
          update: {
            args: Prisma.processtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$processtbPayload>
          }
          deleteMany: {
            args: Prisma.processtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.processtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.processtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$processtbPayload>
          }
          aggregate: {
            args: Prisma.ProcesstbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProcesstb>
          }
          groupBy: {
            args: Prisma.processtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcesstbGroupByOutputType>[]
          }
          count: {
            args: Prisma.processtbCountArgs<ExtArgs>
            result: $Utils.Optional<ProcesstbCountAggregateOutputType> | number
          }
        }
      }
      rechargecarddetailtb: {
        payload: Prisma.$rechargecarddetailtbPayload<ExtArgs>
        fields: Prisma.rechargecarddetailtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rechargecarddetailtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecarddetailtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rechargecarddetailtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecarddetailtbPayload>
          }
          findFirst: {
            args: Prisma.rechargecarddetailtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecarddetailtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rechargecarddetailtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecarddetailtbPayload>
          }
          findMany: {
            args: Prisma.rechargecarddetailtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecarddetailtbPayload>[]
          }
          create: {
            args: Prisma.rechargecarddetailtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecarddetailtbPayload>
          }
          createMany: {
            args: Prisma.rechargecarddetailtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rechargecarddetailtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecarddetailtbPayload>
          }
          update: {
            args: Prisma.rechargecarddetailtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecarddetailtbPayload>
          }
          deleteMany: {
            args: Prisma.rechargecarddetailtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rechargecarddetailtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rechargecarddetailtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecarddetailtbPayload>
          }
          aggregate: {
            args: Prisma.RechargecarddetailtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRechargecarddetailtb>
          }
          groupBy: {
            args: Prisma.rechargecarddetailtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<RechargecarddetailtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.rechargecarddetailtbCountArgs<ExtArgs>
            result: $Utils.Optional<RechargecarddetailtbCountAggregateOutputType> | number
          }
        }
      }
      rechargecardtb: {
        payload: Prisma.$rechargecardtbPayload<ExtArgs>
        fields: Prisma.rechargecardtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rechargecardtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecardtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rechargecardtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecardtbPayload>
          }
          findFirst: {
            args: Prisma.rechargecardtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecardtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rechargecardtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecardtbPayload>
          }
          findMany: {
            args: Prisma.rechargecardtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecardtbPayload>[]
          }
          create: {
            args: Prisma.rechargecardtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecardtbPayload>
          }
          createMany: {
            args: Prisma.rechargecardtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rechargecardtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecardtbPayload>
          }
          update: {
            args: Prisma.rechargecardtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecardtbPayload>
          }
          deleteMany: {
            args: Prisma.rechargecardtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rechargecardtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rechargecardtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rechargecardtbPayload>
          }
          aggregate: {
            args: Prisma.RechargecardtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRechargecardtb>
          }
          groupBy: {
            args: Prisma.rechargecardtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<RechargecardtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.rechargecardtbCountArgs<ExtArgs>
            result: $Utils.Optional<RechargecardtbCountAggregateOutputType> | number
          }
        }
      }
      reportdaily: {
        payload: Prisma.$reportdailyPayload<ExtArgs>
        fields: Prisma.reportdailyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportdailyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportdailyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportdailyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportdailyPayload>
          }
          findFirst: {
            args: Prisma.reportdailyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportdailyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportdailyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportdailyPayload>
          }
          findMany: {
            args: Prisma.reportdailyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportdailyPayload>[]
          }
          create: {
            args: Prisma.reportdailyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportdailyPayload>
          }
          createMany: {
            args: Prisma.reportdailyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reportdailyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportdailyPayload>
          }
          update: {
            args: Prisma.reportdailyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportdailyPayload>
          }
          deleteMany: {
            args: Prisma.reportdailyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reportdailyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reportdailyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportdailyPayload>
          }
          aggregate: {
            args: Prisma.ReportdailyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportdaily>
          }
          groupBy: {
            args: Prisma.reportdailyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportdailyGroupByOutputType>[]
          }
          count: {
            args: Prisma.reportdailyCountArgs<ExtArgs>
            result: $Utils.Optional<ReportdailyCountAggregateOutputType> | number
          }
        }
      }
      reportmonthly: {
        payload: Prisma.$reportmonthlyPayload<ExtArgs>
        fields: Prisma.reportmonthlyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportmonthlyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportmonthlyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportmonthlyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportmonthlyPayload>
          }
          findFirst: {
            args: Prisma.reportmonthlyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportmonthlyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportmonthlyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportmonthlyPayload>
          }
          findMany: {
            args: Prisma.reportmonthlyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportmonthlyPayload>[]
          }
          create: {
            args: Prisma.reportmonthlyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportmonthlyPayload>
          }
          createMany: {
            args: Prisma.reportmonthlyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.reportmonthlyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportmonthlyPayload>
          }
          update: {
            args: Prisma.reportmonthlyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportmonthlyPayload>
          }
          deleteMany: {
            args: Prisma.reportmonthlyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reportmonthlyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.reportmonthlyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reportmonthlyPayload>
          }
          aggregate: {
            args: Prisma.ReportmonthlyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportmonthly>
          }
          groupBy: {
            args: Prisma.reportmonthlyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportmonthlyGroupByOutputType>[]
          }
          count: {
            args: Prisma.reportmonthlyCountArgs<ExtArgs>
            result: $Utils.Optional<ReportmonthlyCountAggregateOutputType> | number
          }
        }
      }
      righttb: {
        payload: Prisma.$righttbPayload<ExtArgs>
        fields: Prisma.righttbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.righttbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$righttbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.righttbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$righttbPayload>
          }
          findFirst: {
            args: Prisma.righttbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$righttbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.righttbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$righttbPayload>
          }
          findMany: {
            args: Prisma.righttbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$righttbPayload>[]
          }
          create: {
            args: Prisma.righttbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$righttbPayload>
          }
          createMany: {
            args: Prisma.righttbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.righttbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$righttbPayload>
          }
          update: {
            args: Prisma.righttbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$righttbPayload>
          }
          deleteMany: {
            args: Prisma.righttbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.righttbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.righttbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$righttbPayload>
          }
          aggregate: {
            args: Prisma.RighttbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRighttb>
          }
          groupBy: {
            args: Prisma.righttbGroupByArgs<ExtArgs>
            result: $Utils.Optional<RighttbGroupByOutputType>[]
          }
          count: {
            args: Prisma.righttbCountArgs<ExtArgs>
            result: $Utils.Optional<RighttbCountAggregateOutputType> | number
          }
        }
      }
      serverlogtb: {
        payload: Prisma.$serverlogtbPayload<ExtArgs>
        fields: Prisma.serverlogtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serverlogtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverlogtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serverlogtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverlogtbPayload>
          }
          findFirst: {
            args: Prisma.serverlogtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverlogtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serverlogtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverlogtbPayload>
          }
          findMany: {
            args: Prisma.serverlogtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverlogtbPayload>[]
          }
          create: {
            args: Prisma.serverlogtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverlogtbPayload>
          }
          createMany: {
            args: Prisma.serverlogtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.serverlogtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverlogtbPayload>
          }
          update: {
            args: Prisma.serverlogtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverlogtbPayload>
          }
          deleteMany: {
            args: Prisma.serverlogtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serverlogtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serverlogtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serverlogtbPayload>
          }
          aggregate: {
            args: Prisma.ServerlogtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServerlogtb>
          }
          groupBy: {
            args: Prisma.serverlogtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServerlogtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.serverlogtbCountArgs<ExtArgs>
            result: $Utils.Optional<ServerlogtbCountAggregateOutputType> | number
          }
        }
      }
      servicedetailtb: {
        payload: Prisma.$servicedetailtbPayload<ExtArgs>
        fields: Prisma.servicedetailtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicedetailtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicedetailtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicedetailtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicedetailtbPayload>
          }
          findFirst: {
            args: Prisma.servicedetailtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicedetailtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicedetailtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicedetailtbPayload>
          }
          findMany: {
            args: Prisma.servicedetailtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicedetailtbPayload>[]
          }
          create: {
            args: Prisma.servicedetailtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicedetailtbPayload>
          }
          createMany: {
            args: Prisma.servicedetailtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.servicedetailtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicedetailtbPayload>
          }
          update: {
            args: Prisma.servicedetailtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicedetailtbPayload>
          }
          deleteMany: {
            args: Prisma.servicedetailtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.servicedetailtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.servicedetailtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicedetailtbPayload>
          }
          aggregate: {
            args: Prisma.ServicedetailtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicedetailtb>
          }
          groupBy: {
            args: Prisma.servicedetailtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicedetailtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicedetailtbCountArgs<ExtArgs>
            result: $Utils.Optional<ServicedetailtbCountAggregateOutputType> | number
          }
        }
      }
      servicegiftsbag: {
        payload: Prisma.$servicegiftsbagPayload<ExtArgs>
        fields: Prisma.servicegiftsbagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicegiftsbagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegiftsbagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicegiftsbagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegiftsbagPayload>
          }
          findFirst: {
            args: Prisma.servicegiftsbagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegiftsbagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicegiftsbagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegiftsbagPayload>
          }
          findMany: {
            args: Prisma.servicegiftsbagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegiftsbagPayload>[]
          }
          create: {
            args: Prisma.servicegiftsbagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegiftsbagPayload>
          }
          createMany: {
            args: Prisma.servicegiftsbagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.servicegiftsbagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegiftsbagPayload>
          }
          update: {
            args: Prisma.servicegiftsbagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegiftsbagPayload>
          }
          deleteMany: {
            args: Prisma.servicegiftsbagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.servicegiftsbagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.servicegiftsbagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegiftsbagPayload>
          }
          aggregate: {
            args: Prisma.ServicegiftsbagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicegiftsbag>
          }
          groupBy: {
            args: Prisma.servicegiftsbagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicegiftsbagGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicegiftsbagCountArgs<ExtArgs>
            result: $Utils.Optional<ServicegiftsbagCountAggregateOutputType> | number
          }
        }
      }
      servicegrouptb: {
        payload: Prisma.$servicegrouptbPayload<ExtArgs>
        fields: Prisma.servicegrouptbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicegrouptbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegrouptbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicegrouptbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegrouptbPayload>
          }
          findFirst: {
            args: Prisma.servicegrouptbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegrouptbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicegrouptbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegrouptbPayload>
          }
          findMany: {
            args: Prisma.servicegrouptbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegrouptbPayload>[]
          }
          create: {
            args: Prisma.servicegrouptbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegrouptbPayload>
          }
          createMany: {
            args: Prisma.servicegrouptbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.servicegrouptbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegrouptbPayload>
          }
          update: {
            args: Prisma.servicegrouptbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegrouptbPayload>
          }
          deleteMany: {
            args: Prisma.servicegrouptbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.servicegrouptbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.servicegrouptbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicegrouptbPayload>
          }
          aggregate: {
            args: Prisma.ServicegrouptbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicegrouptb>
          }
          groupBy: {
            args: Prisma.servicegrouptbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicegrouptbGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicegrouptbCountArgs<ExtArgs>
            result: $Utils.Optional<ServicegrouptbCountAggregateOutputType> | number
          }
        }
      }
      serviceinfologtb: {
        payload: Prisma.$serviceinfologtbPayload<ExtArgs>
        fields: Prisma.serviceinfologtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceinfologtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfologtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceinfologtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfologtbPayload>
          }
          findFirst: {
            args: Prisma.serviceinfologtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfologtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceinfologtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfologtbPayload>
          }
          findMany: {
            args: Prisma.serviceinfologtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfologtbPayload>[]
          }
          create: {
            args: Prisma.serviceinfologtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfologtbPayload>
          }
          createMany: {
            args: Prisma.serviceinfologtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.serviceinfologtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfologtbPayload>
          }
          update: {
            args: Prisma.serviceinfologtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfologtbPayload>
          }
          deleteMany: {
            args: Prisma.serviceinfologtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceinfologtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serviceinfologtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfologtbPayload>
          }
          aggregate: {
            args: Prisma.ServiceinfologtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceinfologtb>
          }
          groupBy: {
            args: Prisma.serviceinfologtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceinfologtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceinfologtbCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceinfologtbCountAggregateOutputType> | number
          }
        }
      }
      serviceinfotb: {
        payload: Prisma.$serviceinfotbPayload<ExtArgs>
        fields: Prisma.serviceinfotbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceinfotbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfotbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceinfotbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfotbPayload>
          }
          findFirst: {
            args: Prisma.serviceinfotbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfotbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceinfotbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfotbPayload>
          }
          findMany: {
            args: Prisma.serviceinfotbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfotbPayload>[]
          }
          create: {
            args: Prisma.serviceinfotbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfotbPayload>
          }
          createMany: {
            args: Prisma.serviceinfotbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.serviceinfotbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfotbPayload>
          }
          update: {
            args: Prisma.serviceinfotbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfotbPayload>
          }
          deleteMany: {
            args: Prisma.serviceinfotbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceinfotbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serviceinfotbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceinfotbPayload>
          }
          aggregate: {
            args: Prisma.ServiceinfotbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceinfotb>
          }
          groupBy: {
            args: Prisma.serviceinfotbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceinfotbGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceinfotbCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceinfotbCountAggregateOutputType> | number
          }
        }
      }
      servicetb: {
        payload: Prisma.$servicetbPayload<ExtArgs>
        fields: Prisma.servicetbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicetbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicetbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicetbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicetbPayload>
          }
          findFirst: {
            args: Prisma.servicetbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicetbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicetbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicetbPayload>
          }
          findMany: {
            args: Prisma.servicetbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicetbPayload>[]
          }
          create: {
            args: Prisma.servicetbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicetbPayload>
          }
          createMany: {
            args: Prisma.servicetbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.servicetbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicetbPayload>
          }
          update: {
            args: Prisma.servicetbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicetbPayload>
          }
          deleteMany: {
            args: Prisma.servicetbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.servicetbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.servicetbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicetbPayload>
          }
          aggregate: {
            args: Prisma.ServicetbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicetb>
          }
          groupBy: {
            args: Prisma.servicetbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicetbGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicetbCountArgs<ExtArgs>
            result: $Utils.Optional<ServicetbCountAggregateOutputType> | number
          }
        }
      }
      serviceunittb: {
        payload: Prisma.$serviceunittbPayload<ExtArgs>
        fields: Prisma.serviceunittbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.serviceunittbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceunittbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.serviceunittbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceunittbPayload>
          }
          findFirst: {
            args: Prisma.serviceunittbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceunittbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.serviceunittbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceunittbPayload>
          }
          findMany: {
            args: Prisma.serviceunittbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceunittbPayload>[]
          }
          create: {
            args: Prisma.serviceunittbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceunittbPayload>
          }
          createMany: {
            args: Prisma.serviceunittbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.serviceunittbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceunittbPayload>
          }
          update: {
            args: Prisma.serviceunittbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceunittbPayload>
          }
          deleteMany: {
            args: Prisma.serviceunittbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.serviceunittbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.serviceunittbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$serviceunittbPayload>
          }
          aggregate: {
            args: Prisma.ServiceunittbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceunittb>
          }
          groupBy: {
            args: Prisma.serviceunittbGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceunittbGroupByOutputType>[]
          }
          count: {
            args: Prisma.serviceunittbCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceunittbCountAggregateOutputType> | number
          }
        }
      }
      servicevisit: {
        payload: Prisma.$servicevisitPayload<ExtArgs>
        fields: Prisma.servicevisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.servicevisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicevisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.servicevisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicevisitPayload>
          }
          findFirst: {
            args: Prisma.servicevisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicevisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.servicevisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicevisitPayload>
          }
          findMany: {
            args: Prisma.servicevisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicevisitPayload>[]
          }
          create: {
            args: Prisma.servicevisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicevisitPayload>
          }
          createMany: {
            args: Prisma.servicevisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.servicevisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicevisitPayload>
          }
          update: {
            args: Prisma.servicevisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicevisitPayload>
          }
          deleteMany: {
            args: Prisma.servicevisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.servicevisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.servicevisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$servicevisitPayload>
          }
          aggregate: {
            args: Prisma.ServicevisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicevisit>
          }
          groupBy: {
            args: Prisma.servicevisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicevisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.servicevisitCountArgs<ExtArgs>
            result: $Utils.Optional<ServicevisitCountAggregateOutputType> | number
          }
        }
      }
      settingtb: {
        payload: Prisma.$settingtbPayload<ExtArgs>
        fields: Prisma.settingtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.settingtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.settingtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingtbPayload>
          }
          findFirst: {
            args: Prisma.settingtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.settingtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingtbPayload>
          }
          findMany: {
            args: Prisma.settingtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingtbPayload>[]
          }
          create: {
            args: Prisma.settingtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingtbPayload>
          }
          createMany: {
            args: Prisma.settingtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.settingtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingtbPayload>
          }
          update: {
            args: Prisma.settingtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingtbPayload>
          }
          deleteMany: {
            args: Prisma.settingtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.settingtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.settingtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$settingtbPayload>
          }
          aggregate: {
            args: Prisma.SettingtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettingtb>
          }
          groupBy: {
            args: Prisma.settingtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.settingtbCountArgs<ExtArgs>
            result: $Utils.Optional<SettingtbCountAggregateOutputType> | number
          }
        }
      }
      softwaretb: {
        payload: Prisma.$softwaretbPayload<ExtArgs>
        fields: Prisma.softwaretbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.softwaretbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwaretbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.softwaretbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwaretbPayload>
          }
          findFirst: {
            args: Prisma.softwaretbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwaretbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.softwaretbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwaretbPayload>
          }
          findMany: {
            args: Prisma.softwaretbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwaretbPayload>[]
          }
          create: {
            args: Prisma.softwaretbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwaretbPayload>
          }
          createMany: {
            args: Prisma.softwaretbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.softwaretbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwaretbPayload>
          }
          update: {
            args: Prisma.softwaretbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwaretbPayload>
          }
          deleteMany: {
            args: Prisma.softwaretbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.softwaretbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.softwaretbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$softwaretbPayload>
          }
          aggregate: {
            args: Prisma.SoftwaretbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSoftwaretb>
          }
          groupBy: {
            args: Prisma.softwaretbGroupByArgs<ExtArgs>
            result: $Utils.Optional<SoftwaretbGroupByOutputType>[]
          }
          count: {
            args: Prisma.softwaretbCountArgs<ExtArgs>
            result: $Utils.Optional<SoftwaretbCountAggregateOutputType> | number
          }
        }
      }
      specappdetailtb: {
        payload: Prisma.$specappdetailtbPayload<ExtArgs>
        fields: Prisma.specappdetailtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.specappdetailtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specappdetailtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.specappdetailtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specappdetailtbPayload>
          }
          findFirst: {
            args: Prisma.specappdetailtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specappdetailtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.specappdetailtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specappdetailtbPayload>
          }
          findMany: {
            args: Prisma.specappdetailtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specappdetailtbPayload>[]
          }
          create: {
            args: Prisma.specappdetailtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specappdetailtbPayload>
          }
          createMany: {
            args: Prisma.specappdetailtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.specappdetailtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specappdetailtbPayload>
          }
          update: {
            args: Prisma.specappdetailtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specappdetailtbPayload>
          }
          deleteMany: {
            args: Prisma.specappdetailtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.specappdetailtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.specappdetailtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$specappdetailtbPayload>
          }
          aggregate: {
            args: Prisma.SpecappdetailtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpecappdetailtb>
          }
          groupBy: {
            args: Prisma.specappdetailtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpecappdetailtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.specappdetailtbCountArgs<ExtArgs>
            result: $Utils.Optional<SpecappdetailtbCountAggregateOutputType> | number
          }
        }
      }
      standardservicetb: {
        payload: Prisma.$standardservicetbPayload<ExtArgs>
        fields: Prisma.standardservicetbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.standardservicetbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$standardservicetbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.standardservicetbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$standardservicetbPayload>
          }
          findFirst: {
            args: Prisma.standardservicetbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$standardservicetbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.standardservicetbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$standardservicetbPayload>
          }
          findMany: {
            args: Prisma.standardservicetbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$standardservicetbPayload>[]
          }
          create: {
            args: Prisma.standardservicetbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$standardservicetbPayload>
          }
          createMany: {
            args: Prisma.standardservicetbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.standardservicetbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$standardservicetbPayload>
          }
          update: {
            args: Prisma.standardservicetbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$standardservicetbPayload>
          }
          deleteMany: {
            args: Prisma.standardservicetbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.standardservicetbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.standardservicetbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$standardservicetbPayload>
          }
          aggregate: {
            args: Prisma.StandardservicetbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStandardservicetb>
          }
          groupBy: {
            args: Prisma.standardservicetbGroupByArgs<ExtArgs>
            result: $Utils.Optional<StandardservicetbGroupByOutputType>[]
          }
          count: {
            args: Prisma.standardservicetbCountArgs<ExtArgs>
            result: $Utils.Optional<StandardservicetbCountAggregateOutputType> | number
          }
        }
      }
      stocktakingtb: {
        payload: Prisma.$stocktakingtbPayload<ExtArgs>
        fields: Prisma.stocktakingtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.stocktakingtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stocktakingtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.stocktakingtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stocktakingtbPayload>
          }
          findFirst: {
            args: Prisma.stocktakingtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stocktakingtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.stocktakingtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stocktakingtbPayload>
          }
          findMany: {
            args: Prisma.stocktakingtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stocktakingtbPayload>[]
          }
          create: {
            args: Prisma.stocktakingtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stocktakingtbPayload>
          }
          createMany: {
            args: Prisma.stocktakingtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.stocktakingtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stocktakingtbPayload>
          }
          update: {
            args: Prisma.stocktakingtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stocktakingtbPayload>
          }
          deleteMany: {
            args: Prisma.stocktakingtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.stocktakingtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.stocktakingtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$stocktakingtbPayload>
          }
          aggregate: {
            args: Prisma.StocktakingtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStocktakingtb>
          }
          groupBy: {
            args: Prisma.stocktakingtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<StocktakingtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.stocktakingtbCountArgs<ExtArgs>
            result: $Utils.Optional<StocktakingtbCountAggregateOutputType> | number
          }
        }
      }
      supports: {
        payload: Prisma.$supportsPayload<ExtArgs>
        fields: Prisma.supportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportsPayload>
          }
          findFirst: {
            args: Prisma.supportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportsPayload>
          }
          findMany: {
            args: Prisma.supportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportsPayload>[]
          }
          create: {
            args: Prisma.supportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportsPayload>
          }
          createMany: {
            args: Prisma.supportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.supportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportsPayload>
          }
          update: {
            args: Prisma.supportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportsPayload>
          }
          deleteMany: {
            args: Prisma.supportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.supportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.supportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportsPayload>
          }
          aggregate: {
            args: Prisma.SupportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupports>
          }
          groupBy: {
            args: Prisma.supportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportsGroupByOutputType>[]
          }
          count: {
            args: Prisma.supportsCountArgs<ExtArgs>
            result: $Utils.Optional<SupportsCountAggregateOutputType> | number
          }
        }
      }
      systemfunctiontb: {
        payload: Prisma.$systemfunctiontbPayload<ExtArgs>
        fields: Prisma.systemfunctiontbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.systemfunctiontbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemfunctiontbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.systemfunctiontbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemfunctiontbPayload>
          }
          findFirst: {
            args: Prisma.systemfunctiontbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemfunctiontbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.systemfunctiontbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemfunctiontbPayload>
          }
          findMany: {
            args: Prisma.systemfunctiontbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemfunctiontbPayload>[]
          }
          create: {
            args: Prisma.systemfunctiontbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemfunctiontbPayload>
          }
          createMany: {
            args: Prisma.systemfunctiontbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.systemfunctiontbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemfunctiontbPayload>
          }
          update: {
            args: Prisma.systemfunctiontbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemfunctiontbPayload>
          }
          deleteMany: {
            args: Prisma.systemfunctiontbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.systemfunctiontbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.systemfunctiontbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemfunctiontbPayload>
          }
          aggregate: {
            args: Prisma.SystemfunctiontbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemfunctiontb>
          }
          groupBy: {
            args: Prisma.systemfunctiontbGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemfunctiontbGroupByOutputType>[]
          }
          count: {
            args: Prisma.systemfunctiontbCountArgs<ExtArgs>
            result: $Utils.Optional<SystemfunctiontbCountAggregateOutputType> | number
          }
        }
      }
      systemlogtb: {
        payload: Prisma.$systemlogtbPayload<ExtArgs>
        fields: Prisma.systemlogtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.systemlogtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemlogtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.systemlogtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemlogtbPayload>
          }
          findFirst: {
            args: Prisma.systemlogtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemlogtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.systemlogtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemlogtbPayload>
          }
          findMany: {
            args: Prisma.systemlogtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemlogtbPayload>[]
          }
          create: {
            args: Prisma.systemlogtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemlogtbPayload>
          }
          createMany: {
            args: Prisma.systemlogtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.systemlogtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemlogtbPayload>
          }
          update: {
            args: Prisma.systemlogtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemlogtbPayload>
          }
          deleteMany: {
            args: Prisma.systemlogtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.systemlogtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.systemlogtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$systemlogtbPayload>
          }
          aggregate: {
            args: Prisma.SystemlogtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemlogtb>
          }
          groupBy: {
            args: Prisma.systemlogtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemlogtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.systemlogtbCountArgs<ExtArgs>
            result: $Utils.Optional<SystemlogtbCountAggregateOutputType> | number
          }
        }
      }
      trackappdetailtb: {
        payload: Prisma.$trackappdetailtbPayload<ExtArgs>
        fields: Prisma.trackappdetailtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trackappdetailtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackappdetailtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trackappdetailtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackappdetailtbPayload>
          }
          findFirst: {
            args: Prisma.trackappdetailtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackappdetailtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trackappdetailtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackappdetailtbPayload>
          }
          findMany: {
            args: Prisma.trackappdetailtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackappdetailtbPayload>[]
          }
          create: {
            args: Prisma.trackappdetailtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackappdetailtbPayload>
          }
          createMany: {
            args: Prisma.trackappdetailtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.trackappdetailtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackappdetailtbPayload>
          }
          update: {
            args: Prisma.trackappdetailtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackappdetailtbPayload>
          }
          deleteMany: {
            args: Prisma.trackappdetailtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trackappdetailtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.trackappdetailtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackappdetailtbPayload>
          }
          aggregate: {
            args: Prisma.TrackappdetailtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrackappdetailtb>
          }
          groupBy: {
            args: Prisma.trackappdetailtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrackappdetailtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.trackappdetailtbCountArgs<ExtArgs>
            result: $Utils.Optional<TrackappdetailtbCountAggregateOutputType> | number
          }
        }
      }
      trackapptb: {
        payload: Prisma.$trackapptbPayload<ExtArgs>
        fields: Prisma.trackapptbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trackapptbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackapptbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trackapptbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackapptbPayload>
          }
          findFirst: {
            args: Prisma.trackapptbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackapptbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trackapptbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackapptbPayload>
          }
          findMany: {
            args: Prisma.trackapptbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackapptbPayload>[]
          }
          create: {
            args: Prisma.trackapptbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackapptbPayload>
          }
          createMany: {
            args: Prisma.trackapptbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.trackapptbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackapptbPayload>
          }
          update: {
            args: Prisma.trackapptbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackapptbPayload>
          }
          deleteMany: {
            args: Prisma.trackapptbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trackapptbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.trackapptbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackapptbPayload>
          }
          aggregate: {
            args: Prisma.TrackapptbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrackapptb>
          }
          groupBy: {
            args: Prisma.trackapptbGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrackapptbGroupByOutputType>[]
          }
          count: {
            args: Prisma.trackapptbCountArgs<ExtArgs>
            result: $Utils.Optional<TrackapptbCountAggregateOutputType> | number
          }
        }
      }
      trackguitb: {
        payload: Prisma.$trackguitbPayload<ExtArgs>
        fields: Prisma.trackguitbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trackguitbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackguitbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trackguitbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackguitbPayload>
          }
          findFirst: {
            args: Prisma.trackguitbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackguitbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trackguitbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackguitbPayload>
          }
          findMany: {
            args: Prisma.trackguitbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackguitbPayload>[]
          }
          create: {
            args: Prisma.trackguitbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackguitbPayload>
          }
          createMany: {
            args: Prisma.trackguitbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.trackguitbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackguitbPayload>
          }
          update: {
            args: Prisma.trackguitbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackguitbPayload>
          }
          deleteMany: {
            args: Prisma.trackguitbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trackguitbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.trackguitbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trackguitbPayload>
          }
          aggregate: {
            args: Prisma.TrackguitbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrackguitb>
          }
          groupBy: {
            args: Prisma.trackguitbGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrackguitbGroupByOutputType>[]
          }
          count: {
            args: Prisma.trackguitbCountArgs<ExtArgs>
            result: $Utils.Optional<TrackguitbCountAggregateOutputType> | number
          }
        }
      }
      transferdetailtb: {
        payload: Prisma.$transferdetailtbPayload<ExtArgs>
        fields: Prisma.transferdetailtbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transferdetailtbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transferdetailtbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transferdetailtbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transferdetailtbPayload>
          }
          findFirst: {
            args: Prisma.transferdetailtbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transferdetailtbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transferdetailtbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transferdetailtbPayload>
          }
          findMany: {
            args: Prisma.transferdetailtbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transferdetailtbPayload>[]
          }
          create: {
            args: Prisma.transferdetailtbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transferdetailtbPayload>
          }
          createMany: {
            args: Prisma.transferdetailtbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transferdetailtbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transferdetailtbPayload>
          }
          update: {
            args: Prisma.transferdetailtbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transferdetailtbPayload>
          }
          deleteMany: {
            args: Prisma.transferdetailtbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transferdetailtbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transferdetailtbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transferdetailtbPayload>
          }
          aggregate: {
            args: Prisma.TransferdetailtbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransferdetailtb>
          }
          groupBy: {
            args: Prisma.transferdetailtbGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransferdetailtbGroupByOutputType>[]
          }
          count: {
            args: Prisma.transferdetailtbCountArgs<ExtArgs>
            result: $Utils.Optional<TransferdetailtbCountAggregateOutputType> | number
          }
        }
      }
      usagetimetb: {
        payload: Prisma.$usagetimetbPayload<ExtArgs>
        fields: Prisma.usagetimetbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usagetimetbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usagetimetbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usagetimetbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usagetimetbPayload>
          }
          findFirst: {
            args: Prisma.usagetimetbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usagetimetbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usagetimetbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usagetimetbPayload>
          }
          findMany: {
            args: Prisma.usagetimetbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usagetimetbPayload>[]
          }
          create: {
            args: Prisma.usagetimetbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usagetimetbPayload>
          }
          createMany: {
            args: Prisma.usagetimetbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usagetimetbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usagetimetbPayload>
          }
          update: {
            args: Prisma.usagetimetbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usagetimetbPayload>
          }
          deleteMany: {
            args: Prisma.usagetimetbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usagetimetbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usagetimetbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usagetimetbPayload>
          }
          aggregate: {
            args: Prisma.UsagetimetbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsagetimetb>
          }
          groupBy: {
            args: Prisma.usagetimetbGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsagetimetbGroupByOutputType>[]
          }
          count: {
            args: Prisma.usagetimetbCountArgs<ExtArgs>
            result: $Utils.Optional<UsagetimetbCountAggregateOutputType> | number
          }
        }
      }
      usertb: {
        payload: Prisma.$usertbPayload<ExtArgs>
        fields: Prisma.usertbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usertbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usertbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertbPayload>
          }
          findFirst: {
            args: Prisma.usertbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usertbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertbPayload>
          }
          findMany: {
            args: Prisma.usertbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertbPayload>[]
          }
          create: {
            args: Prisma.usertbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertbPayload>
          }
          createMany: {
            args: Prisma.usertbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usertbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertbPayload>
          }
          update: {
            args: Prisma.usertbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertbPayload>
          }
          deleteMany: {
            args: Prisma.usertbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usertbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usertbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertbPayload>
          }
          aggregate: {
            args: Prisma.UsertbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsertb>
          }
          groupBy: {
            args: Prisma.usertbGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsertbGroupByOutputType>[]
          }
          count: {
            args: Prisma.usertbCountArgs<ExtArgs>
            result: $Utils.Optional<UsertbCountAggregateOutputType> | number
          }
        }
      }
      versiontb: {
        payload: Prisma.$versiontbPayload<ExtArgs>
        fields: Prisma.versiontbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.versiontbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$versiontbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.versiontbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$versiontbPayload>
          }
          findFirst: {
            args: Prisma.versiontbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$versiontbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.versiontbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$versiontbPayload>
          }
          findMany: {
            args: Prisma.versiontbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$versiontbPayload>[]
          }
          create: {
            args: Prisma.versiontbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$versiontbPayload>
          }
          createMany: {
            args: Prisma.versiontbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.versiontbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$versiontbPayload>
          }
          update: {
            args: Prisma.versiontbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$versiontbPayload>
          }
          deleteMany: {
            args: Prisma.versiontbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.versiontbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.versiontbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$versiontbPayload>
          }
          aggregate: {
            args: Prisma.VersiontbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVersiontb>
          }
          groupBy: {
            args: Prisma.versiontbGroupByArgs<ExtArgs>
            result: $Utils.Optional<VersiontbGroupByOutputType>[]
          }
          count: {
            args: Prisma.versiontbCountArgs<ExtArgs>
            result: $Utils.Optional<VersiontbCountAggregateOutputType> | number
          }
        }
      }
      wallettb: {
        payload: Prisma.$wallettbPayload<ExtArgs>
        fields: Prisma.wallettbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.wallettbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallettbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.wallettbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallettbPayload>
          }
          findFirst: {
            args: Prisma.wallettbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallettbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.wallettbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallettbPayload>
          }
          findMany: {
            args: Prisma.wallettbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallettbPayload>[]
          }
          create: {
            args: Prisma.wallettbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallettbPayload>
          }
          createMany: {
            args: Prisma.wallettbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.wallettbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallettbPayload>
          }
          update: {
            args: Prisma.wallettbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallettbPayload>
          }
          deleteMany: {
            args: Prisma.wallettbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.wallettbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.wallettbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$wallettbPayload>
          }
          aggregate: {
            args: Prisma.WallettbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallettb>
          }
          groupBy: {
            args: Prisma.wallettbGroupByArgs<ExtArgs>
            result: $Utils.Optional<WallettbGroupByOutputType>[]
          }
          count: {
            args: Prisma.wallettbCountArgs<ExtArgs>
            result: $Utils.Optional<WallettbCountAggregateOutputType> | number
          }
        }
      }
      webhistorytb: {
        payload: Prisma.$webhistorytbPayload<ExtArgs>
        fields: Prisma.webhistorytbFieldRefs
        operations: {
          findUnique: {
            args: Prisma.webhistorytbFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhistorytbPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.webhistorytbFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhistorytbPayload>
          }
          findFirst: {
            args: Prisma.webhistorytbFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhistorytbPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.webhistorytbFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhistorytbPayload>
          }
          findMany: {
            args: Prisma.webhistorytbFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhistorytbPayload>[]
          }
          create: {
            args: Prisma.webhistorytbCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhistorytbPayload>
          }
          createMany: {
            args: Prisma.webhistorytbCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.webhistorytbDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhistorytbPayload>
          }
          update: {
            args: Prisma.webhistorytbUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhistorytbPayload>
          }
          deleteMany: {
            args: Prisma.webhistorytbDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.webhistorytbUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.webhistorytbUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhistorytbPayload>
          }
          aggregate: {
            args: Prisma.WebhistorytbAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhistorytb>
          }
          groupBy: {
            args: Prisma.webhistorytbGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhistorytbGroupByOutputType>[]
          }
          count: {
            args: Prisma.webhistorytbCountArgs<ExtArgs>
            result: $Utils.Optional<WebhistorytbCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model accountingentrytb
   */

  export type AggregateAccountingentrytb = {
    _count: AccountingentrytbCountAggregateOutputType | null
    _avg: AccountingentrytbAvgAggregateOutputType | null
    _sum: AccountingentrytbSumAggregateOutputType | null
    _min: AccountingentrytbMinAggregateOutputType | null
    _max: AccountingentrytbMaxAggregateOutputType | null
  }

  export type AccountingentrytbAvgAggregateOutputType = {
    ID: number | null
    StaffID: number | null
    NumBalance: number | null
    ImportQuantity: number | null
    ImportTotalAmount: Decimal | null
    SaleQuantity: number | null
    SaleTotalAmount: Decimal | null
    NumInventoryExpected: number | null
    NumInventoryReal: number | null
    NumAdjust: number | null
    ServiceID: number | null
  }

  export type AccountingentrytbSumAggregateOutputType = {
    ID: number | null
    StaffID: number | null
    NumBalance: number | null
    ImportQuantity: number | null
    ImportTotalAmount: Decimal | null
    SaleQuantity: number | null
    SaleTotalAmount: Decimal | null
    NumInventoryExpected: number | null
    NumInventoryReal: number | null
    NumAdjust: number | null
    ServiceID: number | null
  }

  export type AccountingentrytbMinAggregateOutputType = {
    ID: number | null
    CreateDate: Date | null
    CreateTime: Date | null
    StaffID: number | null
    FromDate: Date | null
    FromTime: Date | null
    NumBalance: number | null
    ImportQuantity: number | null
    ImportTotalAmount: Decimal | null
    SaleQuantity: number | null
    SaleTotalAmount: Decimal | null
    NumInventoryExpected: number | null
    NumInventoryReal: number | null
    NumAdjust: number | null
    Note: string | null
    ServiceID: number | null
  }

  export type AccountingentrytbMaxAggregateOutputType = {
    ID: number | null
    CreateDate: Date | null
    CreateTime: Date | null
    StaffID: number | null
    FromDate: Date | null
    FromTime: Date | null
    NumBalance: number | null
    ImportQuantity: number | null
    ImportTotalAmount: Decimal | null
    SaleQuantity: number | null
    SaleTotalAmount: Decimal | null
    NumInventoryExpected: number | null
    NumInventoryReal: number | null
    NumAdjust: number | null
    Note: string | null
    ServiceID: number | null
  }

  export type AccountingentrytbCountAggregateOutputType = {
    ID: number
    CreateDate: number
    CreateTime: number
    StaffID: number
    FromDate: number
    FromTime: number
    NumBalance: number
    ImportQuantity: number
    ImportTotalAmount: number
    SaleQuantity: number
    SaleTotalAmount: number
    NumInventoryExpected: number
    NumInventoryReal: number
    NumAdjust: number
    Note: number
    ServiceID: number
    _all: number
  }


  export type AccountingentrytbAvgAggregateInputType = {
    ID?: true
    StaffID?: true
    NumBalance?: true
    ImportQuantity?: true
    ImportTotalAmount?: true
    SaleQuantity?: true
    SaleTotalAmount?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    ServiceID?: true
  }

  export type AccountingentrytbSumAggregateInputType = {
    ID?: true
    StaffID?: true
    NumBalance?: true
    ImportQuantity?: true
    ImportTotalAmount?: true
    SaleQuantity?: true
    SaleTotalAmount?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    ServiceID?: true
  }

  export type AccountingentrytbMinAggregateInputType = {
    ID?: true
    CreateDate?: true
    CreateTime?: true
    StaffID?: true
    FromDate?: true
    FromTime?: true
    NumBalance?: true
    ImportQuantity?: true
    ImportTotalAmount?: true
    SaleQuantity?: true
    SaleTotalAmount?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    Note?: true
    ServiceID?: true
  }

  export type AccountingentrytbMaxAggregateInputType = {
    ID?: true
    CreateDate?: true
    CreateTime?: true
    StaffID?: true
    FromDate?: true
    FromTime?: true
    NumBalance?: true
    ImportQuantity?: true
    ImportTotalAmount?: true
    SaleQuantity?: true
    SaleTotalAmount?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    Note?: true
    ServiceID?: true
  }

  export type AccountingentrytbCountAggregateInputType = {
    ID?: true
    CreateDate?: true
    CreateTime?: true
    StaffID?: true
    FromDate?: true
    FromTime?: true
    NumBalance?: true
    ImportQuantity?: true
    ImportTotalAmount?: true
    SaleQuantity?: true
    SaleTotalAmount?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    Note?: true
    ServiceID?: true
    _all?: true
  }

  export type AccountingentrytbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accountingentrytb to aggregate.
     */
    where?: accountingentrytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accountingentrytbs to fetch.
     */
    orderBy?: accountingentrytbOrderByWithRelationInput | accountingentrytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountingentrytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accountingentrytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accountingentrytbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accountingentrytbs
    **/
    _count?: true | AccountingentrytbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountingentrytbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountingentrytbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountingentrytbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountingentrytbMaxAggregateInputType
  }

  export type GetAccountingentrytbAggregateType<T extends AccountingentrytbAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountingentrytb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountingentrytb[P]>
      : GetScalarType<T[P], AggregateAccountingentrytb[P]>
  }




  export type accountingentrytbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountingentrytbWhereInput
    orderBy?: accountingentrytbOrderByWithAggregationInput | accountingentrytbOrderByWithAggregationInput[]
    by: AccountingentrytbScalarFieldEnum[] | AccountingentrytbScalarFieldEnum
    having?: accountingentrytbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountingentrytbCountAggregateInputType | true
    _avg?: AccountingentrytbAvgAggregateInputType
    _sum?: AccountingentrytbSumAggregateInputType
    _min?: AccountingentrytbMinAggregateInputType
    _max?: AccountingentrytbMaxAggregateInputType
  }

  export type AccountingentrytbGroupByOutputType = {
    ID: number
    CreateDate: Date
    CreateTime: Date
    StaffID: number
    FromDate: Date
    FromTime: Date
    NumBalance: number
    ImportQuantity: number
    ImportTotalAmount: Decimal
    SaleQuantity: number
    SaleTotalAmount: Decimal
    NumInventoryExpected: number
    NumInventoryReal: number
    NumAdjust: number
    Note: string | null
    ServiceID: number
    _count: AccountingentrytbCountAggregateOutputType | null
    _avg: AccountingentrytbAvgAggregateOutputType | null
    _sum: AccountingentrytbSumAggregateOutputType | null
    _min: AccountingentrytbMinAggregateOutputType | null
    _max: AccountingentrytbMaxAggregateOutputType | null
  }

  type GetAccountingentrytbGroupByPayload<T extends accountingentrytbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountingentrytbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountingentrytbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountingentrytbGroupByOutputType[P]>
            : GetScalarType<T[P], AccountingentrytbGroupByOutputType[P]>
        }
      >
    >


  export type accountingentrytbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    StaffID?: boolean
    FromDate?: boolean
    FromTime?: boolean
    NumBalance?: boolean
    ImportQuantity?: boolean
    ImportTotalAmount?: boolean
    SaleQuantity?: boolean
    SaleTotalAmount?: boolean
    NumInventoryExpected?: boolean
    NumInventoryReal?: boolean
    NumAdjust?: boolean
    Note?: boolean
    ServiceID?: boolean
  }, ExtArgs["result"]["accountingentrytb"]>


  export type accountingentrytbSelectScalar = {
    ID?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    StaffID?: boolean
    FromDate?: boolean
    FromTime?: boolean
    NumBalance?: boolean
    ImportQuantity?: boolean
    ImportTotalAmount?: boolean
    SaleQuantity?: boolean
    SaleTotalAmount?: boolean
    NumInventoryExpected?: boolean
    NumInventoryReal?: boolean
    NumAdjust?: boolean
    Note?: boolean
    ServiceID?: boolean
  }


  export type $accountingentrytbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accountingentrytb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      CreateDate: Date
      CreateTime: Date
      StaffID: number
      FromDate: Date
      FromTime: Date
      NumBalance: number
      ImportQuantity: number
      ImportTotalAmount: Prisma.Decimal
      SaleQuantity: number
      SaleTotalAmount: Prisma.Decimal
      NumInventoryExpected: number
      NumInventoryReal: number
      NumAdjust: number
      Note: string | null
      ServiceID: number
    }, ExtArgs["result"]["accountingentrytb"]>
    composites: {}
  }

  type accountingentrytbGetPayload<S extends boolean | null | undefined | accountingentrytbDefaultArgs> = $Result.GetResult<Prisma.$accountingentrytbPayload, S>

  type accountingentrytbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<accountingentrytbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountingentrytbCountAggregateInputType | true
    }

  export interface accountingentrytbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accountingentrytb'], meta: { name: 'accountingentrytb' } }
    /**
     * Find zero or one Accountingentrytb that matches the filter.
     * @param {accountingentrytbFindUniqueArgs} args - Arguments to find a Accountingentrytb
     * @example
     * // Get one Accountingentrytb
     * const accountingentrytb = await prisma.accountingentrytb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountingentrytbFindUniqueArgs>(args: SelectSubset<T, accountingentrytbFindUniqueArgs<ExtArgs>>): Prisma__accountingentrytbClient<$Result.GetResult<Prisma.$accountingentrytbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Accountingentrytb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {accountingentrytbFindUniqueOrThrowArgs} args - Arguments to find a Accountingentrytb
     * @example
     * // Get one Accountingentrytb
     * const accountingentrytb = await prisma.accountingentrytb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountingentrytbFindUniqueOrThrowArgs>(args: SelectSubset<T, accountingentrytbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountingentrytbClient<$Result.GetResult<Prisma.$accountingentrytbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Accountingentrytb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountingentrytbFindFirstArgs} args - Arguments to find a Accountingentrytb
     * @example
     * // Get one Accountingentrytb
     * const accountingentrytb = await prisma.accountingentrytb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountingentrytbFindFirstArgs>(args?: SelectSubset<T, accountingentrytbFindFirstArgs<ExtArgs>>): Prisma__accountingentrytbClient<$Result.GetResult<Prisma.$accountingentrytbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Accountingentrytb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountingentrytbFindFirstOrThrowArgs} args - Arguments to find a Accountingentrytb
     * @example
     * // Get one Accountingentrytb
     * const accountingentrytb = await prisma.accountingentrytb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountingentrytbFindFirstOrThrowArgs>(args?: SelectSubset<T, accountingentrytbFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountingentrytbClient<$Result.GetResult<Prisma.$accountingentrytbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accountingentrytbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountingentrytbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accountingentrytbs
     * const accountingentrytbs = await prisma.accountingentrytb.findMany()
     * 
     * // Get first 10 Accountingentrytbs
     * const accountingentrytbs = await prisma.accountingentrytb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const accountingentrytbWithIDOnly = await prisma.accountingentrytb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends accountingentrytbFindManyArgs>(args?: SelectSubset<T, accountingentrytbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountingentrytbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Accountingentrytb.
     * @param {accountingentrytbCreateArgs} args - Arguments to create a Accountingentrytb.
     * @example
     * // Create one Accountingentrytb
     * const Accountingentrytb = await prisma.accountingentrytb.create({
     *   data: {
     *     // ... data to create a Accountingentrytb
     *   }
     * })
     * 
     */
    create<T extends accountingentrytbCreateArgs>(args: SelectSubset<T, accountingentrytbCreateArgs<ExtArgs>>): Prisma__accountingentrytbClient<$Result.GetResult<Prisma.$accountingentrytbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accountingentrytbs.
     * @param {accountingentrytbCreateManyArgs} args - Arguments to create many Accountingentrytbs.
     * @example
     * // Create many Accountingentrytbs
     * const accountingentrytb = await prisma.accountingentrytb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountingentrytbCreateManyArgs>(args?: SelectSubset<T, accountingentrytbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accountingentrytb.
     * @param {accountingentrytbDeleteArgs} args - Arguments to delete one Accountingentrytb.
     * @example
     * // Delete one Accountingentrytb
     * const Accountingentrytb = await prisma.accountingentrytb.delete({
     *   where: {
     *     // ... filter to delete one Accountingentrytb
     *   }
     * })
     * 
     */
    delete<T extends accountingentrytbDeleteArgs>(args: SelectSubset<T, accountingentrytbDeleteArgs<ExtArgs>>): Prisma__accountingentrytbClient<$Result.GetResult<Prisma.$accountingentrytbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Accountingentrytb.
     * @param {accountingentrytbUpdateArgs} args - Arguments to update one Accountingentrytb.
     * @example
     * // Update one Accountingentrytb
     * const accountingentrytb = await prisma.accountingentrytb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountingentrytbUpdateArgs>(args: SelectSubset<T, accountingentrytbUpdateArgs<ExtArgs>>): Prisma__accountingentrytbClient<$Result.GetResult<Prisma.$accountingentrytbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accountingentrytbs.
     * @param {accountingentrytbDeleteManyArgs} args - Arguments to filter Accountingentrytbs to delete.
     * @example
     * // Delete a few Accountingentrytbs
     * const { count } = await prisma.accountingentrytb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountingentrytbDeleteManyArgs>(args?: SelectSubset<T, accountingentrytbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accountingentrytbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountingentrytbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accountingentrytbs
     * const accountingentrytb = await prisma.accountingentrytb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountingentrytbUpdateManyArgs>(args: SelectSubset<T, accountingentrytbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accountingentrytb.
     * @param {accountingentrytbUpsertArgs} args - Arguments to update or create a Accountingentrytb.
     * @example
     * // Update or create a Accountingentrytb
     * const accountingentrytb = await prisma.accountingentrytb.upsert({
     *   create: {
     *     // ... data to create a Accountingentrytb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accountingentrytb we want to update
     *   }
     * })
     */
    upsert<T extends accountingentrytbUpsertArgs>(args: SelectSubset<T, accountingentrytbUpsertArgs<ExtArgs>>): Prisma__accountingentrytbClient<$Result.GetResult<Prisma.$accountingentrytbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accountingentrytbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountingentrytbCountArgs} args - Arguments to filter Accountingentrytbs to count.
     * @example
     * // Count the number of Accountingentrytbs
     * const count = await prisma.accountingentrytb.count({
     *   where: {
     *     // ... the filter for the Accountingentrytbs we want to count
     *   }
     * })
    **/
    count<T extends accountingentrytbCountArgs>(
      args?: Subset<T, accountingentrytbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountingentrytbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accountingentrytb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingentrytbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountingentrytbAggregateArgs>(args: Subset<T, AccountingentrytbAggregateArgs>): Prisma.PrismaPromise<GetAccountingentrytbAggregateType<T>>

    /**
     * Group by Accountingentrytb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountingentrytbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountingentrytbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountingentrytbGroupByArgs['orderBy'] }
        : { orderBy?: accountingentrytbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountingentrytbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountingentrytbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accountingentrytb model
   */
  readonly fields: accountingentrytbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accountingentrytb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountingentrytbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accountingentrytb model
   */ 
  interface accountingentrytbFieldRefs {
    readonly ID: FieldRef<"accountingentrytb", 'Int'>
    readonly CreateDate: FieldRef<"accountingentrytb", 'DateTime'>
    readonly CreateTime: FieldRef<"accountingentrytb", 'DateTime'>
    readonly StaffID: FieldRef<"accountingentrytb", 'Int'>
    readonly FromDate: FieldRef<"accountingentrytb", 'DateTime'>
    readonly FromTime: FieldRef<"accountingentrytb", 'DateTime'>
    readonly NumBalance: FieldRef<"accountingentrytb", 'Int'>
    readonly ImportQuantity: FieldRef<"accountingentrytb", 'Int'>
    readonly ImportTotalAmount: FieldRef<"accountingentrytb", 'Decimal'>
    readonly SaleQuantity: FieldRef<"accountingentrytb", 'Int'>
    readonly SaleTotalAmount: FieldRef<"accountingentrytb", 'Decimal'>
    readonly NumInventoryExpected: FieldRef<"accountingentrytb", 'Int'>
    readonly NumInventoryReal: FieldRef<"accountingentrytb", 'Int'>
    readonly NumAdjust: FieldRef<"accountingentrytb", 'Int'>
    readonly Note: FieldRef<"accountingentrytb", 'String'>
    readonly ServiceID: FieldRef<"accountingentrytb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * accountingentrytb findUnique
   */
  export type accountingentrytbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
    /**
     * Filter, which accountingentrytb to fetch.
     */
    where: accountingentrytbWhereUniqueInput
  }

  /**
   * accountingentrytb findUniqueOrThrow
   */
  export type accountingentrytbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
    /**
     * Filter, which accountingentrytb to fetch.
     */
    where: accountingentrytbWhereUniqueInput
  }

  /**
   * accountingentrytb findFirst
   */
  export type accountingentrytbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
    /**
     * Filter, which accountingentrytb to fetch.
     */
    where?: accountingentrytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accountingentrytbs to fetch.
     */
    orderBy?: accountingentrytbOrderByWithRelationInput | accountingentrytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accountingentrytbs.
     */
    cursor?: accountingentrytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accountingentrytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accountingentrytbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accountingentrytbs.
     */
    distinct?: AccountingentrytbScalarFieldEnum | AccountingentrytbScalarFieldEnum[]
  }

  /**
   * accountingentrytb findFirstOrThrow
   */
  export type accountingentrytbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
    /**
     * Filter, which accountingentrytb to fetch.
     */
    where?: accountingentrytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accountingentrytbs to fetch.
     */
    orderBy?: accountingentrytbOrderByWithRelationInput | accountingentrytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accountingentrytbs.
     */
    cursor?: accountingentrytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accountingentrytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accountingentrytbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accountingentrytbs.
     */
    distinct?: AccountingentrytbScalarFieldEnum | AccountingentrytbScalarFieldEnum[]
  }

  /**
   * accountingentrytb findMany
   */
  export type accountingentrytbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
    /**
     * Filter, which accountingentrytbs to fetch.
     */
    where?: accountingentrytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accountingentrytbs to fetch.
     */
    orderBy?: accountingentrytbOrderByWithRelationInput | accountingentrytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accountingentrytbs.
     */
    cursor?: accountingentrytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accountingentrytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accountingentrytbs.
     */
    skip?: number
    distinct?: AccountingentrytbScalarFieldEnum | AccountingentrytbScalarFieldEnum[]
  }

  /**
   * accountingentrytb create
   */
  export type accountingentrytbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
    /**
     * The data needed to create a accountingentrytb.
     */
    data?: XOR<accountingentrytbCreateInput, accountingentrytbUncheckedCreateInput>
  }

  /**
   * accountingentrytb createMany
   */
  export type accountingentrytbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accountingentrytbs.
     */
    data: accountingentrytbCreateManyInput | accountingentrytbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accountingentrytb update
   */
  export type accountingentrytbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
    /**
     * The data needed to update a accountingentrytb.
     */
    data: XOR<accountingentrytbUpdateInput, accountingentrytbUncheckedUpdateInput>
    /**
     * Choose, which accountingentrytb to update.
     */
    where: accountingentrytbWhereUniqueInput
  }

  /**
   * accountingentrytb updateMany
   */
  export type accountingentrytbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accountingentrytbs.
     */
    data: XOR<accountingentrytbUpdateManyMutationInput, accountingentrytbUncheckedUpdateManyInput>
    /**
     * Filter which accountingentrytbs to update
     */
    where?: accountingentrytbWhereInput
  }

  /**
   * accountingentrytb upsert
   */
  export type accountingentrytbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
    /**
     * The filter to search for the accountingentrytb to update in case it exists.
     */
    where: accountingentrytbWhereUniqueInput
    /**
     * In case the accountingentrytb found by the `where` argument doesn't exist, create a new accountingentrytb with this data.
     */
    create: XOR<accountingentrytbCreateInput, accountingentrytbUncheckedCreateInput>
    /**
     * In case the accountingentrytb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountingentrytbUpdateInput, accountingentrytbUncheckedUpdateInput>
  }

  /**
   * accountingentrytb delete
   */
  export type accountingentrytbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
    /**
     * Filter which accountingentrytb to delete.
     */
    where: accountingentrytbWhereUniqueInput
  }

  /**
   * accountingentrytb deleteMany
   */
  export type accountingentrytbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accountingentrytbs to delete
     */
    where?: accountingentrytbWhereInput
  }

  /**
   * accountingentrytb without action
   */
  export type accountingentrytbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accountingentrytb
     */
    select?: accountingentrytbSelect<ExtArgs> | null
  }


  /**
   * Model anonymoustb
   */

  export type AggregateAnonymoustb = {
    _count: AnonymoustbCountAggregateOutputType | null
    _avg: AnonymoustbAvgAggregateOutputType | null
    _sum: AnonymoustbSumAggregateOutputType | null
    _min: AnonymoustbMinAggregateOutputType | null
    _max: AnonymoustbMaxAggregateOutputType | null
  }

  export type AnonymoustbAvgAggregateOutputType = {
    ID: number | null
    MachineID: number | null
    Session: number | null
  }

  export type AnonymoustbSumAggregateOutputType = {
    ID: number | null
    MachineID: number | null
    Session: number | null
  }

  export type AnonymoustbMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    IDCard: string | null
    Address: string | null
    MachineID: number | null
    Session: number | null
    RecordDate: Date | null
  }

  export type AnonymoustbMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    IDCard: string | null
    Address: string | null
    MachineID: number | null
    Session: number | null
    RecordDate: Date | null
  }

  export type AnonymoustbCountAggregateOutputType = {
    ID: number
    Name: number
    IDCard: number
    Address: number
    MachineID: number
    Session: number
    RecordDate: number
    _all: number
  }


  export type AnonymoustbAvgAggregateInputType = {
    ID?: true
    MachineID?: true
    Session?: true
  }

  export type AnonymoustbSumAggregateInputType = {
    ID?: true
    MachineID?: true
    Session?: true
  }

  export type AnonymoustbMinAggregateInputType = {
    ID?: true
    Name?: true
    IDCard?: true
    Address?: true
    MachineID?: true
    Session?: true
    RecordDate?: true
  }

  export type AnonymoustbMaxAggregateInputType = {
    ID?: true
    Name?: true
    IDCard?: true
    Address?: true
    MachineID?: true
    Session?: true
    RecordDate?: true
  }

  export type AnonymoustbCountAggregateInputType = {
    ID?: true
    Name?: true
    IDCard?: true
    Address?: true
    MachineID?: true
    Session?: true
    RecordDate?: true
    _all?: true
  }

  export type AnonymoustbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anonymoustb to aggregate.
     */
    where?: anonymoustbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anonymoustbs to fetch.
     */
    orderBy?: anonymoustbOrderByWithRelationInput | anonymoustbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: anonymoustbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anonymoustbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anonymoustbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned anonymoustbs
    **/
    _count?: true | AnonymoustbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnonymoustbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnonymoustbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnonymoustbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnonymoustbMaxAggregateInputType
  }

  export type GetAnonymoustbAggregateType<T extends AnonymoustbAggregateArgs> = {
        [P in keyof T & keyof AggregateAnonymoustb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnonymoustb[P]>
      : GetScalarType<T[P], AggregateAnonymoustb[P]>
  }




  export type anonymoustbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anonymoustbWhereInput
    orderBy?: anonymoustbOrderByWithAggregationInput | anonymoustbOrderByWithAggregationInput[]
    by: AnonymoustbScalarFieldEnum[] | AnonymoustbScalarFieldEnum
    having?: anonymoustbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnonymoustbCountAggregateInputType | true
    _avg?: AnonymoustbAvgAggregateInputType
    _sum?: AnonymoustbSumAggregateInputType
    _min?: AnonymoustbMinAggregateInputType
    _max?: AnonymoustbMaxAggregateInputType
  }

  export type AnonymoustbGroupByOutputType = {
    ID: number
    Name: string | null
    IDCard: string | null
    Address: string | null
    MachineID: number | null
    Session: number
    RecordDate: Date
    _count: AnonymoustbCountAggregateOutputType | null
    _avg: AnonymoustbAvgAggregateOutputType | null
    _sum: AnonymoustbSumAggregateOutputType | null
    _min: AnonymoustbMinAggregateOutputType | null
    _max: AnonymoustbMaxAggregateOutputType | null
  }

  type GetAnonymoustbGroupByPayload<T extends anonymoustbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnonymoustbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnonymoustbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnonymoustbGroupByOutputType[P]>
            : GetScalarType<T[P], AnonymoustbGroupByOutputType[P]>
        }
      >
    >


  export type anonymoustbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    IDCard?: boolean
    Address?: boolean
    MachineID?: boolean
    Session?: boolean
    RecordDate?: boolean
  }, ExtArgs["result"]["anonymoustb"]>


  export type anonymoustbSelectScalar = {
    ID?: boolean
    Name?: boolean
    IDCard?: boolean
    Address?: boolean
    MachineID?: boolean
    Session?: boolean
    RecordDate?: boolean
  }


  export type $anonymoustbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "anonymoustb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Name: string | null
      IDCard: string | null
      Address: string | null
      MachineID: number | null
      Session: number
      RecordDate: Date
    }, ExtArgs["result"]["anonymoustb"]>
    composites: {}
  }

  type anonymoustbGetPayload<S extends boolean | null | undefined | anonymoustbDefaultArgs> = $Result.GetResult<Prisma.$anonymoustbPayload, S>

  type anonymoustbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<anonymoustbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnonymoustbCountAggregateInputType | true
    }

  export interface anonymoustbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['anonymoustb'], meta: { name: 'anonymoustb' } }
    /**
     * Find zero or one Anonymoustb that matches the filter.
     * @param {anonymoustbFindUniqueArgs} args - Arguments to find a Anonymoustb
     * @example
     * // Get one Anonymoustb
     * const anonymoustb = await prisma.anonymoustb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends anonymoustbFindUniqueArgs>(args: SelectSubset<T, anonymoustbFindUniqueArgs<ExtArgs>>): Prisma__anonymoustbClient<$Result.GetResult<Prisma.$anonymoustbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Anonymoustb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {anonymoustbFindUniqueOrThrowArgs} args - Arguments to find a Anonymoustb
     * @example
     * // Get one Anonymoustb
     * const anonymoustb = await prisma.anonymoustb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends anonymoustbFindUniqueOrThrowArgs>(args: SelectSubset<T, anonymoustbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__anonymoustbClient<$Result.GetResult<Prisma.$anonymoustbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Anonymoustb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anonymoustbFindFirstArgs} args - Arguments to find a Anonymoustb
     * @example
     * // Get one Anonymoustb
     * const anonymoustb = await prisma.anonymoustb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends anonymoustbFindFirstArgs>(args?: SelectSubset<T, anonymoustbFindFirstArgs<ExtArgs>>): Prisma__anonymoustbClient<$Result.GetResult<Prisma.$anonymoustbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Anonymoustb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anonymoustbFindFirstOrThrowArgs} args - Arguments to find a Anonymoustb
     * @example
     * // Get one Anonymoustb
     * const anonymoustb = await prisma.anonymoustb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends anonymoustbFindFirstOrThrowArgs>(args?: SelectSubset<T, anonymoustbFindFirstOrThrowArgs<ExtArgs>>): Prisma__anonymoustbClient<$Result.GetResult<Prisma.$anonymoustbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Anonymoustbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anonymoustbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anonymoustbs
     * const anonymoustbs = await prisma.anonymoustb.findMany()
     * 
     * // Get first 10 Anonymoustbs
     * const anonymoustbs = await prisma.anonymoustb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const anonymoustbWithIDOnly = await prisma.anonymoustb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends anonymoustbFindManyArgs>(args?: SelectSubset<T, anonymoustbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anonymoustbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Anonymoustb.
     * @param {anonymoustbCreateArgs} args - Arguments to create a Anonymoustb.
     * @example
     * // Create one Anonymoustb
     * const Anonymoustb = await prisma.anonymoustb.create({
     *   data: {
     *     // ... data to create a Anonymoustb
     *   }
     * })
     * 
     */
    create<T extends anonymoustbCreateArgs>(args: SelectSubset<T, anonymoustbCreateArgs<ExtArgs>>): Prisma__anonymoustbClient<$Result.GetResult<Prisma.$anonymoustbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Anonymoustbs.
     * @param {anonymoustbCreateManyArgs} args - Arguments to create many Anonymoustbs.
     * @example
     * // Create many Anonymoustbs
     * const anonymoustb = await prisma.anonymoustb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends anonymoustbCreateManyArgs>(args?: SelectSubset<T, anonymoustbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Anonymoustb.
     * @param {anonymoustbDeleteArgs} args - Arguments to delete one Anonymoustb.
     * @example
     * // Delete one Anonymoustb
     * const Anonymoustb = await prisma.anonymoustb.delete({
     *   where: {
     *     // ... filter to delete one Anonymoustb
     *   }
     * })
     * 
     */
    delete<T extends anonymoustbDeleteArgs>(args: SelectSubset<T, anonymoustbDeleteArgs<ExtArgs>>): Prisma__anonymoustbClient<$Result.GetResult<Prisma.$anonymoustbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Anonymoustb.
     * @param {anonymoustbUpdateArgs} args - Arguments to update one Anonymoustb.
     * @example
     * // Update one Anonymoustb
     * const anonymoustb = await prisma.anonymoustb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends anonymoustbUpdateArgs>(args: SelectSubset<T, anonymoustbUpdateArgs<ExtArgs>>): Prisma__anonymoustbClient<$Result.GetResult<Prisma.$anonymoustbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Anonymoustbs.
     * @param {anonymoustbDeleteManyArgs} args - Arguments to filter Anonymoustbs to delete.
     * @example
     * // Delete a few Anonymoustbs
     * const { count } = await prisma.anonymoustb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends anonymoustbDeleteManyArgs>(args?: SelectSubset<T, anonymoustbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anonymoustbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anonymoustbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anonymoustbs
     * const anonymoustb = await prisma.anonymoustb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends anonymoustbUpdateManyArgs>(args: SelectSubset<T, anonymoustbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Anonymoustb.
     * @param {anonymoustbUpsertArgs} args - Arguments to update or create a Anonymoustb.
     * @example
     * // Update or create a Anonymoustb
     * const anonymoustb = await prisma.anonymoustb.upsert({
     *   create: {
     *     // ... data to create a Anonymoustb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anonymoustb we want to update
     *   }
     * })
     */
    upsert<T extends anonymoustbUpsertArgs>(args: SelectSubset<T, anonymoustbUpsertArgs<ExtArgs>>): Prisma__anonymoustbClient<$Result.GetResult<Prisma.$anonymoustbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Anonymoustbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anonymoustbCountArgs} args - Arguments to filter Anonymoustbs to count.
     * @example
     * // Count the number of Anonymoustbs
     * const count = await prisma.anonymoustb.count({
     *   where: {
     *     // ... the filter for the Anonymoustbs we want to count
     *   }
     * })
    **/
    count<T extends anonymoustbCountArgs>(
      args?: Subset<T, anonymoustbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnonymoustbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anonymoustb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymoustbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnonymoustbAggregateArgs>(args: Subset<T, AnonymoustbAggregateArgs>): Prisma.PrismaPromise<GetAnonymoustbAggregateType<T>>

    /**
     * Group by Anonymoustb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anonymoustbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends anonymoustbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: anonymoustbGroupByArgs['orderBy'] }
        : { orderBy?: anonymoustbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, anonymoustbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnonymoustbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the anonymoustb model
   */
  readonly fields: anonymoustbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for anonymoustb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__anonymoustbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the anonymoustb model
   */ 
  interface anonymoustbFieldRefs {
    readonly ID: FieldRef<"anonymoustb", 'Int'>
    readonly Name: FieldRef<"anonymoustb", 'String'>
    readonly IDCard: FieldRef<"anonymoustb", 'String'>
    readonly Address: FieldRef<"anonymoustb", 'String'>
    readonly MachineID: FieldRef<"anonymoustb", 'Int'>
    readonly Session: FieldRef<"anonymoustb", 'Int'>
    readonly RecordDate: FieldRef<"anonymoustb", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * anonymoustb findUnique
   */
  export type anonymoustbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
    /**
     * Filter, which anonymoustb to fetch.
     */
    where: anonymoustbWhereUniqueInput
  }

  /**
   * anonymoustb findUniqueOrThrow
   */
  export type anonymoustbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
    /**
     * Filter, which anonymoustb to fetch.
     */
    where: anonymoustbWhereUniqueInput
  }

  /**
   * anonymoustb findFirst
   */
  export type anonymoustbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
    /**
     * Filter, which anonymoustb to fetch.
     */
    where?: anonymoustbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anonymoustbs to fetch.
     */
    orderBy?: anonymoustbOrderByWithRelationInput | anonymoustbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anonymoustbs.
     */
    cursor?: anonymoustbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anonymoustbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anonymoustbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anonymoustbs.
     */
    distinct?: AnonymoustbScalarFieldEnum | AnonymoustbScalarFieldEnum[]
  }

  /**
   * anonymoustb findFirstOrThrow
   */
  export type anonymoustbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
    /**
     * Filter, which anonymoustb to fetch.
     */
    where?: anonymoustbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anonymoustbs to fetch.
     */
    orderBy?: anonymoustbOrderByWithRelationInput | anonymoustbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anonymoustbs.
     */
    cursor?: anonymoustbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anonymoustbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anonymoustbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anonymoustbs.
     */
    distinct?: AnonymoustbScalarFieldEnum | AnonymoustbScalarFieldEnum[]
  }

  /**
   * anonymoustb findMany
   */
  export type anonymoustbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
    /**
     * Filter, which anonymoustbs to fetch.
     */
    where?: anonymoustbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anonymoustbs to fetch.
     */
    orderBy?: anonymoustbOrderByWithRelationInput | anonymoustbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing anonymoustbs.
     */
    cursor?: anonymoustbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anonymoustbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anonymoustbs.
     */
    skip?: number
    distinct?: AnonymoustbScalarFieldEnum | AnonymoustbScalarFieldEnum[]
  }

  /**
   * anonymoustb create
   */
  export type anonymoustbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
    /**
     * The data needed to create a anonymoustb.
     */
    data: XOR<anonymoustbCreateInput, anonymoustbUncheckedCreateInput>
  }

  /**
   * anonymoustb createMany
   */
  export type anonymoustbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many anonymoustbs.
     */
    data: anonymoustbCreateManyInput | anonymoustbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * anonymoustb update
   */
  export type anonymoustbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
    /**
     * The data needed to update a anonymoustb.
     */
    data: XOR<anonymoustbUpdateInput, anonymoustbUncheckedUpdateInput>
    /**
     * Choose, which anonymoustb to update.
     */
    where: anonymoustbWhereUniqueInput
  }

  /**
   * anonymoustb updateMany
   */
  export type anonymoustbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update anonymoustbs.
     */
    data: XOR<anonymoustbUpdateManyMutationInput, anonymoustbUncheckedUpdateManyInput>
    /**
     * Filter which anonymoustbs to update
     */
    where?: anonymoustbWhereInput
  }

  /**
   * anonymoustb upsert
   */
  export type anonymoustbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
    /**
     * The filter to search for the anonymoustb to update in case it exists.
     */
    where: anonymoustbWhereUniqueInput
    /**
     * In case the anonymoustb found by the `where` argument doesn't exist, create a new anonymoustb with this data.
     */
    create: XOR<anonymoustbCreateInput, anonymoustbUncheckedCreateInput>
    /**
     * In case the anonymoustb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<anonymoustbUpdateInput, anonymoustbUncheckedUpdateInput>
  }

  /**
   * anonymoustb delete
   */
  export type anonymoustbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
    /**
     * Filter which anonymoustb to delete.
     */
    where: anonymoustbWhereUniqueInput
  }

  /**
   * anonymoustb deleteMany
   */
  export type anonymoustbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anonymoustbs to delete
     */
    where?: anonymoustbWhereInput
  }

  /**
   * anonymoustb without action
   */
  export type anonymoustbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anonymoustb
     */
    select?: anonymoustbSelect<ExtArgs> | null
  }


  /**
   * Model applicationrenttb
   */

  export type AggregateApplicationrenttb = {
    _count: ApplicationrenttbCountAggregateOutputType | null
    _avg: ApplicationrenttbAvgAggregateOutputType | null
    _sum: ApplicationrenttbSumAggregateOutputType | null
    _min: ApplicationrenttbMinAggregateOutputType | null
    _max: ApplicationrenttbMaxAggregateOutputType | null
  }

  export type ApplicationrenttbAvgAggregateOutputType = {
    ApplicationRentID: number | null
    AddBy: number | null
    Status: number | null
  }

  export type ApplicationrenttbSumAggregateOutputType = {
    ApplicationRentID: number | null
    AddBy: number | null
    Status: number | null
  }

  export type ApplicationrenttbMinAggregateOutputType = {
    ApplicationRentID: number | null
    Name: string | null
    Hash: string | null
    AddBy: number | null
    Status: number | null
  }

  export type ApplicationrenttbMaxAggregateOutputType = {
    ApplicationRentID: number | null
    Name: string | null
    Hash: string | null
    AddBy: number | null
    Status: number | null
  }

  export type ApplicationrenttbCountAggregateOutputType = {
    ApplicationRentID: number
    Name: number
    Hash: number
    AddBy: number
    Status: number
    _all: number
  }


  export type ApplicationrenttbAvgAggregateInputType = {
    ApplicationRentID?: true
    AddBy?: true
    Status?: true
  }

  export type ApplicationrenttbSumAggregateInputType = {
    ApplicationRentID?: true
    AddBy?: true
    Status?: true
  }

  export type ApplicationrenttbMinAggregateInputType = {
    ApplicationRentID?: true
    Name?: true
    Hash?: true
    AddBy?: true
    Status?: true
  }

  export type ApplicationrenttbMaxAggregateInputType = {
    ApplicationRentID?: true
    Name?: true
    Hash?: true
    AddBy?: true
    Status?: true
  }

  export type ApplicationrenttbCountAggregateInputType = {
    ApplicationRentID?: true
    Name?: true
    Hash?: true
    AddBy?: true
    Status?: true
    _all?: true
  }

  export type ApplicationrenttbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationrenttb to aggregate.
     */
    where?: applicationrenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationrenttbs to fetch.
     */
    orderBy?: applicationrenttbOrderByWithRelationInput | applicationrenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationrenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationrenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationrenttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applicationrenttbs
    **/
    _count?: true | ApplicationrenttbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationrenttbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationrenttbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationrenttbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationrenttbMaxAggregateInputType
  }

  export type GetApplicationrenttbAggregateType<T extends ApplicationrenttbAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationrenttb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationrenttb[P]>
      : GetScalarType<T[P], AggregateApplicationrenttb[P]>
  }




  export type applicationrenttbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationrenttbWhereInput
    orderBy?: applicationrenttbOrderByWithAggregationInput | applicationrenttbOrderByWithAggregationInput[]
    by: ApplicationrenttbScalarFieldEnum[] | ApplicationrenttbScalarFieldEnum
    having?: applicationrenttbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationrenttbCountAggregateInputType | true
    _avg?: ApplicationrenttbAvgAggregateInputType
    _sum?: ApplicationrenttbSumAggregateInputType
    _min?: ApplicationrenttbMinAggregateInputType
    _max?: ApplicationrenttbMaxAggregateInputType
  }

  export type ApplicationrenttbGroupByOutputType = {
    ApplicationRentID: number
    Name: string
    Hash: string
    AddBy: number
    Status: number
    _count: ApplicationrenttbCountAggregateOutputType | null
    _avg: ApplicationrenttbAvgAggregateOutputType | null
    _sum: ApplicationrenttbSumAggregateOutputType | null
    _min: ApplicationrenttbMinAggregateOutputType | null
    _max: ApplicationrenttbMaxAggregateOutputType | null
  }

  type GetApplicationrenttbGroupByPayload<T extends applicationrenttbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationrenttbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationrenttbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationrenttbGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationrenttbGroupByOutputType[P]>
        }
      >
    >


  export type applicationrenttbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ApplicationRentID?: boolean
    Name?: boolean
    Hash?: boolean
    AddBy?: boolean
    Status?: boolean
  }, ExtArgs["result"]["applicationrenttb"]>


  export type applicationrenttbSelectScalar = {
    ApplicationRentID?: boolean
    Name?: boolean
    Hash?: boolean
    AddBy?: boolean
    Status?: boolean
  }


  export type $applicationrenttbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applicationrenttb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ApplicationRentID: number
      Name: string
      Hash: string
      AddBy: number
      Status: number
    }, ExtArgs["result"]["applicationrenttb"]>
    composites: {}
  }

  type applicationrenttbGetPayload<S extends boolean | null | undefined | applicationrenttbDefaultArgs> = $Result.GetResult<Prisma.$applicationrenttbPayload, S>

  type applicationrenttbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<applicationrenttbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicationrenttbCountAggregateInputType | true
    }

  export interface applicationrenttbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applicationrenttb'], meta: { name: 'applicationrenttb' } }
    /**
     * Find zero or one Applicationrenttb that matches the filter.
     * @param {applicationrenttbFindUniqueArgs} args - Arguments to find a Applicationrenttb
     * @example
     * // Get one Applicationrenttb
     * const applicationrenttb = await prisma.applicationrenttb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicationrenttbFindUniqueArgs>(args: SelectSubset<T, applicationrenttbFindUniqueArgs<ExtArgs>>): Prisma__applicationrenttbClient<$Result.GetResult<Prisma.$applicationrenttbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Applicationrenttb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {applicationrenttbFindUniqueOrThrowArgs} args - Arguments to find a Applicationrenttb
     * @example
     * // Get one Applicationrenttb
     * const applicationrenttb = await prisma.applicationrenttb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicationrenttbFindUniqueOrThrowArgs>(args: SelectSubset<T, applicationrenttbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicationrenttbClient<$Result.GetResult<Prisma.$applicationrenttbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Applicationrenttb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationrenttbFindFirstArgs} args - Arguments to find a Applicationrenttb
     * @example
     * // Get one Applicationrenttb
     * const applicationrenttb = await prisma.applicationrenttb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicationrenttbFindFirstArgs>(args?: SelectSubset<T, applicationrenttbFindFirstArgs<ExtArgs>>): Prisma__applicationrenttbClient<$Result.GetResult<Prisma.$applicationrenttbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Applicationrenttb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationrenttbFindFirstOrThrowArgs} args - Arguments to find a Applicationrenttb
     * @example
     * // Get one Applicationrenttb
     * const applicationrenttb = await prisma.applicationrenttb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicationrenttbFindFirstOrThrowArgs>(args?: SelectSubset<T, applicationrenttbFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicationrenttbClient<$Result.GetResult<Prisma.$applicationrenttbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Applicationrenttbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationrenttbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicationrenttbs
     * const applicationrenttbs = await prisma.applicationrenttb.findMany()
     * 
     * // Get first 10 Applicationrenttbs
     * const applicationrenttbs = await prisma.applicationrenttb.findMany({ take: 10 })
     * 
     * // Only select the `ApplicationRentID`
     * const applicationrenttbWithApplicationRentIDOnly = await prisma.applicationrenttb.findMany({ select: { ApplicationRentID: true } })
     * 
     */
    findMany<T extends applicationrenttbFindManyArgs>(args?: SelectSubset<T, applicationrenttbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationrenttbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Applicationrenttb.
     * @param {applicationrenttbCreateArgs} args - Arguments to create a Applicationrenttb.
     * @example
     * // Create one Applicationrenttb
     * const Applicationrenttb = await prisma.applicationrenttb.create({
     *   data: {
     *     // ... data to create a Applicationrenttb
     *   }
     * })
     * 
     */
    create<T extends applicationrenttbCreateArgs>(args: SelectSubset<T, applicationrenttbCreateArgs<ExtArgs>>): Prisma__applicationrenttbClient<$Result.GetResult<Prisma.$applicationrenttbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Applicationrenttbs.
     * @param {applicationrenttbCreateManyArgs} args - Arguments to create many Applicationrenttbs.
     * @example
     * // Create many Applicationrenttbs
     * const applicationrenttb = await prisma.applicationrenttb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicationrenttbCreateManyArgs>(args?: SelectSubset<T, applicationrenttbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Applicationrenttb.
     * @param {applicationrenttbDeleteArgs} args - Arguments to delete one Applicationrenttb.
     * @example
     * // Delete one Applicationrenttb
     * const Applicationrenttb = await prisma.applicationrenttb.delete({
     *   where: {
     *     // ... filter to delete one Applicationrenttb
     *   }
     * })
     * 
     */
    delete<T extends applicationrenttbDeleteArgs>(args: SelectSubset<T, applicationrenttbDeleteArgs<ExtArgs>>): Prisma__applicationrenttbClient<$Result.GetResult<Prisma.$applicationrenttbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Applicationrenttb.
     * @param {applicationrenttbUpdateArgs} args - Arguments to update one Applicationrenttb.
     * @example
     * // Update one Applicationrenttb
     * const applicationrenttb = await prisma.applicationrenttb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicationrenttbUpdateArgs>(args: SelectSubset<T, applicationrenttbUpdateArgs<ExtArgs>>): Prisma__applicationrenttbClient<$Result.GetResult<Prisma.$applicationrenttbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Applicationrenttbs.
     * @param {applicationrenttbDeleteManyArgs} args - Arguments to filter Applicationrenttbs to delete.
     * @example
     * // Delete a few Applicationrenttbs
     * const { count } = await prisma.applicationrenttb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicationrenttbDeleteManyArgs>(args?: SelectSubset<T, applicationrenttbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicationrenttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationrenttbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicationrenttbs
     * const applicationrenttb = await prisma.applicationrenttb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicationrenttbUpdateManyArgs>(args: SelectSubset<T, applicationrenttbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Applicationrenttb.
     * @param {applicationrenttbUpsertArgs} args - Arguments to update or create a Applicationrenttb.
     * @example
     * // Update or create a Applicationrenttb
     * const applicationrenttb = await prisma.applicationrenttb.upsert({
     *   create: {
     *     // ... data to create a Applicationrenttb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicationrenttb we want to update
     *   }
     * })
     */
    upsert<T extends applicationrenttbUpsertArgs>(args: SelectSubset<T, applicationrenttbUpsertArgs<ExtArgs>>): Prisma__applicationrenttbClient<$Result.GetResult<Prisma.$applicationrenttbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Applicationrenttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationrenttbCountArgs} args - Arguments to filter Applicationrenttbs to count.
     * @example
     * // Count the number of Applicationrenttbs
     * const count = await prisma.applicationrenttb.count({
     *   where: {
     *     // ... the filter for the Applicationrenttbs we want to count
     *   }
     * })
    **/
    count<T extends applicationrenttbCountArgs>(
      args?: Subset<T, applicationrenttbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationrenttbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicationrenttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationrenttbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationrenttbAggregateArgs>(args: Subset<T, ApplicationrenttbAggregateArgs>): Prisma.PrismaPromise<GetApplicationrenttbAggregateType<T>>

    /**
     * Group by Applicationrenttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationrenttbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationrenttbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationrenttbGroupByArgs['orderBy'] }
        : { orderBy?: applicationrenttbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationrenttbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationrenttbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applicationrenttb model
   */
  readonly fields: applicationrenttbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applicationrenttb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationrenttbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the applicationrenttb model
   */ 
  interface applicationrenttbFieldRefs {
    readonly ApplicationRentID: FieldRef<"applicationrenttb", 'Int'>
    readonly Name: FieldRef<"applicationrenttb", 'String'>
    readonly Hash: FieldRef<"applicationrenttb", 'String'>
    readonly AddBy: FieldRef<"applicationrenttb", 'Int'>
    readonly Status: FieldRef<"applicationrenttb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * applicationrenttb findUnique
   */
  export type applicationrenttbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
    /**
     * Filter, which applicationrenttb to fetch.
     */
    where: applicationrenttbWhereUniqueInput
  }

  /**
   * applicationrenttb findUniqueOrThrow
   */
  export type applicationrenttbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
    /**
     * Filter, which applicationrenttb to fetch.
     */
    where: applicationrenttbWhereUniqueInput
  }

  /**
   * applicationrenttb findFirst
   */
  export type applicationrenttbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
    /**
     * Filter, which applicationrenttb to fetch.
     */
    where?: applicationrenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationrenttbs to fetch.
     */
    orderBy?: applicationrenttbOrderByWithRelationInput | applicationrenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationrenttbs.
     */
    cursor?: applicationrenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationrenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationrenttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationrenttbs.
     */
    distinct?: ApplicationrenttbScalarFieldEnum | ApplicationrenttbScalarFieldEnum[]
  }

  /**
   * applicationrenttb findFirstOrThrow
   */
  export type applicationrenttbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
    /**
     * Filter, which applicationrenttb to fetch.
     */
    where?: applicationrenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationrenttbs to fetch.
     */
    orderBy?: applicationrenttbOrderByWithRelationInput | applicationrenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationrenttbs.
     */
    cursor?: applicationrenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationrenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationrenttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationrenttbs.
     */
    distinct?: ApplicationrenttbScalarFieldEnum | ApplicationrenttbScalarFieldEnum[]
  }

  /**
   * applicationrenttb findMany
   */
  export type applicationrenttbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
    /**
     * Filter, which applicationrenttbs to fetch.
     */
    where?: applicationrenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationrenttbs to fetch.
     */
    orderBy?: applicationrenttbOrderByWithRelationInput | applicationrenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applicationrenttbs.
     */
    cursor?: applicationrenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationrenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationrenttbs.
     */
    skip?: number
    distinct?: ApplicationrenttbScalarFieldEnum | ApplicationrenttbScalarFieldEnum[]
  }

  /**
   * applicationrenttb create
   */
  export type applicationrenttbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
    /**
     * The data needed to create a applicationrenttb.
     */
    data?: XOR<applicationrenttbCreateInput, applicationrenttbUncheckedCreateInput>
  }

  /**
   * applicationrenttb createMany
   */
  export type applicationrenttbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applicationrenttbs.
     */
    data: applicationrenttbCreateManyInput | applicationrenttbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * applicationrenttb update
   */
  export type applicationrenttbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
    /**
     * The data needed to update a applicationrenttb.
     */
    data: XOR<applicationrenttbUpdateInput, applicationrenttbUncheckedUpdateInput>
    /**
     * Choose, which applicationrenttb to update.
     */
    where: applicationrenttbWhereUniqueInput
  }

  /**
   * applicationrenttb updateMany
   */
  export type applicationrenttbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applicationrenttbs.
     */
    data: XOR<applicationrenttbUpdateManyMutationInput, applicationrenttbUncheckedUpdateManyInput>
    /**
     * Filter which applicationrenttbs to update
     */
    where?: applicationrenttbWhereInput
  }

  /**
   * applicationrenttb upsert
   */
  export type applicationrenttbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
    /**
     * The filter to search for the applicationrenttb to update in case it exists.
     */
    where: applicationrenttbWhereUniqueInput
    /**
     * In case the applicationrenttb found by the `where` argument doesn't exist, create a new applicationrenttb with this data.
     */
    create: XOR<applicationrenttbCreateInput, applicationrenttbUncheckedCreateInput>
    /**
     * In case the applicationrenttb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationrenttbUpdateInput, applicationrenttbUncheckedUpdateInput>
  }

  /**
   * applicationrenttb delete
   */
  export type applicationrenttbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
    /**
     * Filter which applicationrenttb to delete.
     */
    where: applicationrenttbWhereUniqueInput
  }

  /**
   * applicationrenttb deleteMany
   */
  export type applicationrenttbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationrenttbs to delete
     */
    where?: applicationrenttbWhereInput
  }

  /**
   * applicationrenttb without action
   */
  export type applicationrenttbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationrenttb
     */
    select?: applicationrenttbSelect<ExtArgs> | null
  }


  /**
   * Model applicationtb
   */

  export type AggregateApplicationtb = {
    _count: ApplicationtbCountAggregateOutputType | null
    _avg: ApplicationtbAvgAggregateOutputType | null
    _sum: ApplicationtbSumAggregateOutputType | null
    _min: ApplicationtbMinAggregateOutputType | null
    _max: ApplicationtbMaxAggregateOutputType | null
  }

  export type ApplicationtbAvgAggregateOutputType = {
    ApplicationId: number | null
    RestrictType: number | null
    AppType: number | null
    AddedBy: number | null
  }

  export type ApplicationtbSumAggregateOutputType = {
    ApplicationId: number | null
    RestrictType: number | null
    AppType: number | null
    AddedBy: number | null
  }

  export type ApplicationtbMinAggregateOutputType = {
    ApplicationId: number | null
    ApplicationName: string | null
    Description: string | null
    RestrictType: number | null
    Hash: string | null
    AppType: number | null
    AddedBy: number | null
  }

  export type ApplicationtbMaxAggregateOutputType = {
    ApplicationId: number | null
    ApplicationName: string | null
    Description: string | null
    RestrictType: number | null
    Hash: string | null
    AppType: number | null
    AddedBy: number | null
  }

  export type ApplicationtbCountAggregateOutputType = {
    ApplicationId: number
    ApplicationName: number
    Description: number
    RestrictType: number
    Hash: number
    AppType: number
    AddedBy: number
    _all: number
  }


  export type ApplicationtbAvgAggregateInputType = {
    ApplicationId?: true
    RestrictType?: true
    AppType?: true
    AddedBy?: true
  }

  export type ApplicationtbSumAggregateInputType = {
    ApplicationId?: true
    RestrictType?: true
    AppType?: true
    AddedBy?: true
  }

  export type ApplicationtbMinAggregateInputType = {
    ApplicationId?: true
    ApplicationName?: true
    Description?: true
    RestrictType?: true
    Hash?: true
    AppType?: true
    AddedBy?: true
  }

  export type ApplicationtbMaxAggregateInputType = {
    ApplicationId?: true
    ApplicationName?: true
    Description?: true
    RestrictType?: true
    Hash?: true
    AppType?: true
    AddedBy?: true
  }

  export type ApplicationtbCountAggregateInputType = {
    ApplicationId?: true
    ApplicationName?: true
    Description?: true
    RestrictType?: true
    Hash?: true
    AppType?: true
    AddedBy?: true
    _all?: true
  }

  export type ApplicationtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationtb to aggregate.
     */
    where?: applicationtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationtbs to fetch.
     */
    orderBy?: applicationtbOrderByWithRelationInput | applicationtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicationtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applicationtbs
    **/
    _count?: true | ApplicationtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationtbMaxAggregateInputType
  }

  export type GetApplicationtbAggregateType<T extends ApplicationtbAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicationtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicationtb[P]>
      : GetScalarType<T[P], AggregateApplicationtb[P]>
  }




  export type applicationtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicationtbWhereInput
    orderBy?: applicationtbOrderByWithAggregationInput | applicationtbOrderByWithAggregationInput[]
    by: ApplicationtbScalarFieldEnum[] | ApplicationtbScalarFieldEnum
    having?: applicationtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationtbCountAggregateInputType | true
    _avg?: ApplicationtbAvgAggregateInputType
    _sum?: ApplicationtbSumAggregateInputType
    _min?: ApplicationtbMinAggregateInputType
    _max?: ApplicationtbMaxAggregateInputType
  }

  export type ApplicationtbGroupByOutputType = {
    ApplicationId: number
    ApplicationName: string
    Description: string | null
    RestrictType: number
    Hash: string | null
    AppType: number
    AddedBy: number
    _count: ApplicationtbCountAggregateOutputType | null
    _avg: ApplicationtbAvgAggregateOutputType | null
    _sum: ApplicationtbSumAggregateOutputType | null
    _min: ApplicationtbMinAggregateOutputType | null
    _max: ApplicationtbMaxAggregateOutputType | null
  }

  type GetApplicationtbGroupByPayload<T extends applicationtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationtbGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationtbGroupByOutputType[P]>
        }
      >
    >


  export type applicationtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ApplicationId?: boolean
    ApplicationName?: boolean
    Description?: boolean
    RestrictType?: boolean
    Hash?: boolean
    AppType?: boolean
    AddedBy?: boolean
  }, ExtArgs["result"]["applicationtb"]>


  export type applicationtbSelectScalar = {
    ApplicationId?: boolean
    ApplicationName?: boolean
    Description?: boolean
    RestrictType?: boolean
    Hash?: boolean
    AppType?: boolean
    AddedBy?: boolean
  }


  export type $applicationtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applicationtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ApplicationId: number
      ApplicationName: string
      Description: string | null
      RestrictType: number
      Hash: string | null
      AppType: number
      AddedBy: number
    }, ExtArgs["result"]["applicationtb"]>
    composites: {}
  }

  type applicationtbGetPayload<S extends boolean | null | undefined | applicationtbDefaultArgs> = $Result.GetResult<Prisma.$applicationtbPayload, S>

  type applicationtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<applicationtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicationtbCountAggregateInputType | true
    }

  export interface applicationtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applicationtb'], meta: { name: 'applicationtb' } }
    /**
     * Find zero or one Applicationtb that matches the filter.
     * @param {applicationtbFindUniqueArgs} args - Arguments to find a Applicationtb
     * @example
     * // Get one Applicationtb
     * const applicationtb = await prisma.applicationtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicationtbFindUniqueArgs>(args: SelectSubset<T, applicationtbFindUniqueArgs<ExtArgs>>): Prisma__applicationtbClient<$Result.GetResult<Prisma.$applicationtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Applicationtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {applicationtbFindUniqueOrThrowArgs} args - Arguments to find a Applicationtb
     * @example
     * // Get one Applicationtb
     * const applicationtb = await prisma.applicationtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicationtbFindUniqueOrThrowArgs>(args: SelectSubset<T, applicationtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicationtbClient<$Result.GetResult<Prisma.$applicationtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Applicationtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtbFindFirstArgs} args - Arguments to find a Applicationtb
     * @example
     * // Get one Applicationtb
     * const applicationtb = await prisma.applicationtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicationtbFindFirstArgs>(args?: SelectSubset<T, applicationtbFindFirstArgs<ExtArgs>>): Prisma__applicationtbClient<$Result.GetResult<Prisma.$applicationtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Applicationtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtbFindFirstOrThrowArgs} args - Arguments to find a Applicationtb
     * @example
     * // Get one Applicationtb
     * const applicationtb = await prisma.applicationtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicationtbFindFirstOrThrowArgs>(args?: SelectSubset<T, applicationtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicationtbClient<$Result.GetResult<Prisma.$applicationtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Applicationtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicationtbs
     * const applicationtbs = await prisma.applicationtb.findMany()
     * 
     * // Get first 10 Applicationtbs
     * const applicationtbs = await prisma.applicationtb.findMany({ take: 10 })
     * 
     * // Only select the `ApplicationId`
     * const applicationtbWithApplicationIdOnly = await prisma.applicationtb.findMany({ select: { ApplicationId: true } })
     * 
     */
    findMany<T extends applicationtbFindManyArgs>(args?: SelectSubset<T, applicationtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicationtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Applicationtb.
     * @param {applicationtbCreateArgs} args - Arguments to create a Applicationtb.
     * @example
     * // Create one Applicationtb
     * const Applicationtb = await prisma.applicationtb.create({
     *   data: {
     *     // ... data to create a Applicationtb
     *   }
     * })
     * 
     */
    create<T extends applicationtbCreateArgs>(args: SelectSubset<T, applicationtbCreateArgs<ExtArgs>>): Prisma__applicationtbClient<$Result.GetResult<Prisma.$applicationtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Applicationtbs.
     * @param {applicationtbCreateManyArgs} args - Arguments to create many Applicationtbs.
     * @example
     * // Create many Applicationtbs
     * const applicationtb = await prisma.applicationtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicationtbCreateManyArgs>(args?: SelectSubset<T, applicationtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Applicationtb.
     * @param {applicationtbDeleteArgs} args - Arguments to delete one Applicationtb.
     * @example
     * // Delete one Applicationtb
     * const Applicationtb = await prisma.applicationtb.delete({
     *   where: {
     *     // ... filter to delete one Applicationtb
     *   }
     * })
     * 
     */
    delete<T extends applicationtbDeleteArgs>(args: SelectSubset<T, applicationtbDeleteArgs<ExtArgs>>): Prisma__applicationtbClient<$Result.GetResult<Prisma.$applicationtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Applicationtb.
     * @param {applicationtbUpdateArgs} args - Arguments to update one Applicationtb.
     * @example
     * // Update one Applicationtb
     * const applicationtb = await prisma.applicationtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicationtbUpdateArgs>(args: SelectSubset<T, applicationtbUpdateArgs<ExtArgs>>): Prisma__applicationtbClient<$Result.GetResult<Prisma.$applicationtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Applicationtbs.
     * @param {applicationtbDeleteManyArgs} args - Arguments to filter Applicationtbs to delete.
     * @example
     * // Delete a few Applicationtbs
     * const { count } = await prisma.applicationtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicationtbDeleteManyArgs>(args?: SelectSubset<T, applicationtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicationtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicationtbs
     * const applicationtb = await prisma.applicationtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicationtbUpdateManyArgs>(args: SelectSubset<T, applicationtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Applicationtb.
     * @param {applicationtbUpsertArgs} args - Arguments to update or create a Applicationtb.
     * @example
     * // Update or create a Applicationtb
     * const applicationtb = await prisma.applicationtb.upsert({
     *   create: {
     *     // ... data to create a Applicationtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicationtb we want to update
     *   }
     * })
     */
    upsert<T extends applicationtbUpsertArgs>(args: SelectSubset<T, applicationtbUpsertArgs<ExtArgs>>): Prisma__applicationtbClient<$Result.GetResult<Prisma.$applicationtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Applicationtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtbCountArgs} args - Arguments to filter Applicationtbs to count.
     * @example
     * // Count the number of Applicationtbs
     * const count = await prisma.applicationtb.count({
     *   where: {
     *     // ... the filter for the Applicationtbs we want to count
     *   }
     * })
    **/
    count<T extends applicationtbCountArgs>(
      args?: Subset<T, applicationtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicationtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationtbAggregateArgs>(args: Subset<T, ApplicationtbAggregateArgs>): Prisma.PrismaPromise<GetApplicationtbAggregateType<T>>

    /**
     * Group by Applicationtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicationtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicationtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicationtbGroupByArgs['orderBy'] }
        : { orderBy?: applicationtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicationtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applicationtb model
   */
  readonly fields: applicationtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applicationtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicationtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the applicationtb model
   */ 
  interface applicationtbFieldRefs {
    readonly ApplicationId: FieldRef<"applicationtb", 'Int'>
    readonly ApplicationName: FieldRef<"applicationtb", 'String'>
    readonly Description: FieldRef<"applicationtb", 'String'>
    readonly RestrictType: FieldRef<"applicationtb", 'Int'>
    readonly Hash: FieldRef<"applicationtb", 'String'>
    readonly AppType: FieldRef<"applicationtb", 'Int'>
    readonly AddedBy: FieldRef<"applicationtb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * applicationtb findUnique
   */
  export type applicationtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
    /**
     * Filter, which applicationtb to fetch.
     */
    where: applicationtbWhereUniqueInput
  }

  /**
   * applicationtb findUniqueOrThrow
   */
  export type applicationtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
    /**
     * Filter, which applicationtb to fetch.
     */
    where: applicationtbWhereUniqueInput
  }

  /**
   * applicationtb findFirst
   */
  export type applicationtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
    /**
     * Filter, which applicationtb to fetch.
     */
    where?: applicationtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationtbs to fetch.
     */
    orderBy?: applicationtbOrderByWithRelationInput | applicationtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationtbs.
     */
    cursor?: applicationtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationtbs.
     */
    distinct?: ApplicationtbScalarFieldEnum | ApplicationtbScalarFieldEnum[]
  }

  /**
   * applicationtb findFirstOrThrow
   */
  export type applicationtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
    /**
     * Filter, which applicationtb to fetch.
     */
    where?: applicationtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationtbs to fetch.
     */
    orderBy?: applicationtbOrderByWithRelationInput | applicationtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicationtbs.
     */
    cursor?: applicationtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicationtbs.
     */
    distinct?: ApplicationtbScalarFieldEnum | ApplicationtbScalarFieldEnum[]
  }

  /**
   * applicationtb findMany
   */
  export type applicationtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
    /**
     * Filter, which applicationtbs to fetch.
     */
    where?: applicationtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicationtbs to fetch.
     */
    orderBy?: applicationtbOrderByWithRelationInput | applicationtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applicationtbs.
     */
    cursor?: applicationtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicationtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicationtbs.
     */
    skip?: number
    distinct?: ApplicationtbScalarFieldEnum | ApplicationtbScalarFieldEnum[]
  }

  /**
   * applicationtb create
   */
  export type applicationtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
    /**
     * The data needed to create a applicationtb.
     */
    data: XOR<applicationtbCreateInput, applicationtbUncheckedCreateInput>
  }

  /**
   * applicationtb createMany
   */
  export type applicationtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applicationtbs.
     */
    data: applicationtbCreateManyInput | applicationtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * applicationtb update
   */
  export type applicationtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
    /**
     * The data needed to update a applicationtb.
     */
    data: XOR<applicationtbUpdateInput, applicationtbUncheckedUpdateInput>
    /**
     * Choose, which applicationtb to update.
     */
    where: applicationtbWhereUniqueInput
  }

  /**
   * applicationtb updateMany
   */
  export type applicationtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applicationtbs.
     */
    data: XOR<applicationtbUpdateManyMutationInput, applicationtbUncheckedUpdateManyInput>
    /**
     * Filter which applicationtbs to update
     */
    where?: applicationtbWhereInput
  }

  /**
   * applicationtb upsert
   */
  export type applicationtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
    /**
     * The filter to search for the applicationtb to update in case it exists.
     */
    where: applicationtbWhereUniqueInput
    /**
     * In case the applicationtb found by the `where` argument doesn't exist, create a new applicationtb with this data.
     */
    create: XOR<applicationtbCreateInput, applicationtbUncheckedCreateInput>
    /**
     * In case the applicationtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicationtbUpdateInput, applicationtbUncheckedUpdateInput>
  }

  /**
   * applicationtb delete
   */
  export type applicationtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
    /**
     * Filter which applicationtb to delete.
     */
    where: applicationtbWhereUniqueInput
  }

  /**
   * applicationtb deleteMany
   */
  export type applicationtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicationtbs to delete
     */
    where?: applicationtbWhereInput
  }

  /**
   * applicationtb without action
   */
  export type applicationtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicationtb
     */
    select?: applicationtbSelect<ExtArgs> | null
  }


  /**
   * Model blacklisttb
   */

  export type AggregateBlacklisttb = {
    _count: BlacklisttbCountAggregateOutputType | null
    _avg: BlacklisttbAvgAggregateOutputType | null
    _sum: BlacklisttbSumAggregateOutputType | null
    _min: BlacklisttbMinAggregateOutputType | null
    _max: BlacklisttbMaxAggregateOutputType | null
  }

  export type BlacklisttbAvgAggregateOutputType = {
    URLId: number | null
    Active: number | null
    AddedBy: number | null
  }

  export type BlacklisttbSumAggregateOutputType = {
    URLId: number | null
    Active: number | null
    AddedBy: number | null
  }

  export type BlacklisttbMinAggregateOutputType = {
    URLId: number | null
    URL: string | null
    Title: string | null
    Description: string | null
    RecordDate: Date | null
    Active: number | null
    AddedBy: number | null
  }

  export type BlacklisttbMaxAggregateOutputType = {
    URLId: number | null
    URL: string | null
    Title: string | null
    Description: string | null
    RecordDate: Date | null
    Active: number | null
    AddedBy: number | null
  }

  export type BlacklisttbCountAggregateOutputType = {
    URLId: number
    URL: number
    Title: number
    Description: number
    RecordDate: number
    Active: number
    AddedBy: number
    _all: number
  }


  export type BlacklisttbAvgAggregateInputType = {
    URLId?: true
    Active?: true
    AddedBy?: true
  }

  export type BlacklisttbSumAggregateInputType = {
    URLId?: true
    Active?: true
    AddedBy?: true
  }

  export type BlacklisttbMinAggregateInputType = {
    URLId?: true
    URL?: true
    Title?: true
    Description?: true
    RecordDate?: true
    Active?: true
    AddedBy?: true
  }

  export type BlacklisttbMaxAggregateInputType = {
    URLId?: true
    URL?: true
    Title?: true
    Description?: true
    RecordDate?: true
    Active?: true
    AddedBy?: true
  }

  export type BlacklisttbCountAggregateInputType = {
    URLId?: true
    URL?: true
    Title?: true
    Description?: true
    RecordDate?: true
    Active?: true
    AddedBy?: true
    _all?: true
  }

  export type BlacklisttbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blacklisttb to aggregate.
     */
    where?: blacklisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blacklisttbs to fetch.
     */
    orderBy?: blacklisttbOrderByWithRelationInput | blacklisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blacklisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blacklisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blacklisttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blacklisttbs
    **/
    _count?: true | BlacklisttbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlacklisttbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlacklisttbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlacklisttbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlacklisttbMaxAggregateInputType
  }

  export type GetBlacklisttbAggregateType<T extends BlacklisttbAggregateArgs> = {
        [P in keyof T & keyof AggregateBlacklisttb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlacklisttb[P]>
      : GetScalarType<T[P], AggregateBlacklisttb[P]>
  }




  export type blacklisttbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blacklisttbWhereInput
    orderBy?: blacklisttbOrderByWithAggregationInput | blacklisttbOrderByWithAggregationInput[]
    by: BlacklisttbScalarFieldEnum[] | BlacklisttbScalarFieldEnum
    having?: blacklisttbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlacklisttbCountAggregateInputType | true
    _avg?: BlacklisttbAvgAggregateInputType
    _sum?: BlacklisttbSumAggregateInputType
    _min?: BlacklisttbMinAggregateInputType
    _max?: BlacklisttbMaxAggregateInputType
  }

  export type BlacklisttbGroupByOutputType = {
    URLId: number
    URL: string
    Title: string | null
    Description: string | null
    RecordDate: Date
    Active: number
    AddedBy: number
    _count: BlacklisttbCountAggregateOutputType | null
    _avg: BlacklisttbAvgAggregateOutputType | null
    _sum: BlacklisttbSumAggregateOutputType | null
    _min: BlacklisttbMinAggregateOutputType | null
    _max: BlacklisttbMaxAggregateOutputType | null
  }

  type GetBlacklisttbGroupByPayload<T extends blacklisttbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlacklisttbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlacklisttbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlacklisttbGroupByOutputType[P]>
            : GetScalarType<T[P], BlacklisttbGroupByOutputType[P]>
        }
      >
    >


  export type blacklisttbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    URLId?: boolean
    URL?: boolean
    Title?: boolean
    Description?: boolean
    RecordDate?: boolean
    Active?: boolean
    AddedBy?: boolean
  }, ExtArgs["result"]["blacklisttb"]>


  export type blacklisttbSelectScalar = {
    URLId?: boolean
    URL?: boolean
    Title?: boolean
    Description?: boolean
    RecordDate?: boolean
    Active?: boolean
    AddedBy?: boolean
  }


  export type $blacklisttbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blacklisttb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      URLId: number
      URL: string
      Title: string | null
      Description: string | null
      RecordDate: Date
      Active: number
      AddedBy: number
    }, ExtArgs["result"]["blacklisttb"]>
    composites: {}
  }

  type blacklisttbGetPayload<S extends boolean | null | undefined | blacklisttbDefaultArgs> = $Result.GetResult<Prisma.$blacklisttbPayload, S>

  type blacklisttbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<blacklisttbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BlacklisttbCountAggregateInputType | true
    }

  export interface blacklisttbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blacklisttb'], meta: { name: 'blacklisttb' } }
    /**
     * Find zero or one Blacklisttb that matches the filter.
     * @param {blacklisttbFindUniqueArgs} args - Arguments to find a Blacklisttb
     * @example
     * // Get one Blacklisttb
     * const blacklisttb = await prisma.blacklisttb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blacklisttbFindUniqueArgs>(args: SelectSubset<T, blacklisttbFindUniqueArgs<ExtArgs>>): Prisma__blacklisttbClient<$Result.GetResult<Prisma.$blacklisttbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Blacklisttb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {blacklisttbFindUniqueOrThrowArgs} args - Arguments to find a Blacklisttb
     * @example
     * // Get one Blacklisttb
     * const blacklisttb = await prisma.blacklisttb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blacklisttbFindUniqueOrThrowArgs>(args: SelectSubset<T, blacklisttbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blacklisttbClient<$Result.GetResult<Prisma.$blacklisttbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Blacklisttb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklisttbFindFirstArgs} args - Arguments to find a Blacklisttb
     * @example
     * // Get one Blacklisttb
     * const blacklisttb = await prisma.blacklisttb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blacklisttbFindFirstArgs>(args?: SelectSubset<T, blacklisttbFindFirstArgs<ExtArgs>>): Prisma__blacklisttbClient<$Result.GetResult<Prisma.$blacklisttbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Blacklisttb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklisttbFindFirstOrThrowArgs} args - Arguments to find a Blacklisttb
     * @example
     * // Get one Blacklisttb
     * const blacklisttb = await prisma.blacklisttb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blacklisttbFindFirstOrThrowArgs>(args?: SelectSubset<T, blacklisttbFindFirstOrThrowArgs<ExtArgs>>): Prisma__blacklisttbClient<$Result.GetResult<Prisma.$blacklisttbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Blacklisttbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklisttbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blacklisttbs
     * const blacklisttbs = await prisma.blacklisttb.findMany()
     * 
     * // Get first 10 Blacklisttbs
     * const blacklisttbs = await prisma.blacklisttb.findMany({ take: 10 })
     * 
     * // Only select the `URLId`
     * const blacklisttbWithURLIdOnly = await prisma.blacklisttb.findMany({ select: { URLId: true } })
     * 
     */
    findMany<T extends blacklisttbFindManyArgs>(args?: SelectSubset<T, blacklisttbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blacklisttbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Blacklisttb.
     * @param {blacklisttbCreateArgs} args - Arguments to create a Blacklisttb.
     * @example
     * // Create one Blacklisttb
     * const Blacklisttb = await prisma.blacklisttb.create({
     *   data: {
     *     // ... data to create a Blacklisttb
     *   }
     * })
     * 
     */
    create<T extends blacklisttbCreateArgs>(args: SelectSubset<T, blacklisttbCreateArgs<ExtArgs>>): Prisma__blacklisttbClient<$Result.GetResult<Prisma.$blacklisttbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Blacklisttbs.
     * @param {blacklisttbCreateManyArgs} args - Arguments to create many Blacklisttbs.
     * @example
     * // Create many Blacklisttbs
     * const blacklisttb = await prisma.blacklisttb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blacklisttbCreateManyArgs>(args?: SelectSubset<T, blacklisttbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blacklisttb.
     * @param {blacklisttbDeleteArgs} args - Arguments to delete one Blacklisttb.
     * @example
     * // Delete one Blacklisttb
     * const Blacklisttb = await prisma.blacklisttb.delete({
     *   where: {
     *     // ... filter to delete one Blacklisttb
     *   }
     * })
     * 
     */
    delete<T extends blacklisttbDeleteArgs>(args: SelectSubset<T, blacklisttbDeleteArgs<ExtArgs>>): Prisma__blacklisttbClient<$Result.GetResult<Prisma.$blacklisttbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Blacklisttb.
     * @param {blacklisttbUpdateArgs} args - Arguments to update one Blacklisttb.
     * @example
     * // Update one Blacklisttb
     * const blacklisttb = await prisma.blacklisttb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blacklisttbUpdateArgs>(args: SelectSubset<T, blacklisttbUpdateArgs<ExtArgs>>): Prisma__blacklisttbClient<$Result.GetResult<Prisma.$blacklisttbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Blacklisttbs.
     * @param {blacklisttbDeleteManyArgs} args - Arguments to filter Blacklisttbs to delete.
     * @example
     * // Delete a few Blacklisttbs
     * const { count } = await prisma.blacklisttb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blacklisttbDeleteManyArgs>(args?: SelectSubset<T, blacklisttbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blacklisttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklisttbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blacklisttbs
     * const blacklisttb = await prisma.blacklisttb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blacklisttbUpdateManyArgs>(args: SelectSubset<T, blacklisttbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blacklisttb.
     * @param {blacklisttbUpsertArgs} args - Arguments to update or create a Blacklisttb.
     * @example
     * // Update or create a Blacklisttb
     * const blacklisttb = await prisma.blacklisttb.upsert({
     *   create: {
     *     // ... data to create a Blacklisttb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blacklisttb we want to update
     *   }
     * })
     */
    upsert<T extends blacklisttbUpsertArgs>(args: SelectSubset<T, blacklisttbUpsertArgs<ExtArgs>>): Prisma__blacklisttbClient<$Result.GetResult<Prisma.$blacklisttbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Blacklisttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklisttbCountArgs} args - Arguments to filter Blacklisttbs to count.
     * @example
     * // Count the number of Blacklisttbs
     * const count = await prisma.blacklisttb.count({
     *   where: {
     *     // ... the filter for the Blacklisttbs we want to count
     *   }
     * })
    **/
    count<T extends blacklisttbCountArgs>(
      args?: Subset<T, blacklisttbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlacklisttbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blacklisttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklisttbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlacklisttbAggregateArgs>(args: Subset<T, BlacklisttbAggregateArgs>): Prisma.PrismaPromise<GetBlacklisttbAggregateType<T>>

    /**
     * Group by Blacklisttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklisttbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blacklisttbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blacklisttbGroupByArgs['orderBy'] }
        : { orderBy?: blacklisttbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blacklisttbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlacklisttbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blacklisttb model
   */
  readonly fields: blacklisttbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blacklisttb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blacklisttbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blacklisttb model
   */ 
  interface blacklisttbFieldRefs {
    readonly URLId: FieldRef<"blacklisttb", 'Int'>
    readonly URL: FieldRef<"blacklisttb", 'String'>
    readonly Title: FieldRef<"blacklisttb", 'String'>
    readonly Description: FieldRef<"blacklisttb", 'String'>
    readonly RecordDate: FieldRef<"blacklisttb", 'DateTime'>
    readonly Active: FieldRef<"blacklisttb", 'Int'>
    readonly AddedBy: FieldRef<"blacklisttb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * blacklisttb findUnique
   */
  export type blacklisttbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
    /**
     * Filter, which blacklisttb to fetch.
     */
    where: blacklisttbWhereUniqueInput
  }

  /**
   * blacklisttb findUniqueOrThrow
   */
  export type blacklisttbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
    /**
     * Filter, which blacklisttb to fetch.
     */
    where: blacklisttbWhereUniqueInput
  }

  /**
   * blacklisttb findFirst
   */
  export type blacklisttbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
    /**
     * Filter, which blacklisttb to fetch.
     */
    where?: blacklisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blacklisttbs to fetch.
     */
    orderBy?: blacklisttbOrderByWithRelationInput | blacklisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blacklisttbs.
     */
    cursor?: blacklisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blacklisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blacklisttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blacklisttbs.
     */
    distinct?: BlacklisttbScalarFieldEnum | BlacklisttbScalarFieldEnum[]
  }

  /**
   * blacklisttb findFirstOrThrow
   */
  export type blacklisttbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
    /**
     * Filter, which blacklisttb to fetch.
     */
    where?: blacklisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blacklisttbs to fetch.
     */
    orderBy?: blacklisttbOrderByWithRelationInput | blacklisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blacklisttbs.
     */
    cursor?: blacklisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blacklisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blacklisttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blacklisttbs.
     */
    distinct?: BlacklisttbScalarFieldEnum | BlacklisttbScalarFieldEnum[]
  }

  /**
   * blacklisttb findMany
   */
  export type blacklisttbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
    /**
     * Filter, which blacklisttbs to fetch.
     */
    where?: blacklisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blacklisttbs to fetch.
     */
    orderBy?: blacklisttbOrderByWithRelationInput | blacklisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blacklisttbs.
     */
    cursor?: blacklisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blacklisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blacklisttbs.
     */
    skip?: number
    distinct?: BlacklisttbScalarFieldEnum | BlacklisttbScalarFieldEnum[]
  }

  /**
   * blacklisttb create
   */
  export type blacklisttbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
    /**
     * The data needed to create a blacklisttb.
     */
    data: XOR<blacklisttbCreateInput, blacklisttbUncheckedCreateInput>
  }

  /**
   * blacklisttb createMany
   */
  export type blacklisttbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blacklisttbs.
     */
    data: blacklisttbCreateManyInput | blacklisttbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blacklisttb update
   */
  export type blacklisttbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
    /**
     * The data needed to update a blacklisttb.
     */
    data: XOR<blacklisttbUpdateInput, blacklisttbUncheckedUpdateInput>
    /**
     * Choose, which blacklisttb to update.
     */
    where: blacklisttbWhereUniqueInput
  }

  /**
   * blacklisttb updateMany
   */
  export type blacklisttbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blacklisttbs.
     */
    data: XOR<blacklisttbUpdateManyMutationInput, blacklisttbUncheckedUpdateManyInput>
    /**
     * Filter which blacklisttbs to update
     */
    where?: blacklisttbWhereInput
  }

  /**
   * blacklisttb upsert
   */
  export type blacklisttbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
    /**
     * The filter to search for the blacklisttb to update in case it exists.
     */
    where: blacklisttbWhereUniqueInput
    /**
     * In case the blacklisttb found by the `where` argument doesn't exist, create a new blacklisttb with this data.
     */
    create: XOR<blacklisttbCreateInput, blacklisttbUncheckedCreateInput>
    /**
     * In case the blacklisttb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blacklisttbUpdateInput, blacklisttbUncheckedUpdateInput>
  }

  /**
   * blacklisttb delete
   */
  export type blacklisttbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
    /**
     * Filter which blacklisttb to delete.
     */
    where: blacklisttbWhereUniqueInput
  }

  /**
   * blacklisttb deleteMany
   */
  export type blacklisttbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blacklisttbs to delete
     */
    where?: blacklisttbWhereInput
  }

  /**
   * blacklisttb without action
   */
  export type blacklisttbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklisttb
     */
    select?: blacklisttbSelect<ExtArgs> | null
  }


  /**
   * Model changepcdetailtb
   */

  export type AggregateChangepcdetailtb = {
    _count: ChangepcdetailtbCountAggregateOutputType | null
    _avg: ChangepcdetailtbAvgAggregateOutputType | null
    _sum: ChangepcdetailtbSumAggregateOutputType | null
    _min: ChangepcdetailtbMinAggregateOutputType | null
    _max: ChangepcdetailtbMaxAggregateOutputType | null
  }

  export type ChangepcdetailtbAvgAggregateOutputType = {
    ChangePCDetailId: number | null
    VoucherId: number | null
    FromMachineId: number | null
    ToMachineId: number | null
    TimeUsed: number | null
    MoneyUsed: number | null
    SessionId: number | null
    LogType: number | null
  }

  export type ChangepcdetailtbSumAggregateOutputType = {
    ChangePCDetailId: number | null
    VoucherId: number | null
    FromMachineId: number | null
    ToMachineId: number | null
    TimeUsed: number | null
    MoneyUsed: number | null
    SessionId: number | null
    LogType: number | null
  }

  export type ChangepcdetailtbMinAggregateOutputType = {
    ChangePCDetailId: number | null
    VoucherId: number | null
    FromMachineId: number | null
    ToMachineId: number | null
    TimeUsed: number | null
    MoneyUsed: number | null
    SessionId: number | null
    ChangePCDate: Date | null
    ChangePCTime: Date | null
    BeginDateTime: Date | null
    LogNote: string | null
    MachineName: string | null
    LogType: number | null
  }

  export type ChangepcdetailtbMaxAggregateOutputType = {
    ChangePCDetailId: number | null
    VoucherId: number | null
    FromMachineId: number | null
    ToMachineId: number | null
    TimeUsed: number | null
    MoneyUsed: number | null
    SessionId: number | null
    ChangePCDate: Date | null
    ChangePCTime: Date | null
    BeginDateTime: Date | null
    LogNote: string | null
    MachineName: string | null
    LogType: number | null
  }

  export type ChangepcdetailtbCountAggregateOutputType = {
    ChangePCDetailId: number
    VoucherId: number
    FromMachineId: number
    ToMachineId: number
    TimeUsed: number
    MoneyUsed: number
    SessionId: number
    ChangePCDate: number
    ChangePCTime: number
    BeginDateTime: number
    LogNote: number
    MachineName: number
    LogType: number
    _all: number
  }


  export type ChangepcdetailtbAvgAggregateInputType = {
    ChangePCDetailId?: true
    VoucherId?: true
    FromMachineId?: true
    ToMachineId?: true
    TimeUsed?: true
    MoneyUsed?: true
    SessionId?: true
    LogType?: true
  }

  export type ChangepcdetailtbSumAggregateInputType = {
    ChangePCDetailId?: true
    VoucherId?: true
    FromMachineId?: true
    ToMachineId?: true
    TimeUsed?: true
    MoneyUsed?: true
    SessionId?: true
    LogType?: true
  }

  export type ChangepcdetailtbMinAggregateInputType = {
    ChangePCDetailId?: true
    VoucherId?: true
    FromMachineId?: true
    ToMachineId?: true
    TimeUsed?: true
    MoneyUsed?: true
    SessionId?: true
    ChangePCDate?: true
    ChangePCTime?: true
    BeginDateTime?: true
    LogNote?: true
    MachineName?: true
    LogType?: true
  }

  export type ChangepcdetailtbMaxAggregateInputType = {
    ChangePCDetailId?: true
    VoucherId?: true
    FromMachineId?: true
    ToMachineId?: true
    TimeUsed?: true
    MoneyUsed?: true
    SessionId?: true
    ChangePCDate?: true
    ChangePCTime?: true
    BeginDateTime?: true
    LogNote?: true
    MachineName?: true
    LogType?: true
  }

  export type ChangepcdetailtbCountAggregateInputType = {
    ChangePCDetailId?: true
    VoucherId?: true
    FromMachineId?: true
    ToMachineId?: true
    TimeUsed?: true
    MoneyUsed?: true
    SessionId?: true
    ChangePCDate?: true
    ChangePCTime?: true
    BeginDateTime?: true
    LogNote?: true
    MachineName?: true
    LogType?: true
    _all?: true
  }

  export type ChangepcdetailtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which changepcdetailtb to aggregate.
     */
    where?: changepcdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of changepcdetailtbs to fetch.
     */
    orderBy?: changepcdetailtbOrderByWithRelationInput | changepcdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: changepcdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` changepcdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` changepcdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned changepcdetailtbs
    **/
    _count?: true | ChangepcdetailtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChangepcdetailtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChangepcdetailtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangepcdetailtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangepcdetailtbMaxAggregateInputType
  }

  export type GetChangepcdetailtbAggregateType<T extends ChangepcdetailtbAggregateArgs> = {
        [P in keyof T & keyof AggregateChangepcdetailtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangepcdetailtb[P]>
      : GetScalarType<T[P], AggregateChangepcdetailtb[P]>
  }




  export type changepcdetailtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: changepcdetailtbWhereInput
    orderBy?: changepcdetailtbOrderByWithAggregationInput | changepcdetailtbOrderByWithAggregationInput[]
    by: ChangepcdetailtbScalarFieldEnum[] | ChangepcdetailtbScalarFieldEnum
    having?: changepcdetailtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangepcdetailtbCountAggregateInputType | true
    _avg?: ChangepcdetailtbAvgAggregateInputType
    _sum?: ChangepcdetailtbSumAggregateInputType
    _min?: ChangepcdetailtbMinAggregateInputType
    _max?: ChangepcdetailtbMaxAggregateInputType
  }

  export type ChangepcdetailtbGroupByOutputType = {
    ChangePCDetailId: number
    VoucherId: number
    FromMachineId: number
    ToMachineId: number
    TimeUsed: number
    MoneyUsed: number
    SessionId: number
    ChangePCDate: Date
    ChangePCTime: Date
    BeginDateTime: Date
    LogNote: string
    MachineName: string
    LogType: number
    _count: ChangepcdetailtbCountAggregateOutputType | null
    _avg: ChangepcdetailtbAvgAggregateOutputType | null
    _sum: ChangepcdetailtbSumAggregateOutputType | null
    _min: ChangepcdetailtbMinAggregateOutputType | null
    _max: ChangepcdetailtbMaxAggregateOutputType | null
  }

  type GetChangepcdetailtbGroupByPayload<T extends changepcdetailtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangepcdetailtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangepcdetailtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangepcdetailtbGroupByOutputType[P]>
            : GetScalarType<T[P], ChangepcdetailtbGroupByOutputType[P]>
        }
      >
    >


  export type changepcdetailtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ChangePCDetailId?: boolean
    VoucherId?: boolean
    FromMachineId?: boolean
    ToMachineId?: boolean
    TimeUsed?: boolean
    MoneyUsed?: boolean
    SessionId?: boolean
    ChangePCDate?: boolean
    ChangePCTime?: boolean
    BeginDateTime?: boolean
    LogNote?: boolean
    MachineName?: boolean
    LogType?: boolean
  }, ExtArgs["result"]["changepcdetailtb"]>


  export type changepcdetailtbSelectScalar = {
    ChangePCDetailId?: boolean
    VoucherId?: boolean
    FromMachineId?: boolean
    ToMachineId?: boolean
    TimeUsed?: boolean
    MoneyUsed?: boolean
    SessionId?: boolean
    ChangePCDate?: boolean
    ChangePCTime?: boolean
    BeginDateTime?: boolean
    LogNote?: boolean
    MachineName?: boolean
    LogType?: boolean
  }


  export type $changepcdetailtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "changepcdetailtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ChangePCDetailId: number
      VoucherId: number
      FromMachineId: number
      ToMachineId: number
      TimeUsed: number
      MoneyUsed: number
      SessionId: number
      ChangePCDate: Date
      ChangePCTime: Date
      BeginDateTime: Date
      LogNote: string
      MachineName: string
      LogType: number
    }, ExtArgs["result"]["changepcdetailtb"]>
    composites: {}
  }

  type changepcdetailtbGetPayload<S extends boolean | null | undefined | changepcdetailtbDefaultArgs> = $Result.GetResult<Prisma.$changepcdetailtbPayload, S>

  type changepcdetailtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<changepcdetailtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChangepcdetailtbCountAggregateInputType | true
    }

  export interface changepcdetailtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['changepcdetailtb'], meta: { name: 'changepcdetailtb' } }
    /**
     * Find zero or one Changepcdetailtb that matches the filter.
     * @param {changepcdetailtbFindUniqueArgs} args - Arguments to find a Changepcdetailtb
     * @example
     * // Get one Changepcdetailtb
     * const changepcdetailtb = await prisma.changepcdetailtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends changepcdetailtbFindUniqueArgs>(args: SelectSubset<T, changepcdetailtbFindUniqueArgs<ExtArgs>>): Prisma__changepcdetailtbClient<$Result.GetResult<Prisma.$changepcdetailtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Changepcdetailtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {changepcdetailtbFindUniqueOrThrowArgs} args - Arguments to find a Changepcdetailtb
     * @example
     * // Get one Changepcdetailtb
     * const changepcdetailtb = await prisma.changepcdetailtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends changepcdetailtbFindUniqueOrThrowArgs>(args: SelectSubset<T, changepcdetailtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__changepcdetailtbClient<$Result.GetResult<Prisma.$changepcdetailtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Changepcdetailtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {changepcdetailtbFindFirstArgs} args - Arguments to find a Changepcdetailtb
     * @example
     * // Get one Changepcdetailtb
     * const changepcdetailtb = await prisma.changepcdetailtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends changepcdetailtbFindFirstArgs>(args?: SelectSubset<T, changepcdetailtbFindFirstArgs<ExtArgs>>): Prisma__changepcdetailtbClient<$Result.GetResult<Prisma.$changepcdetailtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Changepcdetailtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {changepcdetailtbFindFirstOrThrowArgs} args - Arguments to find a Changepcdetailtb
     * @example
     * // Get one Changepcdetailtb
     * const changepcdetailtb = await prisma.changepcdetailtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends changepcdetailtbFindFirstOrThrowArgs>(args?: SelectSubset<T, changepcdetailtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__changepcdetailtbClient<$Result.GetResult<Prisma.$changepcdetailtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Changepcdetailtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {changepcdetailtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Changepcdetailtbs
     * const changepcdetailtbs = await prisma.changepcdetailtb.findMany()
     * 
     * // Get first 10 Changepcdetailtbs
     * const changepcdetailtbs = await prisma.changepcdetailtb.findMany({ take: 10 })
     * 
     * // Only select the `ChangePCDetailId`
     * const changepcdetailtbWithChangePCDetailIdOnly = await prisma.changepcdetailtb.findMany({ select: { ChangePCDetailId: true } })
     * 
     */
    findMany<T extends changepcdetailtbFindManyArgs>(args?: SelectSubset<T, changepcdetailtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$changepcdetailtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Changepcdetailtb.
     * @param {changepcdetailtbCreateArgs} args - Arguments to create a Changepcdetailtb.
     * @example
     * // Create one Changepcdetailtb
     * const Changepcdetailtb = await prisma.changepcdetailtb.create({
     *   data: {
     *     // ... data to create a Changepcdetailtb
     *   }
     * })
     * 
     */
    create<T extends changepcdetailtbCreateArgs>(args: SelectSubset<T, changepcdetailtbCreateArgs<ExtArgs>>): Prisma__changepcdetailtbClient<$Result.GetResult<Prisma.$changepcdetailtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Changepcdetailtbs.
     * @param {changepcdetailtbCreateManyArgs} args - Arguments to create many Changepcdetailtbs.
     * @example
     * // Create many Changepcdetailtbs
     * const changepcdetailtb = await prisma.changepcdetailtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends changepcdetailtbCreateManyArgs>(args?: SelectSubset<T, changepcdetailtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Changepcdetailtb.
     * @param {changepcdetailtbDeleteArgs} args - Arguments to delete one Changepcdetailtb.
     * @example
     * // Delete one Changepcdetailtb
     * const Changepcdetailtb = await prisma.changepcdetailtb.delete({
     *   where: {
     *     // ... filter to delete one Changepcdetailtb
     *   }
     * })
     * 
     */
    delete<T extends changepcdetailtbDeleteArgs>(args: SelectSubset<T, changepcdetailtbDeleteArgs<ExtArgs>>): Prisma__changepcdetailtbClient<$Result.GetResult<Prisma.$changepcdetailtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Changepcdetailtb.
     * @param {changepcdetailtbUpdateArgs} args - Arguments to update one Changepcdetailtb.
     * @example
     * // Update one Changepcdetailtb
     * const changepcdetailtb = await prisma.changepcdetailtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends changepcdetailtbUpdateArgs>(args: SelectSubset<T, changepcdetailtbUpdateArgs<ExtArgs>>): Prisma__changepcdetailtbClient<$Result.GetResult<Prisma.$changepcdetailtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Changepcdetailtbs.
     * @param {changepcdetailtbDeleteManyArgs} args - Arguments to filter Changepcdetailtbs to delete.
     * @example
     * // Delete a few Changepcdetailtbs
     * const { count } = await prisma.changepcdetailtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends changepcdetailtbDeleteManyArgs>(args?: SelectSubset<T, changepcdetailtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Changepcdetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {changepcdetailtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Changepcdetailtbs
     * const changepcdetailtb = await prisma.changepcdetailtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends changepcdetailtbUpdateManyArgs>(args: SelectSubset<T, changepcdetailtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Changepcdetailtb.
     * @param {changepcdetailtbUpsertArgs} args - Arguments to update or create a Changepcdetailtb.
     * @example
     * // Update or create a Changepcdetailtb
     * const changepcdetailtb = await prisma.changepcdetailtb.upsert({
     *   create: {
     *     // ... data to create a Changepcdetailtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Changepcdetailtb we want to update
     *   }
     * })
     */
    upsert<T extends changepcdetailtbUpsertArgs>(args: SelectSubset<T, changepcdetailtbUpsertArgs<ExtArgs>>): Prisma__changepcdetailtbClient<$Result.GetResult<Prisma.$changepcdetailtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Changepcdetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {changepcdetailtbCountArgs} args - Arguments to filter Changepcdetailtbs to count.
     * @example
     * // Count the number of Changepcdetailtbs
     * const count = await prisma.changepcdetailtb.count({
     *   where: {
     *     // ... the filter for the Changepcdetailtbs we want to count
     *   }
     * })
    **/
    count<T extends changepcdetailtbCountArgs>(
      args?: Subset<T, changepcdetailtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangepcdetailtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Changepcdetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangepcdetailtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangepcdetailtbAggregateArgs>(args: Subset<T, ChangepcdetailtbAggregateArgs>): Prisma.PrismaPromise<GetChangepcdetailtbAggregateType<T>>

    /**
     * Group by Changepcdetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {changepcdetailtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends changepcdetailtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: changepcdetailtbGroupByArgs['orderBy'] }
        : { orderBy?: changepcdetailtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, changepcdetailtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangepcdetailtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the changepcdetailtb model
   */
  readonly fields: changepcdetailtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for changepcdetailtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__changepcdetailtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the changepcdetailtb model
   */ 
  interface changepcdetailtbFieldRefs {
    readonly ChangePCDetailId: FieldRef<"changepcdetailtb", 'Int'>
    readonly VoucherId: FieldRef<"changepcdetailtb", 'Int'>
    readonly FromMachineId: FieldRef<"changepcdetailtb", 'Int'>
    readonly ToMachineId: FieldRef<"changepcdetailtb", 'Int'>
    readonly TimeUsed: FieldRef<"changepcdetailtb", 'Int'>
    readonly MoneyUsed: FieldRef<"changepcdetailtb", 'Int'>
    readonly SessionId: FieldRef<"changepcdetailtb", 'Int'>
    readonly ChangePCDate: FieldRef<"changepcdetailtb", 'DateTime'>
    readonly ChangePCTime: FieldRef<"changepcdetailtb", 'DateTime'>
    readonly BeginDateTime: FieldRef<"changepcdetailtb", 'DateTime'>
    readonly LogNote: FieldRef<"changepcdetailtb", 'String'>
    readonly MachineName: FieldRef<"changepcdetailtb", 'String'>
    readonly LogType: FieldRef<"changepcdetailtb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * changepcdetailtb findUnique
   */
  export type changepcdetailtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which changepcdetailtb to fetch.
     */
    where: changepcdetailtbWhereUniqueInput
  }

  /**
   * changepcdetailtb findUniqueOrThrow
   */
  export type changepcdetailtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which changepcdetailtb to fetch.
     */
    where: changepcdetailtbWhereUniqueInput
  }

  /**
   * changepcdetailtb findFirst
   */
  export type changepcdetailtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which changepcdetailtb to fetch.
     */
    where?: changepcdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of changepcdetailtbs to fetch.
     */
    orderBy?: changepcdetailtbOrderByWithRelationInput | changepcdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for changepcdetailtbs.
     */
    cursor?: changepcdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` changepcdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` changepcdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of changepcdetailtbs.
     */
    distinct?: ChangepcdetailtbScalarFieldEnum | ChangepcdetailtbScalarFieldEnum[]
  }

  /**
   * changepcdetailtb findFirstOrThrow
   */
  export type changepcdetailtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which changepcdetailtb to fetch.
     */
    where?: changepcdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of changepcdetailtbs to fetch.
     */
    orderBy?: changepcdetailtbOrderByWithRelationInput | changepcdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for changepcdetailtbs.
     */
    cursor?: changepcdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` changepcdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` changepcdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of changepcdetailtbs.
     */
    distinct?: ChangepcdetailtbScalarFieldEnum | ChangepcdetailtbScalarFieldEnum[]
  }

  /**
   * changepcdetailtb findMany
   */
  export type changepcdetailtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which changepcdetailtbs to fetch.
     */
    where?: changepcdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of changepcdetailtbs to fetch.
     */
    orderBy?: changepcdetailtbOrderByWithRelationInput | changepcdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing changepcdetailtbs.
     */
    cursor?: changepcdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` changepcdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` changepcdetailtbs.
     */
    skip?: number
    distinct?: ChangepcdetailtbScalarFieldEnum | ChangepcdetailtbScalarFieldEnum[]
  }

  /**
   * changepcdetailtb create
   */
  export type changepcdetailtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
    /**
     * The data needed to create a changepcdetailtb.
     */
    data?: XOR<changepcdetailtbCreateInput, changepcdetailtbUncheckedCreateInput>
  }

  /**
   * changepcdetailtb createMany
   */
  export type changepcdetailtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many changepcdetailtbs.
     */
    data: changepcdetailtbCreateManyInput | changepcdetailtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * changepcdetailtb update
   */
  export type changepcdetailtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
    /**
     * The data needed to update a changepcdetailtb.
     */
    data: XOR<changepcdetailtbUpdateInput, changepcdetailtbUncheckedUpdateInput>
    /**
     * Choose, which changepcdetailtb to update.
     */
    where: changepcdetailtbWhereUniqueInput
  }

  /**
   * changepcdetailtb updateMany
   */
  export type changepcdetailtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update changepcdetailtbs.
     */
    data: XOR<changepcdetailtbUpdateManyMutationInput, changepcdetailtbUncheckedUpdateManyInput>
    /**
     * Filter which changepcdetailtbs to update
     */
    where?: changepcdetailtbWhereInput
  }

  /**
   * changepcdetailtb upsert
   */
  export type changepcdetailtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
    /**
     * The filter to search for the changepcdetailtb to update in case it exists.
     */
    where: changepcdetailtbWhereUniqueInput
    /**
     * In case the changepcdetailtb found by the `where` argument doesn't exist, create a new changepcdetailtb with this data.
     */
    create: XOR<changepcdetailtbCreateInput, changepcdetailtbUncheckedCreateInput>
    /**
     * In case the changepcdetailtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<changepcdetailtbUpdateInput, changepcdetailtbUncheckedUpdateInput>
  }

  /**
   * changepcdetailtb delete
   */
  export type changepcdetailtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
    /**
     * Filter which changepcdetailtb to delete.
     */
    where: changepcdetailtbWhereUniqueInput
  }

  /**
   * changepcdetailtb deleteMany
   */
  export type changepcdetailtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which changepcdetailtbs to delete
     */
    where?: changepcdetailtbWhereInput
  }

  /**
   * changepcdetailtb without action
   */
  export type changepcdetailtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the changepcdetailtb
     */
    select?: changepcdetailtbSelect<ExtArgs> | null
  }


  /**
   * Model clientatb
   */

  export type AggregateClientatb = {
    _count: ClientatbCountAggregateOutputType | null
    _avg: ClientatbAvgAggregateOutputType | null
    _sum: ClientatbSumAggregateOutputType | null
    _min: ClientatbMinAggregateOutputType | null
    _max: ClientatbMaxAggregateOutputType | null
  }

  export type ClientatbAvgAggregateOutputType = {
    ID: number | null
    PubID: number | null
    AID: number | null
    STime: number | null
    ETime: number | null
    Panel: number | null
    Row: number | null
    Col: number | null
    CountS: number | null
    CountC: number | null
  }

  export type ClientatbSumAggregateOutputType = {
    ID: number | null
    PubID: number | null
    AID: number | null
    STime: number | null
    ETime: number | null
    Panel: number | null
    Row: number | null
    Col: number | null
    CountS: number | null
    CountC: number | null
  }

  export type ClientatbMinAggregateOutputType = {
    ID: number | null
    PubID: number | null
    AID: number | null
    DateA: string | null
    STime: number | null
    ETime: number | null
    FName: string | null
    FLink: string | null
    Area: string | null
    Panel: number | null
    Row: number | null
    Col: number | null
    Method: string | null
    CountS: number | null
    CountC: number | null
    RecordDate: string | null
  }

  export type ClientatbMaxAggregateOutputType = {
    ID: number | null
    PubID: number | null
    AID: number | null
    DateA: string | null
    STime: number | null
    ETime: number | null
    FName: string | null
    FLink: string | null
    Area: string | null
    Panel: number | null
    Row: number | null
    Col: number | null
    Method: string | null
    CountS: number | null
    CountC: number | null
    RecordDate: string | null
  }

  export type ClientatbCountAggregateOutputType = {
    ID: number
    PubID: number
    AID: number
    DateA: number
    STime: number
    ETime: number
    FName: number
    FLink: number
    Area: number
    Panel: number
    Row: number
    Col: number
    Method: number
    CountS: number
    CountC: number
    RecordDate: number
    _all: number
  }


  export type ClientatbAvgAggregateInputType = {
    ID?: true
    PubID?: true
    AID?: true
    STime?: true
    ETime?: true
    Panel?: true
    Row?: true
    Col?: true
    CountS?: true
    CountC?: true
  }

  export type ClientatbSumAggregateInputType = {
    ID?: true
    PubID?: true
    AID?: true
    STime?: true
    ETime?: true
    Panel?: true
    Row?: true
    Col?: true
    CountS?: true
    CountC?: true
  }

  export type ClientatbMinAggregateInputType = {
    ID?: true
    PubID?: true
    AID?: true
    DateA?: true
    STime?: true
    ETime?: true
    FName?: true
    FLink?: true
    Area?: true
    Panel?: true
    Row?: true
    Col?: true
    Method?: true
    CountS?: true
    CountC?: true
    RecordDate?: true
  }

  export type ClientatbMaxAggregateInputType = {
    ID?: true
    PubID?: true
    AID?: true
    DateA?: true
    STime?: true
    ETime?: true
    FName?: true
    FLink?: true
    Area?: true
    Panel?: true
    Row?: true
    Col?: true
    Method?: true
    CountS?: true
    CountC?: true
    RecordDate?: true
  }

  export type ClientatbCountAggregateInputType = {
    ID?: true
    PubID?: true
    AID?: true
    DateA?: true
    STime?: true
    ETime?: true
    FName?: true
    FLink?: true
    Area?: true
    Panel?: true
    Row?: true
    Col?: true
    Method?: true
    CountS?: true
    CountC?: true
    RecordDate?: true
    _all?: true
  }

  export type ClientatbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientatb to aggregate.
     */
    where?: clientatbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientatbs to fetch.
     */
    orderBy?: clientatbOrderByWithRelationInput | clientatbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientatbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientatbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientatbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientatbs
    **/
    _count?: true | ClientatbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientatbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientatbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientatbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientatbMaxAggregateInputType
  }

  export type GetClientatbAggregateType<T extends ClientatbAggregateArgs> = {
        [P in keyof T & keyof AggregateClientatb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientatb[P]>
      : GetScalarType<T[P], AggregateClientatb[P]>
  }




  export type clientatbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientatbWhereInput
    orderBy?: clientatbOrderByWithAggregationInput | clientatbOrderByWithAggregationInput[]
    by: ClientatbScalarFieldEnum[] | ClientatbScalarFieldEnum
    having?: clientatbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientatbCountAggregateInputType | true
    _avg?: ClientatbAvgAggregateInputType
    _sum?: ClientatbSumAggregateInputType
    _min?: ClientatbMinAggregateInputType
    _max?: ClientatbMaxAggregateInputType
  }

  export type ClientatbGroupByOutputType = {
    ID: number
    PubID: number
    AID: number
    DateA: string
    STime: number
    ETime: number
    FName: string
    FLink: string
    Area: string
    Panel: number
    Row: number
    Col: number
    Method: string
    CountS: number
    CountC: number
    RecordDate: string
    _count: ClientatbCountAggregateOutputType | null
    _avg: ClientatbAvgAggregateOutputType | null
    _sum: ClientatbSumAggregateOutputType | null
    _min: ClientatbMinAggregateOutputType | null
    _max: ClientatbMaxAggregateOutputType | null
  }

  type GetClientatbGroupByPayload<T extends clientatbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientatbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientatbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientatbGroupByOutputType[P]>
            : GetScalarType<T[P], ClientatbGroupByOutputType[P]>
        }
      >
    >


  export type clientatbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    PubID?: boolean
    AID?: boolean
    DateA?: boolean
    STime?: boolean
    ETime?: boolean
    FName?: boolean
    FLink?: boolean
    Area?: boolean
    Panel?: boolean
    Row?: boolean
    Col?: boolean
    Method?: boolean
    CountS?: boolean
    CountC?: boolean
    RecordDate?: boolean
  }, ExtArgs["result"]["clientatb"]>


  export type clientatbSelectScalar = {
    ID?: boolean
    PubID?: boolean
    AID?: boolean
    DateA?: boolean
    STime?: boolean
    ETime?: boolean
    FName?: boolean
    FLink?: boolean
    Area?: boolean
    Panel?: boolean
    Row?: boolean
    Col?: boolean
    Method?: boolean
    CountS?: boolean
    CountC?: boolean
    RecordDate?: boolean
  }


  export type $clientatbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clientatb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      PubID: number
      AID: number
      DateA: string
      STime: number
      ETime: number
      FName: string
      FLink: string
      Area: string
      Panel: number
      Row: number
      Col: number
      Method: string
      CountS: number
      CountC: number
      RecordDate: string
    }, ExtArgs["result"]["clientatb"]>
    composites: {}
  }

  type clientatbGetPayload<S extends boolean | null | undefined | clientatbDefaultArgs> = $Result.GetResult<Prisma.$clientatbPayload, S>

  type clientatbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clientatbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientatbCountAggregateInputType | true
    }

  export interface clientatbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clientatb'], meta: { name: 'clientatb' } }
    /**
     * Find zero or one Clientatb that matches the filter.
     * @param {clientatbFindUniqueArgs} args - Arguments to find a Clientatb
     * @example
     * // Get one Clientatb
     * const clientatb = await prisma.clientatb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientatbFindUniqueArgs>(args: SelectSubset<T, clientatbFindUniqueArgs<ExtArgs>>): Prisma__clientatbClient<$Result.GetResult<Prisma.$clientatbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clientatb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {clientatbFindUniqueOrThrowArgs} args - Arguments to find a Clientatb
     * @example
     * // Get one Clientatb
     * const clientatb = await prisma.clientatb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientatbFindUniqueOrThrowArgs>(args: SelectSubset<T, clientatbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientatbClient<$Result.GetResult<Prisma.$clientatbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clientatb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientatbFindFirstArgs} args - Arguments to find a Clientatb
     * @example
     * // Get one Clientatb
     * const clientatb = await prisma.clientatb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientatbFindFirstArgs>(args?: SelectSubset<T, clientatbFindFirstArgs<ExtArgs>>): Prisma__clientatbClient<$Result.GetResult<Prisma.$clientatbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clientatb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientatbFindFirstOrThrowArgs} args - Arguments to find a Clientatb
     * @example
     * // Get one Clientatb
     * const clientatb = await prisma.clientatb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientatbFindFirstOrThrowArgs>(args?: SelectSubset<T, clientatbFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientatbClient<$Result.GetResult<Prisma.$clientatbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientatbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientatbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientatbs
     * const clientatbs = await prisma.clientatb.findMany()
     * 
     * // Get first 10 Clientatbs
     * const clientatbs = await prisma.clientatb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const clientatbWithIDOnly = await prisma.clientatb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends clientatbFindManyArgs>(args?: SelectSubset<T, clientatbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientatbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clientatb.
     * @param {clientatbCreateArgs} args - Arguments to create a Clientatb.
     * @example
     * // Create one Clientatb
     * const Clientatb = await prisma.clientatb.create({
     *   data: {
     *     // ... data to create a Clientatb
     *   }
     * })
     * 
     */
    create<T extends clientatbCreateArgs>(args: SelectSubset<T, clientatbCreateArgs<ExtArgs>>): Prisma__clientatbClient<$Result.GetResult<Prisma.$clientatbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientatbs.
     * @param {clientatbCreateManyArgs} args - Arguments to create many Clientatbs.
     * @example
     * // Create many Clientatbs
     * const clientatb = await prisma.clientatb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientatbCreateManyArgs>(args?: SelectSubset<T, clientatbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clientatb.
     * @param {clientatbDeleteArgs} args - Arguments to delete one Clientatb.
     * @example
     * // Delete one Clientatb
     * const Clientatb = await prisma.clientatb.delete({
     *   where: {
     *     // ... filter to delete one Clientatb
     *   }
     * })
     * 
     */
    delete<T extends clientatbDeleteArgs>(args: SelectSubset<T, clientatbDeleteArgs<ExtArgs>>): Prisma__clientatbClient<$Result.GetResult<Prisma.$clientatbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clientatb.
     * @param {clientatbUpdateArgs} args - Arguments to update one Clientatb.
     * @example
     * // Update one Clientatb
     * const clientatb = await prisma.clientatb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientatbUpdateArgs>(args: SelectSubset<T, clientatbUpdateArgs<ExtArgs>>): Prisma__clientatbClient<$Result.GetResult<Prisma.$clientatbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientatbs.
     * @param {clientatbDeleteManyArgs} args - Arguments to filter Clientatbs to delete.
     * @example
     * // Delete a few Clientatbs
     * const { count } = await prisma.clientatb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientatbDeleteManyArgs>(args?: SelectSubset<T, clientatbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientatbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientatbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientatbs
     * const clientatb = await prisma.clientatb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientatbUpdateManyArgs>(args: SelectSubset<T, clientatbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientatb.
     * @param {clientatbUpsertArgs} args - Arguments to update or create a Clientatb.
     * @example
     * // Update or create a Clientatb
     * const clientatb = await prisma.clientatb.upsert({
     *   create: {
     *     // ... data to create a Clientatb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientatb we want to update
     *   }
     * })
     */
    upsert<T extends clientatbUpsertArgs>(args: SelectSubset<T, clientatbUpsertArgs<ExtArgs>>): Prisma__clientatbClient<$Result.GetResult<Prisma.$clientatbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientatbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientatbCountArgs} args - Arguments to filter Clientatbs to count.
     * @example
     * // Count the number of Clientatbs
     * const count = await prisma.clientatb.count({
     *   where: {
     *     // ... the filter for the Clientatbs we want to count
     *   }
     * })
    **/
    count<T extends clientatbCountArgs>(
      args?: Subset<T, clientatbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientatbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientatb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientatbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientatbAggregateArgs>(args: Subset<T, ClientatbAggregateArgs>): Prisma.PrismaPromise<GetClientatbAggregateType<T>>

    /**
     * Group by Clientatb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientatbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientatbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientatbGroupByArgs['orderBy'] }
        : { orderBy?: clientatbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientatbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientatbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clientatb model
   */
  readonly fields: clientatbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientatb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientatbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clientatb model
   */ 
  interface clientatbFieldRefs {
    readonly ID: FieldRef<"clientatb", 'Int'>
    readonly PubID: FieldRef<"clientatb", 'Int'>
    readonly AID: FieldRef<"clientatb", 'Int'>
    readonly DateA: FieldRef<"clientatb", 'String'>
    readonly STime: FieldRef<"clientatb", 'Int'>
    readonly ETime: FieldRef<"clientatb", 'Int'>
    readonly FName: FieldRef<"clientatb", 'String'>
    readonly FLink: FieldRef<"clientatb", 'String'>
    readonly Area: FieldRef<"clientatb", 'String'>
    readonly Panel: FieldRef<"clientatb", 'Int'>
    readonly Row: FieldRef<"clientatb", 'Int'>
    readonly Col: FieldRef<"clientatb", 'Int'>
    readonly Method: FieldRef<"clientatb", 'String'>
    readonly CountS: FieldRef<"clientatb", 'Int'>
    readonly CountC: FieldRef<"clientatb", 'Int'>
    readonly RecordDate: FieldRef<"clientatb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clientatb findUnique
   */
  export type clientatbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
    /**
     * Filter, which clientatb to fetch.
     */
    where: clientatbWhereUniqueInput
  }

  /**
   * clientatb findUniqueOrThrow
   */
  export type clientatbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
    /**
     * Filter, which clientatb to fetch.
     */
    where: clientatbWhereUniqueInput
  }

  /**
   * clientatb findFirst
   */
  export type clientatbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
    /**
     * Filter, which clientatb to fetch.
     */
    where?: clientatbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientatbs to fetch.
     */
    orderBy?: clientatbOrderByWithRelationInput | clientatbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientatbs.
     */
    cursor?: clientatbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientatbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientatbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientatbs.
     */
    distinct?: ClientatbScalarFieldEnum | ClientatbScalarFieldEnum[]
  }

  /**
   * clientatb findFirstOrThrow
   */
  export type clientatbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
    /**
     * Filter, which clientatb to fetch.
     */
    where?: clientatbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientatbs to fetch.
     */
    orderBy?: clientatbOrderByWithRelationInput | clientatbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientatbs.
     */
    cursor?: clientatbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientatbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientatbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientatbs.
     */
    distinct?: ClientatbScalarFieldEnum | ClientatbScalarFieldEnum[]
  }

  /**
   * clientatb findMany
   */
  export type clientatbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
    /**
     * Filter, which clientatbs to fetch.
     */
    where?: clientatbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientatbs to fetch.
     */
    orderBy?: clientatbOrderByWithRelationInput | clientatbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientatbs.
     */
    cursor?: clientatbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientatbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientatbs.
     */
    skip?: number
    distinct?: ClientatbScalarFieldEnum | ClientatbScalarFieldEnum[]
  }

  /**
   * clientatb create
   */
  export type clientatbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
    /**
     * The data needed to create a clientatb.
     */
    data?: XOR<clientatbCreateInput, clientatbUncheckedCreateInput>
  }

  /**
   * clientatb createMany
   */
  export type clientatbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientatbs.
     */
    data: clientatbCreateManyInput | clientatbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clientatb update
   */
  export type clientatbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
    /**
     * The data needed to update a clientatb.
     */
    data: XOR<clientatbUpdateInput, clientatbUncheckedUpdateInput>
    /**
     * Choose, which clientatb to update.
     */
    where: clientatbWhereUniqueInput
  }

  /**
   * clientatb updateMany
   */
  export type clientatbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientatbs.
     */
    data: XOR<clientatbUpdateManyMutationInput, clientatbUncheckedUpdateManyInput>
    /**
     * Filter which clientatbs to update
     */
    where?: clientatbWhereInput
  }

  /**
   * clientatb upsert
   */
  export type clientatbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
    /**
     * The filter to search for the clientatb to update in case it exists.
     */
    where: clientatbWhereUniqueInput
    /**
     * In case the clientatb found by the `where` argument doesn't exist, create a new clientatb with this data.
     */
    create: XOR<clientatbCreateInput, clientatbUncheckedCreateInput>
    /**
     * In case the clientatb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientatbUpdateInput, clientatbUncheckedUpdateInput>
  }

  /**
   * clientatb delete
   */
  export type clientatbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
    /**
     * Filter which clientatb to delete.
     */
    where: clientatbWhereUniqueInput
  }

  /**
   * clientatb deleteMany
   */
  export type clientatbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientatbs to delete
     */
    where?: clientatbWhereInput
  }

  /**
   * clientatb without action
   */
  export type clientatbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientatb
     */
    select?: clientatbSelect<ExtArgs> | null
  }


  /**
   * Model clientsystb
   */

  export type AggregateClientsystb = {
    _count: ClientsystbCountAggregateOutputType | null
    _avg: ClientsystbAvgAggregateOutputType | null
    _sum: ClientsystbSumAggregateOutputType | null
    _min: ClientsystbMinAggregateOutputType | null
    _max: ClientsystbMaxAggregateOutputType | null
  }

  export type ClientsystbAvgAggregateOutputType = {
    ID: number | null
    UserId: number | null
    Active: number | null
  }

  export type ClientsystbSumAggregateOutputType = {
    ID: number | null
    UserId: number | null
    Active: number | null
  }

  export type ClientsystbMinAggregateOutputType = {
    ID: number | null
    UserId: number | null
    MAC: string | null
    CPU: string | null
    RAM: string | null
    HD: string | null
    OS: string | null
    CardName: string | null
    ChipType: string | null
    VGAMem: string | null
    NIC: string | null
    FreeSpace: string | null
    CPName: string | null
    Active: number | null
    NTFS: string | null
    FAT: string | null
    Mainboard: string | null
    IP: string | null
    LAN: string | null
    RamFree: string | null
    PageFile: string | null
    TempCPU: string | null
    LoadCPU: string | null
    TempGPU: string | null
    LoadGPU: string | null
    LastUpdate: Date | null
    PCName: string | null
    NetInfo: string | null
  }

  export type ClientsystbMaxAggregateOutputType = {
    ID: number | null
    UserId: number | null
    MAC: string | null
    CPU: string | null
    RAM: string | null
    HD: string | null
    OS: string | null
    CardName: string | null
    ChipType: string | null
    VGAMem: string | null
    NIC: string | null
    FreeSpace: string | null
    CPName: string | null
    Active: number | null
    NTFS: string | null
    FAT: string | null
    Mainboard: string | null
    IP: string | null
    LAN: string | null
    RamFree: string | null
    PageFile: string | null
    TempCPU: string | null
    LoadCPU: string | null
    TempGPU: string | null
    LoadGPU: string | null
    LastUpdate: Date | null
    PCName: string | null
    NetInfo: string | null
  }

  export type ClientsystbCountAggregateOutputType = {
    ID: number
    UserId: number
    MAC: number
    CPU: number
    RAM: number
    HD: number
    OS: number
    CardName: number
    ChipType: number
    VGAMem: number
    NIC: number
    FreeSpace: number
    CPName: number
    Active: number
    NTFS: number
    FAT: number
    Mainboard: number
    IP: number
    LAN: number
    RamFree: number
    PageFile: number
    TempCPU: number
    LoadCPU: number
    TempGPU: number
    LoadGPU: number
    LastUpdate: number
    PCName: number
    NetInfo: number
    _all: number
  }


  export type ClientsystbAvgAggregateInputType = {
    ID?: true
    UserId?: true
    Active?: true
  }

  export type ClientsystbSumAggregateInputType = {
    ID?: true
    UserId?: true
    Active?: true
  }

  export type ClientsystbMinAggregateInputType = {
    ID?: true
    UserId?: true
    MAC?: true
    CPU?: true
    RAM?: true
    HD?: true
    OS?: true
    CardName?: true
    ChipType?: true
    VGAMem?: true
    NIC?: true
    FreeSpace?: true
    CPName?: true
    Active?: true
    NTFS?: true
    FAT?: true
    Mainboard?: true
    IP?: true
    LAN?: true
    RamFree?: true
    PageFile?: true
    TempCPU?: true
    LoadCPU?: true
    TempGPU?: true
    LoadGPU?: true
    LastUpdate?: true
    PCName?: true
    NetInfo?: true
  }

  export type ClientsystbMaxAggregateInputType = {
    ID?: true
    UserId?: true
    MAC?: true
    CPU?: true
    RAM?: true
    HD?: true
    OS?: true
    CardName?: true
    ChipType?: true
    VGAMem?: true
    NIC?: true
    FreeSpace?: true
    CPName?: true
    Active?: true
    NTFS?: true
    FAT?: true
    Mainboard?: true
    IP?: true
    LAN?: true
    RamFree?: true
    PageFile?: true
    TempCPU?: true
    LoadCPU?: true
    TempGPU?: true
    LoadGPU?: true
    LastUpdate?: true
    PCName?: true
    NetInfo?: true
  }

  export type ClientsystbCountAggregateInputType = {
    ID?: true
    UserId?: true
    MAC?: true
    CPU?: true
    RAM?: true
    HD?: true
    OS?: true
    CardName?: true
    ChipType?: true
    VGAMem?: true
    NIC?: true
    FreeSpace?: true
    CPName?: true
    Active?: true
    NTFS?: true
    FAT?: true
    Mainboard?: true
    IP?: true
    LAN?: true
    RamFree?: true
    PageFile?: true
    TempCPU?: true
    LoadCPU?: true
    TempGPU?: true
    LoadGPU?: true
    LastUpdate?: true
    PCName?: true
    NetInfo?: true
    _all?: true
  }

  export type ClientsystbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientsystb to aggregate.
     */
    where?: clientsystbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientsystbs to fetch.
     */
    orderBy?: clientsystbOrderByWithRelationInput | clientsystbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientsystbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientsystbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientsystbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientsystbs
    **/
    _count?: true | ClientsystbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientsystbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientsystbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientsystbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientsystbMaxAggregateInputType
  }

  export type GetClientsystbAggregateType<T extends ClientsystbAggregateArgs> = {
        [P in keyof T & keyof AggregateClientsystb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientsystb[P]>
      : GetScalarType<T[P], AggregateClientsystb[P]>
  }




  export type clientsystbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientsystbWhereInput
    orderBy?: clientsystbOrderByWithAggregationInput | clientsystbOrderByWithAggregationInput[]
    by: ClientsystbScalarFieldEnum[] | ClientsystbScalarFieldEnum
    having?: clientsystbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientsystbCountAggregateInputType | true
    _avg?: ClientsystbAvgAggregateInputType
    _sum?: ClientsystbSumAggregateInputType
    _min?: ClientsystbMinAggregateInputType
    _max?: ClientsystbMaxAggregateInputType
  }

  export type ClientsystbGroupByOutputType = {
    ID: number
    UserId: number
    MAC: string
    CPU: string
    RAM: string
    HD: string
    OS: string
    CardName: string
    ChipType: string
    VGAMem: string
    NIC: string
    FreeSpace: string
    CPName: string
    Active: number
    NTFS: string
    FAT: string
    Mainboard: string
    IP: string
    LAN: string
    RamFree: string
    PageFile: string
    TempCPU: string
    LoadCPU: string
    TempGPU: string
    LoadGPU: string
    LastUpdate: Date
    PCName: string | null
    NetInfo: string | null
    _count: ClientsystbCountAggregateOutputType | null
    _avg: ClientsystbAvgAggregateOutputType | null
    _sum: ClientsystbSumAggregateOutputType | null
    _min: ClientsystbMinAggregateOutputType | null
    _max: ClientsystbMaxAggregateOutputType | null
  }

  type GetClientsystbGroupByPayload<T extends clientsystbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientsystbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientsystbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientsystbGroupByOutputType[P]>
            : GetScalarType<T[P], ClientsystbGroupByOutputType[P]>
        }
      >
    >


  export type clientsystbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    UserId?: boolean
    MAC?: boolean
    CPU?: boolean
    RAM?: boolean
    HD?: boolean
    OS?: boolean
    CardName?: boolean
    ChipType?: boolean
    VGAMem?: boolean
    NIC?: boolean
    FreeSpace?: boolean
    CPName?: boolean
    Active?: boolean
    NTFS?: boolean
    FAT?: boolean
    Mainboard?: boolean
    IP?: boolean
    LAN?: boolean
    RamFree?: boolean
    PageFile?: boolean
    TempCPU?: boolean
    LoadCPU?: boolean
    TempGPU?: boolean
    LoadGPU?: boolean
    LastUpdate?: boolean
    PCName?: boolean
    NetInfo?: boolean
  }, ExtArgs["result"]["clientsystb"]>


  export type clientsystbSelectScalar = {
    ID?: boolean
    UserId?: boolean
    MAC?: boolean
    CPU?: boolean
    RAM?: boolean
    HD?: boolean
    OS?: boolean
    CardName?: boolean
    ChipType?: boolean
    VGAMem?: boolean
    NIC?: boolean
    FreeSpace?: boolean
    CPName?: boolean
    Active?: boolean
    NTFS?: boolean
    FAT?: boolean
    Mainboard?: boolean
    IP?: boolean
    LAN?: boolean
    RamFree?: boolean
    PageFile?: boolean
    TempCPU?: boolean
    LoadCPU?: boolean
    TempGPU?: boolean
    LoadGPU?: boolean
    LastUpdate?: boolean
    PCName?: boolean
    NetInfo?: boolean
  }


  export type $clientsystbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clientsystb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      UserId: number
      MAC: string
      CPU: string
      RAM: string
      HD: string
      OS: string
      CardName: string
      ChipType: string
      VGAMem: string
      NIC: string
      FreeSpace: string
      CPName: string
      Active: number
      NTFS: string
      FAT: string
      Mainboard: string
      IP: string
      LAN: string
      RamFree: string
      PageFile: string
      TempCPU: string
      LoadCPU: string
      TempGPU: string
      LoadGPU: string
      LastUpdate: Date
      PCName: string | null
      NetInfo: string | null
    }, ExtArgs["result"]["clientsystb"]>
    composites: {}
  }

  type clientsystbGetPayload<S extends boolean | null | undefined | clientsystbDefaultArgs> = $Result.GetResult<Prisma.$clientsystbPayload, S>

  type clientsystbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clientsystbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientsystbCountAggregateInputType | true
    }

  export interface clientsystbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clientsystb'], meta: { name: 'clientsystb' } }
    /**
     * Find zero or one Clientsystb that matches the filter.
     * @param {clientsystbFindUniqueArgs} args - Arguments to find a Clientsystb
     * @example
     * // Get one Clientsystb
     * const clientsystb = await prisma.clientsystb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientsystbFindUniqueArgs>(args: SelectSubset<T, clientsystbFindUniqueArgs<ExtArgs>>): Prisma__clientsystbClient<$Result.GetResult<Prisma.$clientsystbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clientsystb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {clientsystbFindUniqueOrThrowArgs} args - Arguments to find a Clientsystb
     * @example
     * // Get one Clientsystb
     * const clientsystb = await prisma.clientsystb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientsystbFindUniqueOrThrowArgs>(args: SelectSubset<T, clientsystbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientsystbClient<$Result.GetResult<Prisma.$clientsystbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clientsystb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsystbFindFirstArgs} args - Arguments to find a Clientsystb
     * @example
     * // Get one Clientsystb
     * const clientsystb = await prisma.clientsystb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientsystbFindFirstArgs>(args?: SelectSubset<T, clientsystbFindFirstArgs<ExtArgs>>): Prisma__clientsystbClient<$Result.GetResult<Prisma.$clientsystbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clientsystb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsystbFindFirstOrThrowArgs} args - Arguments to find a Clientsystb
     * @example
     * // Get one Clientsystb
     * const clientsystb = await prisma.clientsystb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientsystbFindFirstOrThrowArgs>(args?: SelectSubset<T, clientsystbFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientsystbClient<$Result.GetResult<Prisma.$clientsystbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientsystbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsystbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientsystbs
     * const clientsystbs = await prisma.clientsystb.findMany()
     * 
     * // Get first 10 Clientsystbs
     * const clientsystbs = await prisma.clientsystb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const clientsystbWithIDOnly = await prisma.clientsystb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends clientsystbFindManyArgs>(args?: SelectSubset<T, clientsystbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientsystbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clientsystb.
     * @param {clientsystbCreateArgs} args - Arguments to create a Clientsystb.
     * @example
     * // Create one Clientsystb
     * const Clientsystb = await prisma.clientsystb.create({
     *   data: {
     *     // ... data to create a Clientsystb
     *   }
     * })
     * 
     */
    create<T extends clientsystbCreateArgs>(args: SelectSubset<T, clientsystbCreateArgs<ExtArgs>>): Prisma__clientsystbClient<$Result.GetResult<Prisma.$clientsystbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientsystbs.
     * @param {clientsystbCreateManyArgs} args - Arguments to create many Clientsystbs.
     * @example
     * // Create many Clientsystbs
     * const clientsystb = await prisma.clientsystb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientsystbCreateManyArgs>(args?: SelectSubset<T, clientsystbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clientsystb.
     * @param {clientsystbDeleteArgs} args - Arguments to delete one Clientsystb.
     * @example
     * // Delete one Clientsystb
     * const Clientsystb = await prisma.clientsystb.delete({
     *   where: {
     *     // ... filter to delete one Clientsystb
     *   }
     * })
     * 
     */
    delete<T extends clientsystbDeleteArgs>(args: SelectSubset<T, clientsystbDeleteArgs<ExtArgs>>): Prisma__clientsystbClient<$Result.GetResult<Prisma.$clientsystbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clientsystb.
     * @param {clientsystbUpdateArgs} args - Arguments to update one Clientsystb.
     * @example
     * // Update one Clientsystb
     * const clientsystb = await prisma.clientsystb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientsystbUpdateArgs>(args: SelectSubset<T, clientsystbUpdateArgs<ExtArgs>>): Prisma__clientsystbClient<$Result.GetResult<Prisma.$clientsystbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientsystbs.
     * @param {clientsystbDeleteManyArgs} args - Arguments to filter Clientsystbs to delete.
     * @example
     * // Delete a few Clientsystbs
     * const { count } = await prisma.clientsystb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientsystbDeleteManyArgs>(args?: SelectSubset<T, clientsystbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientsystbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsystbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientsystbs
     * const clientsystb = await prisma.clientsystb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientsystbUpdateManyArgs>(args: SelectSubset<T, clientsystbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientsystb.
     * @param {clientsystbUpsertArgs} args - Arguments to update or create a Clientsystb.
     * @example
     * // Update or create a Clientsystb
     * const clientsystb = await prisma.clientsystb.upsert({
     *   create: {
     *     // ... data to create a Clientsystb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientsystb we want to update
     *   }
     * })
     */
    upsert<T extends clientsystbUpsertArgs>(args: SelectSubset<T, clientsystbUpsertArgs<ExtArgs>>): Prisma__clientsystbClient<$Result.GetResult<Prisma.$clientsystbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientsystbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsystbCountArgs} args - Arguments to filter Clientsystbs to count.
     * @example
     * // Count the number of Clientsystbs
     * const count = await prisma.clientsystb.count({
     *   where: {
     *     // ... the filter for the Clientsystbs we want to count
     *   }
     * })
    **/
    count<T extends clientsystbCountArgs>(
      args?: Subset<T, clientsystbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientsystbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientsystb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsystbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientsystbAggregateArgs>(args: Subset<T, ClientsystbAggregateArgs>): Prisma.PrismaPromise<GetClientsystbAggregateType<T>>

    /**
     * Group by Clientsystb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsystbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientsystbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientsystbGroupByArgs['orderBy'] }
        : { orderBy?: clientsystbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientsystbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientsystbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clientsystb model
   */
  readonly fields: clientsystbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientsystb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientsystbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clientsystb model
   */ 
  interface clientsystbFieldRefs {
    readonly ID: FieldRef<"clientsystb", 'Int'>
    readonly UserId: FieldRef<"clientsystb", 'Int'>
    readonly MAC: FieldRef<"clientsystb", 'String'>
    readonly CPU: FieldRef<"clientsystb", 'String'>
    readonly RAM: FieldRef<"clientsystb", 'String'>
    readonly HD: FieldRef<"clientsystb", 'String'>
    readonly OS: FieldRef<"clientsystb", 'String'>
    readonly CardName: FieldRef<"clientsystb", 'String'>
    readonly ChipType: FieldRef<"clientsystb", 'String'>
    readonly VGAMem: FieldRef<"clientsystb", 'String'>
    readonly NIC: FieldRef<"clientsystb", 'String'>
    readonly FreeSpace: FieldRef<"clientsystb", 'String'>
    readonly CPName: FieldRef<"clientsystb", 'String'>
    readonly Active: FieldRef<"clientsystb", 'Int'>
    readonly NTFS: FieldRef<"clientsystb", 'String'>
    readonly FAT: FieldRef<"clientsystb", 'String'>
    readonly Mainboard: FieldRef<"clientsystb", 'String'>
    readonly IP: FieldRef<"clientsystb", 'String'>
    readonly LAN: FieldRef<"clientsystb", 'String'>
    readonly RamFree: FieldRef<"clientsystb", 'String'>
    readonly PageFile: FieldRef<"clientsystb", 'String'>
    readonly TempCPU: FieldRef<"clientsystb", 'String'>
    readonly LoadCPU: FieldRef<"clientsystb", 'String'>
    readonly TempGPU: FieldRef<"clientsystb", 'String'>
    readonly LoadGPU: FieldRef<"clientsystb", 'String'>
    readonly LastUpdate: FieldRef<"clientsystb", 'DateTime'>
    readonly PCName: FieldRef<"clientsystb", 'String'>
    readonly NetInfo: FieldRef<"clientsystb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clientsystb findUnique
   */
  export type clientsystbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
    /**
     * Filter, which clientsystb to fetch.
     */
    where: clientsystbWhereUniqueInput
  }

  /**
   * clientsystb findUniqueOrThrow
   */
  export type clientsystbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
    /**
     * Filter, which clientsystb to fetch.
     */
    where: clientsystbWhereUniqueInput
  }

  /**
   * clientsystb findFirst
   */
  export type clientsystbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
    /**
     * Filter, which clientsystb to fetch.
     */
    where?: clientsystbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientsystbs to fetch.
     */
    orderBy?: clientsystbOrderByWithRelationInput | clientsystbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientsystbs.
     */
    cursor?: clientsystbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientsystbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientsystbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientsystbs.
     */
    distinct?: ClientsystbScalarFieldEnum | ClientsystbScalarFieldEnum[]
  }

  /**
   * clientsystb findFirstOrThrow
   */
  export type clientsystbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
    /**
     * Filter, which clientsystb to fetch.
     */
    where?: clientsystbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientsystbs to fetch.
     */
    orderBy?: clientsystbOrderByWithRelationInput | clientsystbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientsystbs.
     */
    cursor?: clientsystbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientsystbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientsystbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientsystbs.
     */
    distinct?: ClientsystbScalarFieldEnum | ClientsystbScalarFieldEnum[]
  }

  /**
   * clientsystb findMany
   */
  export type clientsystbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
    /**
     * Filter, which clientsystbs to fetch.
     */
    where?: clientsystbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientsystbs to fetch.
     */
    orderBy?: clientsystbOrderByWithRelationInput | clientsystbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientsystbs.
     */
    cursor?: clientsystbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientsystbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientsystbs.
     */
    skip?: number
    distinct?: ClientsystbScalarFieldEnum | ClientsystbScalarFieldEnum[]
  }

  /**
   * clientsystb create
   */
  export type clientsystbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
    /**
     * The data needed to create a clientsystb.
     */
    data?: XOR<clientsystbCreateInput, clientsystbUncheckedCreateInput>
  }

  /**
   * clientsystb createMany
   */
  export type clientsystbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientsystbs.
     */
    data: clientsystbCreateManyInput | clientsystbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clientsystb update
   */
  export type clientsystbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
    /**
     * The data needed to update a clientsystb.
     */
    data: XOR<clientsystbUpdateInput, clientsystbUncheckedUpdateInput>
    /**
     * Choose, which clientsystb to update.
     */
    where: clientsystbWhereUniqueInput
  }

  /**
   * clientsystb updateMany
   */
  export type clientsystbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientsystbs.
     */
    data: XOR<clientsystbUpdateManyMutationInput, clientsystbUncheckedUpdateManyInput>
    /**
     * Filter which clientsystbs to update
     */
    where?: clientsystbWhereInput
  }

  /**
   * clientsystb upsert
   */
  export type clientsystbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
    /**
     * The filter to search for the clientsystb to update in case it exists.
     */
    where: clientsystbWhereUniqueInput
    /**
     * In case the clientsystb found by the `where` argument doesn't exist, create a new clientsystb with this data.
     */
    create: XOR<clientsystbCreateInput, clientsystbUncheckedCreateInput>
    /**
     * In case the clientsystb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientsystbUpdateInput, clientsystbUncheckedUpdateInput>
  }

  /**
   * clientsystb delete
   */
  export type clientsystbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
    /**
     * Filter which clientsystb to delete.
     */
    where: clientsystbWhereUniqueInput
  }

  /**
   * clientsystb deleteMany
   */
  export type clientsystbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientsystbs to delete
     */
    where?: clientsystbWhereInput
  }

  /**
   * clientsystb without action
   */
  export type clientsystbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientsystb
     */
    select?: clientsystbSelect<ExtArgs> | null
  }


  /**
   * Model combodetailtb
   */

  export type AggregateCombodetailtb = {
    _count: CombodetailtbCountAggregateOutputType | null
    _avg: CombodetailtbAvgAggregateOutputType | null
    _sum: CombodetailtbSumAggregateOutputType | null
    _min: CombodetailtbMinAggregateOutputType | null
    _max: CombodetailtbMaxAggregateOutputType | null
  }

  export type CombodetailtbAvgAggregateOutputType = {
    ComboDetailID: number | null
    UserID: number | null
    ComboID: number | null
    VoucherID: number | null
    Accept: number | null
    Ownerid: number | null
  }

  export type CombodetailtbSumAggregateOutputType = {
    ComboDetailID: number | null
    UserID: number | null
    ComboID: number | null
    VoucherID: number | null
    Accept: number | null
    Ownerid: bigint | null
  }

  export type CombodetailtbMinAggregateOutputType = {
    ComboDetailID: number | null
    UserID: number | null
    ComboID: number | null
    VoucherID: number | null
    Accept: number | null
    CreateDate: Date | null
    CreateTime: Date | null
    FromDate: Date | null
    FromTime: Date | null
    ToDate: Date | null
    ToTime: Date | null
    Zone: string | null
    LoginTime: Date | null
    Ownerid: bigint | null
  }

  export type CombodetailtbMaxAggregateOutputType = {
    ComboDetailID: number | null
    UserID: number | null
    ComboID: number | null
    VoucherID: number | null
    Accept: number | null
    CreateDate: Date | null
    CreateTime: Date | null
    FromDate: Date | null
    FromTime: Date | null
    ToDate: Date | null
    ToTime: Date | null
    Zone: string | null
    LoginTime: Date | null
    Ownerid: bigint | null
  }

  export type CombodetailtbCountAggregateOutputType = {
    ComboDetailID: number
    UserID: number
    ComboID: number
    VoucherID: number
    Accept: number
    CreateDate: number
    CreateTime: number
    FromDate: number
    FromTime: number
    ToDate: number
    ToTime: number
    Zone: number
    LoginTime: number
    Ownerid: number
    _all: number
  }


  export type CombodetailtbAvgAggregateInputType = {
    ComboDetailID?: true
    UserID?: true
    ComboID?: true
    VoucherID?: true
    Accept?: true
    Ownerid?: true
  }

  export type CombodetailtbSumAggregateInputType = {
    ComboDetailID?: true
    UserID?: true
    ComboID?: true
    VoucherID?: true
    Accept?: true
    Ownerid?: true
  }

  export type CombodetailtbMinAggregateInputType = {
    ComboDetailID?: true
    UserID?: true
    ComboID?: true
    VoucherID?: true
    Accept?: true
    CreateDate?: true
    CreateTime?: true
    FromDate?: true
    FromTime?: true
    ToDate?: true
    ToTime?: true
    Zone?: true
    LoginTime?: true
    Ownerid?: true
  }

  export type CombodetailtbMaxAggregateInputType = {
    ComboDetailID?: true
    UserID?: true
    ComboID?: true
    VoucherID?: true
    Accept?: true
    CreateDate?: true
    CreateTime?: true
    FromDate?: true
    FromTime?: true
    ToDate?: true
    ToTime?: true
    Zone?: true
    LoginTime?: true
    Ownerid?: true
  }

  export type CombodetailtbCountAggregateInputType = {
    ComboDetailID?: true
    UserID?: true
    ComboID?: true
    VoucherID?: true
    Accept?: true
    CreateDate?: true
    CreateTime?: true
    FromDate?: true
    FromTime?: true
    ToDate?: true
    ToTime?: true
    Zone?: true
    LoginTime?: true
    Ownerid?: true
    _all?: true
  }

  export type CombodetailtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combodetailtb to aggregate.
     */
    where?: combodetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combodetailtbs to fetch.
     */
    orderBy?: combodetailtbOrderByWithRelationInput | combodetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: combodetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combodetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combodetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned combodetailtbs
    **/
    _count?: true | CombodetailtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombodetailtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombodetailtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombodetailtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombodetailtbMaxAggregateInputType
  }

  export type GetCombodetailtbAggregateType<T extends CombodetailtbAggregateArgs> = {
        [P in keyof T & keyof AggregateCombodetailtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombodetailtb[P]>
      : GetScalarType<T[P], AggregateCombodetailtb[P]>
  }




  export type combodetailtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: combodetailtbWhereInput
    orderBy?: combodetailtbOrderByWithAggregationInput | combodetailtbOrderByWithAggregationInput[]
    by: CombodetailtbScalarFieldEnum[] | CombodetailtbScalarFieldEnum
    having?: combodetailtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombodetailtbCountAggregateInputType | true
    _avg?: CombodetailtbAvgAggregateInputType
    _sum?: CombodetailtbSumAggregateInputType
    _min?: CombodetailtbMinAggregateInputType
    _max?: CombodetailtbMaxAggregateInputType
  }

  export type CombodetailtbGroupByOutputType = {
    ComboDetailID: number
    UserID: number
    ComboID: number
    VoucherID: number
    Accept: number
    CreateDate: Date
    CreateTime: Date
    FromDate: Date
    FromTime: Date
    ToDate: Date
    ToTime: Date
    Zone: string | null
    LoginTime: Date
    Ownerid: bigint | null
    _count: CombodetailtbCountAggregateOutputType | null
    _avg: CombodetailtbAvgAggregateOutputType | null
    _sum: CombodetailtbSumAggregateOutputType | null
    _min: CombodetailtbMinAggregateOutputType | null
    _max: CombodetailtbMaxAggregateOutputType | null
  }

  type GetCombodetailtbGroupByPayload<T extends combodetailtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombodetailtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombodetailtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombodetailtbGroupByOutputType[P]>
            : GetScalarType<T[P], CombodetailtbGroupByOutputType[P]>
        }
      >
    >


  export type combodetailtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ComboDetailID?: boolean
    UserID?: boolean
    ComboID?: boolean
    VoucherID?: boolean
    Accept?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    FromDate?: boolean
    FromTime?: boolean
    ToDate?: boolean
    ToTime?: boolean
    Zone?: boolean
    LoginTime?: boolean
    Ownerid?: boolean
  }, ExtArgs["result"]["combodetailtb"]>


  export type combodetailtbSelectScalar = {
    ComboDetailID?: boolean
    UserID?: boolean
    ComboID?: boolean
    VoucherID?: boolean
    Accept?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    FromDate?: boolean
    FromTime?: boolean
    ToDate?: boolean
    ToTime?: boolean
    Zone?: boolean
    LoginTime?: boolean
    Ownerid?: boolean
  }


  export type $combodetailtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "combodetailtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ComboDetailID: number
      UserID: number
      ComboID: number
      VoucherID: number
      Accept: number
      CreateDate: Date
      CreateTime: Date
      FromDate: Date
      FromTime: Date
      ToDate: Date
      ToTime: Date
      Zone: string | null
      LoginTime: Date
      Ownerid: bigint | null
    }, ExtArgs["result"]["combodetailtb"]>
    composites: {}
  }

  type combodetailtbGetPayload<S extends boolean | null | undefined | combodetailtbDefaultArgs> = $Result.GetResult<Prisma.$combodetailtbPayload, S>

  type combodetailtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<combodetailtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CombodetailtbCountAggregateInputType | true
    }

  export interface combodetailtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['combodetailtb'], meta: { name: 'combodetailtb' } }
    /**
     * Find zero or one Combodetailtb that matches the filter.
     * @param {combodetailtbFindUniqueArgs} args - Arguments to find a Combodetailtb
     * @example
     * // Get one Combodetailtb
     * const combodetailtb = await prisma.combodetailtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends combodetailtbFindUniqueArgs>(args: SelectSubset<T, combodetailtbFindUniqueArgs<ExtArgs>>): Prisma__combodetailtbClient<$Result.GetResult<Prisma.$combodetailtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Combodetailtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {combodetailtbFindUniqueOrThrowArgs} args - Arguments to find a Combodetailtb
     * @example
     * // Get one Combodetailtb
     * const combodetailtb = await prisma.combodetailtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends combodetailtbFindUniqueOrThrowArgs>(args: SelectSubset<T, combodetailtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__combodetailtbClient<$Result.GetResult<Prisma.$combodetailtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Combodetailtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodetailtbFindFirstArgs} args - Arguments to find a Combodetailtb
     * @example
     * // Get one Combodetailtb
     * const combodetailtb = await prisma.combodetailtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends combodetailtbFindFirstArgs>(args?: SelectSubset<T, combodetailtbFindFirstArgs<ExtArgs>>): Prisma__combodetailtbClient<$Result.GetResult<Prisma.$combodetailtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Combodetailtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodetailtbFindFirstOrThrowArgs} args - Arguments to find a Combodetailtb
     * @example
     * // Get one Combodetailtb
     * const combodetailtb = await prisma.combodetailtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends combodetailtbFindFirstOrThrowArgs>(args?: SelectSubset<T, combodetailtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__combodetailtbClient<$Result.GetResult<Prisma.$combodetailtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Combodetailtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodetailtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Combodetailtbs
     * const combodetailtbs = await prisma.combodetailtb.findMany()
     * 
     * // Get first 10 Combodetailtbs
     * const combodetailtbs = await prisma.combodetailtb.findMany({ take: 10 })
     * 
     * // Only select the `ComboDetailID`
     * const combodetailtbWithComboDetailIDOnly = await prisma.combodetailtb.findMany({ select: { ComboDetailID: true } })
     * 
     */
    findMany<T extends combodetailtbFindManyArgs>(args?: SelectSubset<T, combodetailtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$combodetailtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Combodetailtb.
     * @param {combodetailtbCreateArgs} args - Arguments to create a Combodetailtb.
     * @example
     * // Create one Combodetailtb
     * const Combodetailtb = await prisma.combodetailtb.create({
     *   data: {
     *     // ... data to create a Combodetailtb
     *   }
     * })
     * 
     */
    create<T extends combodetailtbCreateArgs>(args: SelectSubset<T, combodetailtbCreateArgs<ExtArgs>>): Prisma__combodetailtbClient<$Result.GetResult<Prisma.$combodetailtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Combodetailtbs.
     * @param {combodetailtbCreateManyArgs} args - Arguments to create many Combodetailtbs.
     * @example
     * // Create many Combodetailtbs
     * const combodetailtb = await prisma.combodetailtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends combodetailtbCreateManyArgs>(args?: SelectSubset<T, combodetailtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Combodetailtb.
     * @param {combodetailtbDeleteArgs} args - Arguments to delete one Combodetailtb.
     * @example
     * // Delete one Combodetailtb
     * const Combodetailtb = await prisma.combodetailtb.delete({
     *   where: {
     *     // ... filter to delete one Combodetailtb
     *   }
     * })
     * 
     */
    delete<T extends combodetailtbDeleteArgs>(args: SelectSubset<T, combodetailtbDeleteArgs<ExtArgs>>): Prisma__combodetailtbClient<$Result.GetResult<Prisma.$combodetailtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Combodetailtb.
     * @param {combodetailtbUpdateArgs} args - Arguments to update one Combodetailtb.
     * @example
     * // Update one Combodetailtb
     * const combodetailtb = await prisma.combodetailtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends combodetailtbUpdateArgs>(args: SelectSubset<T, combodetailtbUpdateArgs<ExtArgs>>): Prisma__combodetailtbClient<$Result.GetResult<Prisma.$combodetailtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Combodetailtbs.
     * @param {combodetailtbDeleteManyArgs} args - Arguments to filter Combodetailtbs to delete.
     * @example
     * // Delete a few Combodetailtbs
     * const { count } = await prisma.combodetailtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends combodetailtbDeleteManyArgs>(args?: SelectSubset<T, combodetailtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Combodetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodetailtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Combodetailtbs
     * const combodetailtb = await prisma.combodetailtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends combodetailtbUpdateManyArgs>(args: SelectSubset<T, combodetailtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Combodetailtb.
     * @param {combodetailtbUpsertArgs} args - Arguments to update or create a Combodetailtb.
     * @example
     * // Update or create a Combodetailtb
     * const combodetailtb = await prisma.combodetailtb.upsert({
     *   create: {
     *     // ... data to create a Combodetailtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Combodetailtb we want to update
     *   }
     * })
     */
    upsert<T extends combodetailtbUpsertArgs>(args: SelectSubset<T, combodetailtbUpsertArgs<ExtArgs>>): Prisma__combodetailtbClient<$Result.GetResult<Prisma.$combodetailtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Combodetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodetailtbCountArgs} args - Arguments to filter Combodetailtbs to count.
     * @example
     * // Count the number of Combodetailtbs
     * const count = await prisma.combodetailtb.count({
     *   where: {
     *     // ... the filter for the Combodetailtbs we want to count
     *   }
     * })
    **/
    count<T extends combodetailtbCountArgs>(
      args?: Subset<T, combodetailtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombodetailtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Combodetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombodetailtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombodetailtbAggregateArgs>(args: Subset<T, CombodetailtbAggregateArgs>): Prisma.PrismaPromise<GetCombodetailtbAggregateType<T>>

    /**
     * Group by Combodetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodetailtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends combodetailtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: combodetailtbGroupByArgs['orderBy'] }
        : { orderBy?: combodetailtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, combodetailtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombodetailtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the combodetailtb model
   */
  readonly fields: combodetailtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for combodetailtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__combodetailtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the combodetailtb model
   */ 
  interface combodetailtbFieldRefs {
    readonly ComboDetailID: FieldRef<"combodetailtb", 'Int'>
    readonly UserID: FieldRef<"combodetailtb", 'Int'>
    readonly ComboID: FieldRef<"combodetailtb", 'Int'>
    readonly VoucherID: FieldRef<"combodetailtb", 'Int'>
    readonly Accept: FieldRef<"combodetailtb", 'Int'>
    readonly CreateDate: FieldRef<"combodetailtb", 'DateTime'>
    readonly CreateTime: FieldRef<"combodetailtb", 'DateTime'>
    readonly FromDate: FieldRef<"combodetailtb", 'DateTime'>
    readonly FromTime: FieldRef<"combodetailtb", 'DateTime'>
    readonly ToDate: FieldRef<"combodetailtb", 'DateTime'>
    readonly ToTime: FieldRef<"combodetailtb", 'DateTime'>
    readonly Zone: FieldRef<"combodetailtb", 'String'>
    readonly LoginTime: FieldRef<"combodetailtb", 'DateTime'>
    readonly Ownerid: FieldRef<"combodetailtb", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * combodetailtb findUnique
   */
  export type combodetailtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
    /**
     * Filter, which combodetailtb to fetch.
     */
    where: combodetailtbWhereUniqueInput
  }

  /**
   * combodetailtb findUniqueOrThrow
   */
  export type combodetailtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
    /**
     * Filter, which combodetailtb to fetch.
     */
    where: combodetailtbWhereUniqueInput
  }

  /**
   * combodetailtb findFirst
   */
  export type combodetailtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
    /**
     * Filter, which combodetailtb to fetch.
     */
    where?: combodetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combodetailtbs to fetch.
     */
    orderBy?: combodetailtbOrderByWithRelationInput | combodetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combodetailtbs.
     */
    cursor?: combodetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combodetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combodetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combodetailtbs.
     */
    distinct?: CombodetailtbScalarFieldEnum | CombodetailtbScalarFieldEnum[]
  }

  /**
   * combodetailtb findFirstOrThrow
   */
  export type combodetailtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
    /**
     * Filter, which combodetailtb to fetch.
     */
    where?: combodetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combodetailtbs to fetch.
     */
    orderBy?: combodetailtbOrderByWithRelationInput | combodetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combodetailtbs.
     */
    cursor?: combodetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combodetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combodetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combodetailtbs.
     */
    distinct?: CombodetailtbScalarFieldEnum | CombodetailtbScalarFieldEnum[]
  }

  /**
   * combodetailtb findMany
   */
  export type combodetailtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
    /**
     * Filter, which combodetailtbs to fetch.
     */
    where?: combodetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combodetailtbs to fetch.
     */
    orderBy?: combodetailtbOrderByWithRelationInput | combodetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing combodetailtbs.
     */
    cursor?: combodetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combodetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combodetailtbs.
     */
    skip?: number
    distinct?: CombodetailtbScalarFieldEnum | CombodetailtbScalarFieldEnum[]
  }

  /**
   * combodetailtb create
   */
  export type combodetailtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
    /**
     * The data needed to create a combodetailtb.
     */
    data?: XOR<combodetailtbCreateInput, combodetailtbUncheckedCreateInput>
  }

  /**
   * combodetailtb createMany
   */
  export type combodetailtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many combodetailtbs.
     */
    data: combodetailtbCreateManyInput | combodetailtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * combodetailtb update
   */
  export type combodetailtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
    /**
     * The data needed to update a combodetailtb.
     */
    data: XOR<combodetailtbUpdateInput, combodetailtbUncheckedUpdateInput>
    /**
     * Choose, which combodetailtb to update.
     */
    where: combodetailtbWhereUniqueInput
  }

  /**
   * combodetailtb updateMany
   */
  export type combodetailtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update combodetailtbs.
     */
    data: XOR<combodetailtbUpdateManyMutationInput, combodetailtbUncheckedUpdateManyInput>
    /**
     * Filter which combodetailtbs to update
     */
    where?: combodetailtbWhereInput
  }

  /**
   * combodetailtb upsert
   */
  export type combodetailtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
    /**
     * The filter to search for the combodetailtb to update in case it exists.
     */
    where: combodetailtbWhereUniqueInput
    /**
     * In case the combodetailtb found by the `where` argument doesn't exist, create a new combodetailtb with this data.
     */
    create: XOR<combodetailtbCreateInput, combodetailtbUncheckedCreateInput>
    /**
     * In case the combodetailtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<combodetailtbUpdateInput, combodetailtbUncheckedUpdateInput>
  }

  /**
   * combodetailtb delete
   */
  export type combodetailtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
    /**
     * Filter which combodetailtb to delete.
     */
    where: combodetailtbWhereUniqueInput
  }

  /**
   * combodetailtb deleteMany
   */
  export type combodetailtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combodetailtbs to delete
     */
    where?: combodetailtbWhereInput
  }

  /**
   * combodetailtb without action
   */
  export type combodetailtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodetailtb
     */
    select?: combodetailtbSelect<ExtArgs> | null
  }


  /**
   * Model combodonatetb
   */

  export type AggregateCombodonatetb = {
    _count: CombodonatetbCountAggregateOutputType | null
    _avg: CombodonatetbAvgAggregateOutputType | null
    _sum: CombodonatetbSumAggregateOutputType | null
    _min: CombodonatetbMinAggregateOutputType | null
    _max: CombodonatetbMaxAggregateOutputType | null
  }

  export type CombodonatetbAvgAggregateOutputType = {
    ComboDonateID: number | null
    ComboID: number | null
    ServiceID: number | null
    Quantity: number | null
  }

  export type CombodonatetbSumAggregateOutputType = {
    ComboDonateID: number | null
    ComboID: number | null
    ServiceID: number | null
    Quantity: number | null
  }

  export type CombodonatetbMinAggregateOutputType = {
    ComboDonateID: number | null
    ComboID: number | null
    ServiceID: number | null
    Quantity: number | null
  }

  export type CombodonatetbMaxAggregateOutputType = {
    ComboDonateID: number | null
    ComboID: number | null
    ServiceID: number | null
    Quantity: number | null
  }

  export type CombodonatetbCountAggregateOutputType = {
    ComboDonateID: number
    ComboID: number
    ServiceID: number
    Quantity: number
    _all: number
  }


  export type CombodonatetbAvgAggregateInputType = {
    ComboDonateID?: true
    ComboID?: true
    ServiceID?: true
    Quantity?: true
  }

  export type CombodonatetbSumAggregateInputType = {
    ComboDonateID?: true
    ComboID?: true
    ServiceID?: true
    Quantity?: true
  }

  export type CombodonatetbMinAggregateInputType = {
    ComboDonateID?: true
    ComboID?: true
    ServiceID?: true
    Quantity?: true
  }

  export type CombodonatetbMaxAggregateInputType = {
    ComboDonateID?: true
    ComboID?: true
    ServiceID?: true
    Quantity?: true
  }

  export type CombodonatetbCountAggregateInputType = {
    ComboDonateID?: true
    ComboID?: true
    ServiceID?: true
    Quantity?: true
    _all?: true
  }

  export type CombodonatetbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combodonatetb to aggregate.
     */
    where?: combodonatetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combodonatetbs to fetch.
     */
    orderBy?: combodonatetbOrderByWithRelationInput | combodonatetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: combodonatetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combodonatetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combodonatetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned combodonatetbs
    **/
    _count?: true | CombodonatetbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombodonatetbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombodonatetbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombodonatetbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombodonatetbMaxAggregateInputType
  }

  export type GetCombodonatetbAggregateType<T extends CombodonatetbAggregateArgs> = {
        [P in keyof T & keyof AggregateCombodonatetb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombodonatetb[P]>
      : GetScalarType<T[P], AggregateCombodonatetb[P]>
  }




  export type combodonatetbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: combodonatetbWhereInput
    orderBy?: combodonatetbOrderByWithAggregationInput | combodonatetbOrderByWithAggregationInput[]
    by: CombodonatetbScalarFieldEnum[] | CombodonatetbScalarFieldEnum
    having?: combodonatetbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombodonatetbCountAggregateInputType | true
    _avg?: CombodonatetbAvgAggregateInputType
    _sum?: CombodonatetbSumAggregateInputType
    _min?: CombodonatetbMinAggregateInputType
    _max?: CombodonatetbMaxAggregateInputType
  }

  export type CombodonatetbGroupByOutputType = {
    ComboDonateID: number
    ComboID: number
    ServiceID: number
    Quantity: number
    _count: CombodonatetbCountAggregateOutputType | null
    _avg: CombodonatetbAvgAggregateOutputType | null
    _sum: CombodonatetbSumAggregateOutputType | null
    _min: CombodonatetbMinAggregateOutputType | null
    _max: CombodonatetbMaxAggregateOutputType | null
  }

  type GetCombodonatetbGroupByPayload<T extends combodonatetbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombodonatetbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombodonatetbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombodonatetbGroupByOutputType[P]>
            : GetScalarType<T[P], CombodonatetbGroupByOutputType[P]>
        }
      >
    >


  export type combodonatetbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ComboDonateID?: boolean
    ComboID?: boolean
    ServiceID?: boolean
    Quantity?: boolean
  }, ExtArgs["result"]["combodonatetb"]>


  export type combodonatetbSelectScalar = {
    ComboDonateID?: boolean
    ComboID?: boolean
    ServiceID?: boolean
    Quantity?: boolean
  }


  export type $combodonatetbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "combodonatetb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ComboDonateID: number
      ComboID: number
      ServiceID: number
      Quantity: number
    }, ExtArgs["result"]["combodonatetb"]>
    composites: {}
  }

  type combodonatetbGetPayload<S extends boolean | null | undefined | combodonatetbDefaultArgs> = $Result.GetResult<Prisma.$combodonatetbPayload, S>

  type combodonatetbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<combodonatetbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CombodonatetbCountAggregateInputType | true
    }

  export interface combodonatetbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['combodonatetb'], meta: { name: 'combodonatetb' } }
    /**
     * Find zero or one Combodonatetb that matches the filter.
     * @param {combodonatetbFindUniqueArgs} args - Arguments to find a Combodonatetb
     * @example
     * // Get one Combodonatetb
     * const combodonatetb = await prisma.combodonatetb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends combodonatetbFindUniqueArgs>(args: SelectSubset<T, combodonatetbFindUniqueArgs<ExtArgs>>): Prisma__combodonatetbClient<$Result.GetResult<Prisma.$combodonatetbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Combodonatetb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {combodonatetbFindUniqueOrThrowArgs} args - Arguments to find a Combodonatetb
     * @example
     * // Get one Combodonatetb
     * const combodonatetb = await prisma.combodonatetb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends combodonatetbFindUniqueOrThrowArgs>(args: SelectSubset<T, combodonatetbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__combodonatetbClient<$Result.GetResult<Prisma.$combodonatetbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Combodonatetb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodonatetbFindFirstArgs} args - Arguments to find a Combodonatetb
     * @example
     * // Get one Combodonatetb
     * const combodonatetb = await prisma.combodonatetb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends combodonatetbFindFirstArgs>(args?: SelectSubset<T, combodonatetbFindFirstArgs<ExtArgs>>): Prisma__combodonatetbClient<$Result.GetResult<Prisma.$combodonatetbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Combodonatetb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodonatetbFindFirstOrThrowArgs} args - Arguments to find a Combodonatetb
     * @example
     * // Get one Combodonatetb
     * const combodonatetb = await prisma.combodonatetb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends combodonatetbFindFirstOrThrowArgs>(args?: SelectSubset<T, combodonatetbFindFirstOrThrowArgs<ExtArgs>>): Prisma__combodonatetbClient<$Result.GetResult<Prisma.$combodonatetbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Combodonatetbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodonatetbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Combodonatetbs
     * const combodonatetbs = await prisma.combodonatetb.findMany()
     * 
     * // Get first 10 Combodonatetbs
     * const combodonatetbs = await prisma.combodonatetb.findMany({ take: 10 })
     * 
     * // Only select the `ComboDonateID`
     * const combodonatetbWithComboDonateIDOnly = await prisma.combodonatetb.findMany({ select: { ComboDonateID: true } })
     * 
     */
    findMany<T extends combodonatetbFindManyArgs>(args?: SelectSubset<T, combodonatetbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$combodonatetbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Combodonatetb.
     * @param {combodonatetbCreateArgs} args - Arguments to create a Combodonatetb.
     * @example
     * // Create one Combodonatetb
     * const Combodonatetb = await prisma.combodonatetb.create({
     *   data: {
     *     // ... data to create a Combodonatetb
     *   }
     * })
     * 
     */
    create<T extends combodonatetbCreateArgs>(args: SelectSubset<T, combodonatetbCreateArgs<ExtArgs>>): Prisma__combodonatetbClient<$Result.GetResult<Prisma.$combodonatetbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Combodonatetbs.
     * @param {combodonatetbCreateManyArgs} args - Arguments to create many Combodonatetbs.
     * @example
     * // Create many Combodonatetbs
     * const combodonatetb = await prisma.combodonatetb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends combodonatetbCreateManyArgs>(args?: SelectSubset<T, combodonatetbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Combodonatetb.
     * @param {combodonatetbDeleteArgs} args - Arguments to delete one Combodonatetb.
     * @example
     * // Delete one Combodonatetb
     * const Combodonatetb = await prisma.combodonatetb.delete({
     *   where: {
     *     // ... filter to delete one Combodonatetb
     *   }
     * })
     * 
     */
    delete<T extends combodonatetbDeleteArgs>(args: SelectSubset<T, combodonatetbDeleteArgs<ExtArgs>>): Prisma__combodonatetbClient<$Result.GetResult<Prisma.$combodonatetbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Combodonatetb.
     * @param {combodonatetbUpdateArgs} args - Arguments to update one Combodonatetb.
     * @example
     * // Update one Combodonatetb
     * const combodonatetb = await prisma.combodonatetb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends combodonatetbUpdateArgs>(args: SelectSubset<T, combodonatetbUpdateArgs<ExtArgs>>): Prisma__combodonatetbClient<$Result.GetResult<Prisma.$combodonatetbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Combodonatetbs.
     * @param {combodonatetbDeleteManyArgs} args - Arguments to filter Combodonatetbs to delete.
     * @example
     * // Delete a few Combodonatetbs
     * const { count } = await prisma.combodonatetb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends combodonatetbDeleteManyArgs>(args?: SelectSubset<T, combodonatetbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Combodonatetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodonatetbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Combodonatetbs
     * const combodonatetb = await prisma.combodonatetb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends combodonatetbUpdateManyArgs>(args: SelectSubset<T, combodonatetbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Combodonatetb.
     * @param {combodonatetbUpsertArgs} args - Arguments to update or create a Combodonatetb.
     * @example
     * // Update or create a Combodonatetb
     * const combodonatetb = await prisma.combodonatetb.upsert({
     *   create: {
     *     // ... data to create a Combodonatetb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Combodonatetb we want to update
     *   }
     * })
     */
    upsert<T extends combodonatetbUpsertArgs>(args: SelectSubset<T, combodonatetbUpsertArgs<ExtArgs>>): Prisma__combodonatetbClient<$Result.GetResult<Prisma.$combodonatetbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Combodonatetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodonatetbCountArgs} args - Arguments to filter Combodonatetbs to count.
     * @example
     * // Count the number of Combodonatetbs
     * const count = await prisma.combodonatetb.count({
     *   where: {
     *     // ... the filter for the Combodonatetbs we want to count
     *   }
     * })
    **/
    count<T extends combodonatetbCountArgs>(
      args?: Subset<T, combodonatetbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombodonatetbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Combodonatetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombodonatetbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombodonatetbAggregateArgs>(args: Subset<T, CombodonatetbAggregateArgs>): Prisma.PrismaPromise<GetCombodonatetbAggregateType<T>>

    /**
     * Group by Combodonatetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combodonatetbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends combodonatetbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: combodonatetbGroupByArgs['orderBy'] }
        : { orderBy?: combodonatetbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, combodonatetbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombodonatetbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the combodonatetb model
   */
  readonly fields: combodonatetbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for combodonatetb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__combodonatetbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the combodonatetb model
   */ 
  interface combodonatetbFieldRefs {
    readonly ComboDonateID: FieldRef<"combodonatetb", 'Int'>
    readonly ComboID: FieldRef<"combodonatetb", 'Int'>
    readonly ServiceID: FieldRef<"combodonatetb", 'Int'>
    readonly Quantity: FieldRef<"combodonatetb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * combodonatetb findUnique
   */
  export type combodonatetbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
    /**
     * Filter, which combodonatetb to fetch.
     */
    where: combodonatetbWhereUniqueInput
  }

  /**
   * combodonatetb findUniqueOrThrow
   */
  export type combodonatetbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
    /**
     * Filter, which combodonatetb to fetch.
     */
    where: combodonatetbWhereUniqueInput
  }

  /**
   * combodonatetb findFirst
   */
  export type combodonatetbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
    /**
     * Filter, which combodonatetb to fetch.
     */
    where?: combodonatetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combodonatetbs to fetch.
     */
    orderBy?: combodonatetbOrderByWithRelationInput | combodonatetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combodonatetbs.
     */
    cursor?: combodonatetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combodonatetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combodonatetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combodonatetbs.
     */
    distinct?: CombodonatetbScalarFieldEnum | CombodonatetbScalarFieldEnum[]
  }

  /**
   * combodonatetb findFirstOrThrow
   */
  export type combodonatetbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
    /**
     * Filter, which combodonatetb to fetch.
     */
    where?: combodonatetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combodonatetbs to fetch.
     */
    orderBy?: combodonatetbOrderByWithRelationInput | combodonatetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combodonatetbs.
     */
    cursor?: combodonatetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combodonatetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combodonatetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combodonatetbs.
     */
    distinct?: CombodonatetbScalarFieldEnum | CombodonatetbScalarFieldEnum[]
  }

  /**
   * combodonatetb findMany
   */
  export type combodonatetbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
    /**
     * Filter, which combodonatetbs to fetch.
     */
    where?: combodonatetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combodonatetbs to fetch.
     */
    orderBy?: combodonatetbOrderByWithRelationInput | combodonatetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing combodonatetbs.
     */
    cursor?: combodonatetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combodonatetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combodonatetbs.
     */
    skip?: number
    distinct?: CombodonatetbScalarFieldEnum | CombodonatetbScalarFieldEnum[]
  }

  /**
   * combodonatetb create
   */
  export type combodonatetbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
    /**
     * The data needed to create a combodonatetb.
     */
    data?: XOR<combodonatetbCreateInput, combodonatetbUncheckedCreateInput>
  }

  /**
   * combodonatetb createMany
   */
  export type combodonatetbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many combodonatetbs.
     */
    data: combodonatetbCreateManyInput | combodonatetbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * combodonatetb update
   */
  export type combodonatetbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
    /**
     * The data needed to update a combodonatetb.
     */
    data: XOR<combodonatetbUpdateInput, combodonatetbUncheckedUpdateInput>
    /**
     * Choose, which combodonatetb to update.
     */
    where: combodonatetbWhereUniqueInput
  }

  /**
   * combodonatetb updateMany
   */
  export type combodonatetbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update combodonatetbs.
     */
    data: XOR<combodonatetbUpdateManyMutationInput, combodonatetbUncheckedUpdateManyInput>
    /**
     * Filter which combodonatetbs to update
     */
    where?: combodonatetbWhereInput
  }

  /**
   * combodonatetb upsert
   */
  export type combodonatetbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
    /**
     * The filter to search for the combodonatetb to update in case it exists.
     */
    where: combodonatetbWhereUniqueInput
    /**
     * In case the combodonatetb found by the `where` argument doesn't exist, create a new combodonatetb with this data.
     */
    create: XOR<combodonatetbCreateInput, combodonatetbUncheckedCreateInput>
    /**
     * In case the combodonatetb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<combodonatetbUpdateInput, combodonatetbUncheckedUpdateInput>
  }

  /**
   * combodonatetb delete
   */
  export type combodonatetbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
    /**
     * Filter which combodonatetb to delete.
     */
    where: combodonatetbWhereUniqueInput
  }

  /**
   * combodonatetb deleteMany
   */
  export type combodonatetbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combodonatetbs to delete
     */
    where?: combodonatetbWhereInput
  }

  /**
   * combodonatetb without action
   */
  export type combodonatetbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combodonatetb
     */
    select?: combodonatetbSelect<ExtArgs> | null
  }


  /**
   * Model combotb
   */

  export type AggregateCombotb = {
    _count: CombotbCountAggregateOutputType | null
    _avg: CombotbAvgAggregateOutputType | null
    _sum: CombotbSumAggregateOutputType | null
    _min: CombotbMinAggregateOutputType | null
    _max: CombotbMaxAggregateOutputType | null
  }

  export type CombotbAvgAggregateOutputType = {
    ComboID: number | null
    Price: Decimal | null
    Type: number | null
    IsStatus: number | null
    OrderPosition: number | null
    NumOfDay: number | null
  }

  export type CombotbSumAggregateOutputType = {
    ComboID: number | null
    Price: Decimal | null
    Type: number | null
    IsStatus: number | null
    OrderPosition: number | null
    NumOfDay: number | null
  }

  export type CombotbMinAggregateOutputType = {
    ComboID: number | null
    Name: string | null
    Price: Decimal | null
    CreateDate: Date | null
    CreateTime: Date | null
    Type: number | null
    PreAlias: string | null
    IsStatus: number | null
    OrderPosition: number | null
    NumOfDay: number | null
  }

  export type CombotbMaxAggregateOutputType = {
    ComboID: number | null
    Name: string | null
    Price: Decimal | null
    CreateDate: Date | null
    CreateTime: Date | null
    Type: number | null
    PreAlias: string | null
    IsStatus: number | null
    OrderPosition: number | null
    NumOfDay: number | null
  }

  export type CombotbCountAggregateOutputType = {
    ComboID: number
    Name: number
    Price: number
    CreateDate: number
    CreateTime: number
    Type: number
    PreAlias: number
    IsStatus: number
    OrderPosition: number
    NumOfDay: number
    _all: number
  }


  export type CombotbAvgAggregateInputType = {
    ComboID?: true
    Price?: true
    Type?: true
    IsStatus?: true
    OrderPosition?: true
    NumOfDay?: true
  }

  export type CombotbSumAggregateInputType = {
    ComboID?: true
    Price?: true
    Type?: true
    IsStatus?: true
    OrderPosition?: true
    NumOfDay?: true
  }

  export type CombotbMinAggregateInputType = {
    ComboID?: true
    Name?: true
    Price?: true
    CreateDate?: true
    CreateTime?: true
    Type?: true
    PreAlias?: true
    IsStatus?: true
    OrderPosition?: true
    NumOfDay?: true
  }

  export type CombotbMaxAggregateInputType = {
    ComboID?: true
    Name?: true
    Price?: true
    CreateDate?: true
    CreateTime?: true
    Type?: true
    PreAlias?: true
    IsStatus?: true
    OrderPosition?: true
    NumOfDay?: true
  }

  export type CombotbCountAggregateInputType = {
    ComboID?: true
    Name?: true
    Price?: true
    CreateDate?: true
    CreateTime?: true
    Type?: true
    PreAlias?: true
    IsStatus?: true
    OrderPosition?: true
    NumOfDay?: true
    _all?: true
  }

  export type CombotbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combotb to aggregate.
     */
    where?: combotbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combotbs to fetch.
     */
    orderBy?: combotbOrderByWithRelationInput | combotbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: combotbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combotbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combotbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned combotbs
    **/
    _count?: true | CombotbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombotbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombotbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombotbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombotbMaxAggregateInputType
  }

  export type GetCombotbAggregateType<T extends CombotbAggregateArgs> = {
        [P in keyof T & keyof AggregateCombotb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombotb[P]>
      : GetScalarType<T[P], AggregateCombotb[P]>
  }




  export type combotbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: combotbWhereInput
    orderBy?: combotbOrderByWithAggregationInput | combotbOrderByWithAggregationInput[]
    by: CombotbScalarFieldEnum[] | CombotbScalarFieldEnum
    having?: combotbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombotbCountAggregateInputType | true
    _avg?: CombotbAvgAggregateInputType
    _sum?: CombotbSumAggregateInputType
    _min?: CombotbMinAggregateInputType
    _max?: CombotbMaxAggregateInputType
  }

  export type CombotbGroupByOutputType = {
    ComboID: number
    Name: string
    Price: Decimal
    CreateDate: Date
    CreateTime: Date
    Type: number
    PreAlias: string
    IsStatus: number
    OrderPosition: number
    NumOfDay: number
    _count: CombotbCountAggregateOutputType | null
    _avg: CombotbAvgAggregateOutputType | null
    _sum: CombotbSumAggregateOutputType | null
    _min: CombotbMinAggregateOutputType | null
    _max: CombotbMaxAggregateOutputType | null
  }

  type GetCombotbGroupByPayload<T extends combotbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombotbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombotbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombotbGroupByOutputType[P]>
            : GetScalarType<T[P], CombotbGroupByOutputType[P]>
        }
      >
    >


  export type combotbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ComboID?: boolean
    Name?: boolean
    Price?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    Type?: boolean
    PreAlias?: boolean
    IsStatus?: boolean
    OrderPosition?: boolean
    NumOfDay?: boolean
  }, ExtArgs["result"]["combotb"]>


  export type combotbSelectScalar = {
    ComboID?: boolean
    Name?: boolean
    Price?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    Type?: boolean
    PreAlias?: boolean
    IsStatus?: boolean
    OrderPosition?: boolean
    NumOfDay?: boolean
  }


  export type $combotbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "combotb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ComboID: number
      Name: string
      Price: Prisma.Decimal
      CreateDate: Date
      CreateTime: Date
      Type: number
      PreAlias: string
      IsStatus: number
      OrderPosition: number
      NumOfDay: number
    }, ExtArgs["result"]["combotb"]>
    composites: {}
  }

  type combotbGetPayload<S extends boolean | null | undefined | combotbDefaultArgs> = $Result.GetResult<Prisma.$combotbPayload, S>

  type combotbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<combotbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CombotbCountAggregateInputType | true
    }

  export interface combotbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['combotb'], meta: { name: 'combotb' } }
    /**
     * Find zero or one Combotb that matches the filter.
     * @param {combotbFindUniqueArgs} args - Arguments to find a Combotb
     * @example
     * // Get one Combotb
     * const combotb = await prisma.combotb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends combotbFindUniqueArgs>(args: SelectSubset<T, combotbFindUniqueArgs<ExtArgs>>): Prisma__combotbClient<$Result.GetResult<Prisma.$combotbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Combotb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {combotbFindUniqueOrThrowArgs} args - Arguments to find a Combotb
     * @example
     * // Get one Combotb
     * const combotb = await prisma.combotb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends combotbFindUniqueOrThrowArgs>(args: SelectSubset<T, combotbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__combotbClient<$Result.GetResult<Prisma.$combotbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Combotb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combotbFindFirstArgs} args - Arguments to find a Combotb
     * @example
     * // Get one Combotb
     * const combotb = await prisma.combotb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends combotbFindFirstArgs>(args?: SelectSubset<T, combotbFindFirstArgs<ExtArgs>>): Prisma__combotbClient<$Result.GetResult<Prisma.$combotbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Combotb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combotbFindFirstOrThrowArgs} args - Arguments to find a Combotb
     * @example
     * // Get one Combotb
     * const combotb = await prisma.combotb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends combotbFindFirstOrThrowArgs>(args?: SelectSubset<T, combotbFindFirstOrThrowArgs<ExtArgs>>): Prisma__combotbClient<$Result.GetResult<Prisma.$combotbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Combotbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combotbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Combotbs
     * const combotbs = await prisma.combotb.findMany()
     * 
     * // Get first 10 Combotbs
     * const combotbs = await prisma.combotb.findMany({ take: 10 })
     * 
     * // Only select the `ComboID`
     * const combotbWithComboIDOnly = await prisma.combotb.findMany({ select: { ComboID: true } })
     * 
     */
    findMany<T extends combotbFindManyArgs>(args?: SelectSubset<T, combotbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$combotbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Combotb.
     * @param {combotbCreateArgs} args - Arguments to create a Combotb.
     * @example
     * // Create one Combotb
     * const Combotb = await prisma.combotb.create({
     *   data: {
     *     // ... data to create a Combotb
     *   }
     * })
     * 
     */
    create<T extends combotbCreateArgs>(args: SelectSubset<T, combotbCreateArgs<ExtArgs>>): Prisma__combotbClient<$Result.GetResult<Prisma.$combotbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Combotbs.
     * @param {combotbCreateManyArgs} args - Arguments to create many Combotbs.
     * @example
     * // Create many Combotbs
     * const combotb = await prisma.combotb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends combotbCreateManyArgs>(args?: SelectSubset<T, combotbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Combotb.
     * @param {combotbDeleteArgs} args - Arguments to delete one Combotb.
     * @example
     * // Delete one Combotb
     * const Combotb = await prisma.combotb.delete({
     *   where: {
     *     // ... filter to delete one Combotb
     *   }
     * })
     * 
     */
    delete<T extends combotbDeleteArgs>(args: SelectSubset<T, combotbDeleteArgs<ExtArgs>>): Prisma__combotbClient<$Result.GetResult<Prisma.$combotbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Combotb.
     * @param {combotbUpdateArgs} args - Arguments to update one Combotb.
     * @example
     * // Update one Combotb
     * const combotb = await prisma.combotb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends combotbUpdateArgs>(args: SelectSubset<T, combotbUpdateArgs<ExtArgs>>): Prisma__combotbClient<$Result.GetResult<Prisma.$combotbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Combotbs.
     * @param {combotbDeleteManyArgs} args - Arguments to filter Combotbs to delete.
     * @example
     * // Delete a few Combotbs
     * const { count } = await prisma.combotb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends combotbDeleteManyArgs>(args?: SelectSubset<T, combotbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Combotbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combotbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Combotbs
     * const combotb = await prisma.combotb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends combotbUpdateManyArgs>(args: SelectSubset<T, combotbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Combotb.
     * @param {combotbUpsertArgs} args - Arguments to update or create a Combotb.
     * @example
     * // Update or create a Combotb
     * const combotb = await prisma.combotb.upsert({
     *   create: {
     *     // ... data to create a Combotb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Combotb we want to update
     *   }
     * })
     */
    upsert<T extends combotbUpsertArgs>(args: SelectSubset<T, combotbUpsertArgs<ExtArgs>>): Prisma__combotbClient<$Result.GetResult<Prisma.$combotbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Combotbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combotbCountArgs} args - Arguments to filter Combotbs to count.
     * @example
     * // Count the number of Combotbs
     * const count = await prisma.combotb.count({
     *   where: {
     *     // ... the filter for the Combotbs we want to count
     *   }
     * })
    **/
    count<T extends combotbCountArgs>(
      args?: Subset<T, combotbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombotbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Combotb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombotbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombotbAggregateArgs>(args: Subset<T, CombotbAggregateArgs>): Prisma.PrismaPromise<GetCombotbAggregateType<T>>

    /**
     * Group by Combotb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combotbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends combotbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: combotbGroupByArgs['orderBy'] }
        : { orderBy?: combotbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, combotbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombotbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the combotb model
   */
  readonly fields: combotbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for combotb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__combotbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the combotb model
   */ 
  interface combotbFieldRefs {
    readonly ComboID: FieldRef<"combotb", 'Int'>
    readonly Name: FieldRef<"combotb", 'String'>
    readonly Price: FieldRef<"combotb", 'Decimal'>
    readonly CreateDate: FieldRef<"combotb", 'DateTime'>
    readonly CreateTime: FieldRef<"combotb", 'DateTime'>
    readonly Type: FieldRef<"combotb", 'Int'>
    readonly PreAlias: FieldRef<"combotb", 'String'>
    readonly IsStatus: FieldRef<"combotb", 'Int'>
    readonly OrderPosition: FieldRef<"combotb", 'Int'>
    readonly NumOfDay: FieldRef<"combotb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * combotb findUnique
   */
  export type combotbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
    /**
     * Filter, which combotb to fetch.
     */
    where: combotbWhereUniqueInput
  }

  /**
   * combotb findUniqueOrThrow
   */
  export type combotbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
    /**
     * Filter, which combotb to fetch.
     */
    where: combotbWhereUniqueInput
  }

  /**
   * combotb findFirst
   */
  export type combotbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
    /**
     * Filter, which combotb to fetch.
     */
    where?: combotbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combotbs to fetch.
     */
    orderBy?: combotbOrderByWithRelationInput | combotbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combotbs.
     */
    cursor?: combotbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combotbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combotbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combotbs.
     */
    distinct?: CombotbScalarFieldEnum | CombotbScalarFieldEnum[]
  }

  /**
   * combotb findFirstOrThrow
   */
  export type combotbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
    /**
     * Filter, which combotb to fetch.
     */
    where?: combotbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combotbs to fetch.
     */
    orderBy?: combotbOrderByWithRelationInput | combotbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combotbs.
     */
    cursor?: combotbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combotbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combotbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combotbs.
     */
    distinct?: CombotbScalarFieldEnum | CombotbScalarFieldEnum[]
  }

  /**
   * combotb findMany
   */
  export type combotbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
    /**
     * Filter, which combotbs to fetch.
     */
    where?: combotbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combotbs to fetch.
     */
    orderBy?: combotbOrderByWithRelationInput | combotbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing combotbs.
     */
    cursor?: combotbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combotbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combotbs.
     */
    skip?: number
    distinct?: CombotbScalarFieldEnum | CombotbScalarFieldEnum[]
  }

  /**
   * combotb create
   */
  export type combotbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
    /**
     * The data needed to create a combotb.
     */
    data?: XOR<combotbCreateInput, combotbUncheckedCreateInput>
  }

  /**
   * combotb createMany
   */
  export type combotbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many combotbs.
     */
    data: combotbCreateManyInput | combotbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * combotb update
   */
  export type combotbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
    /**
     * The data needed to update a combotb.
     */
    data: XOR<combotbUpdateInput, combotbUncheckedUpdateInput>
    /**
     * Choose, which combotb to update.
     */
    where: combotbWhereUniqueInput
  }

  /**
   * combotb updateMany
   */
  export type combotbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update combotbs.
     */
    data: XOR<combotbUpdateManyMutationInput, combotbUncheckedUpdateManyInput>
    /**
     * Filter which combotbs to update
     */
    where?: combotbWhereInput
  }

  /**
   * combotb upsert
   */
  export type combotbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
    /**
     * The filter to search for the combotb to update in case it exists.
     */
    where: combotbWhereUniqueInput
    /**
     * In case the combotb found by the `where` argument doesn't exist, create a new combotb with this data.
     */
    create: XOR<combotbCreateInput, combotbUncheckedCreateInput>
    /**
     * In case the combotb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<combotbUpdateInput, combotbUncheckedUpdateInput>
  }

  /**
   * combotb delete
   */
  export type combotbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
    /**
     * Filter which combotb to delete.
     */
    where: combotbWhereUniqueInput
  }

  /**
   * combotb deleteMany
   */
  export type combotbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combotbs to delete
     */
    where?: combotbWhereInput
  }

  /**
   * combotb without action
   */
  export type combotbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combotb
     */
    select?: combotbSelect<ExtArgs> | null
  }


  /**
   * Model combousagetb
   */

  export type AggregateCombousagetb = {
    _count: CombousagetbCountAggregateOutputType | null
    _avg: CombousagetbAvgAggregateOutputType | null
    _sum: CombousagetbSumAggregateOutputType | null
    _min: CombousagetbMinAggregateOutputType | null
    _max: CombousagetbMaxAggregateOutputType | null
  }

  export type CombousagetbAvgAggregateOutputType = {
    ComboUsageID: number | null
    ComboID: number | null
    MachineGroupID: number | null
    FromTime: number | null
    ToTime: number | null
  }

  export type CombousagetbSumAggregateOutputType = {
    ComboUsageID: number | null
    ComboID: number | null
    MachineGroupID: number | null
    FromTime: number | null
    ToTime: number | null
  }

  export type CombousagetbMinAggregateOutputType = {
    ComboUsageID: number | null
    ComboID: number | null
    MachineGroupID: number | null
    FromTime: number | null
    ToTime: number | null
  }

  export type CombousagetbMaxAggregateOutputType = {
    ComboUsageID: number | null
    ComboID: number | null
    MachineGroupID: number | null
    FromTime: number | null
    ToTime: number | null
  }

  export type CombousagetbCountAggregateOutputType = {
    ComboUsageID: number
    ComboID: number
    MachineGroupID: number
    FromTime: number
    ToTime: number
    _all: number
  }


  export type CombousagetbAvgAggregateInputType = {
    ComboUsageID?: true
    ComboID?: true
    MachineGroupID?: true
    FromTime?: true
    ToTime?: true
  }

  export type CombousagetbSumAggregateInputType = {
    ComboUsageID?: true
    ComboID?: true
    MachineGroupID?: true
    FromTime?: true
    ToTime?: true
  }

  export type CombousagetbMinAggregateInputType = {
    ComboUsageID?: true
    ComboID?: true
    MachineGroupID?: true
    FromTime?: true
    ToTime?: true
  }

  export type CombousagetbMaxAggregateInputType = {
    ComboUsageID?: true
    ComboID?: true
    MachineGroupID?: true
    FromTime?: true
    ToTime?: true
  }

  export type CombousagetbCountAggregateInputType = {
    ComboUsageID?: true
    ComboID?: true
    MachineGroupID?: true
    FromTime?: true
    ToTime?: true
    _all?: true
  }

  export type CombousagetbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combousagetb to aggregate.
     */
    where?: combousagetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combousagetbs to fetch.
     */
    orderBy?: combousagetbOrderByWithRelationInput | combousagetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: combousagetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combousagetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combousagetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned combousagetbs
    **/
    _count?: true | CombousagetbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CombousagetbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CombousagetbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CombousagetbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CombousagetbMaxAggregateInputType
  }

  export type GetCombousagetbAggregateType<T extends CombousagetbAggregateArgs> = {
        [P in keyof T & keyof AggregateCombousagetb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombousagetb[P]>
      : GetScalarType<T[P], AggregateCombousagetb[P]>
  }




  export type combousagetbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: combousagetbWhereInput
    orderBy?: combousagetbOrderByWithAggregationInput | combousagetbOrderByWithAggregationInput[]
    by: CombousagetbScalarFieldEnum[] | CombousagetbScalarFieldEnum
    having?: combousagetbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CombousagetbCountAggregateInputType | true
    _avg?: CombousagetbAvgAggregateInputType
    _sum?: CombousagetbSumAggregateInputType
    _min?: CombousagetbMinAggregateInputType
    _max?: CombousagetbMaxAggregateInputType
  }

  export type CombousagetbGroupByOutputType = {
    ComboUsageID: number
    ComboID: number
    MachineGroupID: number
    FromTime: number
    ToTime: number
    _count: CombousagetbCountAggregateOutputType | null
    _avg: CombousagetbAvgAggregateOutputType | null
    _sum: CombousagetbSumAggregateOutputType | null
    _min: CombousagetbMinAggregateOutputType | null
    _max: CombousagetbMaxAggregateOutputType | null
  }

  type GetCombousagetbGroupByPayload<T extends combousagetbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CombousagetbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CombousagetbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CombousagetbGroupByOutputType[P]>
            : GetScalarType<T[P], CombousagetbGroupByOutputType[P]>
        }
      >
    >


  export type combousagetbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ComboUsageID?: boolean
    ComboID?: boolean
    MachineGroupID?: boolean
    FromTime?: boolean
    ToTime?: boolean
  }, ExtArgs["result"]["combousagetb"]>


  export type combousagetbSelectScalar = {
    ComboUsageID?: boolean
    ComboID?: boolean
    MachineGroupID?: boolean
    FromTime?: boolean
    ToTime?: boolean
  }


  export type $combousagetbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "combousagetb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ComboUsageID: number
      ComboID: number
      MachineGroupID: number
      FromTime: number
      ToTime: number
    }, ExtArgs["result"]["combousagetb"]>
    composites: {}
  }

  type combousagetbGetPayload<S extends boolean | null | undefined | combousagetbDefaultArgs> = $Result.GetResult<Prisma.$combousagetbPayload, S>

  type combousagetbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<combousagetbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CombousagetbCountAggregateInputType | true
    }

  export interface combousagetbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['combousagetb'], meta: { name: 'combousagetb' } }
    /**
     * Find zero or one Combousagetb that matches the filter.
     * @param {combousagetbFindUniqueArgs} args - Arguments to find a Combousagetb
     * @example
     * // Get one Combousagetb
     * const combousagetb = await prisma.combousagetb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends combousagetbFindUniqueArgs>(args: SelectSubset<T, combousagetbFindUniqueArgs<ExtArgs>>): Prisma__combousagetbClient<$Result.GetResult<Prisma.$combousagetbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Combousagetb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {combousagetbFindUniqueOrThrowArgs} args - Arguments to find a Combousagetb
     * @example
     * // Get one Combousagetb
     * const combousagetb = await prisma.combousagetb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends combousagetbFindUniqueOrThrowArgs>(args: SelectSubset<T, combousagetbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__combousagetbClient<$Result.GetResult<Prisma.$combousagetbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Combousagetb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combousagetbFindFirstArgs} args - Arguments to find a Combousagetb
     * @example
     * // Get one Combousagetb
     * const combousagetb = await prisma.combousagetb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends combousagetbFindFirstArgs>(args?: SelectSubset<T, combousagetbFindFirstArgs<ExtArgs>>): Prisma__combousagetbClient<$Result.GetResult<Prisma.$combousagetbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Combousagetb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combousagetbFindFirstOrThrowArgs} args - Arguments to find a Combousagetb
     * @example
     * // Get one Combousagetb
     * const combousagetb = await prisma.combousagetb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends combousagetbFindFirstOrThrowArgs>(args?: SelectSubset<T, combousagetbFindFirstOrThrowArgs<ExtArgs>>): Prisma__combousagetbClient<$Result.GetResult<Prisma.$combousagetbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Combousagetbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combousagetbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Combousagetbs
     * const combousagetbs = await prisma.combousagetb.findMany()
     * 
     * // Get first 10 Combousagetbs
     * const combousagetbs = await prisma.combousagetb.findMany({ take: 10 })
     * 
     * // Only select the `ComboUsageID`
     * const combousagetbWithComboUsageIDOnly = await prisma.combousagetb.findMany({ select: { ComboUsageID: true } })
     * 
     */
    findMany<T extends combousagetbFindManyArgs>(args?: SelectSubset<T, combousagetbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$combousagetbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Combousagetb.
     * @param {combousagetbCreateArgs} args - Arguments to create a Combousagetb.
     * @example
     * // Create one Combousagetb
     * const Combousagetb = await prisma.combousagetb.create({
     *   data: {
     *     // ... data to create a Combousagetb
     *   }
     * })
     * 
     */
    create<T extends combousagetbCreateArgs>(args: SelectSubset<T, combousagetbCreateArgs<ExtArgs>>): Prisma__combousagetbClient<$Result.GetResult<Prisma.$combousagetbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Combousagetbs.
     * @param {combousagetbCreateManyArgs} args - Arguments to create many Combousagetbs.
     * @example
     * // Create many Combousagetbs
     * const combousagetb = await prisma.combousagetb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends combousagetbCreateManyArgs>(args?: SelectSubset<T, combousagetbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Combousagetb.
     * @param {combousagetbDeleteArgs} args - Arguments to delete one Combousagetb.
     * @example
     * // Delete one Combousagetb
     * const Combousagetb = await prisma.combousagetb.delete({
     *   where: {
     *     // ... filter to delete one Combousagetb
     *   }
     * })
     * 
     */
    delete<T extends combousagetbDeleteArgs>(args: SelectSubset<T, combousagetbDeleteArgs<ExtArgs>>): Prisma__combousagetbClient<$Result.GetResult<Prisma.$combousagetbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Combousagetb.
     * @param {combousagetbUpdateArgs} args - Arguments to update one Combousagetb.
     * @example
     * // Update one Combousagetb
     * const combousagetb = await prisma.combousagetb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends combousagetbUpdateArgs>(args: SelectSubset<T, combousagetbUpdateArgs<ExtArgs>>): Prisma__combousagetbClient<$Result.GetResult<Prisma.$combousagetbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Combousagetbs.
     * @param {combousagetbDeleteManyArgs} args - Arguments to filter Combousagetbs to delete.
     * @example
     * // Delete a few Combousagetbs
     * const { count } = await prisma.combousagetb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends combousagetbDeleteManyArgs>(args?: SelectSubset<T, combousagetbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Combousagetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combousagetbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Combousagetbs
     * const combousagetb = await prisma.combousagetb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends combousagetbUpdateManyArgs>(args: SelectSubset<T, combousagetbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Combousagetb.
     * @param {combousagetbUpsertArgs} args - Arguments to update or create a Combousagetb.
     * @example
     * // Update or create a Combousagetb
     * const combousagetb = await prisma.combousagetb.upsert({
     *   create: {
     *     // ... data to create a Combousagetb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Combousagetb we want to update
     *   }
     * })
     */
    upsert<T extends combousagetbUpsertArgs>(args: SelectSubset<T, combousagetbUpsertArgs<ExtArgs>>): Prisma__combousagetbClient<$Result.GetResult<Prisma.$combousagetbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Combousagetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combousagetbCountArgs} args - Arguments to filter Combousagetbs to count.
     * @example
     * // Count the number of Combousagetbs
     * const count = await prisma.combousagetb.count({
     *   where: {
     *     // ... the filter for the Combousagetbs we want to count
     *   }
     * })
    **/
    count<T extends combousagetbCountArgs>(
      args?: Subset<T, combousagetbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CombousagetbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Combousagetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CombousagetbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CombousagetbAggregateArgs>(args: Subset<T, CombousagetbAggregateArgs>): Prisma.PrismaPromise<GetCombousagetbAggregateType<T>>

    /**
     * Group by Combousagetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {combousagetbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends combousagetbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: combousagetbGroupByArgs['orderBy'] }
        : { orderBy?: combousagetbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, combousagetbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCombousagetbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the combousagetb model
   */
  readonly fields: combousagetbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for combousagetb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__combousagetbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the combousagetb model
   */ 
  interface combousagetbFieldRefs {
    readonly ComboUsageID: FieldRef<"combousagetb", 'Int'>
    readonly ComboID: FieldRef<"combousagetb", 'Int'>
    readonly MachineGroupID: FieldRef<"combousagetb", 'Int'>
    readonly FromTime: FieldRef<"combousagetb", 'Int'>
    readonly ToTime: FieldRef<"combousagetb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * combousagetb findUnique
   */
  export type combousagetbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
    /**
     * Filter, which combousagetb to fetch.
     */
    where: combousagetbWhereUniqueInput
  }

  /**
   * combousagetb findUniqueOrThrow
   */
  export type combousagetbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
    /**
     * Filter, which combousagetb to fetch.
     */
    where: combousagetbWhereUniqueInput
  }

  /**
   * combousagetb findFirst
   */
  export type combousagetbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
    /**
     * Filter, which combousagetb to fetch.
     */
    where?: combousagetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combousagetbs to fetch.
     */
    orderBy?: combousagetbOrderByWithRelationInput | combousagetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combousagetbs.
     */
    cursor?: combousagetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combousagetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combousagetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combousagetbs.
     */
    distinct?: CombousagetbScalarFieldEnum | CombousagetbScalarFieldEnum[]
  }

  /**
   * combousagetb findFirstOrThrow
   */
  export type combousagetbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
    /**
     * Filter, which combousagetb to fetch.
     */
    where?: combousagetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combousagetbs to fetch.
     */
    orderBy?: combousagetbOrderByWithRelationInput | combousagetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combousagetbs.
     */
    cursor?: combousagetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combousagetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combousagetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combousagetbs.
     */
    distinct?: CombousagetbScalarFieldEnum | CombousagetbScalarFieldEnum[]
  }

  /**
   * combousagetb findMany
   */
  export type combousagetbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
    /**
     * Filter, which combousagetbs to fetch.
     */
    where?: combousagetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combousagetbs to fetch.
     */
    orderBy?: combousagetbOrderByWithRelationInput | combousagetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing combousagetbs.
     */
    cursor?: combousagetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combousagetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combousagetbs.
     */
    skip?: number
    distinct?: CombousagetbScalarFieldEnum | CombousagetbScalarFieldEnum[]
  }

  /**
   * combousagetb create
   */
  export type combousagetbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
    /**
     * The data needed to create a combousagetb.
     */
    data?: XOR<combousagetbCreateInput, combousagetbUncheckedCreateInput>
  }

  /**
   * combousagetb createMany
   */
  export type combousagetbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many combousagetbs.
     */
    data: combousagetbCreateManyInput | combousagetbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * combousagetb update
   */
  export type combousagetbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
    /**
     * The data needed to update a combousagetb.
     */
    data: XOR<combousagetbUpdateInput, combousagetbUncheckedUpdateInput>
    /**
     * Choose, which combousagetb to update.
     */
    where: combousagetbWhereUniqueInput
  }

  /**
   * combousagetb updateMany
   */
  export type combousagetbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update combousagetbs.
     */
    data: XOR<combousagetbUpdateManyMutationInput, combousagetbUncheckedUpdateManyInput>
    /**
     * Filter which combousagetbs to update
     */
    where?: combousagetbWhereInput
  }

  /**
   * combousagetb upsert
   */
  export type combousagetbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
    /**
     * The filter to search for the combousagetb to update in case it exists.
     */
    where: combousagetbWhereUniqueInput
    /**
     * In case the combousagetb found by the `where` argument doesn't exist, create a new combousagetb with this data.
     */
    create: XOR<combousagetbCreateInput, combousagetbUncheckedCreateInput>
    /**
     * In case the combousagetb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<combousagetbUpdateInput, combousagetbUncheckedUpdateInput>
  }

  /**
   * combousagetb delete
   */
  export type combousagetbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
    /**
     * Filter which combousagetb to delete.
     */
    where: combousagetbWhereUniqueInput
  }

  /**
   * combousagetb deleteMany
   */
  export type combousagetbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combousagetbs to delete
     */
    where?: combousagetbWhereInput
  }

  /**
   * combousagetb without action
   */
  export type combousagetbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combousagetb
     */
    select?: combousagetbSelect<ExtArgs> | null
  }


  /**
   * Model convertunittb
   */

  export type AggregateConvertunittb = {
    _count: ConvertunittbCountAggregateOutputType | null
    _avg: ConvertunittbAvgAggregateOutputType | null
    _sum: ConvertunittbSumAggregateOutputType | null
    _min: ConvertunittbMinAggregateOutputType | null
    _max: ConvertunittbMaxAggregateOutputType | null
  }

  export type ConvertunittbAvgAggregateOutputType = {
    ID: number | null
    ServiceID: number | null
    UnitRootID: number | null
    ConvertUnitID: number | null
    Quantity: number | null
  }

  export type ConvertunittbSumAggregateOutputType = {
    ID: number | null
    ServiceID: number | null
    UnitRootID: number | null
    ConvertUnitID: number | null
    Quantity: number | null
  }

  export type ConvertunittbMinAggregateOutputType = {
    ID: number | null
    ServiceID: number | null
    UnitRootID: number | null
    ConvertUnitID: number | null
    Quantity: number | null
  }

  export type ConvertunittbMaxAggregateOutputType = {
    ID: number | null
    ServiceID: number | null
    UnitRootID: number | null
    ConvertUnitID: number | null
    Quantity: number | null
  }

  export type ConvertunittbCountAggregateOutputType = {
    ID: number
    ServiceID: number
    UnitRootID: number
    ConvertUnitID: number
    Quantity: number
    _all: number
  }


  export type ConvertunittbAvgAggregateInputType = {
    ID?: true
    ServiceID?: true
    UnitRootID?: true
    ConvertUnitID?: true
    Quantity?: true
  }

  export type ConvertunittbSumAggregateInputType = {
    ID?: true
    ServiceID?: true
    UnitRootID?: true
    ConvertUnitID?: true
    Quantity?: true
  }

  export type ConvertunittbMinAggregateInputType = {
    ID?: true
    ServiceID?: true
    UnitRootID?: true
    ConvertUnitID?: true
    Quantity?: true
  }

  export type ConvertunittbMaxAggregateInputType = {
    ID?: true
    ServiceID?: true
    UnitRootID?: true
    ConvertUnitID?: true
    Quantity?: true
  }

  export type ConvertunittbCountAggregateInputType = {
    ID?: true
    ServiceID?: true
    UnitRootID?: true
    ConvertUnitID?: true
    Quantity?: true
    _all?: true
  }

  export type ConvertunittbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which convertunittb to aggregate.
     */
    where?: convertunittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of convertunittbs to fetch.
     */
    orderBy?: convertunittbOrderByWithRelationInput | convertunittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: convertunittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` convertunittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` convertunittbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned convertunittbs
    **/
    _count?: true | ConvertunittbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConvertunittbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConvertunittbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConvertunittbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConvertunittbMaxAggregateInputType
  }

  export type GetConvertunittbAggregateType<T extends ConvertunittbAggregateArgs> = {
        [P in keyof T & keyof AggregateConvertunittb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConvertunittb[P]>
      : GetScalarType<T[P], AggregateConvertunittb[P]>
  }




  export type convertunittbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: convertunittbWhereInput
    orderBy?: convertunittbOrderByWithAggregationInput | convertunittbOrderByWithAggregationInput[]
    by: ConvertunittbScalarFieldEnum[] | ConvertunittbScalarFieldEnum
    having?: convertunittbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConvertunittbCountAggregateInputType | true
    _avg?: ConvertunittbAvgAggregateInputType
    _sum?: ConvertunittbSumAggregateInputType
    _min?: ConvertunittbMinAggregateInputType
    _max?: ConvertunittbMaxAggregateInputType
  }

  export type ConvertunittbGroupByOutputType = {
    ID: number
    ServiceID: number
    UnitRootID: number
    ConvertUnitID: number
    Quantity: number
    _count: ConvertunittbCountAggregateOutputType | null
    _avg: ConvertunittbAvgAggregateOutputType | null
    _sum: ConvertunittbSumAggregateOutputType | null
    _min: ConvertunittbMinAggregateOutputType | null
    _max: ConvertunittbMaxAggregateOutputType | null
  }

  type GetConvertunittbGroupByPayload<T extends convertunittbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConvertunittbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConvertunittbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConvertunittbGroupByOutputType[P]>
            : GetScalarType<T[P], ConvertunittbGroupByOutputType[P]>
        }
      >
    >


  export type convertunittbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    ServiceID?: boolean
    UnitRootID?: boolean
    ConvertUnitID?: boolean
    Quantity?: boolean
  }, ExtArgs["result"]["convertunittb"]>


  export type convertunittbSelectScalar = {
    ID?: boolean
    ServiceID?: boolean
    UnitRootID?: boolean
    ConvertUnitID?: boolean
    Quantity?: boolean
  }


  export type $convertunittbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "convertunittb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      ServiceID: number
      UnitRootID: number
      ConvertUnitID: number
      Quantity: number
    }, ExtArgs["result"]["convertunittb"]>
    composites: {}
  }

  type convertunittbGetPayload<S extends boolean | null | undefined | convertunittbDefaultArgs> = $Result.GetResult<Prisma.$convertunittbPayload, S>

  type convertunittbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<convertunittbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConvertunittbCountAggregateInputType | true
    }

  export interface convertunittbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['convertunittb'], meta: { name: 'convertunittb' } }
    /**
     * Find zero or one Convertunittb that matches the filter.
     * @param {convertunittbFindUniqueArgs} args - Arguments to find a Convertunittb
     * @example
     * // Get one Convertunittb
     * const convertunittb = await prisma.convertunittb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends convertunittbFindUniqueArgs>(args: SelectSubset<T, convertunittbFindUniqueArgs<ExtArgs>>): Prisma__convertunittbClient<$Result.GetResult<Prisma.$convertunittbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Convertunittb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {convertunittbFindUniqueOrThrowArgs} args - Arguments to find a Convertunittb
     * @example
     * // Get one Convertunittb
     * const convertunittb = await prisma.convertunittb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends convertunittbFindUniqueOrThrowArgs>(args: SelectSubset<T, convertunittbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__convertunittbClient<$Result.GetResult<Prisma.$convertunittbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Convertunittb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convertunittbFindFirstArgs} args - Arguments to find a Convertunittb
     * @example
     * // Get one Convertunittb
     * const convertunittb = await prisma.convertunittb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends convertunittbFindFirstArgs>(args?: SelectSubset<T, convertunittbFindFirstArgs<ExtArgs>>): Prisma__convertunittbClient<$Result.GetResult<Prisma.$convertunittbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Convertunittb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convertunittbFindFirstOrThrowArgs} args - Arguments to find a Convertunittb
     * @example
     * // Get one Convertunittb
     * const convertunittb = await prisma.convertunittb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends convertunittbFindFirstOrThrowArgs>(args?: SelectSubset<T, convertunittbFindFirstOrThrowArgs<ExtArgs>>): Prisma__convertunittbClient<$Result.GetResult<Prisma.$convertunittbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Convertunittbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convertunittbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Convertunittbs
     * const convertunittbs = await prisma.convertunittb.findMany()
     * 
     * // Get first 10 Convertunittbs
     * const convertunittbs = await prisma.convertunittb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const convertunittbWithIDOnly = await prisma.convertunittb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends convertunittbFindManyArgs>(args?: SelectSubset<T, convertunittbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$convertunittbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Convertunittb.
     * @param {convertunittbCreateArgs} args - Arguments to create a Convertunittb.
     * @example
     * // Create one Convertunittb
     * const Convertunittb = await prisma.convertunittb.create({
     *   data: {
     *     // ... data to create a Convertunittb
     *   }
     * })
     * 
     */
    create<T extends convertunittbCreateArgs>(args: SelectSubset<T, convertunittbCreateArgs<ExtArgs>>): Prisma__convertunittbClient<$Result.GetResult<Prisma.$convertunittbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Convertunittbs.
     * @param {convertunittbCreateManyArgs} args - Arguments to create many Convertunittbs.
     * @example
     * // Create many Convertunittbs
     * const convertunittb = await prisma.convertunittb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends convertunittbCreateManyArgs>(args?: SelectSubset<T, convertunittbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Convertunittb.
     * @param {convertunittbDeleteArgs} args - Arguments to delete one Convertunittb.
     * @example
     * // Delete one Convertunittb
     * const Convertunittb = await prisma.convertunittb.delete({
     *   where: {
     *     // ... filter to delete one Convertunittb
     *   }
     * })
     * 
     */
    delete<T extends convertunittbDeleteArgs>(args: SelectSubset<T, convertunittbDeleteArgs<ExtArgs>>): Prisma__convertunittbClient<$Result.GetResult<Prisma.$convertunittbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Convertunittb.
     * @param {convertunittbUpdateArgs} args - Arguments to update one Convertunittb.
     * @example
     * // Update one Convertunittb
     * const convertunittb = await prisma.convertunittb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends convertunittbUpdateArgs>(args: SelectSubset<T, convertunittbUpdateArgs<ExtArgs>>): Prisma__convertunittbClient<$Result.GetResult<Prisma.$convertunittbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Convertunittbs.
     * @param {convertunittbDeleteManyArgs} args - Arguments to filter Convertunittbs to delete.
     * @example
     * // Delete a few Convertunittbs
     * const { count } = await prisma.convertunittb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends convertunittbDeleteManyArgs>(args?: SelectSubset<T, convertunittbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Convertunittbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convertunittbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Convertunittbs
     * const convertunittb = await prisma.convertunittb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends convertunittbUpdateManyArgs>(args: SelectSubset<T, convertunittbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Convertunittb.
     * @param {convertunittbUpsertArgs} args - Arguments to update or create a Convertunittb.
     * @example
     * // Update or create a Convertunittb
     * const convertunittb = await prisma.convertunittb.upsert({
     *   create: {
     *     // ... data to create a Convertunittb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Convertunittb we want to update
     *   }
     * })
     */
    upsert<T extends convertunittbUpsertArgs>(args: SelectSubset<T, convertunittbUpsertArgs<ExtArgs>>): Prisma__convertunittbClient<$Result.GetResult<Prisma.$convertunittbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Convertunittbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convertunittbCountArgs} args - Arguments to filter Convertunittbs to count.
     * @example
     * // Count the number of Convertunittbs
     * const count = await prisma.convertunittb.count({
     *   where: {
     *     // ... the filter for the Convertunittbs we want to count
     *   }
     * })
    **/
    count<T extends convertunittbCountArgs>(
      args?: Subset<T, convertunittbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConvertunittbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Convertunittb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvertunittbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConvertunittbAggregateArgs>(args: Subset<T, ConvertunittbAggregateArgs>): Prisma.PrismaPromise<GetConvertunittbAggregateType<T>>

    /**
     * Group by Convertunittb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {convertunittbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends convertunittbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: convertunittbGroupByArgs['orderBy'] }
        : { orderBy?: convertunittbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, convertunittbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConvertunittbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the convertunittb model
   */
  readonly fields: convertunittbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for convertunittb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__convertunittbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the convertunittb model
   */ 
  interface convertunittbFieldRefs {
    readonly ID: FieldRef<"convertunittb", 'Int'>
    readonly ServiceID: FieldRef<"convertunittb", 'Int'>
    readonly UnitRootID: FieldRef<"convertunittb", 'Int'>
    readonly ConvertUnitID: FieldRef<"convertunittb", 'Int'>
    readonly Quantity: FieldRef<"convertunittb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * convertunittb findUnique
   */
  export type convertunittbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
    /**
     * Filter, which convertunittb to fetch.
     */
    where: convertunittbWhereUniqueInput
  }

  /**
   * convertunittb findUniqueOrThrow
   */
  export type convertunittbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
    /**
     * Filter, which convertunittb to fetch.
     */
    where: convertunittbWhereUniqueInput
  }

  /**
   * convertunittb findFirst
   */
  export type convertunittbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
    /**
     * Filter, which convertunittb to fetch.
     */
    where?: convertunittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of convertunittbs to fetch.
     */
    orderBy?: convertunittbOrderByWithRelationInput | convertunittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for convertunittbs.
     */
    cursor?: convertunittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` convertunittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` convertunittbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of convertunittbs.
     */
    distinct?: ConvertunittbScalarFieldEnum | ConvertunittbScalarFieldEnum[]
  }

  /**
   * convertunittb findFirstOrThrow
   */
  export type convertunittbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
    /**
     * Filter, which convertunittb to fetch.
     */
    where?: convertunittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of convertunittbs to fetch.
     */
    orderBy?: convertunittbOrderByWithRelationInput | convertunittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for convertunittbs.
     */
    cursor?: convertunittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` convertunittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` convertunittbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of convertunittbs.
     */
    distinct?: ConvertunittbScalarFieldEnum | ConvertunittbScalarFieldEnum[]
  }

  /**
   * convertunittb findMany
   */
  export type convertunittbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
    /**
     * Filter, which convertunittbs to fetch.
     */
    where?: convertunittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of convertunittbs to fetch.
     */
    orderBy?: convertunittbOrderByWithRelationInput | convertunittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing convertunittbs.
     */
    cursor?: convertunittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` convertunittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` convertunittbs.
     */
    skip?: number
    distinct?: ConvertunittbScalarFieldEnum | ConvertunittbScalarFieldEnum[]
  }

  /**
   * convertunittb create
   */
  export type convertunittbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
    /**
     * The data needed to create a convertunittb.
     */
    data?: XOR<convertunittbCreateInput, convertunittbUncheckedCreateInput>
  }

  /**
   * convertunittb createMany
   */
  export type convertunittbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many convertunittbs.
     */
    data: convertunittbCreateManyInput | convertunittbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * convertunittb update
   */
  export type convertunittbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
    /**
     * The data needed to update a convertunittb.
     */
    data: XOR<convertunittbUpdateInput, convertunittbUncheckedUpdateInput>
    /**
     * Choose, which convertunittb to update.
     */
    where: convertunittbWhereUniqueInput
  }

  /**
   * convertunittb updateMany
   */
  export type convertunittbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update convertunittbs.
     */
    data: XOR<convertunittbUpdateManyMutationInput, convertunittbUncheckedUpdateManyInput>
    /**
     * Filter which convertunittbs to update
     */
    where?: convertunittbWhereInput
  }

  /**
   * convertunittb upsert
   */
  export type convertunittbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
    /**
     * The filter to search for the convertunittb to update in case it exists.
     */
    where: convertunittbWhereUniqueInput
    /**
     * In case the convertunittb found by the `where` argument doesn't exist, create a new convertunittb with this data.
     */
    create: XOR<convertunittbCreateInput, convertunittbUncheckedCreateInput>
    /**
     * In case the convertunittb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<convertunittbUpdateInput, convertunittbUncheckedUpdateInput>
  }

  /**
   * convertunittb delete
   */
  export type convertunittbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
    /**
     * Filter which convertunittb to delete.
     */
    where: convertunittbWhereUniqueInput
  }

  /**
   * convertunittb deleteMany
   */
  export type convertunittbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which convertunittbs to delete
     */
    where?: convertunittbWhereInput
  }

  /**
   * convertunittb without action
   */
  export type convertunittbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the convertunittb
     */
    select?: convertunittbSelect<ExtArgs> | null
  }


  /**
   * Model dptb
   */

  export type AggregateDptb = {
    _count: DptbCountAggregateOutputType | null
    _avg: DptbAvgAggregateOutputType | null
    _sum: DptbSumAggregateOutputType | null
    _min: DptbMinAggregateOutputType | null
    _max: DptbMaxAggregateOutputType | null
  }

  export type DptbAvgAggregateOutputType = {
    Status: number | null
    Type: number | null
  }

  export type DptbSumAggregateOutputType = {
    Status: number | null
    Type: number | null
  }

  export type DptbMinAggregateOutputType = {
    ComputerName: string | null
    Status: number | null
    Type: number | null
    Version: string | null
    LastUpdate: Date | null
    FNetVersion: string | null
    FNetReleaseDate: Date | null
    DPB: string | null
  }

  export type DptbMaxAggregateOutputType = {
    ComputerName: string | null
    Status: number | null
    Type: number | null
    Version: string | null
    LastUpdate: Date | null
    FNetVersion: string | null
    FNetReleaseDate: Date | null
    DPB: string | null
  }

  export type DptbCountAggregateOutputType = {
    ComputerName: number
    Status: number
    Type: number
    Version: number
    LastUpdate: number
    FNetVersion: number
    FNetReleaseDate: number
    DPB: number
    _all: number
  }


  export type DptbAvgAggregateInputType = {
    Status?: true
    Type?: true
  }

  export type DptbSumAggregateInputType = {
    Status?: true
    Type?: true
  }

  export type DptbMinAggregateInputType = {
    ComputerName?: true
    Status?: true
    Type?: true
    Version?: true
    LastUpdate?: true
    FNetVersion?: true
    FNetReleaseDate?: true
    DPB?: true
  }

  export type DptbMaxAggregateInputType = {
    ComputerName?: true
    Status?: true
    Type?: true
    Version?: true
    LastUpdate?: true
    FNetVersion?: true
    FNetReleaseDate?: true
    DPB?: true
  }

  export type DptbCountAggregateInputType = {
    ComputerName?: true
    Status?: true
    Type?: true
    Version?: true
    LastUpdate?: true
    FNetVersion?: true
    FNetReleaseDate?: true
    DPB?: true
    _all?: true
  }

  export type DptbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dptb to aggregate.
     */
    where?: dptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dptbs to fetch.
     */
    orderBy?: dptbOrderByWithRelationInput | dptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dptbs
    **/
    _count?: true | DptbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DptbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DptbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DptbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DptbMaxAggregateInputType
  }

  export type GetDptbAggregateType<T extends DptbAggregateArgs> = {
        [P in keyof T & keyof AggregateDptb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDptb[P]>
      : GetScalarType<T[P], AggregateDptb[P]>
  }




  export type dptbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dptbWhereInput
    orderBy?: dptbOrderByWithAggregationInput | dptbOrderByWithAggregationInput[]
    by: DptbScalarFieldEnum[] | DptbScalarFieldEnum
    having?: dptbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DptbCountAggregateInputType | true
    _avg?: DptbAvgAggregateInputType
    _sum?: DptbSumAggregateInputType
    _min?: DptbMinAggregateInputType
    _max?: DptbMaxAggregateInputType
  }

  export type DptbGroupByOutputType = {
    ComputerName: string
    Status: number
    Type: number
    Version: string
    LastUpdate: Date
    FNetVersion: string
    FNetReleaseDate: Date
    DPB: string
    _count: DptbCountAggregateOutputType | null
    _avg: DptbAvgAggregateOutputType | null
    _sum: DptbSumAggregateOutputType | null
    _min: DptbMinAggregateOutputType | null
    _max: DptbMaxAggregateOutputType | null
  }

  type GetDptbGroupByPayload<T extends dptbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DptbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DptbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DptbGroupByOutputType[P]>
            : GetScalarType<T[P], DptbGroupByOutputType[P]>
        }
      >
    >


  export type dptbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ComputerName?: boolean
    Status?: boolean
    Type?: boolean
    Version?: boolean
    LastUpdate?: boolean
    FNetVersion?: boolean
    FNetReleaseDate?: boolean
    DPB?: boolean
  }, ExtArgs["result"]["dptb"]>


  export type dptbSelectScalar = {
    ComputerName?: boolean
    Status?: boolean
    Type?: boolean
    Version?: boolean
    LastUpdate?: boolean
    FNetVersion?: boolean
    FNetReleaseDate?: boolean
    DPB?: boolean
  }


  export type $dptbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dptb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ComputerName: string
      Status: number
      Type: number
      Version: string
      LastUpdate: Date
      FNetVersion: string
      FNetReleaseDate: Date
      DPB: string
    }, ExtArgs["result"]["dptb"]>
    composites: {}
  }

  type dptbGetPayload<S extends boolean | null | undefined | dptbDefaultArgs> = $Result.GetResult<Prisma.$dptbPayload, S>

  type dptbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<dptbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DptbCountAggregateInputType | true
    }

  export interface dptbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dptb'], meta: { name: 'dptb' } }
    /**
     * Find zero or one Dptb that matches the filter.
     * @param {dptbFindUniqueArgs} args - Arguments to find a Dptb
     * @example
     * // Get one Dptb
     * const dptb = await prisma.dptb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dptbFindUniqueArgs>(args: SelectSubset<T, dptbFindUniqueArgs<ExtArgs>>): Prisma__dptbClient<$Result.GetResult<Prisma.$dptbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dptb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {dptbFindUniqueOrThrowArgs} args - Arguments to find a Dptb
     * @example
     * // Get one Dptb
     * const dptb = await prisma.dptb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dptbFindUniqueOrThrowArgs>(args: SelectSubset<T, dptbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dptbClient<$Result.GetResult<Prisma.$dptbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dptb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dptbFindFirstArgs} args - Arguments to find a Dptb
     * @example
     * // Get one Dptb
     * const dptb = await prisma.dptb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dptbFindFirstArgs>(args?: SelectSubset<T, dptbFindFirstArgs<ExtArgs>>): Prisma__dptbClient<$Result.GetResult<Prisma.$dptbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dptb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dptbFindFirstOrThrowArgs} args - Arguments to find a Dptb
     * @example
     * // Get one Dptb
     * const dptb = await prisma.dptb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dptbFindFirstOrThrowArgs>(args?: SelectSubset<T, dptbFindFirstOrThrowArgs<ExtArgs>>): Prisma__dptbClient<$Result.GetResult<Prisma.$dptbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dptbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dptbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dptbs
     * const dptbs = await prisma.dptb.findMany()
     * 
     * // Get first 10 Dptbs
     * const dptbs = await prisma.dptb.findMany({ take: 10 })
     * 
     * // Only select the `ComputerName`
     * const dptbWithComputerNameOnly = await prisma.dptb.findMany({ select: { ComputerName: true } })
     * 
     */
    findMany<T extends dptbFindManyArgs>(args?: SelectSubset<T, dptbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dptbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dptb.
     * @param {dptbCreateArgs} args - Arguments to create a Dptb.
     * @example
     * // Create one Dptb
     * const Dptb = await prisma.dptb.create({
     *   data: {
     *     // ... data to create a Dptb
     *   }
     * })
     * 
     */
    create<T extends dptbCreateArgs>(args: SelectSubset<T, dptbCreateArgs<ExtArgs>>): Prisma__dptbClient<$Result.GetResult<Prisma.$dptbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dptbs.
     * @param {dptbCreateManyArgs} args - Arguments to create many Dptbs.
     * @example
     * // Create many Dptbs
     * const dptb = await prisma.dptb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dptbCreateManyArgs>(args?: SelectSubset<T, dptbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dptb.
     * @param {dptbDeleteArgs} args - Arguments to delete one Dptb.
     * @example
     * // Delete one Dptb
     * const Dptb = await prisma.dptb.delete({
     *   where: {
     *     // ... filter to delete one Dptb
     *   }
     * })
     * 
     */
    delete<T extends dptbDeleteArgs>(args: SelectSubset<T, dptbDeleteArgs<ExtArgs>>): Prisma__dptbClient<$Result.GetResult<Prisma.$dptbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dptb.
     * @param {dptbUpdateArgs} args - Arguments to update one Dptb.
     * @example
     * // Update one Dptb
     * const dptb = await prisma.dptb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dptbUpdateArgs>(args: SelectSubset<T, dptbUpdateArgs<ExtArgs>>): Prisma__dptbClient<$Result.GetResult<Prisma.$dptbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dptbs.
     * @param {dptbDeleteManyArgs} args - Arguments to filter Dptbs to delete.
     * @example
     * // Delete a few Dptbs
     * const { count } = await prisma.dptb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dptbDeleteManyArgs>(args?: SelectSubset<T, dptbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dptbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dptbs
     * const dptb = await prisma.dptb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dptbUpdateManyArgs>(args: SelectSubset<T, dptbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dptb.
     * @param {dptbUpsertArgs} args - Arguments to update or create a Dptb.
     * @example
     * // Update or create a Dptb
     * const dptb = await prisma.dptb.upsert({
     *   create: {
     *     // ... data to create a Dptb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dptb we want to update
     *   }
     * })
     */
    upsert<T extends dptbUpsertArgs>(args: SelectSubset<T, dptbUpsertArgs<ExtArgs>>): Prisma__dptbClient<$Result.GetResult<Prisma.$dptbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dptbCountArgs} args - Arguments to filter Dptbs to count.
     * @example
     * // Count the number of Dptbs
     * const count = await prisma.dptb.count({
     *   where: {
     *     // ... the filter for the Dptbs we want to count
     *   }
     * })
    **/
    count<T extends dptbCountArgs>(
      args?: Subset<T, dptbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DptbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DptbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DptbAggregateArgs>(args: Subset<T, DptbAggregateArgs>): Prisma.PrismaPromise<GetDptbAggregateType<T>>

    /**
     * Group by Dptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dptbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dptbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dptbGroupByArgs['orderBy'] }
        : { orderBy?: dptbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dptbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDptbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dptb model
   */
  readonly fields: dptbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dptb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dptbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dptb model
   */ 
  interface dptbFieldRefs {
    readonly ComputerName: FieldRef<"dptb", 'String'>
    readonly Status: FieldRef<"dptb", 'Int'>
    readonly Type: FieldRef<"dptb", 'Int'>
    readonly Version: FieldRef<"dptb", 'String'>
    readonly LastUpdate: FieldRef<"dptb", 'DateTime'>
    readonly FNetVersion: FieldRef<"dptb", 'String'>
    readonly FNetReleaseDate: FieldRef<"dptb", 'DateTime'>
    readonly DPB: FieldRef<"dptb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * dptb findUnique
   */
  export type dptbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
    /**
     * Filter, which dptb to fetch.
     */
    where: dptbWhereUniqueInput
  }

  /**
   * dptb findUniqueOrThrow
   */
  export type dptbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
    /**
     * Filter, which dptb to fetch.
     */
    where: dptbWhereUniqueInput
  }

  /**
   * dptb findFirst
   */
  export type dptbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
    /**
     * Filter, which dptb to fetch.
     */
    where?: dptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dptbs to fetch.
     */
    orderBy?: dptbOrderByWithRelationInput | dptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dptbs.
     */
    cursor?: dptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dptbs.
     */
    distinct?: DptbScalarFieldEnum | DptbScalarFieldEnum[]
  }

  /**
   * dptb findFirstOrThrow
   */
  export type dptbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
    /**
     * Filter, which dptb to fetch.
     */
    where?: dptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dptbs to fetch.
     */
    orderBy?: dptbOrderByWithRelationInput | dptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dptbs.
     */
    cursor?: dptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dptbs.
     */
    distinct?: DptbScalarFieldEnum | DptbScalarFieldEnum[]
  }

  /**
   * dptb findMany
   */
  export type dptbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
    /**
     * Filter, which dptbs to fetch.
     */
    where?: dptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dptbs to fetch.
     */
    orderBy?: dptbOrderByWithRelationInput | dptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dptbs.
     */
    cursor?: dptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dptbs.
     */
    skip?: number
    distinct?: DptbScalarFieldEnum | DptbScalarFieldEnum[]
  }

  /**
   * dptb create
   */
  export type dptbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
    /**
     * The data needed to create a dptb.
     */
    data: XOR<dptbCreateInput, dptbUncheckedCreateInput>
  }

  /**
   * dptb createMany
   */
  export type dptbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dptbs.
     */
    data: dptbCreateManyInput | dptbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dptb update
   */
  export type dptbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
    /**
     * The data needed to update a dptb.
     */
    data: XOR<dptbUpdateInput, dptbUncheckedUpdateInput>
    /**
     * Choose, which dptb to update.
     */
    where: dptbWhereUniqueInput
  }

  /**
   * dptb updateMany
   */
  export type dptbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dptbs.
     */
    data: XOR<dptbUpdateManyMutationInput, dptbUncheckedUpdateManyInput>
    /**
     * Filter which dptbs to update
     */
    where?: dptbWhereInput
  }

  /**
   * dptb upsert
   */
  export type dptbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
    /**
     * The filter to search for the dptb to update in case it exists.
     */
    where: dptbWhereUniqueInput
    /**
     * In case the dptb found by the `where` argument doesn't exist, create a new dptb with this data.
     */
    create: XOR<dptbCreateInput, dptbUncheckedCreateInput>
    /**
     * In case the dptb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dptbUpdateInput, dptbUncheckedUpdateInput>
  }

  /**
   * dptb delete
   */
  export type dptbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
    /**
     * Filter which dptb to delete.
     */
    where: dptbWhereUniqueInput
  }

  /**
   * dptb deleteMany
   */
  export type dptbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dptbs to delete
     */
    where?: dptbWhereInput
  }

  /**
   * dptb without action
   */
  export type dptbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dptb
     */
    select?: dptbSelect<ExtArgs> | null
  }


  /**
   * Model freetimedetailtb
   */

  export type AggregateFreetimedetailtb = {
    _count: FreetimedetailtbCountAggregateOutputType | null
    _avg: FreetimedetailtbAvgAggregateOutputType | null
    _sum: FreetimedetailtbSumAggregateOutputType | null
    _min: FreetimedetailtbMinAggregateOutputType | null
    _max: FreetimedetailtbMaxAggregateOutputType | null
  }

  export type FreetimedetailtbAvgAggregateOutputType = {
    FreeTimeDetailId: number | null
    UserId: number | null
    FreeTime: number | null
    FreeMoney: number | null
    Type: number | null
    VoucherId: number | null
  }

  export type FreetimedetailtbSumAggregateOutputType = {
    FreeTimeDetailId: number | null
    UserId: number | null
    FreeTime: number | null
    FreeMoney: number | null
    Type: number | null
    VoucherId: number | null
  }

  export type FreetimedetailtbMinAggregateOutputType = {
    FreeTimeDetailId: number | null
    UserId: number | null
    FreeTime: number | null
    FreeMoney: number | null
    Type: number | null
    RecordDate: Date | null
    VoucherId: number | null
  }

  export type FreetimedetailtbMaxAggregateOutputType = {
    FreeTimeDetailId: number | null
    UserId: number | null
    FreeTime: number | null
    FreeMoney: number | null
    Type: number | null
    RecordDate: Date | null
    VoucherId: number | null
  }

  export type FreetimedetailtbCountAggregateOutputType = {
    FreeTimeDetailId: number
    UserId: number
    FreeTime: number
    FreeMoney: number
    Type: number
    RecordDate: number
    VoucherId: number
    _all: number
  }


  export type FreetimedetailtbAvgAggregateInputType = {
    FreeTimeDetailId?: true
    UserId?: true
    FreeTime?: true
    FreeMoney?: true
    Type?: true
    VoucherId?: true
  }

  export type FreetimedetailtbSumAggregateInputType = {
    FreeTimeDetailId?: true
    UserId?: true
    FreeTime?: true
    FreeMoney?: true
    Type?: true
    VoucherId?: true
  }

  export type FreetimedetailtbMinAggregateInputType = {
    FreeTimeDetailId?: true
    UserId?: true
    FreeTime?: true
    FreeMoney?: true
    Type?: true
    RecordDate?: true
    VoucherId?: true
  }

  export type FreetimedetailtbMaxAggregateInputType = {
    FreeTimeDetailId?: true
    UserId?: true
    FreeTime?: true
    FreeMoney?: true
    Type?: true
    RecordDate?: true
    VoucherId?: true
  }

  export type FreetimedetailtbCountAggregateInputType = {
    FreeTimeDetailId?: true
    UserId?: true
    FreeTime?: true
    FreeMoney?: true
    Type?: true
    RecordDate?: true
    VoucherId?: true
    _all?: true
  }

  export type FreetimedetailtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which freetimedetailtb to aggregate.
     */
    where?: freetimedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of freetimedetailtbs to fetch.
     */
    orderBy?: freetimedetailtbOrderByWithRelationInput | freetimedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: freetimedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` freetimedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` freetimedetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned freetimedetailtbs
    **/
    _count?: true | FreetimedetailtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FreetimedetailtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FreetimedetailtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreetimedetailtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreetimedetailtbMaxAggregateInputType
  }

  export type GetFreetimedetailtbAggregateType<T extends FreetimedetailtbAggregateArgs> = {
        [P in keyof T & keyof AggregateFreetimedetailtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreetimedetailtb[P]>
      : GetScalarType<T[P], AggregateFreetimedetailtb[P]>
  }




  export type freetimedetailtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: freetimedetailtbWhereInput
    orderBy?: freetimedetailtbOrderByWithAggregationInput | freetimedetailtbOrderByWithAggregationInput[]
    by: FreetimedetailtbScalarFieldEnum[] | FreetimedetailtbScalarFieldEnum
    having?: freetimedetailtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreetimedetailtbCountAggregateInputType | true
    _avg?: FreetimedetailtbAvgAggregateInputType
    _sum?: FreetimedetailtbSumAggregateInputType
    _min?: FreetimedetailtbMinAggregateInputType
    _max?: FreetimedetailtbMaxAggregateInputType
  }

  export type FreetimedetailtbGroupByOutputType = {
    FreeTimeDetailId: number
    UserId: number
    FreeTime: number
    FreeMoney: number
    Type: number
    RecordDate: Date
    VoucherId: number
    _count: FreetimedetailtbCountAggregateOutputType | null
    _avg: FreetimedetailtbAvgAggregateOutputType | null
    _sum: FreetimedetailtbSumAggregateOutputType | null
    _min: FreetimedetailtbMinAggregateOutputType | null
    _max: FreetimedetailtbMaxAggregateOutputType | null
  }

  type GetFreetimedetailtbGroupByPayload<T extends freetimedetailtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreetimedetailtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreetimedetailtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreetimedetailtbGroupByOutputType[P]>
            : GetScalarType<T[P], FreetimedetailtbGroupByOutputType[P]>
        }
      >
    >


  export type freetimedetailtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FreeTimeDetailId?: boolean
    UserId?: boolean
    FreeTime?: boolean
    FreeMoney?: boolean
    Type?: boolean
    RecordDate?: boolean
    VoucherId?: boolean
  }, ExtArgs["result"]["freetimedetailtb"]>


  export type freetimedetailtbSelectScalar = {
    FreeTimeDetailId?: boolean
    UserId?: boolean
    FreeTime?: boolean
    FreeMoney?: boolean
    Type?: boolean
    RecordDate?: boolean
    VoucherId?: boolean
  }


  export type $freetimedetailtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "freetimedetailtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      FreeTimeDetailId: number
      UserId: number
      FreeTime: number
      FreeMoney: number
      Type: number
      RecordDate: Date
      VoucherId: number
    }, ExtArgs["result"]["freetimedetailtb"]>
    composites: {}
  }

  type freetimedetailtbGetPayload<S extends boolean | null | undefined | freetimedetailtbDefaultArgs> = $Result.GetResult<Prisma.$freetimedetailtbPayload, S>

  type freetimedetailtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<freetimedetailtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FreetimedetailtbCountAggregateInputType | true
    }

  export interface freetimedetailtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['freetimedetailtb'], meta: { name: 'freetimedetailtb' } }
    /**
     * Find zero or one Freetimedetailtb that matches the filter.
     * @param {freetimedetailtbFindUniqueArgs} args - Arguments to find a Freetimedetailtb
     * @example
     * // Get one Freetimedetailtb
     * const freetimedetailtb = await prisma.freetimedetailtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends freetimedetailtbFindUniqueArgs>(args: SelectSubset<T, freetimedetailtbFindUniqueArgs<ExtArgs>>): Prisma__freetimedetailtbClient<$Result.GetResult<Prisma.$freetimedetailtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Freetimedetailtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {freetimedetailtbFindUniqueOrThrowArgs} args - Arguments to find a Freetimedetailtb
     * @example
     * // Get one Freetimedetailtb
     * const freetimedetailtb = await prisma.freetimedetailtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends freetimedetailtbFindUniqueOrThrowArgs>(args: SelectSubset<T, freetimedetailtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__freetimedetailtbClient<$Result.GetResult<Prisma.$freetimedetailtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Freetimedetailtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freetimedetailtbFindFirstArgs} args - Arguments to find a Freetimedetailtb
     * @example
     * // Get one Freetimedetailtb
     * const freetimedetailtb = await prisma.freetimedetailtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends freetimedetailtbFindFirstArgs>(args?: SelectSubset<T, freetimedetailtbFindFirstArgs<ExtArgs>>): Prisma__freetimedetailtbClient<$Result.GetResult<Prisma.$freetimedetailtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Freetimedetailtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freetimedetailtbFindFirstOrThrowArgs} args - Arguments to find a Freetimedetailtb
     * @example
     * // Get one Freetimedetailtb
     * const freetimedetailtb = await prisma.freetimedetailtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends freetimedetailtbFindFirstOrThrowArgs>(args?: SelectSubset<T, freetimedetailtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__freetimedetailtbClient<$Result.GetResult<Prisma.$freetimedetailtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Freetimedetailtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freetimedetailtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Freetimedetailtbs
     * const freetimedetailtbs = await prisma.freetimedetailtb.findMany()
     * 
     * // Get first 10 Freetimedetailtbs
     * const freetimedetailtbs = await prisma.freetimedetailtb.findMany({ take: 10 })
     * 
     * // Only select the `FreeTimeDetailId`
     * const freetimedetailtbWithFreeTimeDetailIdOnly = await prisma.freetimedetailtb.findMany({ select: { FreeTimeDetailId: true } })
     * 
     */
    findMany<T extends freetimedetailtbFindManyArgs>(args?: SelectSubset<T, freetimedetailtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$freetimedetailtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Freetimedetailtb.
     * @param {freetimedetailtbCreateArgs} args - Arguments to create a Freetimedetailtb.
     * @example
     * // Create one Freetimedetailtb
     * const Freetimedetailtb = await prisma.freetimedetailtb.create({
     *   data: {
     *     // ... data to create a Freetimedetailtb
     *   }
     * })
     * 
     */
    create<T extends freetimedetailtbCreateArgs>(args: SelectSubset<T, freetimedetailtbCreateArgs<ExtArgs>>): Prisma__freetimedetailtbClient<$Result.GetResult<Prisma.$freetimedetailtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Freetimedetailtbs.
     * @param {freetimedetailtbCreateManyArgs} args - Arguments to create many Freetimedetailtbs.
     * @example
     * // Create many Freetimedetailtbs
     * const freetimedetailtb = await prisma.freetimedetailtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends freetimedetailtbCreateManyArgs>(args?: SelectSubset<T, freetimedetailtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Freetimedetailtb.
     * @param {freetimedetailtbDeleteArgs} args - Arguments to delete one Freetimedetailtb.
     * @example
     * // Delete one Freetimedetailtb
     * const Freetimedetailtb = await prisma.freetimedetailtb.delete({
     *   where: {
     *     // ... filter to delete one Freetimedetailtb
     *   }
     * })
     * 
     */
    delete<T extends freetimedetailtbDeleteArgs>(args: SelectSubset<T, freetimedetailtbDeleteArgs<ExtArgs>>): Prisma__freetimedetailtbClient<$Result.GetResult<Prisma.$freetimedetailtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Freetimedetailtb.
     * @param {freetimedetailtbUpdateArgs} args - Arguments to update one Freetimedetailtb.
     * @example
     * // Update one Freetimedetailtb
     * const freetimedetailtb = await prisma.freetimedetailtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends freetimedetailtbUpdateArgs>(args: SelectSubset<T, freetimedetailtbUpdateArgs<ExtArgs>>): Prisma__freetimedetailtbClient<$Result.GetResult<Prisma.$freetimedetailtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Freetimedetailtbs.
     * @param {freetimedetailtbDeleteManyArgs} args - Arguments to filter Freetimedetailtbs to delete.
     * @example
     * // Delete a few Freetimedetailtbs
     * const { count } = await prisma.freetimedetailtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends freetimedetailtbDeleteManyArgs>(args?: SelectSubset<T, freetimedetailtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Freetimedetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freetimedetailtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Freetimedetailtbs
     * const freetimedetailtb = await prisma.freetimedetailtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends freetimedetailtbUpdateManyArgs>(args: SelectSubset<T, freetimedetailtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Freetimedetailtb.
     * @param {freetimedetailtbUpsertArgs} args - Arguments to update or create a Freetimedetailtb.
     * @example
     * // Update or create a Freetimedetailtb
     * const freetimedetailtb = await prisma.freetimedetailtb.upsert({
     *   create: {
     *     // ... data to create a Freetimedetailtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Freetimedetailtb we want to update
     *   }
     * })
     */
    upsert<T extends freetimedetailtbUpsertArgs>(args: SelectSubset<T, freetimedetailtbUpsertArgs<ExtArgs>>): Prisma__freetimedetailtbClient<$Result.GetResult<Prisma.$freetimedetailtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Freetimedetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freetimedetailtbCountArgs} args - Arguments to filter Freetimedetailtbs to count.
     * @example
     * // Count the number of Freetimedetailtbs
     * const count = await prisma.freetimedetailtb.count({
     *   where: {
     *     // ... the filter for the Freetimedetailtbs we want to count
     *   }
     * })
    **/
    count<T extends freetimedetailtbCountArgs>(
      args?: Subset<T, freetimedetailtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreetimedetailtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Freetimedetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreetimedetailtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreetimedetailtbAggregateArgs>(args: Subset<T, FreetimedetailtbAggregateArgs>): Prisma.PrismaPromise<GetFreetimedetailtbAggregateType<T>>

    /**
     * Group by Freetimedetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {freetimedetailtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends freetimedetailtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: freetimedetailtbGroupByArgs['orderBy'] }
        : { orderBy?: freetimedetailtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, freetimedetailtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreetimedetailtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the freetimedetailtb model
   */
  readonly fields: freetimedetailtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for freetimedetailtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__freetimedetailtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the freetimedetailtb model
   */ 
  interface freetimedetailtbFieldRefs {
    readonly FreeTimeDetailId: FieldRef<"freetimedetailtb", 'Int'>
    readonly UserId: FieldRef<"freetimedetailtb", 'Int'>
    readonly FreeTime: FieldRef<"freetimedetailtb", 'Int'>
    readonly FreeMoney: FieldRef<"freetimedetailtb", 'Int'>
    readonly Type: FieldRef<"freetimedetailtb", 'Int'>
    readonly RecordDate: FieldRef<"freetimedetailtb", 'DateTime'>
    readonly VoucherId: FieldRef<"freetimedetailtb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * freetimedetailtb findUnique
   */
  export type freetimedetailtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which freetimedetailtb to fetch.
     */
    where: freetimedetailtbWhereUniqueInput
  }

  /**
   * freetimedetailtb findUniqueOrThrow
   */
  export type freetimedetailtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which freetimedetailtb to fetch.
     */
    where: freetimedetailtbWhereUniqueInput
  }

  /**
   * freetimedetailtb findFirst
   */
  export type freetimedetailtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which freetimedetailtb to fetch.
     */
    where?: freetimedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of freetimedetailtbs to fetch.
     */
    orderBy?: freetimedetailtbOrderByWithRelationInput | freetimedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for freetimedetailtbs.
     */
    cursor?: freetimedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` freetimedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` freetimedetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of freetimedetailtbs.
     */
    distinct?: FreetimedetailtbScalarFieldEnum | FreetimedetailtbScalarFieldEnum[]
  }

  /**
   * freetimedetailtb findFirstOrThrow
   */
  export type freetimedetailtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which freetimedetailtb to fetch.
     */
    where?: freetimedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of freetimedetailtbs to fetch.
     */
    orderBy?: freetimedetailtbOrderByWithRelationInput | freetimedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for freetimedetailtbs.
     */
    cursor?: freetimedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` freetimedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` freetimedetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of freetimedetailtbs.
     */
    distinct?: FreetimedetailtbScalarFieldEnum | FreetimedetailtbScalarFieldEnum[]
  }

  /**
   * freetimedetailtb findMany
   */
  export type freetimedetailtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which freetimedetailtbs to fetch.
     */
    where?: freetimedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of freetimedetailtbs to fetch.
     */
    orderBy?: freetimedetailtbOrderByWithRelationInput | freetimedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing freetimedetailtbs.
     */
    cursor?: freetimedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` freetimedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` freetimedetailtbs.
     */
    skip?: number
    distinct?: FreetimedetailtbScalarFieldEnum | FreetimedetailtbScalarFieldEnum[]
  }

  /**
   * freetimedetailtb create
   */
  export type freetimedetailtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
    /**
     * The data needed to create a freetimedetailtb.
     */
    data: XOR<freetimedetailtbCreateInput, freetimedetailtbUncheckedCreateInput>
  }

  /**
   * freetimedetailtb createMany
   */
  export type freetimedetailtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many freetimedetailtbs.
     */
    data: freetimedetailtbCreateManyInput | freetimedetailtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * freetimedetailtb update
   */
  export type freetimedetailtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
    /**
     * The data needed to update a freetimedetailtb.
     */
    data: XOR<freetimedetailtbUpdateInput, freetimedetailtbUncheckedUpdateInput>
    /**
     * Choose, which freetimedetailtb to update.
     */
    where: freetimedetailtbWhereUniqueInput
  }

  /**
   * freetimedetailtb updateMany
   */
  export type freetimedetailtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update freetimedetailtbs.
     */
    data: XOR<freetimedetailtbUpdateManyMutationInput, freetimedetailtbUncheckedUpdateManyInput>
    /**
     * Filter which freetimedetailtbs to update
     */
    where?: freetimedetailtbWhereInput
  }

  /**
   * freetimedetailtb upsert
   */
  export type freetimedetailtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
    /**
     * The filter to search for the freetimedetailtb to update in case it exists.
     */
    where: freetimedetailtbWhereUniqueInput
    /**
     * In case the freetimedetailtb found by the `where` argument doesn't exist, create a new freetimedetailtb with this data.
     */
    create: XOR<freetimedetailtbCreateInput, freetimedetailtbUncheckedCreateInput>
    /**
     * In case the freetimedetailtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<freetimedetailtbUpdateInput, freetimedetailtbUncheckedUpdateInput>
  }

  /**
   * freetimedetailtb delete
   */
  export type freetimedetailtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
    /**
     * Filter which freetimedetailtb to delete.
     */
    where: freetimedetailtbWhereUniqueInput
  }

  /**
   * freetimedetailtb deleteMany
   */
  export type freetimedetailtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which freetimedetailtbs to delete
     */
    where?: freetimedetailtbWhereInput
  }

  /**
   * freetimedetailtb without action
   */
  export type freetimedetailtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the freetimedetailtb
     */
    select?: freetimedetailtbSelect<ExtArgs> | null
  }


  /**
   * Model functiontb
   */

  export type AggregateFunctiontb = {
    _count: FunctiontbCountAggregateOutputType | null
    _avg: FunctiontbAvgAggregateOutputType | null
    _sum: FunctiontbSumAggregateOutputType | null
    _min: FunctiontbMinAggregateOutputType | null
    _max: FunctiontbMaxAggregateOutputType | null
  }

  export type FunctiontbAvgAggregateOutputType = {
    LevelFunction: number | null
    OrderOfLevel: number | null
    Active: number | null
  }

  export type FunctiontbSumAggregateOutputType = {
    LevelFunction: number | null
    OrderOfLevel: number | null
    Active: number | null
  }

  export type FunctiontbMinAggregateOutputType = {
    FunctionCode: string | null
    FunctionName: string | null
    ParentFunction: string | null
    LevelFunction: number | null
    OrderOfLevel: number | null
    Active: number | null
  }

  export type FunctiontbMaxAggregateOutputType = {
    FunctionCode: string | null
    FunctionName: string | null
    ParentFunction: string | null
    LevelFunction: number | null
    OrderOfLevel: number | null
    Active: number | null
  }

  export type FunctiontbCountAggregateOutputType = {
    FunctionCode: number
    FunctionName: number
    ParentFunction: number
    LevelFunction: number
    OrderOfLevel: number
    Active: number
    _all: number
  }


  export type FunctiontbAvgAggregateInputType = {
    LevelFunction?: true
    OrderOfLevel?: true
    Active?: true
  }

  export type FunctiontbSumAggregateInputType = {
    LevelFunction?: true
    OrderOfLevel?: true
    Active?: true
  }

  export type FunctiontbMinAggregateInputType = {
    FunctionCode?: true
    FunctionName?: true
    ParentFunction?: true
    LevelFunction?: true
    OrderOfLevel?: true
    Active?: true
  }

  export type FunctiontbMaxAggregateInputType = {
    FunctionCode?: true
    FunctionName?: true
    ParentFunction?: true
    LevelFunction?: true
    OrderOfLevel?: true
    Active?: true
  }

  export type FunctiontbCountAggregateInputType = {
    FunctionCode?: true
    FunctionName?: true
    ParentFunction?: true
    LevelFunction?: true
    OrderOfLevel?: true
    Active?: true
    _all?: true
  }

  export type FunctiontbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which functiontb to aggregate.
     */
    where?: functiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functiontbs to fetch.
     */
    orderBy?: functiontbOrderByWithRelationInput | functiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: functiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned functiontbs
    **/
    _count?: true | FunctiontbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FunctiontbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FunctiontbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunctiontbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunctiontbMaxAggregateInputType
  }

  export type GetFunctiontbAggregateType<T extends FunctiontbAggregateArgs> = {
        [P in keyof T & keyof AggregateFunctiontb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunctiontb[P]>
      : GetScalarType<T[P], AggregateFunctiontb[P]>
  }




  export type functiontbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: functiontbWhereInput
    orderBy?: functiontbOrderByWithAggregationInput | functiontbOrderByWithAggregationInput[]
    by: FunctiontbScalarFieldEnum[] | FunctiontbScalarFieldEnum
    having?: functiontbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunctiontbCountAggregateInputType | true
    _avg?: FunctiontbAvgAggregateInputType
    _sum?: FunctiontbSumAggregateInputType
    _min?: FunctiontbMinAggregateInputType
    _max?: FunctiontbMaxAggregateInputType
  }

  export type FunctiontbGroupByOutputType = {
    FunctionCode: string
    FunctionName: string
    ParentFunction: string
    LevelFunction: number
    OrderOfLevel: number
    Active: number
    _count: FunctiontbCountAggregateOutputType | null
    _avg: FunctiontbAvgAggregateOutputType | null
    _sum: FunctiontbSumAggregateOutputType | null
    _min: FunctiontbMinAggregateOutputType | null
    _max: FunctiontbMaxAggregateOutputType | null
  }

  type GetFunctiontbGroupByPayload<T extends functiontbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunctiontbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunctiontbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunctiontbGroupByOutputType[P]>
            : GetScalarType<T[P], FunctiontbGroupByOutputType[P]>
        }
      >
    >


  export type functiontbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FunctionCode?: boolean
    FunctionName?: boolean
    ParentFunction?: boolean
    LevelFunction?: boolean
    OrderOfLevel?: boolean
    Active?: boolean
  }, ExtArgs["result"]["functiontb"]>


  export type functiontbSelectScalar = {
    FunctionCode?: boolean
    FunctionName?: boolean
    ParentFunction?: boolean
    LevelFunction?: boolean
    OrderOfLevel?: boolean
    Active?: boolean
  }


  export type $functiontbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "functiontb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      FunctionCode: string
      FunctionName: string
      ParentFunction: string
      LevelFunction: number
      OrderOfLevel: number
      Active: number
    }, ExtArgs["result"]["functiontb"]>
    composites: {}
  }

  type functiontbGetPayload<S extends boolean | null | undefined | functiontbDefaultArgs> = $Result.GetResult<Prisma.$functiontbPayload, S>

  type functiontbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<functiontbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FunctiontbCountAggregateInputType | true
    }

  export interface functiontbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['functiontb'], meta: { name: 'functiontb' } }
    /**
     * Find zero or one Functiontb that matches the filter.
     * @param {functiontbFindUniqueArgs} args - Arguments to find a Functiontb
     * @example
     * // Get one Functiontb
     * const functiontb = await prisma.functiontb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends functiontbFindUniqueArgs>(args: SelectSubset<T, functiontbFindUniqueArgs<ExtArgs>>): Prisma__functiontbClient<$Result.GetResult<Prisma.$functiontbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Functiontb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {functiontbFindUniqueOrThrowArgs} args - Arguments to find a Functiontb
     * @example
     * // Get one Functiontb
     * const functiontb = await prisma.functiontb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends functiontbFindUniqueOrThrowArgs>(args: SelectSubset<T, functiontbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__functiontbClient<$Result.GetResult<Prisma.$functiontbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Functiontb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functiontbFindFirstArgs} args - Arguments to find a Functiontb
     * @example
     * // Get one Functiontb
     * const functiontb = await prisma.functiontb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends functiontbFindFirstArgs>(args?: SelectSubset<T, functiontbFindFirstArgs<ExtArgs>>): Prisma__functiontbClient<$Result.GetResult<Prisma.$functiontbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Functiontb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functiontbFindFirstOrThrowArgs} args - Arguments to find a Functiontb
     * @example
     * // Get one Functiontb
     * const functiontb = await prisma.functiontb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends functiontbFindFirstOrThrowArgs>(args?: SelectSubset<T, functiontbFindFirstOrThrowArgs<ExtArgs>>): Prisma__functiontbClient<$Result.GetResult<Prisma.$functiontbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Functiontbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functiontbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Functiontbs
     * const functiontbs = await prisma.functiontb.findMany()
     * 
     * // Get first 10 Functiontbs
     * const functiontbs = await prisma.functiontb.findMany({ take: 10 })
     * 
     * // Only select the `FunctionCode`
     * const functiontbWithFunctionCodeOnly = await prisma.functiontb.findMany({ select: { FunctionCode: true } })
     * 
     */
    findMany<T extends functiontbFindManyArgs>(args?: SelectSubset<T, functiontbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$functiontbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Functiontb.
     * @param {functiontbCreateArgs} args - Arguments to create a Functiontb.
     * @example
     * // Create one Functiontb
     * const Functiontb = await prisma.functiontb.create({
     *   data: {
     *     // ... data to create a Functiontb
     *   }
     * })
     * 
     */
    create<T extends functiontbCreateArgs>(args: SelectSubset<T, functiontbCreateArgs<ExtArgs>>): Prisma__functiontbClient<$Result.GetResult<Prisma.$functiontbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Functiontbs.
     * @param {functiontbCreateManyArgs} args - Arguments to create many Functiontbs.
     * @example
     * // Create many Functiontbs
     * const functiontb = await prisma.functiontb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends functiontbCreateManyArgs>(args?: SelectSubset<T, functiontbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Functiontb.
     * @param {functiontbDeleteArgs} args - Arguments to delete one Functiontb.
     * @example
     * // Delete one Functiontb
     * const Functiontb = await prisma.functiontb.delete({
     *   where: {
     *     // ... filter to delete one Functiontb
     *   }
     * })
     * 
     */
    delete<T extends functiontbDeleteArgs>(args: SelectSubset<T, functiontbDeleteArgs<ExtArgs>>): Prisma__functiontbClient<$Result.GetResult<Prisma.$functiontbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Functiontb.
     * @param {functiontbUpdateArgs} args - Arguments to update one Functiontb.
     * @example
     * // Update one Functiontb
     * const functiontb = await prisma.functiontb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends functiontbUpdateArgs>(args: SelectSubset<T, functiontbUpdateArgs<ExtArgs>>): Prisma__functiontbClient<$Result.GetResult<Prisma.$functiontbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Functiontbs.
     * @param {functiontbDeleteManyArgs} args - Arguments to filter Functiontbs to delete.
     * @example
     * // Delete a few Functiontbs
     * const { count } = await prisma.functiontb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends functiontbDeleteManyArgs>(args?: SelectSubset<T, functiontbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Functiontbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functiontbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Functiontbs
     * const functiontb = await prisma.functiontb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends functiontbUpdateManyArgs>(args: SelectSubset<T, functiontbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Functiontb.
     * @param {functiontbUpsertArgs} args - Arguments to update or create a Functiontb.
     * @example
     * // Update or create a Functiontb
     * const functiontb = await prisma.functiontb.upsert({
     *   create: {
     *     // ... data to create a Functiontb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Functiontb we want to update
     *   }
     * })
     */
    upsert<T extends functiontbUpsertArgs>(args: SelectSubset<T, functiontbUpsertArgs<ExtArgs>>): Prisma__functiontbClient<$Result.GetResult<Prisma.$functiontbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Functiontbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functiontbCountArgs} args - Arguments to filter Functiontbs to count.
     * @example
     * // Count the number of Functiontbs
     * const count = await prisma.functiontb.count({
     *   where: {
     *     // ... the filter for the Functiontbs we want to count
     *   }
     * })
    **/
    count<T extends functiontbCountArgs>(
      args?: Subset<T, functiontbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunctiontbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Functiontb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctiontbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunctiontbAggregateArgs>(args: Subset<T, FunctiontbAggregateArgs>): Prisma.PrismaPromise<GetFunctiontbAggregateType<T>>

    /**
     * Group by Functiontb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {functiontbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends functiontbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: functiontbGroupByArgs['orderBy'] }
        : { orderBy?: functiontbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, functiontbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunctiontbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the functiontb model
   */
  readonly fields: functiontbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for functiontb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__functiontbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the functiontb model
   */ 
  interface functiontbFieldRefs {
    readonly FunctionCode: FieldRef<"functiontb", 'String'>
    readonly FunctionName: FieldRef<"functiontb", 'String'>
    readonly ParentFunction: FieldRef<"functiontb", 'String'>
    readonly LevelFunction: FieldRef<"functiontb", 'Int'>
    readonly OrderOfLevel: FieldRef<"functiontb", 'Int'>
    readonly Active: FieldRef<"functiontb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * functiontb findUnique
   */
  export type functiontbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
    /**
     * Filter, which functiontb to fetch.
     */
    where: functiontbWhereUniqueInput
  }

  /**
   * functiontb findUniqueOrThrow
   */
  export type functiontbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
    /**
     * Filter, which functiontb to fetch.
     */
    where: functiontbWhereUniqueInput
  }

  /**
   * functiontb findFirst
   */
  export type functiontbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
    /**
     * Filter, which functiontb to fetch.
     */
    where?: functiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functiontbs to fetch.
     */
    orderBy?: functiontbOrderByWithRelationInput | functiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for functiontbs.
     */
    cursor?: functiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of functiontbs.
     */
    distinct?: FunctiontbScalarFieldEnum | FunctiontbScalarFieldEnum[]
  }

  /**
   * functiontb findFirstOrThrow
   */
  export type functiontbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
    /**
     * Filter, which functiontb to fetch.
     */
    where?: functiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functiontbs to fetch.
     */
    orderBy?: functiontbOrderByWithRelationInput | functiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for functiontbs.
     */
    cursor?: functiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of functiontbs.
     */
    distinct?: FunctiontbScalarFieldEnum | FunctiontbScalarFieldEnum[]
  }

  /**
   * functiontb findMany
   */
  export type functiontbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
    /**
     * Filter, which functiontbs to fetch.
     */
    where?: functiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of functiontbs to fetch.
     */
    orderBy?: functiontbOrderByWithRelationInput | functiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing functiontbs.
     */
    cursor?: functiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` functiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` functiontbs.
     */
    skip?: number
    distinct?: FunctiontbScalarFieldEnum | FunctiontbScalarFieldEnum[]
  }

  /**
   * functiontb create
   */
  export type functiontbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
    /**
     * The data needed to create a functiontb.
     */
    data: XOR<functiontbCreateInput, functiontbUncheckedCreateInput>
  }

  /**
   * functiontb createMany
   */
  export type functiontbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many functiontbs.
     */
    data: functiontbCreateManyInput | functiontbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * functiontb update
   */
  export type functiontbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
    /**
     * The data needed to update a functiontb.
     */
    data: XOR<functiontbUpdateInput, functiontbUncheckedUpdateInput>
    /**
     * Choose, which functiontb to update.
     */
    where: functiontbWhereUniqueInput
  }

  /**
   * functiontb updateMany
   */
  export type functiontbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update functiontbs.
     */
    data: XOR<functiontbUpdateManyMutationInput, functiontbUncheckedUpdateManyInput>
    /**
     * Filter which functiontbs to update
     */
    where?: functiontbWhereInput
  }

  /**
   * functiontb upsert
   */
  export type functiontbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
    /**
     * The filter to search for the functiontb to update in case it exists.
     */
    where: functiontbWhereUniqueInput
    /**
     * In case the functiontb found by the `where` argument doesn't exist, create a new functiontb with this data.
     */
    create: XOR<functiontbCreateInput, functiontbUncheckedCreateInput>
    /**
     * In case the functiontb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<functiontbUpdateInput, functiontbUncheckedUpdateInput>
  }

  /**
   * functiontb delete
   */
  export type functiontbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
    /**
     * Filter which functiontb to delete.
     */
    where: functiontbWhereUniqueInput
  }

  /**
   * functiontb deleteMany
   */
  export type functiontbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which functiontbs to delete
     */
    where?: functiontbWhereInput
  }

  /**
   * functiontb without action
   */
  export type functiontbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the functiontb
     */
    select?: functiontbSelect<ExtArgs> | null
  }


  /**
   * Model gamefoldertb
   */

  export type AggregateGamefoldertb = {
    _count: GamefoldertbCountAggregateOutputType | null
    _avg: GamefoldertbAvgAggregateOutputType | null
    _sum: GamefoldertbSumAggregateOutputType | null
    _min: GamefoldertbMinAggregateOutputType | null
    _max: GamefoldertbMaxAggregateOutputType | null
  }

  export type GamefoldertbAvgAggregateOutputType = {
    ID: number | null
    MachineID: number | null
    GameId: number | null
  }

  export type GamefoldertbSumAggregateOutputType = {
    ID: number | null
    MachineID: number | null
    GameId: number | null
  }

  export type GamefoldertbMinAggregateOutputType = {
    ID: number | null
    MachineID: number | null
    GameId: number | null
    GamePath: string | null
  }

  export type GamefoldertbMaxAggregateOutputType = {
    ID: number | null
    MachineID: number | null
    GameId: number | null
    GamePath: string | null
  }

  export type GamefoldertbCountAggregateOutputType = {
    ID: number
    MachineID: number
    GameId: number
    GamePath: number
    _all: number
  }


  export type GamefoldertbAvgAggregateInputType = {
    ID?: true
    MachineID?: true
    GameId?: true
  }

  export type GamefoldertbSumAggregateInputType = {
    ID?: true
    MachineID?: true
    GameId?: true
  }

  export type GamefoldertbMinAggregateInputType = {
    ID?: true
    MachineID?: true
    GameId?: true
    GamePath?: true
  }

  export type GamefoldertbMaxAggregateInputType = {
    ID?: true
    MachineID?: true
    GameId?: true
    GamePath?: true
  }

  export type GamefoldertbCountAggregateInputType = {
    ID?: true
    MachineID?: true
    GameId?: true
    GamePath?: true
    _all?: true
  }

  export type GamefoldertbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gamefoldertb to aggregate.
     */
    where?: gamefoldertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamefoldertbs to fetch.
     */
    orderBy?: gamefoldertbOrderByWithRelationInput | gamefoldertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gamefoldertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamefoldertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamefoldertbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gamefoldertbs
    **/
    _count?: true | GamefoldertbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GamefoldertbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GamefoldertbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamefoldertbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamefoldertbMaxAggregateInputType
  }

  export type GetGamefoldertbAggregateType<T extends GamefoldertbAggregateArgs> = {
        [P in keyof T & keyof AggregateGamefoldertb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGamefoldertb[P]>
      : GetScalarType<T[P], AggregateGamefoldertb[P]>
  }




  export type gamefoldertbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamefoldertbWhereInput
    orderBy?: gamefoldertbOrderByWithAggregationInput | gamefoldertbOrderByWithAggregationInput[]
    by: GamefoldertbScalarFieldEnum[] | GamefoldertbScalarFieldEnum
    having?: gamefoldertbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamefoldertbCountAggregateInputType | true
    _avg?: GamefoldertbAvgAggregateInputType
    _sum?: GamefoldertbSumAggregateInputType
    _min?: GamefoldertbMinAggregateInputType
    _max?: GamefoldertbMaxAggregateInputType
  }

  export type GamefoldertbGroupByOutputType = {
    ID: number
    MachineID: number
    GameId: number
    GamePath: string
    _count: GamefoldertbCountAggregateOutputType | null
    _avg: GamefoldertbAvgAggregateOutputType | null
    _sum: GamefoldertbSumAggregateOutputType | null
    _min: GamefoldertbMinAggregateOutputType | null
    _max: GamefoldertbMaxAggregateOutputType | null
  }

  type GetGamefoldertbGroupByPayload<T extends gamefoldertbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamefoldertbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamefoldertbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamefoldertbGroupByOutputType[P]>
            : GetScalarType<T[P], GamefoldertbGroupByOutputType[P]>
        }
      >
    >


  export type gamefoldertbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    MachineID?: boolean
    GameId?: boolean
    GamePath?: boolean
  }, ExtArgs["result"]["gamefoldertb"]>


  export type gamefoldertbSelectScalar = {
    ID?: boolean
    MachineID?: boolean
    GameId?: boolean
    GamePath?: boolean
  }


  export type $gamefoldertbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gamefoldertb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      MachineID: number
      GameId: number
      GamePath: string
    }, ExtArgs["result"]["gamefoldertb"]>
    composites: {}
  }

  type gamefoldertbGetPayload<S extends boolean | null | undefined | gamefoldertbDefaultArgs> = $Result.GetResult<Prisma.$gamefoldertbPayload, S>

  type gamefoldertbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<gamefoldertbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GamefoldertbCountAggregateInputType | true
    }

  export interface gamefoldertbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gamefoldertb'], meta: { name: 'gamefoldertb' } }
    /**
     * Find zero or one Gamefoldertb that matches the filter.
     * @param {gamefoldertbFindUniqueArgs} args - Arguments to find a Gamefoldertb
     * @example
     * // Get one Gamefoldertb
     * const gamefoldertb = await prisma.gamefoldertb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gamefoldertbFindUniqueArgs>(args: SelectSubset<T, gamefoldertbFindUniqueArgs<ExtArgs>>): Prisma__gamefoldertbClient<$Result.GetResult<Prisma.$gamefoldertbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gamefoldertb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {gamefoldertbFindUniqueOrThrowArgs} args - Arguments to find a Gamefoldertb
     * @example
     * // Get one Gamefoldertb
     * const gamefoldertb = await prisma.gamefoldertb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gamefoldertbFindUniqueOrThrowArgs>(args: SelectSubset<T, gamefoldertbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gamefoldertbClient<$Result.GetResult<Prisma.$gamefoldertbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gamefoldertb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamefoldertbFindFirstArgs} args - Arguments to find a Gamefoldertb
     * @example
     * // Get one Gamefoldertb
     * const gamefoldertb = await prisma.gamefoldertb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gamefoldertbFindFirstArgs>(args?: SelectSubset<T, gamefoldertbFindFirstArgs<ExtArgs>>): Prisma__gamefoldertbClient<$Result.GetResult<Prisma.$gamefoldertbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gamefoldertb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamefoldertbFindFirstOrThrowArgs} args - Arguments to find a Gamefoldertb
     * @example
     * // Get one Gamefoldertb
     * const gamefoldertb = await prisma.gamefoldertb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gamefoldertbFindFirstOrThrowArgs>(args?: SelectSubset<T, gamefoldertbFindFirstOrThrowArgs<ExtArgs>>): Prisma__gamefoldertbClient<$Result.GetResult<Prisma.$gamefoldertbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gamefoldertbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamefoldertbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gamefoldertbs
     * const gamefoldertbs = await prisma.gamefoldertb.findMany()
     * 
     * // Get first 10 Gamefoldertbs
     * const gamefoldertbs = await prisma.gamefoldertb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const gamefoldertbWithIDOnly = await prisma.gamefoldertb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends gamefoldertbFindManyArgs>(args?: SelectSubset<T, gamefoldertbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamefoldertbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gamefoldertb.
     * @param {gamefoldertbCreateArgs} args - Arguments to create a Gamefoldertb.
     * @example
     * // Create one Gamefoldertb
     * const Gamefoldertb = await prisma.gamefoldertb.create({
     *   data: {
     *     // ... data to create a Gamefoldertb
     *   }
     * })
     * 
     */
    create<T extends gamefoldertbCreateArgs>(args: SelectSubset<T, gamefoldertbCreateArgs<ExtArgs>>): Prisma__gamefoldertbClient<$Result.GetResult<Prisma.$gamefoldertbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gamefoldertbs.
     * @param {gamefoldertbCreateManyArgs} args - Arguments to create many Gamefoldertbs.
     * @example
     * // Create many Gamefoldertbs
     * const gamefoldertb = await prisma.gamefoldertb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gamefoldertbCreateManyArgs>(args?: SelectSubset<T, gamefoldertbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gamefoldertb.
     * @param {gamefoldertbDeleteArgs} args - Arguments to delete one Gamefoldertb.
     * @example
     * // Delete one Gamefoldertb
     * const Gamefoldertb = await prisma.gamefoldertb.delete({
     *   where: {
     *     // ... filter to delete one Gamefoldertb
     *   }
     * })
     * 
     */
    delete<T extends gamefoldertbDeleteArgs>(args: SelectSubset<T, gamefoldertbDeleteArgs<ExtArgs>>): Prisma__gamefoldertbClient<$Result.GetResult<Prisma.$gamefoldertbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gamefoldertb.
     * @param {gamefoldertbUpdateArgs} args - Arguments to update one Gamefoldertb.
     * @example
     * // Update one Gamefoldertb
     * const gamefoldertb = await prisma.gamefoldertb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gamefoldertbUpdateArgs>(args: SelectSubset<T, gamefoldertbUpdateArgs<ExtArgs>>): Prisma__gamefoldertbClient<$Result.GetResult<Prisma.$gamefoldertbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gamefoldertbs.
     * @param {gamefoldertbDeleteManyArgs} args - Arguments to filter Gamefoldertbs to delete.
     * @example
     * // Delete a few Gamefoldertbs
     * const { count } = await prisma.gamefoldertb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gamefoldertbDeleteManyArgs>(args?: SelectSubset<T, gamefoldertbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gamefoldertbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamefoldertbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gamefoldertbs
     * const gamefoldertb = await prisma.gamefoldertb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gamefoldertbUpdateManyArgs>(args: SelectSubset<T, gamefoldertbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gamefoldertb.
     * @param {gamefoldertbUpsertArgs} args - Arguments to update or create a Gamefoldertb.
     * @example
     * // Update or create a Gamefoldertb
     * const gamefoldertb = await prisma.gamefoldertb.upsert({
     *   create: {
     *     // ... data to create a Gamefoldertb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gamefoldertb we want to update
     *   }
     * })
     */
    upsert<T extends gamefoldertbUpsertArgs>(args: SelectSubset<T, gamefoldertbUpsertArgs<ExtArgs>>): Prisma__gamefoldertbClient<$Result.GetResult<Prisma.$gamefoldertbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gamefoldertbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamefoldertbCountArgs} args - Arguments to filter Gamefoldertbs to count.
     * @example
     * // Count the number of Gamefoldertbs
     * const count = await prisma.gamefoldertb.count({
     *   where: {
     *     // ... the filter for the Gamefoldertbs we want to count
     *   }
     * })
    **/
    count<T extends gamefoldertbCountArgs>(
      args?: Subset<T, gamefoldertbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamefoldertbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gamefoldertb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamefoldertbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamefoldertbAggregateArgs>(args: Subset<T, GamefoldertbAggregateArgs>): Prisma.PrismaPromise<GetGamefoldertbAggregateType<T>>

    /**
     * Group by Gamefoldertb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamefoldertbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gamefoldertbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gamefoldertbGroupByArgs['orderBy'] }
        : { orderBy?: gamefoldertbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gamefoldertbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamefoldertbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gamefoldertb model
   */
  readonly fields: gamefoldertbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gamefoldertb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gamefoldertbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gamefoldertb model
   */ 
  interface gamefoldertbFieldRefs {
    readonly ID: FieldRef<"gamefoldertb", 'Int'>
    readonly MachineID: FieldRef<"gamefoldertb", 'Int'>
    readonly GameId: FieldRef<"gamefoldertb", 'Int'>
    readonly GamePath: FieldRef<"gamefoldertb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * gamefoldertb findUnique
   */
  export type gamefoldertbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
    /**
     * Filter, which gamefoldertb to fetch.
     */
    where: gamefoldertbWhereUniqueInput
  }

  /**
   * gamefoldertb findUniqueOrThrow
   */
  export type gamefoldertbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
    /**
     * Filter, which gamefoldertb to fetch.
     */
    where: gamefoldertbWhereUniqueInput
  }

  /**
   * gamefoldertb findFirst
   */
  export type gamefoldertbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
    /**
     * Filter, which gamefoldertb to fetch.
     */
    where?: gamefoldertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamefoldertbs to fetch.
     */
    orderBy?: gamefoldertbOrderByWithRelationInput | gamefoldertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gamefoldertbs.
     */
    cursor?: gamefoldertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamefoldertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamefoldertbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gamefoldertbs.
     */
    distinct?: GamefoldertbScalarFieldEnum | GamefoldertbScalarFieldEnum[]
  }

  /**
   * gamefoldertb findFirstOrThrow
   */
  export type gamefoldertbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
    /**
     * Filter, which gamefoldertb to fetch.
     */
    where?: gamefoldertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamefoldertbs to fetch.
     */
    orderBy?: gamefoldertbOrderByWithRelationInput | gamefoldertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gamefoldertbs.
     */
    cursor?: gamefoldertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamefoldertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamefoldertbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gamefoldertbs.
     */
    distinct?: GamefoldertbScalarFieldEnum | GamefoldertbScalarFieldEnum[]
  }

  /**
   * gamefoldertb findMany
   */
  export type gamefoldertbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
    /**
     * Filter, which gamefoldertbs to fetch.
     */
    where?: gamefoldertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamefoldertbs to fetch.
     */
    orderBy?: gamefoldertbOrderByWithRelationInput | gamefoldertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gamefoldertbs.
     */
    cursor?: gamefoldertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamefoldertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamefoldertbs.
     */
    skip?: number
    distinct?: GamefoldertbScalarFieldEnum | GamefoldertbScalarFieldEnum[]
  }

  /**
   * gamefoldertb create
   */
  export type gamefoldertbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
    /**
     * The data needed to create a gamefoldertb.
     */
    data?: XOR<gamefoldertbCreateInput, gamefoldertbUncheckedCreateInput>
  }

  /**
   * gamefoldertb createMany
   */
  export type gamefoldertbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gamefoldertbs.
     */
    data: gamefoldertbCreateManyInput | gamefoldertbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gamefoldertb update
   */
  export type gamefoldertbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
    /**
     * The data needed to update a gamefoldertb.
     */
    data: XOR<gamefoldertbUpdateInput, gamefoldertbUncheckedUpdateInput>
    /**
     * Choose, which gamefoldertb to update.
     */
    where: gamefoldertbWhereUniqueInput
  }

  /**
   * gamefoldertb updateMany
   */
  export type gamefoldertbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gamefoldertbs.
     */
    data: XOR<gamefoldertbUpdateManyMutationInput, gamefoldertbUncheckedUpdateManyInput>
    /**
     * Filter which gamefoldertbs to update
     */
    where?: gamefoldertbWhereInput
  }

  /**
   * gamefoldertb upsert
   */
  export type gamefoldertbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
    /**
     * The filter to search for the gamefoldertb to update in case it exists.
     */
    where: gamefoldertbWhereUniqueInput
    /**
     * In case the gamefoldertb found by the `where` argument doesn't exist, create a new gamefoldertb with this data.
     */
    create: XOR<gamefoldertbCreateInput, gamefoldertbUncheckedCreateInput>
    /**
     * In case the gamefoldertb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gamefoldertbUpdateInput, gamefoldertbUncheckedUpdateInput>
  }

  /**
   * gamefoldertb delete
   */
  export type gamefoldertbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
    /**
     * Filter which gamefoldertb to delete.
     */
    where: gamefoldertbWhereUniqueInput
  }

  /**
   * gamefoldertb deleteMany
   */
  export type gamefoldertbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gamefoldertbs to delete
     */
    where?: gamefoldertbWhereInput
  }

  /**
   * gamefoldertb without action
   */
  export type gamefoldertbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamefoldertb
     */
    select?: gamefoldertbSelect<ExtArgs> | null
  }


  /**
   * Model gamelisttb
   */

  export type AggregateGamelisttb = {
    _count: GamelisttbCountAggregateOutputType | null
    _avg: GamelisttbAvgAggregateOutputType | null
    _sum: GamelisttbSumAggregateOutputType | null
    _min: GamelisttbMinAggregateOutputType | null
    _max: GamelisttbMaxAggregateOutputType | null
  }

  export type GamelisttbAvgAggregateOutputType = {
    GameId: number | null
    Active: number | null
    Type: number | null
    SetupType: number | null
    Checked: number | null
  }

  export type GamelisttbSumAggregateOutputType = {
    GameId: number | null
    Active: number | null
    Type: number | null
    SetupType: number | null
    Checked: number | null
  }

  export type GamelisttbMinAggregateOutputType = {
    GameId: number | null
    GameAlias: string | null
    GameName: string | null
    GameLauncher: string | null
    Active: number | null
    Protocol: string | null
    URL: string | null
    Checksum: string | null
    PublishDate: Date | null
    TorrentFile: string | null
    SetupFile: string | null
    ShortcutPath: string | null
    Type: number | null
    Size: string | null
    SetupType: number | null
    ConfigFile: string | null
    Checked: number | null
  }

  export type GamelisttbMaxAggregateOutputType = {
    GameId: number | null
    GameAlias: string | null
    GameName: string | null
    GameLauncher: string | null
    Active: number | null
    Protocol: string | null
    URL: string | null
    Checksum: string | null
    PublishDate: Date | null
    TorrentFile: string | null
    SetupFile: string | null
    ShortcutPath: string | null
    Type: number | null
    Size: string | null
    SetupType: number | null
    ConfigFile: string | null
    Checked: number | null
  }

  export type GamelisttbCountAggregateOutputType = {
    GameId: number
    GameAlias: number
    GameName: number
    GameLauncher: number
    Active: number
    Protocol: number
    URL: number
    Checksum: number
    PublishDate: number
    TorrentFile: number
    SetupFile: number
    ShortcutPath: number
    Type: number
    Size: number
    SetupType: number
    ConfigFile: number
    Checked: number
    _all: number
  }


  export type GamelisttbAvgAggregateInputType = {
    GameId?: true
    Active?: true
    Type?: true
    SetupType?: true
    Checked?: true
  }

  export type GamelisttbSumAggregateInputType = {
    GameId?: true
    Active?: true
    Type?: true
    SetupType?: true
    Checked?: true
  }

  export type GamelisttbMinAggregateInputType = {
    GameId?: true
    GameAlias?: true
    GameName?: true
    GameLauncher?: true
    Active?: true
    Protocol?: true
    URL?: true
    Checksum?: true
    PublishDate?: true
    TorrentFile?: true
    SetupFile?: true
    ShortcutPath?: true
    Type?: true
    Size?: true
    SetupType?: true
    ConfigFile?: true
    Checked?: true
  }

  export type GamelisttbMaxAggregateInputType = {
    GameId?: true
    GameAlias?: true
    GameName?: true
    GameLauncher?: true
    Active?: true
    Protocol?: true
    URL?: true
    Checksum?: true
    PublishDate?: true
    TorrentFile?: true
    SetupFile?: true
    ShortcutPath?: true
    Type?: true
    Size?: true
    SetupType?: true
    ConfigFile?: true
    Checked?: true
  }

  export type GamelisttbCountAggregateInputType = {
    GameId?: true
    GameAlias?: true
    GameName?: true
    GameLauncher?: true
    Active?: true
    Protocol?: true
    URL?: true
    Checksum?: true
    PublishDate?: true
    TorrentFile?: true
    SetupFile?: true
    ShortcutPath?: true
    Type?: true
    Size?: true
    SetupType?: true
    ConfigFile?: true
    Checked?: true
    _all?: true
  }

  export type GamelisttbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gamelisttb to aggregate.
     */
    where?: gamelisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamelisttbs to fetch.
     */
    orderBy?: gamelisttbOrderByWithRelationInput | gamelisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: gamelisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamelisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamelisttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned gamelisttbs
    **/
    _count?: true | GamelisttbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GamelisttbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GamelisttbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamelisttbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamelisttbMaxAggregateInputType
  }

  export type GetGamelisttbAggregateType<T extends GamelisttbAggregateArgs> = {
        [P in keyof T & keyof AggregateGamelisttb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGamelisttb[P]>
      : GetScalarType<T[P], AggregateGamelisttb[P]>
  }




  export type gamelisttbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: gamelisttbWhereInput
    orderBy?: gamelisttbOrderByWithAggregationInput | gamelisttbOrderByWithAggregationInput[]
    by: GamelisttbScalarFieldEnum[] | GamelisttbScalarFieldEnum
    having?: gamelisttbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamelisttbCountAggregateInputType | true
    _avg?: GamelisttbAvgAggregateInputType
    _sum?: GamelisttbSumAggregateInputType
    _min?: GamelisttbMinAggregateInputType
    _max?: GamelisttbMaxAggregateInputType
  }

  export type GamelisttbGroupByOutputType = {
    GameId: number
    GameAlias: string
    GameName: string
    GameLauncher: string
    Active: number
    Protocol: string
    URL: string
    Checksum: string
    PublishDate: Date
    TorrentFile: string
    SetupFile: string
    ShortcutPath: string
    Type: number
    Size: string
    SetupType: number
    ConfigFile: string
    Checked: number
    _count: GamelisttbCountAggregateOutputType | null
    _avg: GamelisttbAvgAggregateOutputType | null
    _sum: GamelisttbSumAggregateOutputType | null
    _min: GamelisttbMinAggregateOutputType | null
    _max: GamelisttbMaxAggregateOutputType | null
  }

  type GetGamelisttbGroupByPayload<T extends gamelisttbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamelisttbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamelisttbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamelisttbGroupByOutputType[P]>
            : GetScalarType<T[P], GamelisttbGroupByOutputType[P]>
        }
      >
    >


  export type gamelisttbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    GameId?: boolean
    GameAlias?: boolean
    GameName?: boolean
    GameLauncher?: boolean
    Active?: boolean
    Protocol?: boolean
    URL?: boolean
    Checksum?: boolean
    PublishDate?: boolean
    TorrentFile?: boolean
    SetupFile?: boolean
    ShortcutPath?: boolean
    Type?: boolean
    Size?: boolean
    SetupType?: boolean
    ConfigFile?: boolean
    Checked?: boolean
  }, ExtArgs["result"]["gamelisttb"]>


  export type gamelisttbSelectScalar = {
    GameId?: boolean
    GameAlias?: boolean
    GameName?: boolean
    GameLauncher?: boolean
    Active?: boolean
    Protocol?: boolean
    URL?: boolean
    Checksum?: boolean
    PublishDate?: boolean
    TorrentFile?: boolean
    SetupFile?: boolean
    ShortcutPath?: boolean
    Type?: boolean
    Size?: boolean
    SetupType?: boolean
    ConfigFile?: boolean
    Checked?: boolean
  }


  export type $gamelisttbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "gamelisttb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      GameId: number
      GameAlias: string
      GameName: string
      GameLauncher: string
      Active: number
      Protocol: string
      URL: string
      Checksum: string
      PublishDate: Date
      TorrentFile: string
      SetupFile: string
      ShortcutPath: string
      Type: number
      Size: string
      SetupType: number
      ConfigFile: string
      Checked: number
    }, ExtArgs["result"]["gamelisttb"]>
    composites: {}
  }

  type gamelisttbGetPayload<S extends boolean | null | undefined | gamelisttbDefaultArgs> = $Result.GetResult<Prisma.$gamelisttbPayload, S>

  type gamelisttbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<gamelisttbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GamelisttbCountAggregateInputType | true
    }

  export interface gamelisttbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['gamelisttb'], meta: { name: 'gamelisttb' } }
    /**
     * Find zero or one Gamelisttb that matches the filter.
     * @param {gamelisttbFindUniqueArgs} args - Arguments to find a Gamelisttb
     * @example
     * // Get one Gamelisttb
     * const gamelisttb = await prisma.gamelisttb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends gamelisttbFindUniqueArgs>(args: SelectSubset<T, gamelisttbFindUniqueArgs<ExtArgs>>): Prisma__gamelisttbClient<$Result.GetResult<Prisma.$gamelisttbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gamelisttb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {gamelisttbFindUniqueOrThrowArgs} args - Arguments to find a Gamelisttb
     * @example
     * // Get one Gamelisttb
     * const gamelisttb = await prisma.gamelisttb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends gamelisttbFindUniqueOrThrowArgs>(args: SelectSubset<T, gamelisttbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__gamelisttbClient<$Result.GetResult<Prisma.$gamelisttbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gamelisttb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamelisttbFindFirstArgs} args - Arguments to find a Gamelisttb
     * @example
     * // Get one Gamelisttb
     * const gamelisttb = await prisma.gamelisttb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends gamelisttbFindFirstArgs>(args?: SelectSubset<T, gamelisttbFindFirstArgs<ExtArgs>>): Prisma__gamelisttbClient<$Result.GetResult<Prisma.$gamelisttbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gamelisttb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamelisttbFindFirstOrThrowArgs} args - Arguments to find a Gamelisttb
     * @example
     * // Get one Gamelisttb
     * const gamelisttb = await prisma.gamelisttb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends gamelisttbFindFirstOrThrowArgs>(args?: SelectSubset<T, gamelisttbFindFirstOrThrowArgs<ExtArgs>>): Prisma__gamelisttbClient<$Result.GetResult<Prisma.$gamelisttbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gamelisttbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamelisttbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gamelisttbs
     * const gamelisttbs = await prisma.gamelisttb.findMany()
     * 
     * // Get first 10 Gamelisttbs
     * const gamelisttbs = await prisma.gamelisttb.findMany({ take: 10 })
     * 
     * // Only select the `GameId`
     * const gamelisttbWithGameIdOnly = await prisma.gamelisttb.findMany({ select: { GameId: true } })
     * 
     */
    findMany<T extends gamelisttbFindManyArgs>(args?: SelectSubset<T, gamelisttbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$gamelisttbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gamelisttb.
     * @param {gamelisttbCreateArgs} args - Arguments to create a Gamelisttb.
     * @example
     * // Create one Gamelisttb
     * const Gamelisttb = await prisma.gamelisttb.create({
     *   data: {
     *     // ... data to create a Gamelisttb
     *   }
     * })
     * 
     */
    create<T extends gamelisttbCreateArgs>(args: SelectSubset<T, gamelisttbCreateArgs<ExtArgs>>): Prisma__gamelisttbClient<$Result.GetResult<Prisma.$gamelisttbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gamelisttbs.
     * @param {gamelisttbCreateManyArgs} args - Arguments to create many Gamelisttbs.
     * @example
     * // Create many Gamelisttbs
     * const gamelisttb = await prisma.gamelisttb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends gamelisttbCreateManyArgs>(args?: SelectSubset<T, gamelisttbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gamelisttb.
     * @param {gamelisttbDeleteArgs} args - Arguments to delete one Gamelisttb.
     * @example
     * // Delete one Gamelisttb
     * const Gamelisttb = await prisma.gamelisttb.delete({
     *   where: {
     *     // ... filter to delete one Gamelisttb
     *   }
     * })
     * 
     */
    delete<T extends gamelisttbDeleteArgs>(args: SelectSubset<T, gamelisttbDeleteArgs<ExtArgs>>): Prisma__gamelisttbClient<$Result.GetResult<Prisma.$gamelisttbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gamelisttb.
     * @param {gamelisttbUpdateArgs} args - Arguments to update one Gamelisttb.
     * @example
     * // Update one Gamelisttb
     * const gamelisttb = await prisma.gamelisttb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends gamelisttbUpdateArgs>(args: SelectSubset<T, gamelisttbUpdateArgs<ExtArgs>>): Prisma__gamelisttbClient<$Result.GetResult<Prisma.$gamelisttbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gamelisttbs.
     * @param {gamelisttbDeleteManyArgs} args - Arguments to filter Gamelisttbs to delete.
     * @example
     * // Delete a few Gamelisttbs
     * const { count } = await prisma.gamelisttb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends gamelisttbDeleteManyArgs>(args?: SelectSubset<T, gamelisttbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gamelisttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamelisttbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gamelisttbs
     * const gamelisttb = await prisma.gamelisttb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends gamelisttbUpdateManyArgs>(args: SelectSubset<T, gamelisttbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gamelisttb.
     * @param {gamelisttbUpsertArgs} args - Arguments to update or create a Gamelisttb.
     * @example
     * // Update or create a Gamelisttb
     * const gamelisttb = await prisma.gamelisttb.upsert({
     *   create: {
     *     // ... data to create a Gamelisttb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gamelisttb we want to update
     *   }
     * })
     */
    upsert<T extends gamelisttbUpsertArgs>(args: SelectSubset<T, gamelisttbUpsertArgs<ExtArgs>>): Prisma__gamelisttbClient<$Result.GetResult<Prisma.$gamelisttbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gamelisttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamelisttbCountArgs} args - Arguments to filter Gamelisttbs to count.
     * @example
     * // Count the number of Gamelisttbs
     * const count = await prisma.gamelisttb.count({
     *   where: {
     *     // ... the filter for the Gamelisttbs we want to count
     *   }
     * })
    **/
    count<T extends gamelisttbCountArgs>(
      args?: Subset<T, gamelisttbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamelisttbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gamelisttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamelisttbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamelisttbAggregateArgs>(args: Subset<T, GamelisttbAggregateArgs>): Prisma.PrismaPromise<GetGamelisttbAggregateType<T>>

    /**
     * Group by Gamelisttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {gamelisttbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends gamelisttbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: gamelisttbGroupByArgs['orderBy'] }
        : { orderBy?: gamelisttbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, gamelisttbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamelisttbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the gamelisttb model
   */
  readonly fields: gamelisttbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for gamelisttb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__gamelisttbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the gamelisttb model
   */ 
  interface gamelisttbFieldRefs {
    readonly GameId: FieldRef<"gamelisttb", 'Int'>
    readonly GameAlias: FieldRef<"gamelisttb", 'String'>
    readonly GameName: FieldRef<"gamelisttb", 'String'>
    readonly GameLauncher: FieldRef<"gamelisttb", 'String'>
    readonly Active: FieldRef<"gamelisttb", 'Int'>
    readonly Protocol: FieldRef<"gamelisttb", 'String'>
    readonly URL: FieldRef<"gamelisttb", 'String'>
    readonly Checksum: FieldRef<"gamelisttb", 'String'>
    readonly PublishDate: FieldRef<"gamelisttb", 'DateTime'>
    readonly TorrentFile: FieldRef<"gamelisttb", 'String'>
    readonly SetupFile: FieldRef<"gamelisttb", 'String'>
    readonly ShortcutPath: FieldRef<"gamelisttb", 'String'>
    readonly Type: FieldRef<"gamelisttb", 'Int'>
    readonly Size: FieldRef<"gamelisttb", 'String'>
    readonly SetupType: FieldRef<"gamelisttb", 'Int'>
    readonly ConfigFile: FieldRef<"gamelisttb", 'String'>
    readonly Checked: FieldRef<"gamelisttb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * gamelisttb findUnique
   */
  export type gamelisttbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
    /**
     * Filter, which gamelisttb to fetch.
     */
    where: gamelisttbWhereUniqueInput
  }

  /**
   * gamelisttb findUniqueOrThrow
   */
  export type gamelisttbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
    /**
     * Filter, which gamelisttb to fetch.
     */
    where: gamelisttbWhereUniqueInput
  }

  /**
   * gamelisttb findFirst
   */
  export type gamelisttbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
    /**
     * Filter, which gamelisttb to fetch.
     */
    where?: gamelisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamelisttbs to fetch.
     */
    orderBy?: gamelisttbOrderByWithRelationInput | gamelisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gamelisttbs.
     */
    cursor?: gamelisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamelisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamelisttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gamelisttbs.
     */
    distinct?: GamelisttbScalarFieldEnum | GamelisttbScalarFieldEnum[]
  }

  /**
   * gamelisttb findFirstOrThrow
   */
  export type gamelisttbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
    /**
     * Filter, which gamelisttb to fetch.
     */
    where?: gamelisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamelisttbs to fetch.
     */
    orderBy?: gamelisttbOrderByWithRelationInput | gamelisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for gamelisttbs.
     */
    cursor?: gamelisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamelisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamelisttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of gamelisttbs.
     */
    distinct?: GamelisttbScalarFieldEnum | GamelisttbScalarFieldEnum[]
  }

  /**
   * gamelisttb findMany
   */
  export type gamelisttbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
    /**
     * Filter, which gamelisttbs to fetch.
     */
    where?: gamelisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of gamelisttbs to fetch.
     */
    orderBy?: gamelisttbOrderByWithRelationInput | gamelisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing gamelisttbs.
     */
    cursor?: gamelisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` gamelisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` gamelisttbs.
     */
    skip?: number
    distinct?: GamelisttbScalarFieldEnum | GamelisttbScalarFieldEnum[]
  }

  /**
   * gamelisttb create
   */
  export type gamelisttbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
    /**
     * The data needed to create a gamelisttb.
     */
    data?: XOR<gamelisttbCreateInput, gamelisttbUncheckedCreateInput>
  }

  /**
   * gamelisttb createMany
   */
  export type gamelisttbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many gamelisttbs.
     */
    data: gamelisttbCreateManyInput | gamelisttbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * gamelisttb update
   */
  export type gamelisttbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
    /**
     * The data needed to update a gamelisttb.
     */
    data: XOR<gamelisttbUpdateInput, gamelisttbUncheckedUpdateInput>
    /**
     * Choose, which gamelisttb to update.
     */
    where: gamelisttbWhereUniqueInput
  }

  /**
   * gamelisttb updateMany
   */
  export type gamelisttbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update gamelisttbs.
     */
    data: XOR<gamelisttbUpdateManyMutationInput, gamelisttbUncheckedUpdateManyInput>
    /**
     * Filter which gamelisttbs to update
     */
    where?: gamelisttbWhereInput
  }

  /**
   * gamelisttb upsert
   */
  export type gamelisttbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
    /**
     * The filter to search for the gamelisttb to update in case it exists.
     */
    where: gamelisttbWhereUniqueInput
    /**
     * In case the gamelisttb found by the `where` argument doesn't exist, create a new gamelisttb with this data.
     */
    create: XOR<gamelisttbCreateInput, gamelisttbUncheckedCreateInput>
    /**
     * In case the gamelisttb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<gamelisttbUpdateInput, gamelisttbUncheckedUpdateInput>
  }

  /**
   * gamelisttb delete
   */
  export type gamelisttbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
    /**
     * Filter which gamelisttb to delete.
     */
    where: gamelisttbWhereUniqueInput
  }

  /**
   * gamelisttb deleteMany
   */
  export type gamelisttbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which gamelisttbs to delete
     */
    where?: gamelisttbWhereInput
  }

  /**
   * gamelisttb without action
   */
  export type gamelisttbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the gamelisttb
     */
    select?: gamelisttbSelect<ExtArgs> | null
  }


  /**
   * Model hptb
   */

  export type AggregateHptb = {
    _count: HptbCountAggregateOutputType | null
    _avg: HptbAvgAggregateOutputType | null
    _sum: HptbSumAggregateOutputType | null
    _min: HptbMinAggregateOutputType | null
    _max: HptbMaxAggregateOutputType | null
  }

  export type HptbAvgAggregateOutputType = {
    ID: number | null
  }

  export type HptbSumAggregateOutputType = {
    ID: number | null
  }

  export type HptbMinAggregateOutputType = {
    ID: number | null
    MachineName: string | null
    IEHP: string | null
    FFHP: string | null
    GCHP: string | null
    LastUpdateDate: Date | null
  }

  export type HptbMaxAggregateOutputType = {
    ID: number | null
    MachineName: string | null
    IEHP: string | null
    FFHP: string | null
    GCHP: string | null
    LastUpdateDate: Date | null
  }

  export type HptbCountAggregateOutputType = {
    ID: number
    MachineName: number
    IEHP: number
    FFHP: number
    GCHP: number
    LastUpdateDate: number
    _all: number
  }


  export type HptbAvgAggregateInputType = {
    ID?: true
  }

  export type HptbSumAggregateInputType = {
    ID?: true
  }

  export type HptbMinAggregateInputType = {
    ID?: true
    MachineName?: true
    IEHP?: true
    FFHP?: true
    GCHP?: true
    LastUpdateDate?: true
  }

  export type HptbMaxAggregateInputType = {
    ID?: true
    MachineName?: true
    IEHP?: true
    FFHP?: true
    GCHP?: true
    LastUpdateDate?: true
  }

  export type HptbCountAggregateInputType = {
    ID?: true
    MachineName?: true
    IEHP?: true
    FFHP?: true
    GCHP?: true
    LastUpdateDate?: true
    _all?: true
  }

  export type HptbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hptb to aggregate.
     */
    where?: hptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hptbs to fetch.
     */
    orderBy?: hptbOrderByWithRelationInput | hptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hptbs
    **/
    _count?: true | HptbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HptbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HptbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HptbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HptbMaxAggregateInputType
  }

  export type GetHptbAggregateType<T extends HptbAggregateArgs> = {
        [P in keyof T & keyof AggregateHptb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHptb[P]>
      : GetScalarType<T[P], AggregateHptb[P]>
  }




  export type hptbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hptbWhereInput
    orderBy?: hptbOrderByWithAggregationInput | hptbOrderByWithAggregationInput[]
    by: HptbScalarFieldEnum[] | HptbScalarFieldEnum
    having?: hptbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HptbCountAggregateInputType | true
    _avg?: HptbAvgAggregateInputType
    _sum?: HptbSumAggregateInputType
    _min?: HptbMinAggregateInputType
    _max?: HptbMaxAggregateInputType
  }

  export type HptbGroupByOutputType = {
    ID: number
    MachineName: string
    IEHP: string
    FFHP: string
    GCHP: string
    LastUpdateDate: Date
    _count: HptbCountAggregateOutputType | null
    _avg: HptbAvgAggregateOutputType | null
    _sum: HptbSumAggregateOutputType | null
    _min: HptbMinAggregateOutputType | null
    _max: HptbMaxAggregateOutputType | null
  }

  type GetHptbGroupByPayload<T extends hptbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HptbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HptbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HptbGroupByOutputType[P]>
            : GetScalarType<T[P], HptbGroupByOutputType[P]>
        }
      >
    >


  export type hptbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    MachineName?: boolean
    IEHP?: boolean
    FFHP?: boolean
    GCHP?: boolean
    LastUpdateDate?: boolean
  }, ExtArgs["result"]["hptb"]>


  export type hptbSelectScalar = {
    ID?: boolean
    MachineName?: boolean
    IEHP?: boolean
    FFHP?: boolean
    GCHP?: boolean
    LastUpdateDate?: boolean
  }


  export type $hptbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hptb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      MachineName: string
      IEHP: string
      FFHP: string
      GCHP: string
      LastUpdateDate: Date
    }, ExtArgs["result"]["hptb"]>
    composites: {}
  }

  type hptbGetPayload<S extends boolean | null | undefined | hptbDefaultArgs> = $Result.GetResult<Prisma.$hptbPayload, S>

  type hptbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<hptbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HptbCountAggregateInputType | true
    }

  export interface hptbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hptb'], meta: { name: 'hptb' } }
    /**
     * Find zero or one Hptb that matches the filter.
     * @param {hptbFindUniqueArgs} args - Arguments to find a Hptb
     * @example
     * // Get one Hptb
     * const hptb = await prisma.hptb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hptbFindUniqueArgs>(args: SelectSubset<T, hptbFindUniqueArgs<ExtArgs>>): Prisma__hptbClient<$Result.GetResult<Prisma.$hptbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hptb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {hptbFindUniqueOrThrowArgs} args - Arguments to find a Hptb
     * @example
     * // Get one Hptb
     * const hptb = await prisma.hptb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hptbFindUniqueOrThrowArgs>(args: SelectSubset<T, hptbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hptbClient<$Result.GetResult<Prisma.$hptbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hptb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hptbFindFirstArgs} args - Arguments to find a Hptb
     * @example
     * // Get one Hptb
     * const hptb = await prisma.hptb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hptbFindFirstArgs>(args?: SelectSubset<T, hptbFindFirstArgs<ExtArgs>>): Prisma__hptbClient<$Result.GetResult<Prisma.$hptbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hptb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hptbFindFirstOrThrowArgs} args - Arguments to find a Hptb
     * @example
     * // Get one Hptb
     * const hptb = await prisma.hptb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hptbFindFirstOrThrowArgs>(args?: SelectSubset<T, hptbFindFirstOrThrowArgs<ExtArgs>>): Prisma__hptbClient<$Result.GetResult<Prisma.$hptbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hptbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hptbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hptbs
     * const hptbs = await prisma.hptb.findMany()
     * 
     * // Get first 10 Hptbs
     * const hptbs = await prisma.hptb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const hptbWithIDOnly = await prisma.hptb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends hptbFindManyArgs>(args?: SelectSubset<T, hptbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hptbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hptb.
     * @param {hptbCreateArgs} args - Arguments to create a Hptb.
     * @example
     * // Create one Hptb
     * const Hptb = await prisma.hptb.create({
     *   data: {
     *     // ... data to create a Hptb
     *   }
     * })
     * 
     */
    create<T extends hptbCreateArgs>(args: SelectSubset<T, hptbCreateArgs<ExtArgs>>): Prisma__hptbClient<$Result.GetResult<Prisma.$hptbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hptbs.
     * @param {hptbCreateManyArgs} args - Arguments to create many Hptbs.
     * @example
     * // Create many Hptbs
     * const hptb = await prisma.hptb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hptbCreateManyArgs>(args?: SelectSubset<T, hptbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hptb.
     * @param {hptbDeleteArgs} args - Arguments to delete one Hptb.
     * @example
     * // Delete one Hptb
     * const Hptb = await prisma.hptb.delete({
     *   where: {
     *     // ... filter to delete one Hptb
     *   }
     * })
     * 
     */
    delete<T extends hptbDeleteArgs>(args: SelectSubset<T, hptbDeleteArgs<ExtArgs>>): Prisma__hptbClient<$Result.GetResult<Prisma.$hptbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hptb.
     * @param {hptbUpdateArgs} args - Arguments to update one Hptb.
     * @example
     * // Update one Hptb
     * const hptb = await prisma.hptb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hptbUpdateArgs>(args: SelectSubset<T, hptbUpdateArgs<ExtArgs>>): Prisma__hptbClient<$Result.GetResult<Prisma.$hptbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hptbs.
     * @param {hptbDeleteManyArgs} args - Arguments to filter Hptbs to delete.
     * @example
     * // Delete a few Hptbs
     * const { count } = await prisma.hptb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hptbDeleteManyArgs>(args?: SelectSubset<T, hptbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hptbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hptbs
     * const hptb = await prisma.hptb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hptbUpdateManyArgs>(args: SelectSubset<T, hptbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hptb.
     * @param {hptbUpsertArgs} args - Arguments to update or create a Hptb.
     * @example
     * // Update or create a Hptb
     * const hptb = await prisma.hptb.upsert({
     *   create: {
     *     // ... data to create a Hptb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hptb we want to update
     *   }
     * })
     */
    upsert<T extends hptbUpsertArgs>(args: SelectSubset<T, hptbUpsertArgs<ExtArgs>>): Prisma__hptbClient<$Result.GetResult<Prisma.$hptbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hptbCountArgs} args - Arguments to filter Hptbs to count.
     * @example
     * // Count the number of Hptbs
     * const count = await prisma.hptb.count({
     *   where: {
     *     // ... the filter for the Hptbs we want to count
     *   }
     * })
    **/
    count<T extends hptbCountArgs>(
      args?: Subset<T, hptbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HptbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HptbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HptbAggregateArgs>(args: Subset<T, HptbAggregateArgs>): Prisma.PrismaPromise<GetHptbAggregateType<T>>

    /**
     * Group by Hptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hptbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hptbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hptbGroupByArgs['orderBy'] }
        : { orderBy?: hptbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hptbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHptbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hptb model
   */
  readonly fields: hptbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hptb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hptbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hptb model
   */ 
  interface hptbFieldRefs {
    readonly ID: FieldRef<"hptb", 'Int'>
    readonly MachineName: FieldRef<"hptb", 'String'>
    readonly IEHP: FieldRef<"hptb", 'String'>
    readonly FFHP: FieldRef<"hptb", 'String'>
    readonly GCHP: FieldRef<"hptb", 'String'>
    readonly LastUpdateDate: FieldRef<"hptb", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hptb findUnique
   */
  export type hptbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
    /**
     * Filter, which hptb to fetch.
     */
    where: hptbWhereUniqueInput
  }

  /**
   * hptb findUniqueOrThrow
   */
  export type hptbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
    /**
     * Filter, which hptb to fetch.
     */
    where: hptbWhereUniqueInput
  }

  /**
   * hptb findFirst
   */
  export type hptbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
    /**
     * Filter, which hptb to fetch.
     */
    where?: hptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hptbs to fetch.
     */
    orderBy?: hptbOrderByWithRelationInput | hptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hptbs.
     */
    cursor?: hptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hptbs.
     */
    distinct?: HptbScalarFieldEnum | HptbScalarFieldEnum[]
  }

  /**
   * hptb findFirstOrThrow
   */
  export type hptbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
    /**
     * Filter, which hptb to fetch.
     */
    where?: hptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hptbs to fetch.
     */
    orderBy?: hptbOrderByWithRelationInput | hptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hptbs.
     */
    cursor?: hptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hptbs.
     */
    distinct?: HptbScalarFieldEnum | HptbScalarFieldEnum[]
  }

  /**
   * hptb findMany
   */
  export type hptbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
    /**
     * Filter, which hptbs to fetch.
     */
    where?: hptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hptbs to fetch.
     */
    orderBy?: hptbOrderByWithRelationInput | hptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hptbs.
     */
    cursor?: hptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hptbs.
     */
    skip?: number
    distinct?: HptbScalarFieldEnum | HptbScalarFieldEnum[]
  }

  /**
   * hptb create
   */
  export type hptbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
    /**
     * The data needed to create a hptb.
     */
    data: XOR<hptbCreateInput, hptbUncheckedCreateInput>
  }

  /**
   * hptb createMany
   */
  export type hptbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hptbs.
     */
    data: hptbCreateManyInput | hptbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hptb update
   */
  export type hptbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
    /**
     * The data needed to update a hptb.
     */
    data: XOR<hptbUpdateInput, hptbUncheckedUpdateInput>
    /**
     * Choose, which hptb to update.
     */
    where: hptbWhereUniqueInput
  }

  /**
   * hptb updateMany
   */
  export type hptbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hptbs.
     */
    data: XOR<hptbUpdateManyMutationInput, hptbUncheckedUpdateManyInput>
    /**
     * Filter which hptbs to update
     */
    where?: hptbWhereInput
  }

  /**
   * hptb upsert
   */
  export type hptbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
    /**
     * The filter to search for the hptb to update in case it exists.
     */
    where: hptbWhereUniqueInput
    /**
     * In case the hptb found by the `where` argument doesn't exist, create a new hptb with this data.
     */
    create: XOR<hptbCreateInput, hptbUncheckedCreateInput>
    /**
     * In case the hptb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hptbUpdateInput, hptbUncheckedUpdateInput>
  }

  /**
   * hptb delete
   */
  export type hptbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
    /**
     * Filter which hptb to delete.
     */
    where: hptbWhereUniqueInput
  }

  /**
   * hptb deleteMany
   */
  export type hptbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hptbs to delete
     */
    where?: hptbWhereInput
  }

  /**
   * hptb without action
   */
  export type hptbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hptb
     */
    select?: hptbSelect<ExtArgs> | null
  }


  /**
   * Model intoptiontb
   */

  export type AggregateIntoptiontb = {
    _count: IntoptiontbCountAggregateOutputType | null
    _avg: IntoptiontbAvgAggregateOutputType | null
    _sum: IntoptiontbSumAggregateOutputType | null
    _min: IntoptiontbMinAggregateOutputType | null
    _max: IntoptiontbMaxAggregateOutputType | null
  }

  export type IntoptiontbAvgAggregateOutputType = {
    OptionId: number | null
  }

  export type IntoptiontbSumAggregateOutputType = {
    OptionId: number | null
  }

  export type IntoptiontbMinAggregateOutputType = {
    OptionId: number | null
    OptionName: string | null
    Value: string | null
    Active: boolean | null
  }

  export type IntoptiontbMaxAggregateOutputType = {
    OptionId: number | null
    OptionName: string | null
    Value: string | null
    Active: boolean | null
  }

  export type IntoptiontbCountAggregateOutputType = {
    OptionId: number
    OptionName: number
    Value: number
    Active: number
    _all: number
  }


  export type IntoptiontbAvgAggregateInputType = {
    OptionId?: true
  }

  export type IntoptiontbSumAggregateInputType = {
    OptionId?: true
  }

  export type IntoptiontbMinAggregateInputType = {
    OptionId?: true
    OptionName?: true
    Value?: true
    Active?: true
  }

  export type IntoptiontbMaxAggregateInputType = {
    OptionId?: true
    OptionName?: true
    Value?: true
    Active?: true
  }

  export type IntoptiontbCountAggregateInputType = {
    OptionId?: true
    OptionName?: true
    Value?: true
    Active?: true
    _all?: true
  }

  export type IntoptiontbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which intoptiontb to aggregate.
     */
    where?: intoptiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intoptiontbs to fetch.
     */
    orderBy?: intoptiontbOrderByWithRelationInput | intoptiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: intoptiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intoptiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intoptiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned intoptiontbs
    **/
    _count?: true | IntoptiontbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntoptiontbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntoptiontbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntoptiontbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntoptiontbMaxAggregateInputType
  }

  export type GetIntoptiontbAggregateType<T extends IntoptiontbAggregateArgs> = {
        [P in keyof T & keyof AggregateIntoptiontb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntoptiontb[P]>
      : GetScalarType<T[P], AggregateIntoptiontb[P]>
  }




  export type intoptiontbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: intoptiontbWhereInput
    orderBy?: intoptiontbOrderByWithAggregationInput | intoptiontbOrderByWithAggregationInput[]
    by: IntoptiontbScalarFieldEnum[] | IntoptiontbScalarFieldEnum
    having?: intoptiontbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntoptiontbCountAggregateInputType | true
    _avg?: IntoptiontbAvgAggregateInputType
    _sum?: IntoptiontbSumAggregateInputType
    _min?: IntoptiontbMinAggregateInputType
    _max?: IntoptiontbMaxAggregateInputType
  }

  export type IntoptiontbGroupByOutputType = {
    OptionId: number
    OptionName: string
    Value: string
    Active: boolean
    _count: IntoptiontbCountAggregateOutputType | null
    _avg: IntoptiontbAvgAggregateOutputType | null
    _sum: IntoptiontbSumAggregateOutputType | null
    _min: IntoptiontbMinAggregateOutputType | null
    _max: IntoptiontbMaxAggregateOutputType | null
  }

  type GetIntoptiontbGroupByPayload<T extends intoptiontbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntoptiontbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntoptiontbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntoptiontbGroupByOutputType[P]>
            : GetScalarType<T[P], IntoptiontbGroupByOutputType[P]>
        }
      >
    >


  export type intoptiontbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    OptionId?: boolean
    OptionName?: boolean
    Value?: boolean
    Active?: boolean
  }, ExtArgs["result"]["intoptiontb"]>


  export type intoptiontbSelectScalar = {
    OptionId?: boolean
    OptionName?: boolean
    Value?: boolean
    Active?: boolean
  }


  export type $intoptiontbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "intoptiontb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      OptionId: number
      OptionName: string
      Value: string
      Active: boolean
    }, ExtArgs["result"]["intoptiontb"]>
    composites: {}
  }

  type intoptiontbGetPayload<S extends boolean | null | undefined | intoptiontbDefaultArgs> = $Result.GetResult<Prisma.$intoptiontbPayload, S>

  type intoptiontbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<intoptiontbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntoptiontbCountAggregateInputType | true
    }

  export interface intoptiontbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['intoptiontb'], meta: { name: 'intoptiontb' } }
    /**
     * Find zero or one Intoptiontb that matches the filter.
     * @param {intoptiontbFindUniqueArgs} args - Arguments to find a Intoptiontb
     * @example
     * // Get one Intoptiontb
     * const intoptiontb = await prisma.intoptiontb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends intoptiontbFindUniqueArgs>(args: SelectSubset<T, intoptiontbFindUniqueArgs<ExtArgs>>): Prisma__intoptiontbClient<$Result.GetResult<Prisma.$intoptiontbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Intoptiontb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {intoptiontbFindUniqueOrThrowArgs} args - Arguments to find a Intoptiontb
     * @example
     * // Get one Intoptiontb
     * const intoptiontb = await prisma.intoptiontb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends intoptiontbFindUniqueOrThrowArgs>(args: SelectSubset<T, intoptiontbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__intoptiontbClient<$Result.GetResult<Prisma.$intoptiontbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Intoptiontb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intoptiontbFindFirstArgs} args - Arguments to find a Intoptiontb
     * @example
     * // Get one Intoptiontb
     * const intoptiontb = await prisma.intoptiontb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends intoptiontbFindFirstArgs>(args?: SelectSubset<T, intoptiontbFindFirstArgs<ExtArgs>>): Prisma__intoptiontbClient<$Result.GetResult<Prisma.$intoptiontbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Intoptiontb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intoptiontbFindFirstOrThrowArgs} args - Arguments to find a Intoptiontb
     * @example
     * // Get one Intoptiontb
     * const intoptiontb = await prisma.intoptiontb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends intoptiontbFindFirstOrThrowArgs>(args?: SelectSubset<T, intoptiontbFindFirstOrThrowArgs<ExtArgs>>): Prisma__intoptiontbClient<$Result.GetResult<Prisma.$intoptiontbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Intoptiontbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intoptiontbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Intoptiontbs
     * const intoptiontbs = await prisma.intoptiontb.findMany()
     * 
     * // Get first 10 Intoptiontbs
     * const intoptiontbs = await prisma.intoptiontb.findMany({ take: 10 })
     * 
     * // Only select the `OptionId`
     * const intoptiontbWithOptionIdOnly = await prisma.intoptiontb.findMany({ select: { OptionId: true } })
     * 
     */
    findMany<T extends intoptiontbFindManyArgs>(args?: SelectSubset<T, intoptiontbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$intoptiontbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Intoptiontb.
     * @param {intoptiontbCreateArgs} args - Arguments to create a Intoptiontb.
     * @example
     * // Create one Intoptiontb
     * const Intoptiontb = await prisma.intoptiontb.create({
     *   data: {
     *     // ... data to create a Intoptiontb
     *   }
     * })
     * 
     */
    create<T extends intoptiontbCreateArgs>(args: SelectSubset<T, intoptiontbCreateArgs<ExtArgs>>): Prisma__intoptiontbClient<$Result.GetResult<Prisma.$intoptiontbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Intoptiontbs.
     * @param {intoptiontbCreateManyArgs} args - Arguments to create many Intoptiontbs.
     * @example
     * // Create many Intoptiontbs
     * const intoptiontb = await prisma.intoptiontb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends intoptiontbCreateManyArgs>(args?: SelectSubset<T, intoptiontbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Intoptiontb.
     * @param {intoptiontbDeleteArgs} args - Arguments to delete one Intoptiontb.
     * @example
     * // Delete one Intoptiontb
     * const Intoptiontb = await prisma.intoptiontb.delete({
     *   where: {
     *     // ... filter to delete one Intoptiontb
     *   }
     * })
     * 
     */
    delete<T extends intoptiontbDeleteArgs>(args: SelectSubset<T, intoptiontbDeleteArgs<ExtArgs>>): Prisma__intoptiontbClient<$Result.GetResult<Prisma.$intoptiontbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Intoptiontb.
     * @param {intoptiontbUpdateArgs} args - Arguments to update one Intoptiontb.
     * @example
     * // Update one Intoptiontb
     * const intoptiontb = await prisma.intoptiontb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends intoptiontbUpdateArgs>(args: SelectSubset<T, intoptiontbUpdateArgs<ExtArgs>>): Prisma__intoptiontbClient<$Result.GetResult<Prisma.$intoptiontbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Intoptiontbs.
     * @param {intoptiontbDeleteManyArgs} args - Arguments to filter Intoptiontbs to delete.
     * @example
     * // Delete a few Intoptiontbs
     * const { count } = await prisma.intoptiontb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends intoptiontbDeleteManyArgs>(args?: SelectSubset<T, intoptiontbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Intoptiontbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intoptiontbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Intoptiontbs
     * const intoptiontb = await prisma.intoptiontb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends intoptiontbUpdateManyArgs>(args: SelectSubset<T, intoptiontbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Intoptiontb.
     * @param {intoptiontbUpsertArgs} args - Arguments to update or create a Intoptiontb.
     * @example
     * // Update or create a Intoptiontb
     * const intoptiontb = await prisma.intoptiontb.upsert({
     *   create: {
     *     // ... data to create a Intoptiontb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intoptiontb we want to update
     *   }
     * })
     */
    upsert<T extends intoptiontbUpsertArgs>(args: SelectSubset<T, intoptiontbUpsertArgs<ExtArgs>>): Prisma__intoptiontbClient<$Result.GetResult<Prisma.$intoptiontbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Intoptiontbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intoptiontbCountArgs} args - Arguments to filter Intoptiontbs to count.
     * @example
     * // Count the number of Intoptiontbs
     * const count = await prisma.intoptiontb.count({
     *   where: {
     *     // ... the filter for the Intoptiontbs we want to count
     *   }
     * })
    **/
    count<T extends intoptiontbCountArgs>(
      args?: Subset<T, intoptiontbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntoptiontbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intoptiontb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntoptiontbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntoptiontbAggregateArgs>(args: Subset<T, IntoptiontbAggregateArgs>): Prisma.PrismaPromise<GetIntoptiontbAggregateType<T>>

    /**
     * Group by Intoptiontb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {intoptiontbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends intoptiontbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: intoptiontbGroupByArgs['orderBy'] }
        : { orderBy?: intoptiontbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, intoptiontbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntoptiontbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the intoptiontb model
   */
  readonly fields: intoptiontbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for intoptiontb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__intoptiontbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the intoptiontb model
   */ 
  interface intoptiontbFieldRefs {
    readonly OptionId: FieldRef<"intoptiontb", 'Int'>
    readonly OptionName: FieldRef<"intoptiontb", 'String'>
    readonly Value: FieldRef<"intoptiontb", 'String'>
    readonly Active: FieldRef<"intoptiontb", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * intoptiontb findUnique
   */
  export type intoptiontbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
    /**
     * Filter, which intoptiontb to fetch.
     */
    where: intoptiontbWhereUniqueInput
  }

  /**
   * intoptiontb findUniqueOrThrow
   */
  export type intoptiontbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
    /**
     * Filter, which intoptiontb to fetch.
     */
    where: intoptiontbWhereUniqueInput
  }

  /**
   * intoptiontb findFirst
   */
  export type intoptiontbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
    /**
     * Filter, which intoptiontb to fetch.
     */
    where?: intoptiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intoptiontbs to fetch.
     */
    orderBy?: intoptiontbOrderByWithRelationInput | intoptiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for intoptiontbs.
     */
    cursor?: intoptiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intoptiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intoptiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of intoptiontbs.
     */
    distinct?: IntoptiontbScalarFieldEnum | IntoptiontbScalarFieldEnum[]
  }

  /**
   * intoptiontb findFirstOrThrow
   */
  export type intoptiontbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
    /**
     * Filter, which intoptiontb to fetch.
     */
    where?: intoptiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intoptiontbs to fetch.
     */
    orderBy?: intoptiontbOrderByWithRelationInput | intoptiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for intoptiontbs.
     */
    cursor?: intoptiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intoptiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intoptiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of intoptiontbs.
     */
    distinct?: IntoptiontbScalarFieldEnum | IntoptiontbScalarFieldEnum[]
  }

  /**
   * intoptiontb findMany
   */
  export type intoptiontbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
    /**
     * Filter, which intoptiontbs to fetch.
     */
    where?: intoptiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of intoptiontbs to fetch.
     */
    orderBy?: intoptiontbOrderByWithRelationInput | intoptiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing intoptiontbs.
     */
    cursor?: intoptiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` intoptiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` intoptiontbs.
     */
    skip?: number
    distinct?: IntoptiontbScalarFieldEnum | IntoptiontbScalarFieldEnum[]
  }

  /**
   * intoptiontb create
   */
  export type intoptiontbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
    /**
     * The data needed to create a intoptiontb.
     */
    data: XOR<intoptiontbCreateInput, intoptiontbUncheckedCreateInput>
  }

  /**
   * intoptiontb createMany
   */
  export type intoptiontbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many intoptiontbs.
     */
    data: intoptiontbCreateManyInput | intoptiontbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * intoptiontb update
   */
  export type intoptiontbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
    /**
     * The data needed to update a intoptiontb.
     */
    data: XOR<intoptiontbUpdateInput, intoptiontbUncheckedUpdateInput>
    /**
     * Choose, which intoptiontb to update.
     */
    where: intoptiontbWhereUniqueInput
  }

  /**
   * intoptiontb updateMany
   */
  export type intoptiontbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update intoptiontbs.
     */
    data: XOR<intoptiontbUpdateManyMutationInput, intoptiontbUncheckedUpdateManyInput>
    /**
     * Filter which intoptiontbs to update
     */
    where?: intoptiontbWhereInput
  }

  /**
   * intoptiontb upsert
   */
  export type intoptiontbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
    /**
     * The filter to search for the intoptiontb to update in case it exists.
     */
    where: intoptiontbWhereUniqueInput
    /**
     * In case the intoptiontb found by the `where` argument doesn't exist, create a new intoptiontb with this data.
     */
    create: XOR<intoptiontbCreateInput, intoptiontbUncheckedCreateInput>
    /**
     * In case the intoptiontb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<intoptiontbUpdateInput, intoptiontbUncheckedUpdateInput>
  }

  /**
   * intoptiontb delete
   */
  export type intoptiontbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
    /**
     * Filter which intoptiontb to delete.
     */
    where: intoptiontbWhereUniqueInput
  }

  /**
   * intoptiontb deleteMany
   */
  export type intoptiontbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which intoptiontbs to delete
     */
    where?: intoptiontbWhereInput
  }

  /**
   * intoptiontb without action
   */
  export type intoptiontbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the intoptiontb
     */
    select?: intoptiontbSelect<ExtArgs> | null
  }


  /**
   * Model inventorytb
   */

  export type AggregateInventorytb = {
    _count: InventorytbCountAggregateOutputType | null
    _avg: InventorytbAvgAggregateOutputType | null
    _sum: InventorytbSumAggregateOutputType | null
    _min: InventorytbMinAggregateOutputType | null
    _max: InventorytbMaxAggregateOutputType | null
  }

  export type InventorytbAvgAggregateOutputType = {
    ID: number | null
    StaffID: number | null
    ServiceID: number | null
    ImportQuantity: number | null
    ImportPrice: Decimal | null
    ImportTotalAmount: Decimal | null
  }

  export type InventorytbSumAggregateOutputType = {
    ID: number | null
    StaffID: number | null
    ServiceID: number | null
    ImportQuantity: number | null
    ImportPrice: Decimal | null
    ImportTotalAmount: Decimal | null
  }

  export type InventorytbMinAggregateOutputType = {
    ID: number | null
    CreateDate: Date | null
    CreateTime: Date | null
    StaffID: number | null
    Note: string | null
    ServiceID: number | null
    ImportQuantity: number | null
    ImportPrice: Decimal | null
    ImportTotalAmount: Decimal | null
  }

  export type InventorytbMaxAggregateOutputType = {
    ID: number | null
    CreateDate: Date | null
    CreateTime: Date | null
    StaffID: number | null
    Note: string | null
    ServiceID: number | null
    ImportQuantity: number | null
    ImportPrice: Decimal | null
    ImportTotalAmount: Decimal | null
  }

  export type InventorytbCountAggregateOutputType = {
    ID: number
    CreateDate: number
    CreateTime: number
    StaffID: number
    Note: number
    ServiceID: number
    ImportQuantity: number
    ImportPrice: number
    ImportTotalAmount: number
    _all: number
  }


  export type InventorytbAvgAggregateInputType = {
    ID?: true
    StaffID?: true
    ServiceID?: true
    ImportQuantity?: true
    ImportPrice?: true
    ImportTotalAmount?: true
  }

  export type InventorytbSumAggregateInputType = {
    ID?: true
    StaffID?: true
    ServiceID?: true
    ImportQuantity?: true
    ImportPrice?: true
    ImportTotalAmount?: true
  }

  export type InventorytbMinAggregateInputType = {
    ID?: true
    CreateDate?: true
    CreateTime?: true
    StaffID?: true
    Note?: true
    ServiceID?: true
    ImportQuantity?: true
    ImportPrice?: true
    ImportTotalAmount?: true
  }

  export type InventorytbMaxAggregateInputType = {
    ID?: true
    CreateDate?: true
    CreateTime?: true
    StaffID?: true
    Note?: true
    ServiceID?: true
    ImportQuantity?: true
    ImportPrice?: true
    ImportTotalAmount?: true
  }

  export type InventorytbCountAggregateInputType = {
    ID?: true
    CreateDate?: true
    CreateTime?: true
    StaffID?: true
    Note?: true
    ServiceID?: true
    ImportQuantity?: true
    ImportPrice?: true
    ImportTotalAmount?: true
    _all?: true
  }

  export type InventorytbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventorytb to aggregate.
     */
    where?: inventorytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventorytbs to fetch.
     */
    orderBy?: inventorytbOrderByWithRelationInput | inventorytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventorytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventorytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventorytbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventorytbs
    **/
    _count?: true | InventorytbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventorytbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorytbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventorytbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventorytbMaxAggregateInputType
  }

  export type GetInventorytbAggregateType<T extends InventorytbAggregateArgs> = {
        [P in keyof T & keyof AggregateInventorytb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventorytb[P]>
      : GetScalarType<T[P], AggregateInventorytb[P]>
  }




  export type inventorytbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventorytbWhereInput
    orderBy?: inventorytbOrderByWithAggregationInput | inventorytbOrderByWithAggregationInput[]
    by: InventorytbScalarFieldEnum[] | InventorytbScalarFieldEnum
    having?: inventorytbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventorytbCountAggregateInputType | true
    _avg?: InventorytbAvgAggregateInputType
    _sum?: InventorytbSumAggregateInputType
    _min?: InventorytbMinAggregateInputType
    _max?: InventorytbMaxAggregateInputType
  }

  export type InventorytbGroupByOutputType = {
    ID: number
    CreateDate: Date
    CreateTime: Date
    StaffID: number
    Note: string | null
    ServiceID: number
    ImportQuantity: number
    ImportPrice: Decimal
    ImportTotalAmount: Decimal
    _count: InventorytbCountAggregateOutputType | null
    _avg: InventorytbAvgAggregateOutputType | null
    _sum: InventorytbSumAggregateOutputType | null
    _min: InventorytbMinAggregateOutputType | null
    _max: InventorytbMaxAggregateOutputType | null
  }

  type GetInventorytbGroupByPayload<T extends inventorytbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventorytbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventorytbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventorytbGroupByOutputType[P]>
            : GetScalarType<T[P], InventorytbGroupByOutputType[P]>
        }
      >
    >


  export type inventorytbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    StaffID?: boolean
    Note?: boolean
    ServiceID?: boolean
    ImportQuantity?: boolean
    ImportPrice?: boolean
    ImportTotalAmount?: boolean
  }, ExtArgs["result"]["inventorytb"]>


  export type inventorytbSelectScalar = {
    ID?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    StaffID?: boolean
    Note?: boolean
    ServiceID?: boolean
    ImportQuantity?: boolean
    ImportPrice?: boolean
    ImportTotalAmount?: boolean
  }


  export type $inventorytbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventorytb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      CreateDate: Date
      CreateTime: Date
      StaffID: number
      Note: string | null
      ServiceID: number
      ImportQuantity: number
      ImportPrice: Prisma.Decimal
      ImportTotalAmount: Prisma.Decimal
    }, ExtArgs["result"]["inventorytb"]>
    composites: {}
  }

  type inventorytbGetPayload<S extends boolean | null | undefined | inventorytbDefaultArgs> = $Result.GetResult<Prisma.$inventorytbPayload, S>

  type inventorytbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<inventorytbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventorytbCountAggregateInputType | true
    }

  export interface inventorytbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventorytb'], meta: { name: 'inventorytb' } }
    /**
     * Find zero or one Inventorytb that matches the filter.
     * @param {inventorytbFindUniqueArgs} args - Arguments to find a Inventorytb
     * @example
     * // Get one Inventorytb
     * const inventorytb = await prisma.inventorytb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventorytbFindUniqueArgs>(args: SelectSubset<T, inventorytbFindUniqueArgs<ExtArgs>>): Prisma__inventorytbClient<$Result.GetResult<Prisma.$inventorytbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventorytb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {inventorytbFindUniqueOrThrowArgs} args - Arguments to find a Inventorytb
     * @example
     * // Get one Inventorytb
     * const inventorytb = await prisma.inventorytb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventorytbFindUniqueOrThrowArgs>(args: SelectSubset<T, inventorytbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventorytbClient<$Result.GetResult<Prisma.$inventorytbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventorytb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventorytbFindFirstArgs} args - Arguments to find a Inventorytb
     * @example
     * // Get one Inventorytb
     * const inventorytb = await prisma.inventorytb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventorytbFindFirstArgs>(args?: SelectSubset<T, inventorytbFindFirstArgs<ExtArgs>>): Prisma__inventorytbClient<$Result.GetResult<Prisma.$inventorytbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventorytb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventorytbFindFirstOrThrowArgs} args - Arguments to find a Inventorytb
     * @example
     * // Get one Inventorytb
     * const inventorytb = await prisma.inventorytb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventorytbFindFirstOrThrowArgs>(args?: SelectSubset<T, inventorytbFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventorytbClient<$Result.GetResult<Prisma.$inventorytbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventorytbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventorytbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventorytbs
     * const inventorytbs = await prisma.inventorytb.findMany()
     * 
     * // Get first 10 Inventorytbs
     * const inventorytbs = await prisma.inventorytb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const inventorytbWithIDOnly = await prisma.inventorytb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends inventorytbFindManyArgs>(args?: SelectSubset<T, inventorytbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventorytbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventorytb.
     * @param {inventorytbCreateArgs} args - Arguments to create a Inventorytb.
     * @example
     * // Create one Inventorytb
     * const Inventorytb = await prisma.inventorytb.create({
     *   data: {
     *     // ... data to create a Inventorytb
     *   }
     * })
     * 
     */
    create<T extends inventorytbCreateArgs>(args: SelectSubset<T, inventorytbCreateArgs<ExtArgs>>): Prisma__inventorytbClient<$Result.GetResult<Prisma.$inventorytbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventorytbs.
     * @param {inventorytbCreateManyArgs} args - Arguments to create many Inventorytbs.
     * @example
     * // Create many Inventorytbs
     * const inventorytb = await prisma.inventorytb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventorytbCreateManyArgs>(args?: SelectSubset<T, inventorytbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventorytb.
     * @param {inventorytbDeleteArgs} args - Arguments to delete one Inventorytb.
     * @example
     * // Delete one Inventorytb
     * const Inventorytb = await prisma.inventorytb.delete({
     *   where: {
     *     // ... filter to delete one Inventorytb
     *   }
     * })
     * 
     */
    delete<T extends inventorytbDeleteArgs>(args: SelectSubset<T, inventorytbDeleteArgs<ExtArgs>>): Prisma__inventorytbClient<$Result.GetResult<Prisma.$inventorytbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventorytb.
     * @param {inventorytbUpdateArgs} args - Arguments to update one Inventorytb.
     * @example
     * // Update one Inventorytb
     * const inventorytb = await prisma.inventorytb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventorytbUpdateArgs>(args: SelectSubset<T, inventorytbUpdateArgs<ExtArgs>>): Prisma__inventorytbClient<$Result.GetResult<Prisma.$inventorytbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventorytbs.
     * @param {inventorytbDeleteManyArgs} args - Arguments to filter Inventorytbs to delete.
     * @example
     * // Delete a few Inventorytbs
     * const { count } = await prisma.inventorytb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventorytbDeleteManyArgs>(args?: SelectSubset<T, inventorytbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventorytbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventorytbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventorytbs
     * const inventorytb = await prisma.inventorytb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventorytbUpdateManyArgs>(args: SelectSubset<T, inventorytbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventorytb.
     * @param {inventorytbUpsertArgs} args - Arguments to update or create a Inventorytb.
     * @example
     * // Update or create a Inventorytb
     * const inventorytb = await prisma.inventorytb.upsert({
     *   create: {
     *     // ... data to create a Inventorytb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventorytb we want to update
     *   }
     * })
     */
    upsert<T extends inventorytbUpsertArgs>(args: SelectSubset<T, inventorytbUpsertArgs<ExtArgs>>): Prisma__inventorytbClient<$Result.GetResult<Prisma.$inventorytbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventorytbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventorytbCountArgs} args - Arguments to filter Inventorytbs to count.
     * @example
     * // Count the number of Inventorytbs
     * const count = await prisma.inventorytb.count({
     *   where: {
     *     // ... the filter for the Inventorytbs we want to count
     *   }
     * })
    **/
    count<T extends inventorytbCountArgs>(
      args?: Subset<T, inventorytbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventorytbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventorytb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventorytbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventorytbAggregateArgs>(args: Subset<T, InventorytbAggregateArgs>): Prisma.PrismaPromise<GetInventorytbAggregateType<T>>

    /**
     * Group by Inventorytb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventorytbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventorytbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventorytbGroupByArgs['orderBy'] }
        : { orderBy?: inventorytbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventorytbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventorytbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventorytb model
   */
  readonly fields: inventorytbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventorytb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventorytbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventorytb model
   */ 
  interface inventorytbFieldRefs {
    readonly ID: FieldRef<"inventorytb", 'Int'>
    readonly CreateDate: FieldRef<"inventorytb", 'DateTime'>
    readonly CreateTime: FieldRef<"inventorytb", 'DateTime'>
    readonly StaffID: FieldRef<"inventorytb", 'Int'>
    readonly Note: FieldRef<"inventorytb", 'String'>
    readonly ServiceID: FieldRef<"inventorytb", 'Int'>
    readonly ImportQuantity: FieldRef<"inventorytb", 'Int'>
    readonly ImportPrice: FieldRef<"inventorytb", 'Decimal'>
    readonly ImportTotalAmount: FieldRef<"inventorytb", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * inventorytb findUnique
   */
  export type inventorytbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
    /**
     * Filter, which inventorytb to fetch.
     */
    where: inventorytbWhereUniqueInput
  }

  /**
   * inventorytb findUniqueOrThrow
   */
  export type inventorytbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
    /**
     * Filter, which inventorytb to fetch.
     */
    where: inventorytbWhereUniqueInput
  }

  /**
   * inventorytb findFirst
   */
  export type inventorytbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
    /**
     * Filter, which inventorytb to fetch.
     */
    where?: inventorytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventorytbs to fetch.
     */
    orderBy?: inventorytbOrderByWithRelationInput | inventorytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventorytbs.
     */
    cursor?: inventorytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventorytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventorytbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventorytbs.
     */
    distinct?: InventorytbScalarFieldEnum | InventorytbScalarFieldEnum[]
  }

  /**
   * inventorytb findFirstOrThrow
   */
  export type inventorytbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
    /**
     * Filter, which inventorytb to fetch.
     */
    where?: inventorytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventorytbs to fetch.
     */
    orderBy?: inventorytbOrderByWithRelationInput | inventorytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventorytbs.
     */
    cursor?: inventorytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventorytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventorytbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventorytbs.
     */
    distinct?: InventorytbScalarFieldEnum | InventorytbScalarFieldEnum[]
  }

  /**
   * inventorytb findMany
   */
  export type inventorytbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
    /**
     * Filter, which inventorytbs to fetch.
     */
    where?: inventorytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventorytbs to fetch.
     */
    orderBy?: inventorytbOrderByWithRelationInput | inventorytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventorytbs.
     */
    cursor?: inventorytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventorytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventorytbs.
     */
    skip?: number
    distinct?: InventorytbScalarFieldEnum | InventorytbScalarFieldEnum[]
  }

  /**
   * inventorytb create
   */
  export type inventorytbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
    /**
     * The data needed to create a inventorytb.
     */
    data?: XOR<inventorytbCreateInput, inventorytbUncheckedCreateInput>
  }

  /**
   * inventorytb createMany
   */
  export type inventorytbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventorytbs.
     */
    data: inventorytbCreateManyInput | inventorytbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventorytb update
   */
  export type inventorytbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
    /**
     * The data needed to update a inventorytb.
     */
    data: XOR<inventorytbUpdateInput, inventorytbUncheckedUpdateInput>
    /**
     * Choose, which inventorytb to update.
     */
    where: inventorytbWhereUniqueInput
  }

  /**
   * inventorytb updateMany
   */
  export type inventorytbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventorytbs.
     */
    data: XOR<inventorytbUpdateManyMutationInput, inventorytbUncheckedUpdateManyInput>
    /**
     * Filter which inventorytbs to update
     */
    where?: inventorytbWhereInput
  }

  /**
   * inventorytb upsert
   */
  export type inventorytbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
    /**
     * The filter to search for the inventorytb to update in case it exists.
     */
    where: inventorytbWhereUniqueInput
    /**
     * In case the inventorytb found by the `where` argument doesn't exist, create a new inventorytb with this data.
     */
    create: XOR<inventorytbCreateInput, inventorytbUncheckedCreateInput>
    /**
     * In case the inventorytb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventorytbUpdateInput, inventorytbUncheckedUpdateInput>
  }

  /**
   * inventorytb delete
   */
  export type inventorytbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
    /**
     * Filter which inventorytb to delete.
     */
    where: inventorytbWhereUniqueInput
  }

  /**
   * inventorytb deleteMany
   */
  export type inventorytbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventorytbs to delete
     */
    where?: inventorytbWhereInput
  }

  /**
   * inventorytb without action
   */
  export type inventorytbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventorytb
     */
    select?: inventorytbSelect<ExtArgs> | null
  }


  /**
   * Model legalapptb
   */

  export type AggregateLegalapptb = {
    _count: LegalapptbCountAggregateOutputType | null
    _min: LegalapptbMinAggregateOutputType | null
    _max: LegalapptbMaxAggregateOutputType | null
  }

  export type LegalapptbMinAggregateOutputType = {
    AppName: string | null
  }

  export type LegalapptbMaxAggregateOutputType = {
    AppName: string | null
  }

  export type LegalapptbCountAggregateOutputType = {
    AppName: number
    _all: number
  }


  export type LegalapptbMinAggregateInputType = {
    AppName?: true
  }

  export type LegalapptbMaxAggregateInputType = {
    AppName?: true
  }

  export type LegalapptbCountAggregateInputType = {
    AppName?: true
    _all?: true
  }

  export type LegalapptbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which legalapptb to aggregate.
     */
    where?: legalapptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legalapptbs to fetch.
     */
    orderBy?: legalapptbOrderByWithRelationInput | legalapptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: legalapptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legalapptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legalapptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned legalapptbs
    **/
    _count?: true | LegalapptbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LegalapptbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LegalapptbMaxAggregateInputType
  }

  export type GetLegalapptbAggregateType<T extends LegalapptbAggregateArgs> = {
        [P in keyof T & keyof AggregateLegalapptb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegalapptb[P]>
      : GetScalarType<T[P], AggregateLegalapptb[P]>
  }




  export type legalapptbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: legalapptbWhereInput
    orderBy?: legalapptbOrderByWithAggregationInput | legalapptbOrderByWithAggregationInput[]
    by: LegalapptbScalarFieldEnum[] | LegalapptbScalarFieldEnum
    having?: legalapptbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LegalapptbCountAggregateInputType | true
    _min?: LegalapptbMinAggregateInputType
    _max?: LegalapptbMaxAggregateInputType
  }

  export type LegalapptbGroupByOutputType = {
    AppName: string
    _count: LegalapptbCountAggregateOutputType | null
    _min: LegalapptbMinAggregateOutputType | null
    _max: LegalapptbMaxAggregateOutputType | null
  }

  type GetLegalapptbGroupByPayload<T extends legalapptbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LegalapptbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LegalapptbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LegalapptbGroupByOutputType[P]>
            : GetScalarType<T[P], LegalapptbGroupByOutputType[P]>
        }
      >
    >


  export type legalapptbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AppName?: boolean
  }, ExtArgs["result"]["legalapptb"]>


  export type legalapptbSelectScalar = {
    AppName?: boolean
  }


  export type $legalapptbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "legalapptb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      AppName: string
    }, ExtArgs["result"]["legalapptb"]>
    composites: {}
  }

  type legalapptbGetPayload<S extends boolean | null | undefined | legalapptbDefaultArgs> = $Result.GetResult<Prisma.$legalapptbPayload, S>

  type legalapptbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<legalapptbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LegalapptbCountAggregateInputType | true
    }

  export interface legalapptbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['legalapptb'], meta: { name: 'legalapptb' } }
    /**
     * Find zero or one Legalapptb that matches the filter.
     * @param {legalapptbFindUniqueArgs} args - Arguments to find a Legalapptb
     * @example
     * // Get one Legalapptb
     * const legalapptb = await prisma.legalapptb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends legalapptbFindUniqueArgs>(args: SelectSubset<T, legalapptbFindUniqueArgs<ExtArgs>>): Prisma__legalapptbClient<$Result.GetResult<Prisma.$legalapptbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Legalapptb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {legalapptbFindUniqueOrThrowArgs} args - Arguments to find a Legalapptb
     * @example
     * // Get one Legalapptb
     * const legalapptb = await prisma.legalapptb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends legalapptbFindUniqueOrThrowArgs>(args: SelectSubset<T, legalapptbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__legalapptbClient<$Result.GetResult<Prisma.$legalapptbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Legalapptb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legalapptbFindFirstArgs} args - Arguments to find a Legalapptb
     * @example
     * // Get one Legalapptb
     * const legalapptb = await prisma.legalapptb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends legalapptbFindFirstArgs>(args?: SelectSubset<T, legalapptbFindFirstArgs<ExtArgs>>): Prisma__legalapptbClient<$Result.GetResult<Prisma.$legalapptbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Legalapptb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legalapptbFindFirstOrThrowArgs} args - Arguments to find a Legalapptb
     * @example
     * // Get one Legalapptb
     * const legalapptb = await prisma.legalapptb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends legalapptbFindFirstOrThrowArgs>(args?: SelectSubset<T, legalapptbFindFirstOrThrowArgs<ExtArgs>>): Prisma__legalapptbClient<$Result.GetResult<Prisma.$legalapptbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Legalapptbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legalapptbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Legalapptbs
     * const legalapptbs = await prisma.legalapptb.findMany()
     * 
     * // Get first 10 Legalapptbs
     * const legalapptbs = await prisma.legalapptb.findMany({ take: 10 })
     * 
     * // Only select the `AppName`
     * const legalapptbWithAppNameOnly = await prisma.legalapptb.findMany({ select: { AppName: true } })
     * 
     */
    findMany<T extends legalapptbFindManyArgs>(args?: SelectSubset<T, legalapptbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$legalapptbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Legalapptb.
     * @param {legalapptbCreateArgs} args - Arguments to create a Legalapptb.
     * @example
     * // Create one Legalapptb
     * const Legalapptb = await prisma.legalapptb.create({
     *   data: {
     *     // ... data to create a Legalapptb
     *   }
     * })
     * 
     */
    create<T extends legalapptbCreateArgs>(args: SelectSubset<T, legalapptbCreateArgs<ExtArgs>>): Prisma__legalapptbClient<$Result.GetResult<Prisma.$legalapptbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Legalapptbs.
     * @param {legalapptbCreateManyArgs} args - Arguments to create many Legalapptbs.
     * @example
     * // Create many Legalapptbs
     * const legalapptb = await prisma.legalapptb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends legalapptbCreateManyArgs>(args?: SelectSubset<T, legalapptbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Legalapptb.
     * @param {legalapptbDeleteArgs} args - Arguments to delete one Legalapptb.
     * @example
     * // Delete one Legalapptb
     * const Legalapptb = await prisma.legalapptb.delete({
     *   where: {
     *     // ... filter to delete one Legalapptb
     *   }
     * })
     * 
     */
    delete<T extends legalapptbDeleteArgs>(args: SelectSubset<T, legalapptbDeleteArgs<ExtArgs>>): Prisma__legalapptbClient<$Result.GetResult<Prisma.$legalapptbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Legalapptb.
     * @param {legalapptbUpdateArgs} args - Arguments to update one Legalapptb.
     * @example
     * // Update one Legalapptb
     * const legalapptb = await prisma.legalapptb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends legalapptbUpdateArgs>(args: SelectSubset<T, legalapptbUpdateArgs<ExtArgs>>): Prisma__legalapptbClient<$Result.GetResult<Prisma.$legalapptbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Legalapptbs.
     * @param {legalapptbDeleteManyArgs} args - Arguments to filter Legalapptbs to delete.
     * @example
     * // Delete a few Legalapptbs
     * const { count } = await prisma.legalapptb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends legalapptbDeleteManyArgs>(args?: SelectSubset<T, legalapptbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Legalapptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legalapptbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Legalapptbs
     * const legalapptb = await prisma.legalapptb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends legalapptbUpdateManyArgs>(args: SelectSubset<T, legalapptbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Legalapptb.
     * @param {legalapptbUpsertArgs} args - Arguments to update or create a Legalapptb.
     * @example
     * // Update or create a Legalapptb
     * const legalapptb = await prisma.legalapptb.upsert({
     *   create: {
     *     // ... data to create a Legalapptb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Legalapptb we want to update
     *   }
     * })
     */
    upsert<T extends legalapptbUpsertArgs>(args: SelectSubset<T, legalapptbUpsertArgs<ExtArgs>>): Prisma__legalapptbClient<$Result.GetResult<Prisma.$legalapptbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Legalapptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legalapptbCountArgs} args - Arguments to filter Legalapptbs to count.
     * @example
     * // Count the number of Legalapptbs
     * const count = await prisma.legalapptb.count({
     *   where: {
     *     // ... the filter for the Legalapptbs we want to count
     *   }
     * })
    **/
    count<T extends legalapptbCountArgs>(
      args?: Subset<T, legalapptbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LegalapptbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Legalapptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalapptbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LegalapptbAggregateArgs>(args: Subset<T, LegalapptbAggregateArgs>): Prisma.PrismaPromise<GetLegalapptbAggregateType<T>>

    /**
     * Group by Legalapptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {legalapptbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends legalapptbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: legalapptbGroupByArgs['orderBy'] }
        : { orderBy?: legalapptbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, legalapptbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegalapptbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the legalapptb model
   */
  readonly fields: legalapptbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for legalapptb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__legalapptbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the legalapptb model
   */ 
  interface legalapptbFieldRefs {
    readonly AppName: FieldRef<"legalapptb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * legalapptb findUnique
   */
  export type legalapptbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
    /**
     * Filter, which legalapptb to fetch.
     */
    where: legalapptbWhereUniqueInput
  }

  /**
   * legalapptb findUniqueOrThrow
   */
  export type legalapptbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
    /**
     * Filter, which legalapptb to fetch.
     */
    where: legalapptbWhereUniqueInput
  }

  /**
   * legalapptb findFirst
   */
  export type legalapptbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
    /**
     * Filter, which legalapptb to fetch.
     */
    where?: legalapptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legalapptbs to fetch.
     */
    orderBy?: legalapptbOrderByWithRelationInput | legalapptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legalapptbs.
     */
    cursor?: legalapptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legalapptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legalapptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legalapptbs.
     */
    distinct?: LegalapptbScalarFieldEnum | LegalapptbScalarFieldEnum[]
  }

  /**
   * legalapptb findFirstOrThrow
   */
  export type legalapptbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
    /**
     * Filter, which legalapptb to fetch.
     */
    where?: legalapptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legalapptbs to fetch.
     */
    orderBy?: legalapptbOrderByWithRelationInput | legalapptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for legalapptbs.
     */
    cursor?: legalapptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legalapptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legalapptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of legalapptbs.
     */
    distinct?: LegalapptbScalarFieldEnum | LegalapptbScalarFieldEnum[]
  }

  /**
   * legalapptb findMany
   */
  export type legalapptbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
    /**
     * Filter, which legalapptbs to fetch.
     */
    where?: legalapptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of legalapptbs to fetch.
     */
    orderBy?: legalapptbOrderByWithRelationInput | legalapptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing legalapptbs.
     */
    cursor?: legalapptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` legalapptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` legalapptbs.
     */
    skip?: number
    distinct?: LegalapptbScalarFieldEnum | LegalapptbScalarFieldEnum[]
  }

  /**
   * legalapptb create
   */
  export type legalapptbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
    /**
     * The data needed to create a legalapptb.
     */
    data: XOR<legalapptbCreateInput, legalapptbUncheckedCreateInput>
  }

  /**
   * legalapptb createMany
   */
  export type legalapptbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many legalapptbs.
     */
    data: legalapptbCreateManyInput | legalapptbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * legalapptb update
   */
  export type legalapptbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
    /**
     * The data needed to update a legalapptb.
     */
    data: XOR<legalapptbUpdateInput, legalapptbUncheckedUpdateInput>
    /**
     * Choose, which legalapptb to update.
     */
    where: legalapptbWhereUniqueInput
  }

  /**
   * legalapptb updateMany
   */
  export type legalapptbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update legalapptbs.
     */
    data: XOR<legalapptbUpdateManyMutationInput, legalapptbUncheckedUpdateManyInput>
    /**
     * Filter which legalapptbs to update
     */
    where?: legalapptbWhereInput
  }

  /**
   * legalapptb upsert
   */
  export type legalapptbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
    /**
     * The filter to search for the legalapptb to update in case it exists.
     */
    where: legalapptbWhereUniqueInput
    /**
     * In case the legalapptb found by the `where` argument doesn't exist, create a new legalapptb with this data.
     */
    create: XOR<legalapptbCreateInput, legalapptbUncheckedCreateInput>
    /**
     * In case the legalapptb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<legalapptbUpdateInput, legalapptbUncheckedUpdateInput>
  }

  /**
   * legalapptb delete
   */
  export type legalapptbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
    /**
     * Filter which legalapptb to delete.
     */
    where: legalapptbWhereUniqueInput
  }

  /**
   * legalapptb deleteMany
   */
  export type legalapptbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which legalapptbs to delete
     */
    where?: legalapptbWhereInput
  }

  /**
   * legalapptb without action
   */
  export type legalapptbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the legalapptb
     */
    select?: legalapptbSelect<ExtArgs> | null
  }


  /**
   * Model machinegrouptb
   */

  export type AggregateMachinegrouptb = {
    _count: MachinegrouptbCountAggregateOutputType | null
    _avg: MachinegrouptbAvgAggregateOutputType | null
    _sum: MachinegrouptbSumAggregateOutputType | null
    _min: MachinegrouptbMinAggregateOutputType | null
    _max: MachinegrouptbMaxAggregateOutputType | null
  }

  export type MachinegrouptbAvgAggregateOutputType = {
    MachineGroupId: number | null
    PriceDefault: number | null
    Active: number | null
  }

  export type MachinegrouptbSumAggregateOutputType = {
    MachineGroupId: number | null
    PriceDefault: number | null
    Active: number | null
  }

  export type MachinegrouptbMinAggregateOutputType = {
    MachineGroupId: number | null
    MachineGroupName: string | null
    PriceDefault: number | null
    Active: number | null
    Description: string | null
  }

  export type MachinegrouptbMaxAggregateOutputType = {
    MachineGroupId: number | null
    MachineGroupName: string | null
    PriceDefault: number | null
    Active: number | null
    Description: string | null
  }

  export type MachinegrouptbCountAggregateOutputType = {
    MachineGroupId: number
    MachineGroupName: number
    PriceDefault: number
    Active: number
    Description: number
    _all: number
  }


  export type MachinegrouptbAvgAggregateInputType = {
    MachineGroupId?: true
    PriceDefault?: true
    Active?: true
  }

  export type MachinegrouptbSumAggregateInputType = {
    MachineGroupId?: true
    PriceDefault?: true
    Active?: true
  }

  export type MachinegrouptbMinAggregateInputType = {
    MachineGroupId?: true
    MachineGroupName?: true
    PriceDefault?: true
    Active?: true
    Description?: true
  }

  export type MachinegrouptbMaxAggregateInputType = {
    MachineGroupId?: true
    MachineGroupName?: true
    PriceDefault?: true
    Active?: true
    Description?: true
  }

  export type MachinegrouptbCountAggregateInputType = {
    MachineGroupId?: true
    MachineGroupName?: true
    PriceDefault?: true
    Active?: true
    Description?: true
    _all?: true
  }

  export type MachinegrouptbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which machinegrouptb to aggregate.
     */
    where?: machinegrouptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of machinegrouptbs to fetch.
     */
    orderBy?: machinegrouptbOrderByWithRelationInput | machinegrouptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: machinegrouptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` machinegrouptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` machinegrouptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned machinegrouptbs
    **/
    _count?: true | MachinegrouptbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MachinegrouptbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MachinegrouptbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MachinegrouptbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MachinegrouptbMaxAggregateInputType
  }

  export type GetMachinegrouptbAggregateType<T extends MachinegrouptbAggregateArgs> = {
        [P in keyof T & keyof AggregateMachinegrouptb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMachinegrouptb[P]>
      : GetScalarType<T[P], AggregateMachinegrouptb[P]>
  }




  export type machinegrouptbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: machinegrouptbWhereInput
    orderBy?: machinegrouptbOrderByWithAggregationInput | machinegrouptbOrderByWithAggregationInput[]
    by: MachinegrouptbScalarFieldEnum[] | MachinegrouptbScalarFieldEnum
    having?: machinegrouptbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MachinegrouptbCountAggregateInputType | true
    _avg?: MachinegrouptbAvgAggregateInputType
    _sum?: MachinegrouptbSumAggregateInputType
    _min?: MachinegrouptbMinAggregateInputType
    _max?: MachinegrouptbMaxAggregateInputType
  }

  export type MachinegrouptbGroupByOutputType = {
    MachineGroupId: number
    MachineGroupName: string
    PriceDefault: number | null
    Active: number | null
    Description: string | null
    _count: MachinegrouptbCountAggregateOutputType | null
    _avg: MachinegrouptbAvgAggregateOutputType | null
    _sum: MachinegrouptbSumAggregateOutputType | null
    _min: MachinegrouptbMinAggregateOutputType | null
    _max: MachinegrouptbMaxAggregateOutputType | null
  }

  type GetMachinegrouptbGroupByPayload<T extends machinegrouptbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MachinegrouptbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MachinegrouptbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MachinegrouptbGroupByOutputType[P]>
            : GetScalarType<T[P], MachinegrouptbGroupByOutputType[P]>
        }
      >
    >


  export type machinegrouptbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MachineGroupId?: boolean
    MachineGroupName?: boolean
    PriceDefault?: boolean
    Active?: boolean
    Description?: boolean
  }, ExtArgs["result"]["machinegrouptb"]>


  export type machinegrouptbSelectScalar = {
    MachineGroupId?: boolean
    MachineGroupName?: boolean
    PriceDefault?: boolean
    Active?: boolean
    Description?: boolean
  }


  export type $machinegrouptbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "machinegrouptb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      MachineGroupId: number
      MachineGroupName: string
      PriceDefault: number | null
      Active: number | null
      Description: string | null
    }, ExtArgs["result"]["machinegrouptb"]>
    composites: {}
  }

  type machinegrouptbGetPayload<S extends boolean | null | undefined | machinegrouptbDefaultArgs> = $Result.GetResult<Prisma.$machinegrouptbPayload, S>

  type machinegrouptbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<machinegrouptbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MachinegrouptbCountAggregateInputType | true
    }

  export interface machinegrouptbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['machinegrouptb'], meta: { name: 'machinegrouptb' } }
    /**
     * Find zero or one Machinegrouptb that matches the filter.
     * @param {machinegrouptbFindUniqueArgs} args - Arguments to find a Machinegrouptb
     * @example
     * // Get one Machinegrouptb
     * const machinegrouptb = await prisma.machinegrouptb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends machinegrouptbFindUniqueArgs>(args: SelectSubset<T, machinegrouptbFindUniqueArgs<ExtArgs>>): Prisma__machinegrouptbClient<$Result.GetResult<Prisma.$machinegrouptbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Machinegrouptb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {machinegrouptbFindUniqueOrThrowArgs} args - Arguments to find a Machinegrouptb
     * @example
     * // Get one Machinegrouptb
     * const machinegrouptb = await prisma.machinegrouptb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends machinegrouptbFindUniqueOrThrowArgs>(args: SelectSubset<T, machinegrouptbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__machinegrouptbClient<$Result.GetResult<Prisma.$machinegrouptbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Machinegrouptb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinegrouptbFindFirstArgs} args - Arguments to find a Machinegrouptb
     * @example
     * // Get one Machinegrouptb
     * const machinegrouptb = await prisma.machinegrouptb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends machinegrouptbFindFirstArgs>(args?: SelectSubset<T, machinegrouptbFindFirstArgs<ExtArgs>>): Prisma__machinegrouptbClient<$Result.GetResult<Prisma.$machinegrouptbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Machinegrouptb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinegrouptbFindFirstOrThrowArgs} args - Arguments to find a Machinegrouptb
     * @example
     * // Get one Machinegrouptb
     * const machinegrouptb = await prisma.machinegrouptb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends machinegrouptbFindFirstOrThrowArgs>(args?: SelectSubset<T, machinegrouptbFindFirstOrThrowArgs<ExtArgs>>): Prisma__machinegrouptbClient<$Result.GetResult<Prisma.$machinegrouptbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Machinegrouptbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinegrouptbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Machinegrouptbs
     * const machinegrouptbs = await prisma.machinegrouptb.findMany()
     * 
     * // Get first 10 Machinegrouptbs
     * const machinegrouptbs = await prisma.machinegrouptb.findMany({ take: 10 })
     * 
     * // Only select the `MachineGroupId`
     * const machinegrouptbWithMachineGroupIdOnly = await prisma.machinegrouptb.findMany({ select: { MachineGroupId: true } })
     * 
     */
    findMany<T extends machinegrouptbFindManyArgs>(args?: SelectSubset<T, machinegrouptbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$machinegrouptbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Machinegrouptb.
     * @param {machinegrouptbCreateArgs} args - Arguments to create a Machinegrouptb.
     * @example
     * // Create one Machinegrouptb
     * const Machinegrouptb = await prisma.machinegrouptb.create({
     *   data: {
     *     // ... data to create a Machinegrouptb
     *   }
     * })
     * 
     */
    create<T extends machinegrouptbCreateArgs>(args: SelectSubset<T, machinegrouptbCreateArgs<ExtArgs>>): Prisma__machinegrouptbClient<$Result.GetResult<Prisma.$machinegrouptbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Machinegrouptbs.
     * @param {machinegrouptbCreateManyArgs} args - Arguments to create many Machinegrouptbs.
     * @example
     * // Create many Machinegrouptbs
     * const machinegrouptb = await prisma.machinegrouptb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends machinegrouptbCreateManyArgs>(args?: SelectSubset<T, machinegrouptbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Machinegrouptb.
     * @param {machinegrouptbDeleteArgs} args - Arguments to delete one Machinegrouptb.
     * @example
     * // Delete one Machinegrouptb
     * const Machinegrouptb = await prisma.machinegrouptb.delete({
     *   where: {
     *     // ... filter to delete one Machinegrouptb
     *   }
     * })
     * 
     */
    delete<T extends machinegrouptbDeleteArgs>(args: SelectSubset<T, machinegrouptbDeleteArgs<ExtArgs>>): Prisma__machinegrouptbClient<$Result.GetResult<Prisma.$machinegrouptbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Machinegrouptb.
     * @param {machinegrouptbUpdateArgs} args - Arguments to update one Machinegrouptb.
     * @example
     * // Update one Machinegrouptb
     * const machinegrouptb = await prisma.machinegrouptb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends machinegrouptbUpdateArgs>(args: SelectSubset<T, machinegrouptbUpdateArgs<ExtArgs>>): Prisma__machinegrouptbClient<$Result.GetResult<Prisma.$machinegrouptbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Machinegrouptbs.
     * @param {machinegrouptbDeleteManyArgs} args - Arguments to filter Machinegrouptbs to delete.
     * @example
     * // Delete a few Machinegrouptbs
     * const { count } = await prisma.machinegrouptb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends machinegrouptbDeleteManyArgs>(args?: SelectSubset<T, machinegrouptbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Machinegrouptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinegrouptbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Machinegrouptbs
     * const machinegrouptb = await prisma.machinegrouptb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends machinegrouptbUpdateManyArgs>(args: SelectSubset<T, machinegrouptbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Machinegrouptb.
     * @param {machinegrouptbUpsertArgs} args - Arguments to update or create a Machinegrouptb.
     * @example
     * // Update or create a Machinegrouptb
     * const machinegrouptb = await prisma.machinegrouptb.upsert({
     *   create: {
     *     // ... data to create a Machinegrouptb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Machinegrouptb we want to update
     *   }
     * })
     */
    upsert<T extends machinegrouptbUpsertArgs>(args: SelectSubset<T, machinegrouptbUpsertArgs<ExtArgs>>): Prisma__machinegrouptbClient<$Result.GetResult<Prisma.$machinegrouptbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Machinegrouptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinegrouptbCountArgs} args - Arguments to filter Machinegrouptbs to count.
     * @example
     * // Count the number of Machinegrouptbs
     * const count = await prisma.machinegrouptb.count({
     *   where: {
     *     // ... the filter for the Machinegrouptbs we want to count
     *   }
     * })
    **/
    count<T extends machinegrouptbCountArgs>(
      args?: Subset<T, machinegrouptbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MachinegrouptbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Machinegrouptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MachinegrouptbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MachinegrouptbAggregateArgs>(args: Subset<T, MachinegrouptbAggregateArgs>): Prisma.PrismaPromise<GetMachinegrouptbAggregateType<T>>

    /**
     * Group by Machinegrouptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {machinegrouptbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends machinegrouptbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: machinegrouptbGroupByArgs['orderBy'] }
        : { orderBy?: machinegrouptbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, machinegrouptbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMachinegrouptbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the machinegrouptb model
   */
  readonly fields: machinegrouptbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for machinegrouptb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__machinegrouptbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the machinegrouptb model
   */ 
  interface machinegrouptbFieldRefs {
    readonly MachineGroupId: FieldRef<"machinegrouptb", 'Int'>
    readonly MachineGroupName: FieldRef<"machinegrouptb", 'String'>
    readonly PriceDefault: FieldRef<"machinegrouptb", 'Int'>
    readonly Active: FieldRef<"machinegrouptb", 'Int'>
    readonly Description: FieldRef<"machinegrouptb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * machinegrouptb findUnique
   */
  export type machinegrouptbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which machinegrouptb to fetch.
     */
    where: machinegrouptbWhereUniqueInput
  }

  /**
   * machinegrouptb findUniqueOrThrow
   */
  export type machinegrouptbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which machinegrouptb to fetch.
     */
    where: machinegrouptbWhereUniqueInput
  }

  /**
   * machinegrouptb findFirst
   */
  export type machinegrouptbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which machinegrouptb to fetch.
     */
    where?: machinegrouptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of machinegrouptbs to fetch.
     */
    orderBy?: machinegrouptbOrderByWithRelationInput | machinegrouptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for machinegrouptbs.
     */
    cursor?: machinegrouptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` machinegrouptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` machinegrouptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of machinegrouptbs.
     */
    distinct?: MachinegrouptbScalarFieldEnum | MachinegrouptbScalarFieldEnum[]
  }

  /**
   * machinegrouptb findFirstOrThrow
   */
  export type machinegrouptbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which machinegrouptb to fetch.
     */
    where?: machinegrouptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of machinegrouptbs to fetch.
     */
    orderBy?: machinegrouptbOrderByWithRelationInput | machinegrouptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for machinegrouptbs.
     */
    cursor?: machinegrouptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` machinegrouptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` machinegrouptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of machinegrouptbs.
     */
    distinct?: MachinegrouptbScalarFieldEnum | MachinegrouptbScalarFieldEnum[]
  }

  /**
   * machinegrouptb findMany
   */
  export type machinegrouptbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which machinegrouptbs to fetch.
     */
    where?: machinegrouptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of machinegrouptbs to fetch.
     */
    orderBy?: machinegrouptbOrderByWithRelationInput | machinegrouptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing machinegrouptbs.
     */
    cursor?: machinegrouptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` machinegrouptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` machinegrouptbs.
     */
    skip?: number
    distinct?: MachinegrouptbScalarFieldEnum | MachinegrouptbScalarFieldEnum[]
  }

  /**
   * machinegrouptb create
   */
  export type machinegrouptbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
    /**
     * The data needed to create a machinegrouptb.
     */
    data: XOR<machinegrouptbCreateInput, machinegrouptbUncheckedCreateInput>
  }

  /**
   * machinegrouptb createMany
   */
  export type machinegrouptbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many machinegrouptbs.
     */
    data: machinegrouptbCreateManyInput | machinegrouptbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * machinegrouptb update
   */
  export type machinegrouptbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
    /**
     * The data needed to update a machinegrouptb.
     */
    data: XOR<machinegrouptbUpdateInput, machinegrouptbUncheckedUpdateInput>
    /**
     * Choose, which machinegrouptb to update.
     */
    where: machinegrouptbWhereUniqueInput
  }

  /**
   * machinegrouptb updateMany
   */
  export type machinegrouptbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update machinegrouptbs.
     */
    data: XOR<machinegrouptbUpdateManyMutationInput, machinegrouptbUncheckedUpdateManyInput>
    /**
     * Filter which machinegrouptbs to update
     */
    where?: machinegrouptbWhereInput
  }

  /**
   * machinegrouptb upsert
   */
  export type machinegrouptbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
    /**
     * The filter to search for the machinegrouptb to update in case it exists.
     */
    where: machinegrouptbWhereUniqueInput
    /**
     * In case the machinegrouptb found by the `where` argument doesn't exist, create a new machinegrouptb with this data.
     */
    create: XOR<machinegrouptbCreateInput, machinegrouptbUncheckedCreateInput>
    /**
     * In case the machinegrouptb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<machinegrouptbUpdateInput, machinegrouptbUncheckedUpdateInput>
  }

  /**
   * machinegrouptb delete
   */
  export type machinegrouptbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
    /**
     * Filter which machinegrouptb to delete.
     */
    where: machinegrouptbWhereUniqueInput
  }

  /**
   * machinegrouptb deleteMany
   */
  export type machinegrouptbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which machinegrouptbs to delete
     */
    where?: machinegrouptbWhereInput
  }

  /**
   * machinegrouptb without action
   */
  export type machinegrouptbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the machinegrouptb
     */
    select?: machinegrouptbSelect<ExtArgs> | null
  }


  /**
   * Model paymenttb
   */

  export type AggregatePaymenttb = {
    _count: PaymenttbCountAggregateOutputType | null
    _avg: PaymenttbAvgAggregateOutputType | null
    _sum: PaymenttbSumAggregateOutputType | null
    _min: PaymenttbMinAggregateOutputType | null
    _max: PaymenttbMaxAggregateOutputType | null
  }

  export type PaymenttbAvgAggregateOutputType = {
    VoucherId: number | null
    UserId: number | null
    Amount: Decimal | null
    AutoAmount: Decimal | null
    TimeTotal: number | null
    StaffId: number | null
    PaymentType: number | null
    PaymentWaitId: number | null
  }

  export type PaymenttbSumAggregateOutputType = {
    VoucherId: number | null
    UserId: number | null
    Amount: Decimal | null
    AutoAmount: Decimal | null
    TimeTotal: number | null
    StaffId: number | null
    PaymentType: number | null
    PaymentWaitId: number | null
  }

  export type PaymenttbMinAggregateOutputType = {
    VoucherId: number | null
    UserId: number | null
    VoucherNo: string | null
    VoucherDate: Date | null
    VoucherTime: Date | null
    ServeDate: Date | null
    ServeTime: Date | null
    Amount: Decimal | null
    AutoAmount: Decimal | null
    TimeTotal: number | null
    Active: boolean | null
    UserNote: string | null
    Note: string | null
    ServicePaid: boolean | null
    StaffId: number | null
    MachineName: string | null
    PaymentType: number | null
    PaymentWaitId: number | null
    zOid: string | null
    zTid: string | null
    zSig: string | null
  }

  export type PaymenttbMaxAggregateOutputType = {
    VoucherId: number | null
    UserId: number | null
    VoucherNo: string | null
    VoucherDate: Date | null
    VoucherTime: Date | null
    ServeDate: Date | null
    ServeTime: Date | null
    Amount: Decimal | null
    AutoAmount: Decimal | null
    TimeTotal: number | null
    Active: boolean | null
    UserNote: string | null
    Note: string | null
    ServicePaid: boolean | null
    StaffId: number | null
    MachineName: string | null
    PaymentType: number | null
    PaymentWaitId: number | null
    zOid: string | null
    zTid: string | null
    zSig: string | null
  }

  export type PaymenttbCountAggregateOutputType = {
    VoucherId: number
    UserId: number
    VoucherNo: number
    VoucherDate: number
    VoucherTime: number
    ServeDate: number
    ServeTime: number
    Amount: number
    AutoAmount: number
    TimeTotal: number
    Active: number
    UserNote: number
    Note: number
    ServicePaid: number
    StaffId: number
    MachineName: number
    PaymentType: number
    PaymentWaitId: number
    zOid: number
    zTid: number
    zSig: number
    _all: number
  }


  export type PaymenttbAvgAggregateInputType = {
    VoucherId?: true
    UserId?: true
    Amount?: true
    AutoAmount?: true
    TimeTotal?: true
    StaffId?: true
    PaymentType?: true
    PaymentWaitId?: true
  }

  export type PaymenttbSumAggregateInputType = {
    VoucherId?: true
    UserId?: true
    Amount?: true
    AutoAmount?: true
    TimeTotal?: true
    StaffId?: true
    PaymentType?: true
    PaymentWaitId?: true
  }

  export type PaymenttbMinAggregateInputType = {
    VoucherId?: true
    UserId?: true
    VoucherNo?: true
    VoucherDate?: true
    VoucherTime?: true
    ServeDate?: true
    ServeTime?: true
    Amount?: true
    AutoAmount?: true
    TimeTotal?: true
    Active?: true
    UserNote?: true
    Note?: true
    ServicePaid?: true
    StaffId?: true
    MachineName?: true
    PaymentType?: true
    PaymentWaitId?: true
    zOid?: true
    zTid?: true
    zSig?: true
  }

  export type PaymenttbMaxAggregateInputType = {
    VoucherId?: true
    UserId?: true
    VoucherNo?: true
    VoucherDate?: true
    VoucherTime?: true
    ServeDate?: true
    ServeTime?: true
    Amount?: true
    AutoAmount?: true
    TimeTotal?: true
    Active?: true
    UserNote?: true
    Note?: true
    ServicePaid?: true
    StaffId?: true
    MachineName?: true
    PaymentType?: true
    PaymentWaitId?: true
    zOid?: true
    zTid?: true
    zSig?: true
  }

  export type PaymenttbCountAggregateInputType = {
    VoucherId?: true
    UserId?: true
    VoucherNo?: true
    VoucherDate?: true
    VoucherTime?: true
    ServeDate?: true
    ServeTime?: true
    Amount?: true
    AutoAmount?: true
    TimeTotal?: true
    Active?: true
    UserNote?: true
    Note?: true
    ServicePaid?: true
    StaffId?: true
    MachineName?: true
    PaymentType?: true
    PaymentWaitId?: true
    zOid?: true
    zTid?: true
    zSig?: true
    _all?: true
  }

  export type PaymenttbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paymenttb to aggregate.
     */
    where?: paymenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymenttbs to fetch.
     */
    orderBy?: paymenttbOrderByWithRelationInput | paymenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymenttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paymenttbs
    **/
    _count?: true | PaymenttbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymenttbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymenttbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymenttbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymenttbMaxAggregateInputType
  }

  export type GetPaymenttbAggregateType<T extends PaymenttbAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymenttb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymenttb[P]>
      : GetScalarType<T[P], AggregatePaymenttb[P]>
  }




  export type paymenttbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymenttbWhereInput
    orderBy?: paymenttbOrderByWithAggregationInput | paymenttbOrderByWithAggregationInput[]
    by: PaymenttbScalarFieldEnum[] | PaymenttbScalarFieldEnum
    having?: paymenttbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymenttbCountAggregateInputType | true
    _avg?: PaymenttbAvgAggregateInputType
    _sum?: PaymenttbSumAggregateInputType
    _min?: PaymenttbMinAggregateInputType
    _max?: PaymenttbMaxAggregateInputType
  }

  export type PaymenttbGroupByOutputType = {
    VoucherId: number
    UserId: number
    VoucherNo: string | null
    VoucherDate: Date
    VoucherTime: Date
    ServeDate: Date
    ServeTime: Date
    Amount: Decimal
    AutoAmount: Decimal
    TimeTotal: number
    Active: boolean
    UserNote: string
    Note: string
    ServicePaid: boolean
    StaffId: number
    MachineName: string | null
    PaymentType: number | null
    PaymentWaitId: number
    zOid: string | null
    zTid: string | null
    zSig: string | null
    _count: PaymenttbCountAggregateOutputType | null
    _avg: PaymenttbAvgAggregateOutputType | null
    _sum: PaymenttbSumAggregateOutputType | null
    _min: PaymenttbMinAggregateOutputType | null
    _max: PaymenttbMaxAggregateOutputType | null
  }

  type GetPaymenttbGroupByPayload<T extends paymenttbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymenttbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymenttbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymenttbGroupByOutputType[P]>
            : GetScalarType<T[P], PaymenttbGroupByOutputType[P]>
        }
      >
    >


  export type paymenttbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    VoucherId?: boolean
    UserId?: boolean
    VoucherNo?: boolean
    VoucherDate?: boolean
    VoucherTime?: boolean
    ServeDate?: boolean
    ServeTime?: boolean
    Amount?: boolean
    AutoAmount?: boolean
    TimeTotal?: boolean
    Active?: boolean
    UserNote?: boolean
    Note?: boolean
    ServicePaid?: boolean
    StaffId?: boolean
    MachineName?: boolean
    PaymentType?: boolean
    PaymentWaitId?: boolean
    zOid?: boolean
    zTid?: boolean
    zSig?: boolean
  }, ExtArgs["result"]["paymenttb"]>


  export type paymenttbSelectScalar = {
    VoucherId?: boolean
    UserId?: boolean
    VoucherNo?: boolean
    VoucherDate?: boolean
    VoucherTime?: boolean
    ServeDate?: boolean
    ServeTime?: boolean
    Amount?: boolean
    AutoAmount?: boolean
    TimeTotal?: boolean
    Active?: boolean
    UserNote?: boolean
    Note?: boolean
    ServicePaid?: boolean
    StaffId?: boolean
    MachineName?: boolean
    PaymentType?: boolean
    PaymentWaitId?: boolean
    zOid?: boolean
    zTid?: boolean
    zSig?: boolean
  }


  export type $paymenttbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paymenttb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      VoucherId: number
      UserId: number
      VoucherNo: string | null
      VoucherDate: Date
      VoucherTime: Date
      ServeDate: Date
      ServeTime: Date
      Amount: Prisma.Decimal
      AutoAmount: Prisma.Decimal
      TimeTotal: number
      Active: boolean
      UserNote: string
      Note: string
      ServicePaid: boolean
      StaffId: number
      MachineName: string | null
      PaymentType: number | null
      PaymentWaitId: number
      zOid: string | null
      zTid: string | null
      zSig: string | null
    }, ExtArgs["result"]["paymenttb"]>
    composites: {}
  }

  type paymenttbGetPayload<S extends boolean | null | undefined | paymenttbDefaultArgs> = $Result.GetResult<Prisma.$paymenttbPayload, S>

  type paymenttbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<paymenttbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymenttbCountAggregateInputType | true
    }

  export interface paymenttbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paymenttb'], meta: { name: 'paymenttb' } }
    /**
     * Find zero or one Paymenttb that matches the filter.
     * @param {paymenttbFindUniqueArgs} args - Arguments to find a Paymenttb
     * @example
     * // Get one Paymenttb
     * const paymenttb = await prisma.paymenttb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymenttbFindUniqueArgs>(args: SelectSubset<T, paymenttbFindUniqueArgs<ExtArgs>>): Prisma__paymenttbClient<$Result.GetResult<Prisma.$paymenttbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Paymenttb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {paymenttbFindUniqueOrThrowArgs} args - Arguments to find a Paymenttb
     * @example
     * // Get one Paymenttb
     * const paymenttb = await prisma.paymenttb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymenttbFindUniqueOrThrowArgs>(args: SelectSubset<T, paymenttbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymenttbClient<$Result.GetResult<Prisma.$paymenttbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Paymenttb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttbFindFirstArgs} args - Arguments to find a Paymenttb
     * @example
     * // Get one Paymenttb
     * const paymenttb = await prisma.paymenttb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymenttbFindFirstArgs>(args?: SelectSubset<T, paymenttbFindFirstArgs<ExtArgs>>): Prisma__paymenttbClient<$Result.GetResult<Prisma.$paymenttbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Paymenttb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttbFindFirstOrThrowArgs} args - Arguments to find a Paymenttb
     * @example
     * // Get one Paymenttb
     * const paymenttb = await prisma.paymenttb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymenttbFindFirstOrThrowArgs>(args?: SelectSubset<T, paymenttbFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymenttbClient<$Result.GetResult<Prisma.$paymenttbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Paymenttbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paymenttbs
     * const paymenttbs = await prisma.paymenttb.findMany()
     * 
     * // Get first 10 Paymenttbs
     * const paymenttbs = await prisma.paymenttb.findMany({ take: 10 })
     * 
     * // Only select the `VoucherId`
     * const paymenttbWithVoucherIdOnly = await prisma.paymenttb.findMany({ select: { VoucherId: true } })
     * 
     */
    findMany<T extends paymenttbFindManyArgs>(args?: SelectSubset<T, paymenttbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymenttbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Paymenttb.
     * @param {paymenttbCreateArgs} args - Arguments to create a Paymenttb.
     * @example
     * // Create one Paymenttb
     * const Paymenttb = await prisma.paymenttb.create({
     *   data: {
     *     // ... data to create a Paymenttb
     *   }
     * })
     * 
     */
    create<T extends paymenttbCreateArgs>(args: SelectSubset<T, paymenttbCreateArgs<ExtArgs>>): Prisma__paymenttbClient<$Result.GetResult<Prisma.$paymenttbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Paymenttbs.
     * @param {paymenttbCreateManyArgs} args - Arguments to create many Paymenttbs.
     * @example
     * // Create many Paymenttbs
     * const paymenttb = await prisma.paymenttb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymenttbCreateManyArgs>(args?: SelectSubset<T, paymenttbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Paymenttb.
     * @param {paymenttbDeleteArgs} args - Arguments to delete one Paymenttb.
     * @example
     * // Delete one Paymenttb
     * const Paymenttb = await prisma.paymenttb.delete({
     *   where: {
     *     // ... filter to delete one Paymenttb
     *   }
     * })
     * 
     */
    delete<T extends paymenttbDeleteArgs>(args: SelectSubset<T, paymenttbDeleteArgs<ExtArgs>>): Prisma__paymenttbClient<$Result.GetResult<Prisma.$paymenttbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Paymenttb.
     * @param {paymenttbUpdateArgs} args - Arguments to update one Paymenttb.
     * @example
     * // Update one Paymenttb
     * const paymenttb = await prisma.paymenttb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymenttbUpdateArgs>(args: SelectSubset<T, paymenttbUpdateArgs<ExtArgs>>): Prisma__paymenttbClient<$Result.GetResult<Prisma.$paymenttbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Paymenttbs.
     * @param {paymenttbDeleteManyArgs} args - Arguments to filter Paymenttbs to delete.
     * @example
     * // Delete a few Paymenttbs
     * const { count } = await prisma.paymenttb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymenttbDeleteManyArgs>(args?: SelectSubset<T, paymenttbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paymenttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paymenttbs
     * const paymenttb = await prisma.paymenttb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymenttbUpdateManyArgs>(args: SelectSubset<T, paymenttbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paymenttb.
     * @param {paymenttbUpsertArgs} args - Arguments to update or create a Paymenttb.
     * @example
     * // Update or create a Paymenttb
     * const paymenttb = await prisma.paymenttb.upsert({
     *   create: {
     *     // ... data to create a Paymenttb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paymenttb we want to update
     *   }
     * })
     */
    upsert<T extends paymenttbUpsertArgs>(args: SelectSubset<T, paymenttbUpsertArgs<ExtArgs>>): Prisma__paymenttbClient<$Result.GetResult<Prisma.$paymenttbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Paymenttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttbCountArgs} args - Arguments to filter Paymenttbs to count.
     * @example
     * // Count the number of Paymenttbs
     * const count = await prisma.paymenttb.count({
     *   where: {
     *     // ... the filter for the Paymenttbs we want to count
     *   }
     * })
    **/
    count<T extends paymenttbCountArgs>(
      args?: Subset<T, paymenttbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymenttbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paymenttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymenttbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymenttbAggregateArgs>(args: Subset<T, PaymenttbAggregateArgs>): Prisma.PrismaPromise<GetPaymenttbAggregateType<T>>

    /**
     * Group by Paymenttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymenttbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymenttbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymenttbGroupByArgs['orderBy'] }
        : { orderBy?: paymenttbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymenttbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymenttbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paymenttb model
   */
  readonly fields: paymenttbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paymenttb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymenttbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paymenttb model
   */ 
  interface paymenttbFieldRefs {
    readonly VoucherId: FieldRef<"paymenttb", 'Int'>
    readonly UserId: FieldRef<"paymenttb", 'Int'>
    readonly VoucherNo: FieldRef<"paymenttb", 'String'>
    readonly VoucherDate: FieldRef<"paymenttb", 'DateTime'>
    readonly VoucherTime: FieldRef<"paymenttb", 'DateTime'>
    readonly ServeDate: FieldRef<"paymenttb", 'DateTime'>
    readonly ServeTime: FieldRef<"paymenttb", 'DateTime'>
    readonly Amount: FieldRef<"paymenttb", 'Decimal'>
    readonly AutoAmount: FieldRef<"paymenttb", 'Decimal'>
    readonly TimeTotal: FieldRef<"paymenttb", 'Int'>
    readonly Active: FieldRef<"paymenttb", 'Boolean'>
    readonly UserNote: FieldRef<"paymenttb", 'String'>
    readonly Note: FieldRef<"paymenttb", 'String'>
    readonly ServicePaid: FieldRef<"paymenttb", 'Boolean'>
    readonly StaffId: FieldRef<"paymenttb", 'Int'>
    readonly MachineName: FieldRef<"paymenttb", 'String'>
    readonly PaymentType: FieldRef<"paymenttb", 'Int'>
    readonly PaymentWaitId: FieldRef<"paymenttb", 'Int'>
    readonly zOid: FieldRef<"paymenttb", 'String'>
    readonly zTid: FieldRef<"paymenttb", 'String'>
    readonly zSig: FieldRef<"paymenttb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * paymenttb findUnique
   */
  export type paymenttbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
    /**
     * Filter, which paymenttb to fetch.
     */
    where: paymenttbWhereUniqueInput
  }

  /**
   * paymenttb findUniqueOrThrow
   */
  export type paymenttbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
    /**
     * Filter, which paymenttb to fetch.
     */
    where: paymenttbWhereUniqueInput
  }

  /**
   * paymenttb findFirst
   */
  export type paymenttbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
    /**
     * Filter, which paymenttb to fetch.
     */
    where?: paymenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymenttbs to fetch.
     */
    orderBy?: paymenttbOrderByWithRelationInput | paymenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paymenttbs.
     */
    cursor?: paymenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymenttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paymenttbs.
     */
    distinct?: PaymenttbScalarFieldEnum | PaymenttbScalarFieldEnum[]
  }

  /**
   * paymenttb findFirstOrThrow
   */
  export type paymenttbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
    /**
     * Filter, which paymenttb to fetch.
     */
    where?: paymenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymenttbs to fetch.
     */
    orderBy?: paymenttbOrderByWithRelationInput | paymenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paymenttbs.
     */
    cursor?: paymenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymenttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paymenttbs.
     */
    distinct?: PaymenttbScalarFieldEnum | PaymenttbScalarFieldEnum[]
  }

  /**
   * paymenttb findMany
   */
  export type paymenttbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
    /**
     * Filter, which paymenttbs to fetch.
     */
    where?: paymenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymenttbs to fetch.
     */
    orderBy?: paymenttbOrderByWithRelationInput | paymenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paymenttbs.
     */
    cursor?: paymenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymenttbs.
     */
    skip?: number
    distinct?: PaymenttbScalarFieldEnum | PaymenttbScalarFieldEnum[]
  }

  /**
   * paymenttb create
   */
  export type paymenttbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
    /**
     * The data needed to create a paymenttb.
     */
    data: XOR<paymenttbCreateInput, paymenttbUncheckedCreateInput>
  }

  /**
   * paymenttb createMany
   */
  export type paymenttbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paymenttbs.
     */
    data: paymenttbCreateManyInput | paymenttbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paymenttb update
   */
  export type paymenttbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
    /**
     * The data needed to update a paymenttb.
     */
    data: XOR<paymenttbUpdateInput, paymenttbUncheckedUpdateInput>
    /**
     * Choose, which paymenttb to update.
     */
    where: paymenttbWhereUniqueInput
  }

  /**
   * paymenttb updateMany
   */
  export type paymenttbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paymenttbs.
     */
    data: XOR<paymenttbUpdateManyMutationInput, paymenttbUncheckedUpdateManyInput>
    /**
     * Filter which paymenttbs to update
     */
    where?: paymenttbWhereInput
  }

  /**
   * paymenttb upsert
   */
  export type paymenttbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
    /**
     * The filter to search for the paymenttb to update in case it exists.
     */
    where: paymenttbWhereUniqueInput
    /**
     * In case the paymenttb found by the `where` argument doesn't exist, create a new paymenttb with this data.
     */
    create: XOR<paymenttbCreateInput, paymenttbUncheckedCreateInput>
    /**
     * In case the paymenttb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymenttbUpdateInput, paymenttbUncheckedUpdateInput>
  }

  /**
   * paymenttb delete
   */
  export type paymenttbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
    /**
     * Filter which paymenttb to delete.
     */
    where: paymenttbWhereUniqueInput
  }

  /**
   * paymenttb deleteMany
   */
  export type paymenttbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paymenttbs to delete
     */
    where?: paymenttbWhereInput
  }

  /**
   * paymenttb without action
   */
  export type paymenttbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymenttb
     */
    select?: paymenttbSelect<ExtArgs> | null
  }


  /**
   * Model paymentwaittb
   */

  export type AggregatePaymentwaittb = {
    _count: PaymentwaittbCountAggregateOutputType | null
    _avg: PaymentwaittbAvgAggregateOutputType | null
    _sum: PaymentwaittbSumAggregateOutputType | null
    _min: PaymentwaittbMinAggregateOutputType | null
    _max: PaymentwaittbMaxAggregateOutputType | null
  }

  export type PaymentwaittbAvgAggregateOutputType = {
    PaymentWaitId: number | null
    TotalTimeUsed: number | null
    TotalTimeFee: number | null
    TimeFee: Decimal | null
    TimeUsed: number | null
    RemainTime: number | null
    TimePaid: number | null
    FreeTime: number | null
    ChangePCSessionId: number | null
    AnonymId: number | null
    PriceGroupId: number | null
    MachineGroupId: number | null
    PriceAppRentID: number | null
  }

  export type PaymentwaittbSumAggregateOutputType = {
    PaymentWaitId: number | null
    TotalTimeUsed: number | null
    TotalTimeFee: number | null
    TimeFee: Decimal | null
    TimeUsed: number | null
    RemainTime: number | null
    TimePaid: number | null
    FreeTime: number | null
    ChangePCSessionId: number | null
    AnonymId: number | null
    PriceGroupId: number | null
    MachineGroupId: number | null
    PriceAppRentID: number | null
  }

  export type PaymentwaittbMinAggregateOutputType = {
    PaymentWaitId: number | null
    MachineName: string | null
    TotalTimeUsed: number | null
    TotalTimeFee: number | null
    BeginTime: Date | null
    EndTime: Date | null
    TimeFee: Decimal | null
    TimeUsed: number | null
    RemainTime: number | null
    TimePaid: number | null
    FreeTime: number | null
    ChangePCSessionId: number | null
    AnonymId: number | null
    PriceGroupId: number | null
    MachineGroupId: number | null
    Note: string | null
    PriceAppRentID: number | null
  }

  export type PaymentwaittbMaxAggregateOutputType = {
    PaymentWaitId: number | null
    MachineName: string | null
    TotalTimeUsed: number | null
    TotalTimeFee: number | null
    BeginTime: Date | null
    EndTime: Date | null
    TimeFee: Decimal | null
    TimeUsed: number | null
    RemainTime: number | null
    TimePaid: number | null
    FreeTime: number | null
    ChangePCSessionId: number | null
    AnonymId: number | null
    PriceGroupId: number | null
    MachineGroupId: number | null
    Note: string | null
    PriceAppRentID: number | null
  }

  export type PaymentwaittbCountAggregateOutputType = {
    PaymentWaitId: number
    MachineName: number
    TotalTimeUsed: number
    TotalTimeFee: number
    BeginTime: number
    EndTime: number
    TimeFee: number
    TimeUsed: number
    RemainTime: number
    TimePaid: number
    FreeTime: number
    ChangePCSessionId: number
    AnonymId: number
    PriceGroupId: number
    MachineGroupId: number
    Note: number
    PriceAppRentID: number
    _all: number
  }


  export type PaymentwaittbAvgAggregateInputType = {
    PaymentWaitId?: true
    TotalTimeUsed?: true
    TotalTimeFee?: true
    TimeFee?: true
    TimeUsed?: true
    RemainTime?: true
    TimePaid?: true
    FreeTime?: true
    ChangePCSessionId?: true
    AnonymId?: true
    PriceGroupId?: true
    MachineGroupId?: true
    PriceAppRentID?: true
  }

  export type PaymentwaittbSumAggregateInputType = {
    PaymentWaitId?: true
    TotalTimeUsed?: true
    TotalTimeFee?: true
    TimeFee?: true
    TimeUsed?: true
    RemainTime?: true
    TimePaid?: true
    FreeTime?: true
    ChangePCSessionId?: true
    AnonymId?: true
    PriceGroupId?: true
    MachineGroupId?: true
    PriceAppRentID?: true
  }

  export type PaymentwaittbMinAggregateInputType = {
    PaymentWaitId?: true
    MachineName?: true
    TotalTimeUsed?: true
    TotalTimeFee?: true
    BeginTime?: true
    EndTime?: true
    TimeFee?: true
    TimeUsed?: true
    RemainTime?: true
    TimePaid?: true
    FreeTime?: true
    ChangePCSessionId?: true
    AnonymId?: true
    PriceGroupId?: true
    MachineGroupId?: true
    Note?: true
    PriceAppRentID?: true
  }

  export type PaymentwaittbMaxAggregateInputType = {
    PaymentWaitId?: true
    MachineName?: true
    TotalTimeUsed?: true
    TotalTimeFee?: true
    BeginTime?: true
    EndTime?: true
    TimeFee?: true
    TimeUsed?: true
    RemainTime?: true
    TimePaid?: true
    FreeTime?: true
    ChangePCSessionId?: true
    AnonymId?: true
    PriceGroupId?: true
    MachineGroupId?: true
    Note?: true
    PriceAppRentID?: true
  }

  export type PaymentwaittbCountAggregateInputType = {
    PaymentWaitId?: true
    MachineName?: true
    TotalTimeUsed?: true
    TotalTimeFee?: true
    BeginTime?: true
    EndTime?: true
    TimeFee?: true
    TimeUsed?: true
    RemainTime?: true
    TimePaid?: true
    FreeTime?: true
    ChangePCSessionId?: true
    AnonymId?: true
    PriceGroupId?: true
    MachineGroupId?: true
    Note?: true
    PriceAppRentID?: true
    _all?: true
  }

  export type PaymentwaittbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paymentwaittb to aggregate.
     */
    where?: paymentwaittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymentwaittbs to fetch.
     */
    orderBy?: paymentwaittbOrderByWithRelationInput | paymentwaittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentwaittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymentwaittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymentwaittbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paymentwaittbs
    **/
    _count?: true | PaymentwaittbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentwaittbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentwaittbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentwaittbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentwaittbMaxAggregateInputType
  }

  export type GetPaymentwaittbAggregateType<T extends PaymentwaittbAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentwaittb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentwaittb[P]>
      : GetScalarType<T[P], AggregatePaymentwaittb[P]>
  }




  export type paymentwaittbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentwaittbWhereInput
    orderBy?: paymentwaittbOrderByWithAggregationInput | paymentwaittbOrderByWithAggregationInput[]
    by: PaymentwaittbScalarFieldEnum[] | PaymentwaittbScalarFieldEnum
    having?: paymentwaittbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentwaittbCountAggregateInputType | true
    _avg?: PaymentwaittbAvgAggregateInputType
    _sum?: PaymentwaittbSumAggregateInputType
    _min?: PaymentwaittbMinAggregateInputType
    _max?: PaymentwaittbMaxAggregateInputType
  }

  export type PaymentwaittbGroupByOutputType = {
    PaymentWaitId: number
    MachineName: string
    TotalTimeUsed: number
    TotalTimeFee: number
    BeginTime: Date
    EndTime: Date
    TimeFee: Decimal
    TimeUsed: number
    RemainTime: number
    TimePaid: number
    FreeTime: number
    ChangePCSessionId: number
    AnonymId: number
    PriceGroupId: number
    MachineGroupId: number
    Note: string
    PriceAppRentID: number
    _count: PaymentwaittbCountAggregateOutputType | null
    _avg: PaymentwaittbAvgAggregateOutputType | null
    _sum: PaymentwaittbSumAggregateOutputType | null
    _min: PaymentwaittbMinAggregateOutputType | null
    _max: PaymentwaittbMaxAggregateOutputType | null
  }

  type GetPaymentwaittbGroupByPayload<T extends paymentwaittbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentwaittbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentwaittbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentwaittbGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentwaittbGroupByOutputType[P]>
        }
      >
    >


  export type paymentwaittbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PaymentWaitId?: boolean
    MachineName?: boolean
    TotalTimeUsed?: boolean
    TotalTimeFee?: boolean
    BeginTime?: boolean
    EndTime?: boolean
    TimeFee?: boolean
    TimeUsed?: boolean
    RemainTime?: boolean
    TimePaid?: boolean
    FreeTime?: boolean
    ChangePCSessionId?: boolean
    AnonymId?: boolean
    PriceGroupId?: boolean
    MachineGroupId?: boolean
    Note?: boolean
    PriceAppRentID?: boolean
  }, ExtArgs["result"]["paymentwaittb"]>


  export type paymentwaittbSelectScalar = {
    PaymentWaitId?: boolean
    MachineName?: boolean
    TotalTimeUsed?: boolean
    TotalTimeFee?: boolean
    BeginTime?: boolean
    EndTime?: boolean
    TimeFee?: boolean
    TimeUsed?: boolean
    RemainTime?: boolean
    TimePaid?: boolean
    FreeTime?: boolean
    ChangePCSessionId?: boolean
    AnonymId?: boolean
    PriceGroupId?: boolean
    MachineGroupId?: boolean
    Note?: boolean
    PriceAppRentID?: boolean
  }


  export type $paymentwaittbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paymentwaittb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      PaymentWaitId: number
      MachineName: string
      TotalTimeUsed: number
      TotalTimeFee: number
      BeginTime: Date
      EndTime: Date
      TimeFee: Prisma.Decimal
      TimeUsed: number
      RemainTime: number
      TimePaid: number
      FreeTime: number
      ChangePCSessionId: number
      AnonymId: number
      PriceGroupId: number
      MachineGroupId: number
      Note: string
      PriceAppRentID: number
    }, ExtArgs["result"]["paymentwaittb"]>
    composites: {}
  }

  type paymentwaittbGetPayload<S extends boolean | null | undefined | paymentwaittbDefaultArgs> = $Result.GetResult<Prisma.$paymentwaittbPayload, S>

  type paymentwaittbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<paymentwaittbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentwaittbCountAggregateInputType | true
    }

  export interface paymentwaittbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paymentwaittb'], meta: { name: 'paymentwaittb' } }
    /**
     * Find zero or one Paymentwaittb that matches the filter.
     * @param {paymentwaittbFindUniqueArgs} args - Arguments to find a Paymentwaittb
     * @example
     * // Get one Paymentwaittb
     * const paymentwaittb = await prisma.paymentwaittb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentwaittbFindUniqueArgs>(args: SelectSubset<T, paymentwaittbFindUniqueArgs<ExtArgs>>): Prisma__paymentwaittbClient<$Result.GetResult<Prisma.$paymentwaittbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Paymentwaittb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {paymentwaittbFindUniqueOrThrowArgs} args - Arguments to find a Paymentwaittb
     * @example
     * // Get one Paymentwaittb
     * const paymentwaittb = await prisma.paymentwaittb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentwaittbFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentwaittbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentwaittbClient<$Result.GetResult<Prisma.$paymentwaittbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Paymentwaittb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentwaittbFindFirstArgs} args - Arguments to find a Paymentwaittb
     * @example
     * // Get one Paymentwaittb
     * const paymentwaittb = await prisma.paymentwaittb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentwaittbFindFirstArgs>(args?: SelectSubset<T, paymentwaittbFindFirstArgs<ExtArgs>>): Prisma__paymentwaittbClient<$Result.GetResult<Prisma.$paymentwaittbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Paymentwaittb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentwaittbFindFirstOrThrowArgs} args - Arguments to find a Paymentwaittb
     * @example
     * // Get one Paymentwaittb
     * const paymentwaittb = await prisma.paymentwaittb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentwaittbFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentwaittbFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentwaittbClient<$Result.GetResult<Prisma.$paymentwaittbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Paymentwaittbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentwaittbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paymentwaittbs
     * const paymentwaittbs = await prisma.paymentwaittb.findMany()
     * 
     * // Get first 10 Paymentwaittbs
     * const paymentwaittbs = await prisma.paymentwaittb.findMany({ take: 10 })
     * 
     * // Only select the `PaymentWaitId`
     * const paymentwaittbWithPaymentWaitIdOnly = await prisma.paymentwaittb.findMany({ select: { PaymentWaitId: true } })
     * 
     */
    findMany<T extends paymentwaittbFindManyArgs>(args?: SelectSubset<T, paymentwaittbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentwaittbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Paymentwaittb.
     * @param {paymentwaittbCreateArgs} args - Arguments to create a Paymentwaittb.
     * @example
     * // Create one Paymentwaittb
     * const Paymentwaittb = await prisma.paymentwaittb.create({
     *   data: {
     *     // ... data to create a Paymentwaittb
     *   }
     * })
     * 
     */
    create<T extends paymentwaittbCreateArgs>(args: SelectSubset<T, paymentwaittbCreateArgs<ExtArgs>>): Prisma__paymentwaittbClient<$Result.GetResult<Prisma.$paymentwaittbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Paymentwaittbs.
     * @param {paymentwaittbCreateManyArgs} args - Arguments to create many Paymentwaittbs.
     * @example
     * // Create many Paymentwaittbs
     * const paymentwaittb = await prisma.paymentwaittb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentwaittbCreateManyArgs>(args?: SelectSubset<T, paymentwaittbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Paymentwaittb.
     * @param {paymentwaittbDeleteArgs} args - Arguments to delete one Paymentwaittb.
     * @example
     * // Delete one Paymentwaittb
     * const Paymentwaittb = await prisma.paymentwaittb.delete({
     *   where: {
     *     // ... filter to delete one Paymentwaittb
     *   }
     * })
     * 
     */
    delete<T extends paymentwaittbDeleteArgs>(args: SelectSubset<T, paymentwaittbDeleteArgs<ExtArgs>>): Prisma__paymentwaittbClient<$Result.GetResult<Prisma.$paymentwaittbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Paymentwaittb.
     * @param {paymentwaittbUpdateArgs} args - Arguments to update one Paymentwaittb.
     * @example
     * // Update one Paymentwaittb
     * const paymentwaittb = await prisma.paymentwaittb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentwaittbUpdateArgs>(args: SelectSubset<T, paymentwaittbUpdateArgs<ExtArgs>>): Prisma__paymentwaittbClient<$Result.GetResult<Prisma.$paymentwaittbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Paymentwaittbs.
     * @param {paymentwaittbDeleteManyArgs} args - Arguments to filter Paymentwaittbs to delete.
     * @example
     * // Delete a few Paymentwaittbs
     * const { count } = await prisma.paymentwaittb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentwaittbDeleteManyArgs>(args?: SelectSubset<T, paymentwaittbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paymentwaittbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentwaittbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paymentwaittbs
     * const paymentwaittb = await prisma.paymentwaittb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentwaittbUpdateManyArgs>(args: SelectSubset<T, paymentwaittbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Paymentwaittb.
     * @param {paymentwaittbUpsertArgs} args - Arguments to update or create a Paymentwaittb.
     * @example
     * // Update or create a Paymentwaittb
     * const paymentwaittb = await prisma.paymentwaittb.upsert({
     *   create: {
     *     // ... data to create a Paymentwaittb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paymentwaittb we want to update
     *   }
     * })
     */
    upsert<T extends paymentwaittbUpsertArgs>(args: SelectSubset<T, paymentwaittbUpsertArgs<ExtArgs>>): Prisma__paymentwaittbClient<$Result.GetResult<Prisma.$paymentwaittbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Paymentwaittbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentwaittbCountArgs} args - Arguments to filter Paymentwaittbs to count.
     * @example
     * // Count the number of Paymentwaittbs
     * const count = await prisma.paymentwaittb.count({
     *   where: {
     *     // ... the filter for the Paymentwaittbs we want to count
     *   }
     * })
    **/
    count<T extends paymentwaittbCountArgs>(
      args?: Subset<T, paymentwaittbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentwaittbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paymentwaittb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentwaittbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentwaittbAggregateArgs>(args: Subset<T, PaymentwaittbAggregateArgs>): Prisma.PrismaPromise<GetPaymentwaittbAggregateType<T>>

    /**
     * Group by Paymentwaittb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentwaittbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentwaittbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentwaittbGroupByArgs['orderBy'] }
        : { orderBy?: paymentwaittbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentwaittbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentwaittbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paymentwaittb model
   */
  readonly fields: paymentwaittbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paymentwaittb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentwaittbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paymentwaittb model
   */ 
  interface paymentwaittbFieldRefs {
    readonly PaymentWaitId: FieldRef<"paymentwaittb", 'Int'>
    readonly MachineName: FieldRef<"paymentwaittb", 'String'>
    readonly TotalTimeUsed: FieldRef<"paymentwaittb", 'Int'>
    readonly TotalTimeFee: FieldRef<"paymentwaittb", 'Int'>
    readonly BeginTime: FieldRef<"paymentwaittb", 'DateTime'>
    readonly EndTime: FieldRef<"paymentwaittb", 'DateTime'>
    readonly TimeFee: FieldRef<"paymentwaittb", 'Decimal'>
    readonly TimeUsed: FieldRef<"paymentwaittb", 'Int'>
    readonly RemainTime: FieldRef<"paymentwaittb", 'Int'>
    readonly TimePaid: FieldRef<"paymentwaittb", 'Int'>
    readonly FreeTime: FieldRef<"paymentwaittb", 'Int'>
    readonly ChangePCSessionId: FieldRef<"paymentwaittb", 'Int'>
    readonly AnonymId: FieldRef<"paymentwaittb", 'Int'>
    readonly PriceGroupId: FieldRef<"paymentwaittb", 'Int'>
    readonly MachineGroupId: FieldRef<"paymentwaittb", 'Int'>
    readonly Note: FieldRef<"paymentwaittb", 'String'>
    readonly PriceAppRentID: FieldRef<"paymentwaittb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * paymentwaittb findUnique
   */
  export type paymentwaittbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
    /**
     * Filter, which paymentwaittb to fetch.
     */
    where: paymentwaittbWhereUniqueInput
  }

  /**
   * paymentwaittb findUniqueOrThrow
   */
  export type paymentwaittbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
    /**
     * Filter, which paymentwaittb to fetch.
     */
    where: paymentwaittbWhereUniqueInput
  }

  /**
   * paymentwaittb findFirst
   */
  export type paymentwaittbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
    /**
     * Filter, which paymentwaittb to fetch.
     */
    where?: paymentwaittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymentwaittbs to fetch.
     */
    orderBy?: paymentwaittbOrderByWithRelationInput | paymentwaittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paymentwaittbs.
     */
    cursor?: paymentwaittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymentwaittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymentwaittbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paymentwaittbs.
     */
    distinct?: PaymentwaittbScalarFieldEnum | PaymentwaittbScalarFieldEnum[]
  }

  /**
   * paymentwaittb findFirstOrThrow
   */
  export type paymentwaittbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
    /**
     * Filter, which paymentwaittb to fetch.
     */
    where?: paymentwaittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymentwaittbs to fetch.
     */
    orderBy?: paymentwaittbOrderByWithRelationInput | paymentwaittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paymentwaittbs.
     */
    cursor?: paymentwaittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymentwaittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymentwaittbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paymentwaittbs.
     */
    distinct?: PaymentwaittbScalarFieldEnum | PaymentwaittbScalarFieldEnum[]
  }

  /**
   * paymentwaittb findMany
   */
  export type paymentwaittbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
    /**
     * Filter, which paymentwaittbs to fetch.
     */
    where?: paymentwaittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paymentwaittbs to fetch.
     */
    orderBy?: paymentwaittbOrderByWithRelationInput | paymentwaittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paymentwaittbs.
     */
    cursor?: paymentwaittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paymentwaittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paymentwaittbs.
     */
    skip?: number
    distinct?: PaymentwaittbScalarFieldEnum | PaymentwaittbScalarFieldEnum[]
  }

  /**
   * paymentwaittb create
   */
  export type paymentwaittbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
    /**
     * The data needed to create a paymentwaittb.
     */
    data?: XOR<paymentwaittbCreateInput, paymentwaittbUncheckedCreateInput>
  }

  /**
   * paymentwaittb createMany
   */
  export type paymentwaittbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paymentwaittbs.
     */
    data: paymentwaittbCreateManyInput | paymentwaittbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paymentwaittb update
   */
  export type paymentwaittbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
    /**
     * The data needed to update a paymentwaittb.
     */
    data: XOR<paymentwaittbUpdateInput, paymentwaittbUncheckedUpdateInput>
    /**
     * Choose, which paymentwaittb to update.
     */
    where: paymentwaittbWhereUniqueInput
  }

  /**
   * paymentwaittb updateMany
   */
  export type paymentwaittbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paymentwaittbs.
     */
    data: XOR<paymentwaittbUpdateManyMutationInput, paymentwaittbUncheckedUpdateManyInput>
    /**
     * Filter which paymentwaittbs to update
     */
    where?: paymentwaittbWhereInput
  }

  /**
   * paymentwaittb upsert
   */
  export type paymentwaittbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
    /**
     * The filter to search for the paymentwaittb to update in case it exists.
     */
    where: paymentwaittbWhereUniqueInput
    /**
     * In case the paymentwaittb found by the `where` argument doesn't exist, create a new paymentwaittb with this data.
     */
    create: XOR<paymentwaittbCreateInput, paymentwaittbUncheckedCreateInput>
    /**
     * In case the paymentwaittb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentwaittbUpdateInput, paymentwaittbUncheckedUpdateInput>
  }

  /**
   * paymentwaittb delete
   */
  export type paymentwaittbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
    /**
     * Filter which paymentwaittb to delete.
     */
    where: paymentwaittbWhereUniqueInput
  }

  /**
   * paymentwaittb deleteMany
   */
  export type paymentwaittbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paymentwaittbs to delete
     */
    where?: paymentwaittbWhereInput
  }

  /**
   * paymentwaittb without action
   */
  export type paymentwaittbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paymentwaittb
     */
    select?: paymentwaittbSelect<ExtArgs> | null
  }


  /**
   * Model priceapprenttb
   */

  export type AggregatePriceapprenttb = {
    _count: PriceapprenttbCountAggregateOutputType | null
    _avg: PriceapprenttbAvgAggregateOutputType | null
    _sum: PriceapprenttbSumAggregateOutputType | null
    _min: PriceapprenttbMinAggregateOutputType | null
    _max: PriceapprenttbMaxAggregateOutputType | null
  }

  export type PriceapprenttbAvgAggregateOutputType = {
    PriceAppRentID: number | null
    PriceID: number | null
    MachineGroupID: number | null
    Price: Decimal | null
    Status: number | null
  }

  export type PriceapprenttbSumAggregateOutputType = {
    PriceAppRentID: number | null
    PriceID: number | null
    MachineGroupID: number | null
    Price: Decimal | null
    Status: number | null
  }

  export type PriceapprenttbMinAggregateOutputType = {
    PriceAppRentID: number | null
    PriceID: number | null
    MachineGroupID: number | null
    Name: string | null
    Price: Decimal | null
    Status: number | null
  }

  export type PriceapprenttbMaxAggregateOutputType = {
    PriceAppRentID: number | null
    PriceID: number | null
    MachineGroupID: number | null
    Name: string | null
    Price: Decimal | null
    Status: number | null
  }

  export type PriceapprenttbCountAggregateOutputType = {
    PriceAppRentID: number
    PriceID: number
    MachineGroupID: number
    Name: number
    Price: number
    Status: number
    _all: number
  }


  export type PriceapprenttbAvgAggregateInputType = {
    PriceAppRentID?: true
    PriceID?: true
    MachineGroupID?: true
    Price?: true
    Status?: true
  }

  export type PriceapprenttbSumAggregateInputType = {
    PriceAppRentID?: true
    PriceID?: true
    MachineGroupID?: true
    Price?: true
    Status?: true
  }

  export type PriceapprenttbMinAggregateInputType = {
    PriceAppRentID?: true
    PriceID?: true
    MachineGroupID?: true
    Name?: true
    Price?: true
    Status?: true
  }

  export type PriceapprenttbMaxAggregateInputType = {
    PriceAppRentID?: true
    PriceID?: true
    MachineGroupID?: true
    Name?: true
    Price?: true
    Status?: true
  }

  export type PriceapprenttbCountAggregateInputType = {
    PriceAppRentID?: true
    PriceID?: true
    MachineGroupID?: true
    Name?: true
    Price?: true
    Status?: true
    _all?: true
  }

  export type PriceapprenttbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which priceapprenttb to aggregate.
     */
    where?: priceapprenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priceapprenttbs to fetch.
     */
    orderBy?: priceapprenttbOrderByWithRelationInput | priceapprenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: priceapprenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priceapprenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priceapprenttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned priceapprenttbs
    **/
    _count?: true | PriceapprenttbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceapprenttbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceapprenttbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceapprenttbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceapprenttbMaxAggregateInputType
  }

  export type GetPriceapprenttbAggregateType<T extends PriceapprenttbAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceapprenttb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceapprenttb[P]>
      : GetScalarType<T[P], AggregatePriceapprenttb[P]>
  }




  export type priceapprenttbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: priceapprenttbWhereInput
    orderBy?: priceapprenttbOrderByWithAggregationInput | priceapprenttbOrderByWithAggregationInput[]
    by: PriceapprenttbScalarFieldEnum[] | PriceapprenttbScalarFieldEnum
    having?: priceapprenttbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceapprenttbCountAggregateInputType | true
    _avg?: PriceapprenttbAvgAggregateInputType
    _sum?: PriceapprenttbSumAggregateInputType
    _min?: PriceapprenttbMinAggregateInputType
    _max?: PriceapprenttbMaxAggregateInputType
  }

  export type PriceapprenttbGroupByOutputType = {
    PriceAppRentID: number
    PriceID: number
    MachineGroupID: number
    Name: string
    Price: Decimal
    Status: number
    _count: PriceapprenttbCountAggregateOutputType | null
    _avg: PriceapprenttbAvgAggregateOutputType | null
    _sum: PriceapprenttbSumAggregateOutputType | null
    _min: PriceapprenttbMinAggregateOutputType | null
    _max: PriceapprenttbMaxAggregateOutputType | null
  }

  type GetPriceapprenttbGroupByPayload<T extends priceapprenttbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceapprenttbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceapprenttbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceapprenttbGroupByOutputType[P]>
            : GetScalarType<T[P], PriceapprenttbGroupByOutputType[P]>
        }
      >
    >


  export type priceapprenttbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PriceAppRentID?: boolean
    PriceID?: boolean
    MachineGroupID?: boolean
    Name?: boolean
    Price?: boolean
    Status?: boolean
  }, ExtArgs["result"]["priceapprenttb"]>


  export type priceapprenttbSelectScalar = {
    PriceAppRentID?: boolean
    PriceID?: boolean
    MachineGroupID?: boolean
    Name?: boolean
    Price?: boolean
    Status?: boolean
  }


  export type $priceapprenttbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "priceapprenttb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      PriceAppRentID: number
      PriceID: number
      MachineGroupID: number
      Name: string
      Price: Prisma.Decimal
      Status: number
    }, ExtArgs["result"]["priceapprenttb"]>
    composites: {}
  }

  type priceapprenttbGetPayload<S extends boolean | null | undefined | priceapprenttbDefaultArgs> = $Result.GetResult<Prisma.$priceapprenttbPayload, S>

  type priceapprenttbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<priceapprenttbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceapprenttbCountAggregateInputType | true
    }

  export interface priceapprenttbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['priceapprenttb'], meta: { name: 'priceapprenttb' } }
    /**
     * Find zero or one Priceapprenttb that matches the filter.
     * @param {priceapprenttbFindUniqueArgs} args - Arguments to find a Priceapprenttb
     * @example
     * // Get one Priceapprenttb
     * const priceapprenttb = await prisma.priceapprenttb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends priceapprenttbFindUniqueArgs>(args: SelectSubset<T, priceapprenttbFindUniqueArgs<ExtArgs>>): Prisma__priceapprenttbClient<$Result.GetResult<Prisma.$priceapprenttbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Priceapprenttb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {priceapprenttbFindUniqueOrThrowArgs} args - Arguments to find a Priceapprenttb
     * @example
     * // Get one Priceapprenttb
     * const priceapprenttb = await prisma.priceapprenttb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends priceapprenttbFindUniqueOrThrowArgs>(args: SelectSubset<T, priceapprenttbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__priceapprenttbClient<$Result.GetResult<Prisma.$priceapprenttbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Priceapprenttb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprenttbFindFirstArgs} args - Arguments to find a Priceapprenttb
     * @example
     * // Get one Priceapprenttb
     * const priceapprenttb = await prisma.priceapprenttb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends priceapprenttbFindFirstArgs>(args?: SelectSubset<T, priceapprenttbFindFirstArgs<ExtArgs>>): Prisma__priceapprenttbClient<$Result.GetResult<Prisma.$priceapprenttbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Priceapprenttb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprenttbFindFirstOrThrowArgs} args - Arguments to find a Priceapprenttb
     * @example
     * // Get one Priceapprenttb
     * const priceapprenttb = await prisma.priceapprenttb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends priceapprenttbFindFirstOrThrowArgs>(args?: SelectSubset<T, priceapprenttbFindFirstOrThrowArgs<ExtArgs>>): Prisma__priceapprenttbClient<$Result.GetResult<Prisma.$priceapprenttbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Priceapprenttbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprenttbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Priceapprenttbs
     * const priceapprenttbs = await prisma.priceapprenttb.findMany()
     * 
     * // Get first 10 Priceapprenttbs
     * const priceapprenttbs = await prisma.priceapprenttb.findMany({ take: 10 })
     * 
     * // Only select the `PriceAppRentID`
     * const priceapprenttbWithPriceAppRentIDOnly = await prisma.priceapprenttb.findMany({ select: { PriceAppRentID: true } })
     * 
     */
    findMany<T extends priceapprenttbFindManyArgs>(args?: SelectSubset<T, priceapprenttbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$priceapprenttbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Priceapprenttb.
     * @param {priceapprenttbCreateArgs} args - Arguments to create a Priceapprenttb.
     * @example
     * // Create one Priceapprenttb
     * const Priceapprenttb = await prisma.priceapprenttb.create({
     *   data: {
     *     // ... data to create a Priceapprenttb
     *   }
     * })
     * 
     */
    create<T extends priceapprenttbCreateArgs>(args: SelectSubset<T, priceapprenttbCreateArgs<ExtArgs>>): Prisma__priceapprenttbClient<$Result.GetResult<Prisma.$priceapprenttbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Priceapprenttbs.
     * @param {priceapprenttbCreateManyArgs} args - Arguments to create many Priceapprenttbs.
     * @example
     * // Create many Priceapprenttbs
     * const priceapprenttb = await prisma.priceapprenttb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends priceapprenttbCreateManyArgs>(args?: SelectSubset<T, priceapprenttbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Priceapprenttb.
     * @param {priceapprenttbDeleteArgs} args - Arguments to delete one Priceapprenttb.
     * @example
     * // Delete one Priceapprenttb
     * const Priceapprenttb = await prisma.priceapprenttb.delete({
     *   where: {
     *     // ... filter to delete one Priceapprenttb
     *   }
     * })
     * 
     */
    delete<T extends priceapprenttbDeleteArgs>(args: SelectSubset<T, priceapprenttbDeleteArgs<ExtArgs>>): Prisma__priceapprenttbClient<$Result.GetResult<Prisma.$priceapprenttbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Priceapprenttb.
     * @param {priceapprenttbUpdateArgs} args - Arguments to update one Priceapprenttb.
     * @example
     * // Update one Priceapprenttb
     * const priceapprenttb = await prisma.priceapprenttb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends priceapprenttbUpdateArgs>(args: SelectSubset<T, priceapprenttbUpdateArgs<ExtArgs>>): Prisma__priceapprenttbClient<$Result.GetResult<Prisma.$priceapprenttbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Priceapprenttbs.
     * @param {priceapprenttbDeleteManyArgs} args - Arguments to filter Priceapprenttbs to delete.
     * @example
     * // Delete a few Priceapprenttbs
     * const { count } = await prisma.priceapprenttb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends priceapprenttbDeleteManyArgs>(args?: SelectSubset<T, priceapprenttbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Priceapprenttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprenttbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Priceapprenttbs
     * const priceapprenttb = await prisma.priceapprenttb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends priceapprenttbUpdateManyArgs>(args: SelectSubset<T, priceapprenttbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Priceapprenttb.
     * @param {priceapprenttbUpsertArgs} args - Arguments to update or create a Priceapprenttb.
     * @example
     * // Update or create a Priceapprenttb
     * const priceapprenttb = await prisma.priceapprenttb.upsert({
     *   create: {
     *     // ... data to create a Priceapprenttb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Priceapprenttb we want to update
     *   }
     * })
     */
    upsert<T extends priceapprenttbUpsertArgs>(args: SelectSubset<T, priceapprenttbUpsertArgs<ExtArgs>>): Prisma__priceapprenttbClient<$Result.GetResult<Prisma.$priceapprenttbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Priceapprenttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprenttbCountArgs} args - Arguments to filter Priceapprenttbs to count.
     * @example
     * // Count the number of Priceapprenttbs
     * const count = await prisma.priceapprenttb.count({
     *   where: {
     *     // ... the filter for the Priceapprenttbs we want to count
     *   }
     * })
    **/
    count<T extends priceapprenttbCountArgs>(
      args?: Subset<T, priceapprenttbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceapprenttbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Priceapprenttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceapprenttbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceapprenttbAggregateArgs>(args: Subset<T, PriceapprenttbAggregateArgs>): Prisma.PrismaPromise<GetPriceapprenttbAggregateType<T>>

    /**
     * Group by Priceapprenttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprenttbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends priceapprenttbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: priceapprenttbGroupByArgs['orderBy'] }
        : { orderBy?: priceapprenttbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, priceapprenttbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceapprenttbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the priceapprenttb model
   */
  readonly fields: priceapprenttbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for priceapprenttb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__priceapprenttbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the priceapprenttb model
   */ 
  interface priceapprenttbFieldRefs {
    readonly PriceAppRentID: FieldRef<"priceapprenttb", 'Int'>
    readonly PriceID: FieldRef<"priceapprenttb", 'Int'>
    readonly MachineGroupID: FieldRef<"priceapprenttb", 'Int'>
    readonly Name: FieldRef<"priceapprenttb", 'String'>
    readonly Price: FieldRef<"priceapprenttb", 'Decimal'>
    readonly Status: FieldRef<"priceapprenttb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * priceapprenttb findUnique
   */
  export type priceapprenttbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprenttb to fetch.
     */
    where: priceapprenttbWhereUniqueInput
  }

  /**
   * priceapprenttb findUniqueOrThrow
   */
  export type priceapprenttbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprenttb to fetch.
     */
    where: priceapprenttbWhereUniqueInput
  }

  /**
   * priceapprenttb findFirst
   */
  export type priceapprenttbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprenttb to fetch.
     */
    where?: priceapprenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priceapprenttbs to fetch.
     */
    orderBy?: priceapprenttbOrderByWithRelationInput | priceapprenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for priceapprenttbs.
     */
    cursor?: priceapprenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priceapprenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priceapprenttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of priceapprenttbs.
     */
    distinct?: PriceapprenttbScalarFieldEnum | PriceapprenttbScalarFieldEnum[]
  }

  /**
   * priceapprenttb findFirstOrThrow
   */
  export type priceapprenttbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprenttb to fetch.
     */
    where?: priceapprenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priceapprenttbs to fetch.
     */
    orderBy?: priceapprenttbOrderByWithRelationInput | priceapprenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for priceapprenttbs.
     */
    cursor?: priceapprenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priceapprenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priceapprenttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of priceapprenttbs.
     */
    distinct?: PriceapprenttbScalarFieldEnum | PriceapprenttbScalarFieldEnum[]
  }

  /**
   * priceapprenttb findMany
   */
  export type priceapprenttbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprenttbs to fetch.
     */
    where?: priceapprenttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priceapprenttbs to fetch.
     */
    orderBy?: priceapprenttbOrderByWithRelationInput | priceapprenttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing priceapprenttbs.
     */
    cursor?: priceapprenttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priceapprenttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priceapprenttbs.
     */
    skip?: number
    distinct?: PriceapprenttbScalarFieldEnum | PriceapprenttbScalarFieldEnum[]
  }

  /**
   * priceapprenttb create
   */
  export type priceapprenttbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
    /**
     * The data needed to create a priceapprenttb.
     */
    data?: XOR<priceapprenttbCreateInput, priceapprenttbUncheckedCreateInput>
  }

  /**
   * priceapprenttb createMany
   */
  export type priceapprenttbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many priceapprenttbs.
     */
    data: priceapprenttbCreateManyInput | priceapprenttbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * priceapprenttb update
   */
  export type priceapprenttbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
    /**
     * The data needed to update a priceapprenttb.
     */
    data: XOR<priceapprenttbUpdateInput, priceapprenttbUncheckedUpdateInput>
    /**
     * Choose, which priceapprenttb to update.
     */
    where: priceapprenttbWhereUniqueInput
  }

  /**
   * priceapprenttb updateMany
   */
  export type priceapprenttbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update priceapprenttbs.
     */
    data: XOR<priceapprenttbUpdateManyMutationInput, priceapprenttbUncheckedUpdateManyInput>
    /**
     * Filter which priceapprenttbs to update
     */
    where?: priceapprenttbWhereInput
  }

  /**
   * priceapprenttb upsert
   */
  export type priceapprenttbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
    /**
     * The filter to search for the priceapprenttb to update in case it exists.
     */
    where: priceapprenttbWhereUniqueInput
    /**
     * In case the priceapprenttb found by the `where` argument doesn't exist, create a new priceapprenttb with this data.
     */
    create: XOR<priceapprenttbCreateInput, priceapprenttbUncheckedCreateInput>
    /**
     * In case the priceapprenttb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<priceapprenttbUpdateInput, priceapprenttbUncheckedUpdateInput>
  }

  /**
   * priceapprenttb delete
   */
  export type priceapprenttbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
    /**
     * Filter which priceapprenttb to delete.
     */
    where: priceapprenttbWhereUniqueInput
  }

  /**
   * priceapprenttb deleteMany
   */
  export type priceapprenttbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which priceapprenttbs to delete
     */
    where?: priceapprenttbWhereInput
  }

  /**
   * priceapprenttb without action
   */
  export type priceapprenttbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprenttb
     */
    select?: priceapprenttbSelect<ExtArgs> | null
  }


  /**
   * Model priceapprentusetb
   */

  export type AggregatePriceapprentusetb = {
    _count: PriceapprentusetbCountAggregateOutputType | null
    _avg: PriceapprentusetbAvgAggregateOutputType | null
    _sum: PriceapprentusetbSumAggregateOutputType | null
    _min: PriceapprentusetbMinAggregateOutputType | null
    _max: PriceapprentusetbMaxAggregateOutputType | null
  }

  export type PriceapprentusetbAvgAggregateOutputType = {
    PriceAppRentUseID: number | null
    PriceAppRentID: number | null
    ApplicationRentID: number | null
  }

  export type PriceapprentusetbSumAggregateOutputType = {
    PriceAppRentUseID: number | null
    PriceAppRentID: number | null
    ApplicationRentID: number | null
  }

  export type PriceapprentusetbMinAggregateOutputType = {
    PriceAppRentUseID: number | null
    PriceAppRentID: number | null
    ApplicationRentID: number | null
  }

  export type PriceapprentusetbMaxAggregateOutputType = {
    PriceAppRentUseID: number | null
    PriceAppRentID: number | null
    ApplicationRentID: number | null
  }

  export type PriceapprentusetbCountAggregateOutputType = {
    PriceAppRentUseID: number
    PriceAppRentID: number
    ApplicationRentID: number
    _all: number
  }


  export type PriceapprentusetbAvgAggregateInputType = {
    PriceAppRentUseID?: true
    PriceAppRentID?: true
    ApplicationRentID?: true
  }

  export type PriceapprentusetbSumAggregateInputType = {
    PriceAppRentUseID?: true
    PriceAppRentID?: true
    ApplicationRentID?: true
  }

  export type PriceapprentusetbMinAggregateInputType = {
    PriceAppRentUseID?: true
    PriceAppRentID?: true
    ApplicationRentID?: true
  }

  export type PriceapprentusetbMaxAggregateInputType = {
    PriceAppRentUseID?: true
    PriceAppRentID?: true
    ApplicationRentID?: true
  }

  export type PriceapprentusetbCountAggregateInputType = {
    PriceAppRentUseID?: true
    PriceAppRentID?: true
    ApplicationRentID?: true
    _all?: true
  }

  export type PriceapprentusetbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which priceapprentusetb to aggregate.
     */
    where?: priceapprentusetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priceapprentusetbs to fetch.
     */
    orderBy?: priceapprentusetbOrderByWithRelationInput | priceapprentusetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: priceapprentusetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priceapprentusetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priceapprentusetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned priceapprentusetbs
    **/
    _count?: true | PriceapprentusetbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceapprentusetbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceapprentusetbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceapprentusetbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceapprentusetbMaxAggregateInputType
  }

  export type GetPriceapprentusetbAggregateType<T extends PriceapprentusetbAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceapprentusetb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceapprentusetb[P]>
      : GetScalarType<T[P], AggregatePriceapprentusetb[P]>
  }




  export type priceapprentusetbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: priceapprentusetbWhereInput
    orderBy?: priceapprentusetbOrderByWithAggregationInput | priceapprentusetbOrderByWithAggregationInput[]
    by: PriceapprentusetbScalarFieldEnum[] | PriceapprentusetbScalarFieldEnum
    having?: priceapprentusetbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceapprentusetbCountAggregateInputType | true
    _avg?: PriceapprentusetbAvgAggregateInputType
    _sum?: PriceapprentusetbSumAggregateInputType
    _min?: PriceapprentusetbMinAggregateInputType
    _max?: PriceapprentusetbMaxAggregateInputType
  }

  export type PriceapprentusetbGroupByOutputType = {
    PriceAppRentUseID: number
    PriceAppRentID: number
    ApplicationRentID: number
    _count: PriceapprentusetbCountAggregateOutputType | null
    _avg: PriceapprentusetbAvgAggregateOutputType | null
    _sum: PriceapprentusetbSumAggregateOutputType | null
    _min: PriceapprentusetbMinAggregateOutputType | null
    _max: PriceapprentusetbMaxAggregateOutputType | null
  }

  type GetPriceapprentusetbGroupByPayload<T extends priceapprentusetbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceapprentusetbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceapprentusetbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceapprentusetbGroupByOutputType[P]>
            : GetScalarType<T[P], PriceapprentusetbGroupByOutputType[P]>
        }
      >
    >


  export type priceapprentusetbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PriceAppRentUseID?: boolean
    PriceAppRentID?: boolean
    ApplicationRentID?: boolean
  }, ExtArgs["result"]["priceapprentusetb"]>


  export type priceapprentusetbSelectScalar = {
    PriceAppRentUseID?: boolean
    PriceAppRentID?: boolean
    ApplicationRentID?: boolean
  }


  export type $priceapprentusetbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "priceapprentusetb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      PriceAppRentUseID: number
      PriceAppRentID: number
      ApplicationRentID: number
    }, ExtArgs["result"]["priceapprentusetb"]>
    composites: {}
  }

  type priceapprentusetbGetPayload<S extends boolean | null | undefined | priceapprentusetbDefaultArgs> = $Result.GetResult<Prisma.$priceapprentusetbPayload, S>

  type priceapprentusetbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<priceapprentusetbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceapprentusetbCountAggregateInputType | true
    }

  export interface priceapprentusetbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['priceapprentusetb'], meta: { name: 'priceapprentusetb' } }
    /**
     * Find zero or one Priceapprentusetb that matches the filter.
     * @param {priceapprentusetbFindUniqueArgs} args - Arguments to find a Priceapprentusetb
     * @example
     * // Get one Priceapprentusetb
     * const priceapprentusetb = await prisma.priceapprentusetb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends priceapprentusetbFindUniqueArgs>(args: SelectSubset<T, priceapprentusetbFindUniqueArgs<ExtArgs>>): Prisma__priceapprentusetbClient<$Result.GetResult<Prisma.$priceapprentusetbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Priceapprentusetb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {priceapprentusetbFindUniqueOrThrowArgs} args - Arguments to find a Priceapprentusetb
     * @example
     * // Get one Priceapprentusetb
     * const priceapprentusetb = await prisma.priceapprentusetb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends priceapprentusetbFindUniqueOrThrowArgs>(args: SelectSubset<T, priceapprentusetbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__priceapprentusetbClient<$Result.GetResult<Prisma.$priceapprentusetbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Priceapprentusetb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprentusetbFindFirstArgs} args - Arguments to find a Priceapprentusetb
     * @example
     * // Get one Priceapprentusetb
     * const priceapprentusetb = await prisma.priceapprentusetb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends priceapprentusetbFindFirstArgs>(args?: SelectSubset<T, priceapprentusetbFindFirstArgs<ExtArgs>>): Prisma__priceapprentusetbClient<$Result.GetResult<Prisma.$priceapprentusetbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Priceapprentusetb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprentusetbFindFirstOrThrowArgs} args - Arguments to find a Priceapprentusetb
     * @example
     * // Get one Priceapprentusetb
     * const priceapprentusetb = await prisma.priceapprentusetb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends priceapprentusetbFindFirstOrThrowArgs>(args?: SelectSubset<T, priceapprentusetbFindFirstOrThrowArgs<ExtArgs>>): Prisma__priceapprentusetbClient<$Result.GetResult<Prisma.$priceapprentusetbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Priceapprentusetbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprentusetbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Priceapprentusetbs
     * const priceapprentusetbs = await prisma.priceapprentusetb.findMany()
     * 
     * // Get first 10 Priceapprentusetbs
     * const priceapprentusetbs = await prisma.priceapprentusetb.findMany({ take: 10 })
     * 
     * // Only select the `PriceAppRentUseID`
     * const priceapprentusetbWithPriceAppRentUseIDOnly = await prisma.priceapprentusetb.findMany({ select: { PriceAppRentUseID: true } })
     * 
     */
    findMany<T extends priceapprentusetbFindManyArgs>(args?: SelectSubset<T, priceapprentusetbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$priceapprentusetbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Priceapprentusetb.
     * @param {priceapprentusetbCreateArgs} args - Arguments to create a Priceapprentusetb.
     * @example
     * // Create one Priceapprentusetb
     * const Priceapprentusetb = await prisma.priceapprentusetb.create({
     *   data: {
     *     // ... data to create a Priceapprentusetb
     *   }
     * })
     * 
     */
    create<T extends priceapprentusetbCreateArgs>(args: SelectSubset<T, priceapprentusetbCreateArgs<ExtArgs>>): Prisma__priceapprentusetbClient<$Result.GetResult<Prisma.$priceapprentusetbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Priceapprentusetbs.
     * @param {priceapprentusetbCreateManyArgs} args - Arguments to create many Priceapprentusetbs.
     * @example
     * // Create many Priceapprentusetbs
     * const priceapprentusetb = await prisma.priceapprentusetb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends priceapprentusetbCreateManyArgs>(args?: SelectSubset<T, priceapprentusetbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Priceapprentusetb.
     * @param {priceapprentusetbDeleteArgs} args - Arguments to delete one Priceapprentusetb.
     * @example
     * // Delete one Priceapprentusetb
     * const Priceapprentusetb = await prisma.priceapprentusetb.delete({
     *   where: {
     *     // ... filter to delete one Priceapprentusetb
     *   }
     * })
     * 
     */
    delete<T extends priceapprentusetbDeleteArgs>(args: SelectSubset<T, priceapprentusetbDeleteArgs<ExtArgs>>): Prisma__priceapprentusetbClient<$Result.GetResult<Prisma.$priceapprentusetbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Priceapprentusetb.
     * @param {priceapprentusetbUpdateArgs} args - Arguments to update one Priceapprentusetb.
     * @example
     * // Update one Priceapprentusetb
     * const priceapprentusetb = await prisma.priceapprentusetb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends priceapprentusetbUpdateArgs>(args: SelectSubset<T, priceapprentusetbUpdateArgs<ExtArgs>>): Prisma__priceapprentusetbClient<$Result.GetResult<Prisma.$priceapprentusetbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Priceapprentusetbs.
     * @param {priceapprentusetbDeleteManyArgs} args - Arguments to filter Priceapprentusetbs to delete.
     * @example
     * // Delete a few Priceapprentusetbs
     * const { count } = await prisma.priceapprentusetb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends priceapprentusetbDeleteManyArgs>(args?: SelectSubset<T, priceapprentusetbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Priceapprentusetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprentusetbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Priceapprentusetbs
     * const priceapprentusetb = await prisma.priceapprentusetb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends priceapprentusetbUpdateManyArgs>(args: SelectSubset<T, priceapprentusetbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Priceapprentusetb.
     * @param {priceapprentusetbUpsertArgs} args - Arguments to update or create a Priceapprentusetb.
     * @example
     * // Update or create a Priceapprentusetb
     * const priceapprentusetb = await prisma.priceapprentusetb.upsert({
     *   create: {
     *     // ... data to create a Priceapprentusetb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Priceapprentusetb we want to update
     *   }
     * })
     */
    upsert<T extends priceapprentusetbUpsertArgs>(args: SelectSubset<T, priceapprentusetbUpsertArgs<ExtArgs>>): Prisma__priceapprentusetbClient<$Result.GetResult<Prisma.$priceapprentusetbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Priceapprentusetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprentusetbCountArgs} args - Arguments to filter Priceapprentusetbs to count.
     * @example
     * // Count the number of Priceapprentusetbs
     * const count = await prisma.priceapprentusetb.count({
     *   where: {
     *     // ... the filter for the Priceapprentusetbs we want to count
     *   }
     * })
    **/
    count<T extends priceapprentusetbCountArgs>(
      args?: Subset<T, priceapprentusetbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceapprentusetbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Priceapprentusetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceapprentusetbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceapprentusetbAggregateArgs>(args: Subset<T, PriceapprentusetbAggregateArgs>): Prisma.PrismaPromise<GetPriceapprentusetbAggregateType<T>>

    /**
     * Group by Priceapprentusetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {priceapprentusetbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends priceapprentusetbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: priceapprentusetbGroupByArgs['orderBy'] }
        : { orderBy?: priceapprentusetbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, priceapprentusetbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceapprentusetbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the priceapprentusetb model
   */
  readonly fields: priceapprentusetbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for priceapprentusetb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__priceapprentusetbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the priceapprentusetb model
   */ 
  interface priceapprentusetbFieldRefs {
    readonly PriceAppRentUseID: FieldRef<"priceapprentusetb", 'Int'>
    readonly PriceAppRentID: FieldRef<"priceapprentusetb", 'Int'>
    readonly ApplicationRentID: FieldRef<"priceapprentusetb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * priceapprentusetb findUnique
   */
  export type priceapprentusetbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprentusetb to fetch.
     */
    where: priceapprentusetbWhereUniqueInput
  }

  /**
   * priceapprentusetb findUniqueOrThrow
   */
  export type priceapprentusetbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprentusetb to fetch.
     */
    where: priceapprentusetbWhereUniqueInput
  }

  /**
   * priceapprentusetb findFirst
   */
  export type priceapprentusetbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprentusetb to fetch.
     */
    where?: priceapprentusetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priceapprentusetbs to fetch.
     */
    orderBy?: priceapprentusetbOrderByWithRelationInput | priceapprentusetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for priceapprentusetbs.
     */
    cursor?: priceapprentusetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priceapprentusetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priceapprentusetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of priceapprentusetbs.
     */
    distinct?: PriceapprentusetbScalarFieldEnum | PriceapprentusetbScalarFieldEnum[]
  }

  /**
   * priceapprentusetb findFirstOrThrow
   */
  export type priceapprentusetbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprentusetb to fetch.
     */
    where?: priceapprentusetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priceapprentusetbs to fetch.
     */
    orderBy?: priceapprentusetbOrderByWithRelationInput | priceapprentusetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for priceapprentusetbs.
     */
    cursor?: priceapprentusetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priceapprentusetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priceapprentusetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of priceapprentusetbs.
     */
    distinct?: PriceapprentusetbScalarFieldEnum | PriceapprentusetbScalarFieldEnum[]
  }

  /**
   * priceapprentusetb findMany
   */
  export type priceapprentusetbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
    /**
     * Filter, which priceapprentusetbs to fetch.
     */
    where?: priceapprentusetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of priceapprentusetbs to fetch.
     */
    orderBy?: priceapprentusetbOrderByWithRelationInput | priceapprentusetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing priceapprentusetbs.
     */
    cursor?: priceapprentusetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` priceapprentusetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` priceapprentusetbs.
     */
    skip?: number
    distinct?: PriceapprentusetbScalarFieldEnum | PriceapprentusetbScalarFieldEnum[]
  }

  /**
   * priceapprentusetb create
   */
  export type priceapprentusetbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
    /**
     * The data needed to create a priceapprentusetb.
     */
    data?: XOR<priceapprentusetbCreateInput, priceapprentusetbUncheckedCreateInput>
  }

  /**
   * priceapprentusetb createMany
   */
  export type priceapprentusetbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many priceapprentusetbs.
     */
    data: priceapprentusetbCreateManyInput | priceapprentusetbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * priceapprentusetb update
   */
  export type priceapprentusetbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
    /**
     * The data needed to update a priceapprentusetb.
     */
    data: XOR<priceapprentusetbUpdateInput, priceapprentusetbUncheckedUpdateInput>
    /**
     * Choose, which priceapprentusetb to update.
     */
    where: priceapprentusetbWhereUniqueInput
  }

  /**
   * priceapprentusetb updateMany
   */
  export type priceapprentusetbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update priceapprentusetbs.
     */
    data: XOR<priceapprentusetbUpdateManyMutationInput, priceapprentusetbUncheckedUpdateManyInput>
    /**
     * Filter which priceapprentusetbs to update
     */
    where?: priceapprentusetbWhereInput
  }

  /**
   * priceapprentusetb upsert
   */
  export type priceapprentusetbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
    /**
     * The filter to search for the priceapprentusetb to update in case it exists.
     */
    where: priceapprentusetbWhereUniqueInput
    /**
     * In case the priceapprentusetb found by the `where` argument doesn't exist, create a new priceapprentusetb with this data.
     */
    create: XOR<priceapprentusetbCreateInput, priceapprentusetbUncheckedCreateInput>
    /**
     * In case the priceapprentusetb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<priceapprentusetbUpdateInput, priceapprentusetbUncheckedUpdateInput>
  }

  /**
   * priceapprentusetb delete
   */
  export type priceapprentusetbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
    /**
     * Filter which priceapprentusetb to delete.
     */
    where: priceapprentusetbWhereUniqueInput
  }

  /**
   * priceapprentusetb deleteMany
   */
  export type priceapprentusetbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which priceapprentusetbs to delete
     */
    where?: priceapprentusetbWhereInput
  }

  /**
   * priceapprentusetb without action
   */
  export type priceapprentusetbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the priceapprentusetb
     */
    select?: priceapprentusetbSelect<ExtArgs> | null
  }


  /**
   * Model pricedetailtb
   */

  export type AggregatePricedetailtb = {
    _count: PricedetailtbCountAggregateOutputType | null
    _avg: PricedetailtbAvgAggregateOutputType | null
    _sum: PricedetailtbSumAggregateOutputType | null
    _min: PricedetailtbMinAggregateOutputType | null
    _max: PricedetailtbMaxAggregateOutputType | null
  }

  export type PricedetailtbAvgAggregateOutputType = {
    PriceDetailId: number | null
    PriceId: number | null
    MachineGroupId: number | null
    Price: Decimal | null
    Promotion: number | null
    PromotionTerm: number | null
    FreeMoney: number | null
    FreeTime: number | null
    BeginTime: number | null
    EndTime: number | null
    Term: number | null
    PromotionOrder: number | null
    DayOfWeekMask: number | null
    PromotionType: number | null
  }

  export type PricedetailtbSumAggregateOutputType = {
    PriceDetailId: number | null
    PriceId: number | null
    MachineGroupId: number | null
    Price: Decimal | null
    Promotion: number | null
    PromotionTerm: number | null
    FreeMoney: number | null
    FreeTime: number | null
    BeginTime: number | null
    EndTime: number | null
    Term: number | null
    PromotionOrder: number | null
    DayOfWeekMask: number | null
    PromotionType: number | null
  }

  export type PricedetailtbMinAggregateOutputType = {
    PriceDetailId: number | null
    PriceId: number | null
    MachineGroupId: number | null
    Price: Decimal | null
    Promotion: number | null
    PromotionTerm: number | null
    FreeMoney: number | null
    FreeTime: number | null
    BeginTime: number | null
    EndTime: number | null
    Term: number | null
    PromotionOrder: number | null
    BeginDate: Date | null
    EndDate: Date | null
    DayOfWeekMask: number | null
    PromotionType: number | null
  }

  export type PricedetailtbMaxAggregateOutputType = {
    PriceDetailId: number | null
    PriceId: number | null
    MachineGroupId: number | null
    Price: Decimal | null
    Promotion: number | null
    PromotionTerm: number | null
    FreeMoney: number | null
    FreeTime: number | null
    BeginTime: number | null
    EndTime: number | null
    Term: number | null
    PromotionOrder: number | null
    BeginDate: Date | null
    EndDate: Date | null
    DayOfWeekMask: number | null
    PromotionType: number | null
  }

  export type PricedetailtbCountAggregateOutputType = {
    PriceDetailId: number
    PriceId: number
    MachineGroupId: number
    Price: number
    Promotion: number
    PromotionTerm: number
    FreeMoney: number
    FreeTime: number
    BeginTime: number
    EndTime: number
    Term: number
    PromotionOrder: number
    BeginDate: number
    EndDate: number
    DayOfWeekMask: number
    PromotionType: number
    _all: number
  }


  export type PricedetailtbAvgAggregateInputType = {
    PriceDetailId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
    Promotion?: true
    PromotionTerm?: true
    FreeMoney?: true
    FreeTime?: true
    BeginTime?: true
    EndTime?: true
    Term?: true
    PromotionOrder?: true
    DayOfWeekMask?: true
    PromotionType?: true
  }

  export type PricedetailtbSumAggregateInputType = {
    PriceDetailId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
    Promotion?: true
    PromotionTerm?: true
    FreeMoney?: true
    FreeTime?: true
    BeginTime?: true
    EndTime?: true
    Term?: true
    PromotionOrder?: true
    DayOfWeekMask?: true
    PromotionType?: true
  }

  export type PricedetailtbMinAggregateInputType = {
    PriceDetailId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
    Promotion?: true
    PromotionTerm?: true
    FreeMoney?: true
    FreeTime?: true
    BeginTime?: true
    EndTime?: true
    Term?: true
    PromotionOrder?: true
    BeginDate?: true
    EndDate?: true
    DayOfWeekMask?: true
    PromotionType?: true
  }

  export type PricedetailtbMaxAggregateInputType = {
    PriceDetailId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
    Promotion?: true
    PromotionTerm?: true
    FreeMoney?: true
    FreeTime?: true
    BeginTime?: true
    EndTime?: true
    Term?: true
    PromotionOrder?: true
    BeginDate?: true
    EndDate?: true
    DayOfWeekMask?: true
    PromotionType?: true
  }

  export type PricedetailtbCountAggregateInputType = {
    PriceDetailId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
    Promotion?: true
    PromotionTerm?: true
    FreeMoney?: true
    FreeTime?: true
    BeginTime?: true
    EndTime?: true
    Term?: true
    PromotionOrder?: true
    BeginDate?: true
    EndDate?: true
    DayOfWeekMask?: true
    PromotionType?: true
    _all?: true
  }

  export type PricedetailtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricedetailtb to aggregate.
     */
    where?: pricedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricedetailtbs to fetch.
     */
    orderBy?: pricedetailtbOrderByWithRelationInput | pricedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pricedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricedetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pricedetailtbs
    **/
    _count?: true | PricedetailtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricedetailtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricedetailtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricedetailtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricedetailtbMaxAggregateInputType
  }

  export type GetPricedetailtbAggregateType<T extends PricedetailtbAggregateArgs> = {
        [P in keyof T & keyof AggregatePricedetailtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricedetailtb[P]>
      : GetScalarType<T[P], AggregatePricedetailtb[P]>
  }




  export type pricedetailtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pricedetailtbWhereInput
    orderBy?: pricedetailtbOrderByWithAggregationInput | pricedetailtbOrderByWithAggregationInput[]
    by: PricedetailtbScalarFieldEnum[] | PricedetailtbScalarFieldEnum
    having?: pricedetailtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricedetailtbCountAggregateInputType | true
    _avg?: PricedetailtbAvgAggregateInputType
    _sum?: PricedetailtbSumAggregateInputType
    _min?: PricedetailtbMinAggregateInputType
    _max?: PricedetailtbMaxAggregateInputType
  }

  export type PricedetailtbGroupByOutputType = {
    PriceDetailId: number
    PriceId: number
    MachineGroupId: number | null
    Price: Decimal | null
    Promotion: number | null
    PromotionTerm: number | null
    FreeMoney: number | null
    FreeTime: number | null
    BeginTime: number | null
    EndTime: number | null
    Term: number | null
    PromotionOrder: number | null
    BeginDate: Date | null
    EndDate: Date | null
    DayOfWeekMask: number
    PromotionType: number
    _count: PricedetailtbCountAggregateOutputType | null
    _avg: PricedetailtbAvgAggregateOutputType | null
    _sum: PricedetailtbSumAggregateOutputType | null
    _min: PricedetailtbMinAggregateOutputType | null
    _max: PricedetailtbMaxAggregateOutputType | null
  }

  type GetPricedetailtbGroupByPayload<T extends pricedetailtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricedetailtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricedetailtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricedetailtbGroupByOutputType[P]>
            : GetScalarType<T[P], PricedetailtbGroupByOutputType[P]>
        }
      >
    >


  export type pricedetailtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PriceDetailId?: boolean
    PriceId?: boolean
    MachineGroupId?: boolean
    Price?: boolean
    Promotion?: boolean
    PromotionTerm?: boolean
    FreeMoney?: boolean
    FreeTime?: boolean
    BeginTime?: boolean
    EndTime?: boolean
    Term?: boolean
    PromotionOrder?: boolean
    BeginDate?: boolean
    EndDate?: boolean
    DayOfWeekMask?: boolean
    PromotionType?: boolean
  }, ExtArgs["result"]["pricedetailtb"]>


  export type pricedetailtbSelectScalar = {
    PriceDetailId?: boolean
    PriceId?: boolean
    MachineGroupId?: boolean
    Price?: boolean
    Promotion?: boolean
    PromotionTerm?: boolean
    FreeMoney?: boolean
    FreeTime?: boolean
    BeginTime?: boolean
    EndTime?: boolean
    Term?: boolean
    PromotionOrder?: boolean
    BeginDate?: boolean
    EndDate?: boolean
    DayOfWeekMask?: boolean
    PromotionType?: boolean
  }


  export type $pricedetailtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pricedetailtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      PriceDetailId: number
      PriceId: number
      MachineGroupId: number | null
      Price: Prisma.Decimal | null
      Promotion: number | null
      PromotionTerm: number | null
      FreeMoney: number | null
      FreeTime: number | null
      BeginTime: number | null
      EndTime: number | null
      Term: number | null
      PromotionOrder: number | null
      BeginDate: Date | null
      EndDate: Date | null
      DayOfWeekMask: number
      PromotionType: number
    }, ExtArgs["result"]["pricedetailtb"]>
    composites: {}
  }

  type pricedetailtbGetPayload<S extends boolean | null | undefined | pricedetailtbDefaultArgs> = $Result.GetResult<Prisma.$pricedetailtbPayload, S>

  type pricedetailtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pricedetailtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PricedetailtbCountAggregateInputType | true
    }

  export interface pricedetailtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pricedetailtb'], meta: { name: 'pricedetailtb' } }
    /**
     * Find zero or one Pricedetailtb that matches the filter.
     * @param {pricedetailtbFindUniqueArgs} args - Arguments to find a Pricedetailtb
     * @example
     * // Get one Pricedetailtb
     * const pricedetailtb = await prisma.pricedetailtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pricedetailtbFindUniqueArgs>(args: SelectSubset<T, pricedetailtbFindUniqueArgs<ExtArgs>>): Prisma__pricedetailtbClient<$Result.GetResult<Prisma.$pricedetailtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pricedetailtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pricedetailtbFindUniqueOrThrowArgs} args - Arguments to find a Pricedetailtb
     * @example
     * // Get one Pricedetailtb
     * const pricedetailtb = await prisma.pricedetailtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pricedetailtbFindUniqueOrThrowArgs>(args: SelectSubset<T, pricedetailtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pricedetailtbClient<$Result.GetResult<Prisma.$pricedetailtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pricedetailtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricedetailtbFindFirstArgs} args - Arguments to find a Pricedetailtb
     * @example
     * // Get one Pricedetailtb
     * const pricedetailtb = await prisma.pricedetailtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pricedetailtbFindFirstArgs>(args?: SelectSubset<T, pricedetailtbFindFirstArgs<ExtArgs>>): Prisma__pricedetailtbClient<$Result.GetResult<Prisma.$pricedetailtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pricedetailtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricedetailtbFindFirstOrThrowArgs} args - Arguments to find a Pricedetailtb
     * @example
     * // Get one Pricedetailtb
     * const pricedetailtb = await prisma.pricedetailtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pricedetailtbFindFirstOrThrowArgs>(args?: SelectSubset<T, pricedetailtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__pricedetailtbClient<$Result.GetResult<Prisma.$pricedetailtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pricedetailtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricedetailtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pricedetailtbs
     * const pricedetailtbs = await prisma.pricedetailtb.findMany()
     * 
     * // Get first 10 Pricedetailtbs
     * const pricedetailtbs = await prisma.pricedetailtb.findMany({ take: 10 })
     * 
     * // Only select the `PriceDetailId`
     * const pricedetailtbWithPriceDetailIdOnly = await prisma.pricedetailtb.findMany({ select: { PriceDetailId: true } })
     * 
     */
    findMany<T extends pricedetailtbFindManyArgs>(args?: SelectSubset<T, pricedetailtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricedetailtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pricedetailtb.
     * @param {pricedetailtbCreateArgs} args - Arguments to create a Pricedetailtb.
     * @example
     * // Create one Pricedetailtb
     * const Pricedetailtb = await prisma.pricedetailtb.create({
     *   data: {
     *     // ... data to create a Pricedetailtb
     *   }
     * })
     * 
     */
    create<T extends pricedetailtbCreateArgs>(args: SelectSubset<T, pricedetailtbCreateArgs<ExtArgs>>): Prisma__pricedetailtbClient<$Result.GetResult<Prisma.$pricedetailtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pricedetailtbs.
     * @param {pricedetailtbCreateManyArgs} args - Arguments to create many Pricedetailtbs.
     * @example
     * // Create many Pricedetailtbs
     * const pricedetailtb = await prisma.pricedetailtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pricedetailtbCreateManyArgs>(args?: SelectSubset<T, pricedetailtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pricedetailtb.
     * @param {pricedetailtbDeleteArgs} args - Arguments to delete one Pricedetailtb.
     * @example
     * // Delete one Pricedetailtb
     * const Pricedetailtb = await prisma.pricedetailtb.delete({
     *   where: {
     *     // ... filter to delete one Pricedetailtb
     *   }
     * })
     * 
     */
    delete<T extends pricedetailtbDeleteArgs>(args: SelectSubset<T, pricedetailtbDeleteArgs<ExtArgs>>): Prisma__pricedetailtbClient<$Result.GetResult<Prisma.$pricedetailtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pricedetailtb.
     * @param {pricedetailtbUpdateArgs} args - Arguments to update one Pricedetailtb.
     * @example
     * // Update one Pricedetailtb
     * const pricedetailtb = await prisma.pricedetailtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pricedetailtbUpdateArgs>(args: SelectSubset<T, pricedetailtbUpdateArgs<ExtArgs>>): Prisma__pricedetailtbClient<$Result.GetResult<Prisma.$pricedetailtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pricedetailtbs.
     * @param {pricedetailtbDeleteManyArgs} args - Arguments to filter Pricedetailtbs to delete.
     * @example
     * // Delete a few Pricedetailtbs
     * const { count } = await prisma.pricedetailtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pricedetailtbDeleteManyArgs>(args?: SelectSubset<T, pricedetailtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pricedetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricedetailtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pricedetailtbs
     * const pricedetailtb = await prisma.pricedetailtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pricedetailtbUpdateManyArgs>(args: SelectSubset<T, pricedetailtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pricedetailtb.
     * @param {pricedetailtbUpsertArgs} args - Arguments to update or create a Pricedetailtb.
     * @example
     * // Update or create a Pricedetailtb
     * const pricedetailtb = await prisma.pricedetailtb.upsert({
     *   create: {
     *     // ... data to create a Pricedetailtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pricedetailtb we want to update
     *   }
     * })
     */
    upsert<T extends pricedetailtbUpsertArgs>(args: SelectSubset<T, pricedetailtbUpsertArgs<ExtArgs>>): Prisma__pricedetailtbClient<$Result.GetResult<Prisma.$pricedetailtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pricedetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricedetailtbCountArgs} args - Arguments to filter Pricedetailtbs to count.
     * @example
     * // Count the number of Pricedetailtbs
     * const count = await prisma.pricedetailtb.count({
     *   where: {
     *     // ... the filter for the Pricedetailtbs we want to count
     *   }
     * })
    **/
    count<T extends pricedetailtbCountArgs>(
      args?: Subset<T, pricedetailtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricedetailtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pricedetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricedetailtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricedetailtbAggregateArgs>(args: Subset<T, PricedetailtbAggregateArgs>): Prisma.PrismaPromise<GetPricedetailtbAggregateType<T>>

    /**
     * Group by Pricedetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricedetailtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pricedetailtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pricedetailtbGroupByArgs['orderBy'] }
        : { orderBy?: pricedetailtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pricedetailtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricedetailtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pricedetailtb model
   */
  readonly fields: pricedetailtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pricedetailtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pricedetailtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pricedetailtb model
   */ 
  interface pricedetailtbFieldRefs {
    readonly PriceDetailId: FieldRef<"pricedetailtb", 'Int'>
    readonly PriceId: FieldRef<"pricedetailtb", 'Int'>
    readonly MachineGroupId: FieldRef<"pricedetailtb", 'Int'>
    readonly Price: FieldRef<"pricedetailtb", 'Decimal'>
    readonly Promotion: FieldRef<"pricedetailtb", 'Int'>
    readonly PromotionTerm: FieldRef<"pricedetailtb", 'Int'>
    readonly FreeMoney: FieldRef<"pricedetailtb", 'Int'>
    readonly FreeTime: FieldRef<"pricedetailtb", 'Int'>
    readonly BeginTime: FieldRef<"pricedetailtb", 'Int'>
    readonly EndTime: FieldRef<"pricedetailtb", 'Int'>
    readonly Term: FieldRef<"pricedetailtb", 'Int'>
    readonly PromotionOrder: FieldRef<"pricedetailtb", 'Int'>
    readonly BeginDate: FieldRef<"pricedetailtb", 'DateTime'>
    readonly EndDate: FieldRef<"pricedetailtb", 'DateTime'>
    readonly DayOfWeekMask: FieldRef<"pricedetailtb", 'Int'>
    readonly PromotionType: FieldRef<"pricedetailtb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pricedetailtb findUnique
   */
  export type pricedetailtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which pricedetailtb to fetch.
     */
    where: pricedetailtbWhereUniqueInput
  }

  /**
   * pricedetailtb findUniqueOrThrow
   */
  export type pricedetailtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which pricedetailtb to fetch.
     */
    where: pricedetailtbWhereUniqueInput
  }

  /**
   * pricedetailtb findFirst
   */
  export type pricedetailtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which pricedetailtb to fetch.
     */
    where?: pricedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricedetailtbs to fetch.
     */
    orderBy?: pricedetailtbOrderByWithRelationInput | pricedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricedetailtbs.
     */
    cursor?: pricedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricedetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricedetailtbs.
     */
    distinct?: PricedetailtbScalarFieldEnum | PricedetailtbScalarFieldEnum[]
  }

  /**
   * pricedetailtb findFirstOrThrow
   */
  export type pricedetailtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which pricedetailtb to fetch.
     */
    where?: pricedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricedetailtbs to fetch.
     */
    orderBy?: pricedetailtbOrderByWithRelationInput | pricedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricedetailtbs.
     */
    cursor?: pricedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricedetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricedetailtbs.
     */
    distinct?: PricedetailtbScalarFieldEnum | PricedetailtbScalarFieldEnum[]
  }

  /**
   * pricedetailtb findMany
   */
  export type pricedetailtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which pricedetailtbs to fetch.
     */
    where?: pricedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricedetailtbs to fetch.
     */
    orderBy?: pricedetailtbOrderByWithRelationInput | pricedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pricedetailtbs.
     */
    cursor?: pricedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricedetailtbs.
     */
    skip?: number
    distinct?: PricedetailtbScalarFieldEnum | PricedetailtbScalarFieldEnum[]
  }

  /**
   * pricedetailtb create
   */
  export type pricedetailtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
    /**
     * The data needed to create a pricedetailtb.
     */
    data: XOR<pricedetailtbCreateInput, pricedetailtbUncheckedCreateInput>
  }

  /**
   * pricedetailtb createMany
   */
  export type pricedetailtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pricedetailtbs.
     */
    data: pricedetailtbCreateManyInput | pricedetailtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pricedetailtb update
   */
  export type pricedetailtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
    /**
     * The data needed to update a pricedetailtb.
     */
    data: XOR<pricedetailtbUpdateInput, pricedetailtbUncheckedUpdateInput>
    /**
     * Choose, which pricedetailtb to update.
     */
    where: pricedetailtbWhereUniqueInput
  }

  /**
   * pricedetailtb updateMany
   */
  export type pricedetailtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pricedetailtbs.
     */
    data: XOR<pricedetailtbUpdateManyMutationInput, pricedetailtbUncheckedUpdateManyInput>
    /**
     * Filter which pricedetailtbs to update
     */
    where?: pricedetailtbWhereInput
  }

  /**
   * pricedetailtb upsert
   */
  export type pricedetailtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
    /**
     * The filter to search for the pricedetailtb to update in case it exists.
     */
    where: pricedetailtbWhereUniqueInput
    /**
     * In case the pricedetailtb found by the `where` argument doesn't exist, create a new pricedetailtb with this data.
     */
    create: XOR<pricedetailtbCreateInput, pricedetailtbUncheckedCreateInput>
    /**
     * In case the pricedetailtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pricedetailtbUpdateInput, pricedetailtbUncheckedUpdateInput>
  }

  /**
   * pricedetailtb delete
   */
  export type pricedetailtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
    /**
     * Filter which pricedetailtb to delete.
     */
    where: pricedetailtbWhereUniqueInput
  }

  /**
   * pricedetailtb deleteMany
   */
  export type pricedetailtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricedetailtbs to delete
     */
    where?: pricedetailtbWhereInput
  }

  /**
   * pricedetailtb without action
   */
  export type pricedetailtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricedetailtb
     */
    select?: pricedetailtbSelect<ExtArgs> | null
  }


  /**
   * Model pricelisttb
   */

  export type AggregatePricelisttb = {
    _count: PricelisttbCountAggregateOutputType | null
    _avg: PricelisttbAvgAggregateOutputType | null
    _sum: PricelisttbSumAggregateOutputType | null
    _min: PricelisttbMinAggregateOutputType | null
    _max: PricelisttbMaxAggregateOutputType | null
  }

  export type PricelisttbAvgAggregateOutputType = {
    PriceId: number | null
    Price: Decimal | null
    Type: number | null
    Active: number | null
  }

  export type PricelisttbSumAggregateOutputType = {
    PriceId: number | null
    Price: Decimal | null
    Type: number | null
    Active: number | null
  }

  export type PricelisttbMinAggregateOutputType = {
    PriceId: number | null
    PriceType: string | null
    Price: Decimal | null
    Type: number | null
    Active: number | null
  }

  export type PricelisttbMaxAggregateOutputType = {
    PriceId: number | null
    PriceType: string | null
    Price: Decimal | null
    Type: number | null
    Active: number | null
  }

  export type PricelisttbCountAggregateOutputType = {
    PriceId: number
    PriceType: number
    Price: number
    Type: number
    Active: number
    _all: number
  }


  export type PricelisttbAvgAggregateInputType = {
    PriceId?: true
    Price?: true
    Type?: true
    Active?: true
  }

  export type PricelisttbSumAggregateInputType = {
    PriceId?: true
    Price?: true
    Type?: true
    Active?: true
  }

  export type PricelisttbMinAggregateInputType = {
    PriceId?: true
    PriceType?: true
    Price?: true
    Type?: true
    Active?: true
  }

  export type PricelisttbMaxAggregateInputType = {
    PriceId?: true
    PriceType?: true
    Price?: true
    Type?: true
    Active?: true
  }

  export type PricelisttbCountAggregateInputType = {
    PriceId?: true
    PriceType?: true
    Price?: true
    Type?: true
    Active?: true
    _all?: true
  }

  export type PricelisttbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricelisttb to aggregate.
     */
    where?: pricelisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricelisttbs to fetch.
     */
    orderBy?: pricelisttbOrderByWithRelationInput | pricelisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pricelisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricelisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricelisttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pricelisttbs
    **/
    _count?: true | PricelisttbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricelisttbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricelisttbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricelisttbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricelisttbMaxAggregateInputType
  }

  export type GetPricelisttbAggregateType<T extends PricelisttbAggregateArgs> = {
        [P in keyof T & keyof AggregatePricelisttb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricelisttb[P]>
      : GetScalarType<T[P], AggregatePricelisttb[P]>
  }




  export type pricelisttbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pricelisttbWhereInput
    orderBy?: pricelisttbOrderByWithAggregationInput | pricelisttbOrderByWithAggregationInput[]
    by: PricelisttbScalarFieldEnum[] | PricelisttbScalarFieldEnum
    having?: pricelisttbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricelisttbCountAggregateInputType | true
    _avg?: PricelisttbAvgAggregateInputType
    _sum?: PricelisttbSumAggregateInputType
    _min?: PricelisttbMinAggregateInputType
    _max?: PricelisttbMaxAggregateInputType
  }

  export type PricelisttbGroupByOutputType = {
    PriceId: number
    PriceType: string
    Price: Decimal
    Type: number
    Active: number | null
    _count: PricelisttbCountAggregateOutputType | null
    _avg: PricelisttbAvgAggregateOutputType | null
    _sum: PricelisttbSumAggregateOutputType | null
    _min: PricelisttbMinAggregateOutputType | null
    _max: PricelisttbMaxAggregateOutputType | null
  }

  type GetPricelisttbGroupByPayload<T extends pricelisttbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricelisttbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricelisttbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricelisttbGroupByOutputType[P]>
            : GetScalarType<T[P], PricelisttbGroupByOutputType[P]>
        }
      >
    >


  export type pricelisttbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PriceId?: boolean
    PriceType?: boolean
    Price?: boolean
    Type?: boolean
    Active?: boolean
  }, ExtArgs["result"]["pricelisttb"]>


  export type pricelisttbSelectScalar = {
    PriceId?: boolean
    PriceType?: boolean
    Price?: boolean
    Type?: boolean
    Active?: boolean
  }


  export type $pricelisttbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pricelisttb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      PriceId: number
      PriceType: string
      Price: Prisma.Decimal
      Type: number
      Active: number | null
    }, ExtArgs["result"]["pricelisttb"]>
    composites: {}
  }

  type pricelisttbGetPayload<S extends boolean | null | undefined | pricelisttbDefaultArgs> = $Result.GetResult<Prisma.$pricelisttbPayload, S>

  type pricelisttbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pricelisttbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PricelisttbCountAggregateInputType | true
    }

  export interface pricelisttbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pricelisttb'], meta: { name: 'pricelisttb' } }
    /**
     * Find zero or one Pricelisttb that matches the filter.
     * @param {pricelisttbFindUniqueArgs} args - Arguments to find a Pricelisttb
     * @example
     * // Get one Pricelisttb
     * const pricelisttb = await prisma.pricelisttb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pricelisttbFindUniqueArgs>(args: SelectSubset<T, pricelisttbFindUniqueArgs<ExtArgs>>): Prisma__pricelisttbClient<$Result.GetResult<Prisma.$pricelisttbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pricelisttb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pricelisttbFindUniqueOrThrowArgs} args - Arguments to find a Pricelisttb
     * @example
     * // Get one Pricelisttb
     * const pricelisttb = await prisma.pricelisttb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pricelisttbFindUniqueOrThrowArgs>(args: SelectSubset<T, pricelisttbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pricelisttbClient<$Result.GetResult<Prisma.$pricelisttbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pricelisttb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricelisttbFindFirstArgs} args - Arguments to find a Pricelisttb
     * @example
     * // Get one Pricelisttb
     * const pricelisttb = await prisma.pricelisttb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pricelisttbFindFirstArgs>(args?: SelectSubset<T, pricelisttbFindFirstArgs<ExtArgs>>): Prisma__pricelisttbClient<$Result.GetResult<Prisma.$pricelisttbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pricelisttb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricelisttbFindFirstOrThrowArgs} args - Arguments to find a Pricelisttb
     * @example
     * // Get one Pricelisttb
     * const pricelisttb = await prisma.pricelisttb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pricelisttbFindFirstOrThrowArgs>(args?: SelectSubset<T, pricelisttbFindFirstOrThrowArgs<ExtArgs>>): Prisma__pricelisttbClient<$Result.GetResult<Prisma.$pricelisttbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pricelisttbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricelisttbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pricelisttbs
     * const pricelisttbs = await prisma.pricelisttb.findMany()
     * 
     * // Get first 10 Pricelisttbs
     * const pricelisttbs = await prisma.pricelisttb.findMany({ take: 10 })
     * 
     * // Only select the `PriceId`
     * const pricelisttbWithPriceIdOnly = await prisma.pricelisttb.findMany({ select: { PriceId: true } })
     * 
     */
    findMany<T extends pricelisttbFindManyArgs>(args?: SelectSubset<T, pricelisttbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricelisttbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pricelisttb.
     * @param {pricelisttbCreateArgs} args - Arguments to create a Pricelisttb.
     * @example
     * // Create one Pricelisttb
     * const Pricelisttb = await prisma.pricelisttb.create({
     *   data: {
     *     // ... data to create a Pricelisttb
     *   }
     * })
     * 
     */
    create<T extends pricelisttbCreateArgs>(args: SelectSubset<T, pricelisttbCreateArgs<ExtArgs>>): Prisma__pricelisttbClient<$Result.GetResult<Prisma.$pricelisttbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pricelisttbs.
     * @param {pricelisttbCreateManyArgs} args - Arguments to create many Pricelisttbs.
     * @example
     * // Create many Pricelisttbs
     * const pricelisttb = await prisma.pricelisttb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pricelisttbCreateManyArgs>(args?: SelectSubset<T, pricelisttbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pricelisttb.
     * @param {pricelisttbDeleteArgs} args - Arguments to delete one Pricelisttb.
     * @example
     * // Delete one Pricelisttb
     * const Pricelisttb = await prisma.pricelisttb.delete({
     *   where: {
     *     // ... filter to delete one Pricelisttb
     *   }
     * })
     * 
     */
    delete<T extends pricelisttbDeleteArgs>(args: SelectSubset<T, pricelisttbDeleteArgs<ExtArgs>>): Prisma__pricelisttbClient<$Result.GetResult<Prisma.$pricelisttbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pricelisttb.
     * @param {pricelisttbUpdateArgs} args - Arguments to update one Pricelisttb.
     * @example
     * // Update one Pricelisttb
     * const pricelisttb = await prisma.pricelisttb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pricelisttbUpdateArgs>(args: SelectSubset<T, pricelisttbUpdateArgs<ExtArgs>>): Prisma__pricelisttbClient<$Result.GetResult<Prisma.$pricelisttbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pricelisttbs.
     * @param {pricelisttbDeleteManyArgs} args - Arguments to filter Pricelisttbs to delete.
     * @example
     * // Delete a few Pricelisttbs
     * const { count } = await prisma.pricelisttb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pricelisttbDeleteManyArgs>(args?: SelectSubset<T, pricelisttbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pricelisttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricelisttbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pricelisttbs
     * const pricelisttb = await prisma.pricelisttb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pricelisttbUpdateManyArgs>(args: SelectSubset<T, pricelisttbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pricelisttb.
     * @param {pricelisttbUpsertArgs} args - Arguments to update or create a Pricelisttb.
     * @example
     * // Update or create a Pricelisttb
     * const pricelisttb = await prisma.pricelisttb.upsert({
     *   create: {
     *     // ... data to create a Pricelisttb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pricelisttb we want to update
     *   }
     * })
     */
    upsert<T extends pricelisttbUpsertArgs>(args: SelectSubset<T, pricelisttbUpsertArgs<ExtArgs>>): Prisma__pricelisttbClient<$Result.GetResult<Prisma.$pricelisttbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pricelisttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricelisttbCountArgs} args - Arguments to filter Pricelisttbs to count.
     * @example
     * // Count the number of Pricelisttbs
     * const count = await prisma.pricelisttb.count({
     *   where: {
     *     // ... the filter for the Pricelisttbs we want to count
     *   }
     * })
    **/
    count<T extends pricelisttbCountArgs>(
      args?: Subset<T, pricelisttbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricelisttbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pricelisttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricelisttbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricelisttbAggregateArgs>(args: Subset<T, PricelisttbAggregateArgs>): Prisma.PrismaPromise<GetPricelisttbAggregateType<T>>

    /**
     * Group by Pricelisttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricelisttbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pricelisttbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pricelisttbGroupByArgs['orderBy'] }
        : { orderBy?: pricelisttbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pricelisttbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricelisttbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pricelisttb model
   */
  readonly fields: pricelisttbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pricelisttb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pricelisttbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pricelisttb model
   */ 
  interface pricelisttbFieldRefs {
    readonly PriceId: FieldRef<"pricelisttb", 'Int'>
    readonly PriceType: FieldRef<"pricelisttb", 'String'>
    readonly Price: FieldRef<"pricelisttb", 'Decimal'>
    readonly Type: FieldRef<"pricelisttb", 'Int'>
    readonly Active: FieldRef<"pricelisttb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pricelisttb findUnique
   */
  export type pricelisttbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
    /**
     * Filter, which pricelisttb to fetch.
     */
    where: pricelisttbWhereUniqueInput
  }

  /**
   * pricelisttb findUniqueOrThrow
   */
  export type pricelisttbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
    /**
     * Filter, which pricelisttb to fetch.
     */
    where: pricelisttbWhereUniqueInput
  }

  /**
   * pricelisttb findFirst
   */
  export type pricelisttbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
    /**
     * Filter, which pricelisttb to fetch.
     */
    where?: pricelisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricelisttbs to fetch.
     */
    orderBy?: pricelisttbOrderByWithRelationInput | pricelisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricelisttbs.
     */
    cursor?: pricelisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricelisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricelisttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricelisttbs.
     */
    distinct?: PricelisttbScalarFieldEnum | PricelisttbScalarFieldEnum[]
  }

  /**
   * pricelisttb findFirstOrThrow
   */
  export type pricelisttbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
    /**
     * Filter, which pricelisttb to fetch.
     */
    where?: pricelisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricelisttbs to fetch.
     */
    orderBy?: pricelisttbOrderByWithRelationInput | pricelisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricelisttbs.
     */
    cursor?: pricelisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricelisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricelisttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricelisttbs.
     */
    distinct?: PricelisttbScalarFieldEnum | PricelisttbScalarFieldEnum[]
  }

  /**
   * pricelisttb findMany
   */
  export type pricelisttbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
    /**
     * Filter, which pricelisttbs to fetch.
     */
    where?: pricelisttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricelisttbs to fetch.
     */
    orderBy?: pricelisttbOrderByWithRelationInput | pricelisttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pricelisttbs.
     */
    cursor?: pricelisttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricelisttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricelisttbs.
     */
    skip?: number
    distinct?: PricelisttbScalarFieldEnum | PricelisttbScalarFieldEnum[]
  }

  /**
   * pricelisttb create
   */
  export type pricelisttbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
    /**
     * The data needed to create a pricelisttb.
     */
    data: XOR<pricelisttbCreateInput, pricelisttbUncheckedCreateInput>
  }

  /**
   * pricelisttb createMany
   */
  export type pricelisttbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pricelisttbs.
     */
    data: pricelisttbCreateManyInput | pricelisttbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pricelisttb update
   */
  export type pricelisttbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
    /**
     * The data needed to update a pricelisttb.
     */
    data: XOR<pricelisttbUpdateInput, pricelisttbUncheckedUpdateInput>
    /**
     * Choose, which pricelisttb to update.
     */
    where: pricelisttbWhereUniqueInput
  }

  /**
   * pricelisttb updateMany
   */
  export type pricelisttbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pricelisttbs.
     */
    data: XOR<pricelisttbUpdateManyMutationInput, pricelisttbUncheckedUpdateManyInput>
    /**
     * Filter which pricelisttbs to update
     */
    where?: pricelisttbWhereInput
  }

  /**
   * pricelisttb upsert
   */
  export type pricelisttbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
    /**
     * The filter to search for the pricelisttb to update in case it exists.
     */
    where: pricelisttbWhereUniqueInput
    /**
     * In case the pricelisttb found by the `where` argument doesn't exist, create a new pricelisttb with this data.
     */
    create: XOR<pricelisttbCreateInput, pricelisttbUncheckedCreateInput>
    /**
     * In case the pricelisttb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pricelisttbUpdateInput, pricelisttbUncheckedUpdateInput>
  }

  /**
   * pricelisttb delete
   */
  export type pricelisttbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
    /**
     * Filter which pricelisttb to delete.
     */
    where: pricelisttbWhereUniqueInput
  }

  /**
   * pricelisttb deleteMany
   */
  export type pricelisttbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricelisttbs to delete
     */
    where?: pricelisttbWhereInput
  }

  /**
   * pricelisttb without action
   */
  export type pricelisttbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricelisttb
     */
    select?: pricelisttbSelect<ExtArgs> | null
  }


  /**
   * Model pricemachinetb
   */

  export type AggregatePricemachinetb = {
    _count: PricemachinetbCountAggregateOutputType | null
    _avg: PricemachinetbAvgAggregateOutputType | null
    _sum: PricemachinetbSumAggregateOutputType | null
    _min: PricemachinetbMinAggregateOutputType | null
    _max: PricemachinetbMaxAggregateOutputType | null
  }

  export type PricemachinetbAvgAggregateOutputType = {
    PriceMachineId: number | null
    PriceId: number | null
    MachineGroupId: number | null
    Price: Decimal | null
  }

  export type PricemachinetbSumAggregateOutputType = {
    PriceMachineId: number | null
    PriceId: number | null
    MachineGroupId: number | null
    Price: Decimal | null
  }

  export type PricemachinetbMinAggregateOutputType = {
    PriceMachineId: number | null
    PriceId: number | null
    MachineGroupId: number | null
    Price: Decimal | null
  }

  export type PricemachinetbMaxAggregateOutputType = {
    PriceMachineId: number | null
    PriceId: number | null
    MachineGroupId: number | null
    Price: Decimal | null
  }

  export type PricemachinetbCountAggregateOutputType = {
    PriceMachineId: number
    PriceId: number
    MachineGroupId: number
    Price: number
    _all: number
  }


  export type PricemachinetbAvgAggregateInputType = {
    PriceMachineId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
  }

  export type PricemachinetbSumAggregateInputType = {
    PriceMachineId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
  }

  export type PricemachinetbMinAggregateInputType = {
    PriceMachineId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
  }

  export type PricemachinetbMaxAggregateInputType = {
    PriceMachineId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
  }

  export type PricemachinetbCountAggregateInputType = {
    PriceMachineId?: true
    PriceId?: true
    MachineGroupId?: true
    Price?: true
    _all?: true
  }

  export type PricemachinetbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricemachinetb to aggregate.
     */
    where?: pricemachinetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricemachinetbs to fetch.
     */
    orderBy?: pricemachinetbOrderByWithRelationInput | pricemachinetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pricemachinetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricemachinetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricemachinetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pricemachinetbs
    **/
    _count?: true | PricemachinetbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricemachinetbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricemachinetbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricemachinetbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricemachinetbMaxAggregateInputType
  }

  export type GetPricemachinetbAggregateType<T extends PricemachinetbAggregateArgs> = {
        [P in keyof T & keyof AggregatePricemachinetb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricemachinetb[P]>
      : GetScalarType<T[P], AggregatePricemachinetb[P]>
  }




  export type pricemachinetbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pricemachinetbWhereInput
    orderBy?: pricemachinetbOrderByWithAggregationInput | pricemachinetbOrderByWithAggregationInput[]
    by: PricemachinetbScalarFieldEnum[] | PricemachinetbScalarFieldEnum
    having?: pricemachinetbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricemachinetbCountAggregateInputType | true
    _avg?: PricemachinetbAvgAggregateInputType
    _sum?: PricemachinetbSumAggregateInputType
    _min?: PricemachinetbMinAggregateInputType
    _max?: PricemachinetbMaxAggregateInputType
  }

  export type PricemachinetbGroupByOutputType = {
    PriceMachineId: number
    PriceId: number
    MachineGroupId: number
    Price: Decimal
    _count: PricemachinetbCountAggregateOutputType | null
    _avg: PricemachinetbAvgAggregateOutputType | null
    _sum: PricemachinetbSumAggregateOutputType | null
    _min: PricemachinetbMinAggregateOutputType | null
    _max: PricemachinetbMaxAggregateOutputType | null
  }

  type GetPricemachinetbGroupByPayload<T extends pricemachinetbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricemachinetbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricemachinetbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricemachinetbGroupByOutputType[P]>
            : GetScalarType<T[P], PricemachinetbGroupByOutputType[P]>
        }
      >
    >


  export type pricemachinetbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PriceMachineId?: boolean
    PriceId?: boolean
    MachineGroupId?: boolean
    Price?: boolean
  }, ExtArgs["result"]["pricemachinetb"]>


  export type pricemachinetbSelectScalar = {
    PriceMachineId?: boolean
    PriceId?: boolean
    MachineGroupId?: boolean
    Price?: boolean
  }


  export type $pricemachinetbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pricemachinetb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      PriceMachineId: number
      PriceId: number
      MachineGroupId: number
      Price: Prisma.Decimal
    }, ExtArgs["result"]["pricemachinetb"]>
    composites: {}
  }

  type pricemachinetbGetPayload<S extends boolean | null | undefined | pricemachinetbDefaultArgs> = $Result.GetResult<Prisma.$pricemachinetbPayload, S>

  type pricemachinetbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pricemachinetbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PricemachinetbCountAggregateInputType | true
    }

  export interface pricemachinetbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pricemachinetb'], meta: { name: 'pricemachinetb' } }
    /**
     * Find zero or one Pricemachinetb that matches the filter.
     * @param {pricemachinetbFindUniqueArgs} args - Arguments to find a Pricemachinetb
     * @example
     * // Get one Pricemachinetb
     * const pricemachinetb = await prisma.pricemachinetb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pricemachinetbFindUniqueArgs>(args: SelectSubset<T, pricemachinetbFindUniqueArgs<ExtArgs>>): Prisma__pricemachinetbClient<$Result.GetResult<Prisma.$pricemachinetbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pricemachinetb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pricemachinetbFindUniqueOrThrowArgs} args - Arguments to find a Pricemachinetb
     * @example
     * // Get one Pricemachinetb
     * const pricemachinetb = await prisma.pricemachinetb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pricemachinetbFindUniqueOrThrowArgs>(args: SelectSubset<T, pricemachinetbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pricemachinetbClient<$Result.GetResult<Prisma.$pricemachinetbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pricemachinetb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricemachinetbFindFirstArgs} args - Arguments to find a Pricemachinetb
     * @example
     * // Get one Pricemachinetb
     * const pricemachinetb = await prisma.pricemachinetb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pricemachinetbFindFirstArgs>(args?: SelectSubset<T, pricemachinetbFindFirstArgs<ExtArgs>>): Prisma__pricemachinetbClient<$Result.GetResult<Prisma.$pricemachinetbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pricemachinetb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricemachinetbFindFirstOrThrowArgs} args - Arguments to find a Pricemachinetb
     * @example
     * // Get one Pricemachinetb
     * const pricemachinetb = await prisma.pricemachinetb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pricemachinetbFindFirstOrThrowArgs>(args?: SelectSubset<T, pricemachinetbFindFirstOrThrowArgs<ExtArgs>>): Prisma__pricemachinetbClient<$Result.GetResult<Prisma.$pricemachinetbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pricemachinetbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricemachinetbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pricemachinetbs
     * const pricemachinetbs = await prisma.pricemachinetb.findMany()
     * 
     * // Get first 10 Pricemachinetbs
     * const pricemachinetbs = await prisma.pricemachinetb.findMany({ take: 10 })
     * 
     * // Only select the `PriceMachineId`
     * const pricemachinetbWithPriceMachineIdOnly = await prisma.pricemachinetb.findMany({ select: { PriceMachineId: true } })
     * 
     */
    findMany<T extends pricemachinetbFindManyArgs>(args?: SelectSubset<T, pricemachinetbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pricemachinetbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pricemachinetb.
     * @param {pricemachinetbCreateArgs} args - Arguments to create a Pricemachinetb.
     * @example
     * // Create one Pricemachinetb
     * const Pricemachinetb = await prisma.pricemachinetb.create({
     *   data: {
     *     // ... data to create a Pricemachinetb
     *   }
     * })
     * 
     */
    create<T extends pricemachinetbCreateArgs>(args: SelectSubset<T, pricemachinetbCreateArgs<ExtArgs>>): Prisma__pricemachinetbClient<$Result.GetResult<Prisma.$pricemachinetbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pricemachinetbs.
     * @param {pricemachinetbCreateManyArgs} args - Arguments to create many Pricemachinetbs.
     * @example
     * // Create many Pricemachinetbs
     * const pricemachinetb = await prisma.pricemachinetb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pricemachinetbCreateManyArgs>(args?: SelectSubset<T, pricemachinetbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pricemachinetb.
     * @param {pricemachinetbDeleteArgs} args - Arguments to delete one Pricemachinetb.
     * @example
     * // Delete one Pricemachinetb
     * const Pricemachinetb = await prisma.pricemachinetb.delete({
     *   where: {
     *     // ... filter to delete one Pricemachinetb
     *   }
     * })
     * 
     */
    delete<T extends pricemachinetbDeleteArgs>(args: SelectSubset<T, pricemachinetbDeleteArgs<ExtArgs>>): Prisma__pricemachinetbClient<$Result.GetResult<Prisma.$pricemachinetbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pricemachinetb.
     * @param {pricemachinetbUpdateArgs} args - Arguments to update one Pricemachinetb.
     * @example
     * // Update one Pricemachinetb
     * const pricemachinetb = await prisma.pricemachinetb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pricemachinetbUpdateArgs>(args: SelectSubset<T, pricemachinetbUpdateArgs<ExtArgs>>): Prisma__pricemachinetbClient<$Result.GetResult<Prisma.$pricemachinetbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pricemachinetbs.
     * @param {pricemachinetbDeleteManyArgs} args - Arguments to filter Pricemachinetbs to delete.
     * @example
     * // Delete a few Pricemachinetbs
     * const { count } = await prisma.pricemachinetb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pricemachinetbDeleteManyArgs>(args?: SelectSubset<T, pricemachinetbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pricemachinetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricemachinetbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pricemachinetbs
     * const pricemachinetb = await prisma.pricemachinetb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pricemachinetbUpdateManyArgs>(args: SelectSubset<T, pricemachinetbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pricemachinetb.
     * @param {pricemachinetbUpsertArgs} args - Arguments to update or create a Pricemachinetb.
     * @example
     * // Update or create a Pricemachinetb
     * const pricemachinetb = await prisma.pricemachinetb.upsert({
     *   create: {
     *     // ... data to create a Pricemachinetb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pricemachinetb we want to update
     *   }
     * })
     */
    upsert<T extends pricemachinetbUpsertArgs>(args: SelectSubset<T, pricemachinetbUpsertArgs<ExtArgs>>): Prisma__pricemachinetbClient<$Result.GetResult<Prisma.$pricemachinetbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pricemachinetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricemachinetbCountArgs} args - Arguments to filter Pricemachinetbs to count.
     * @example
     * // Count the number of Pricemachinetbs
     * const count = await prisma.pricemachinetb.count({
     *   where: {
     *     // ... the filter for the Pricemachinetbs we want to count
     *   }
     * })
    **/
    count<T extends pricemachinetbCountArgs>(
      args?: Subset<T, pricemachinetbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricemachinetbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pricemachinetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricemachinetbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricemachinetbAggregateArgs>(args: Subset<T, PricemachinetbAggregateArgs>): Prisma.PrismaPromise<GetPricemachinetbAggregateType<T>>

    /**
     * Group by Pricemachinetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pricemachinetbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pricemachinetbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pricemachinetbGroupByArgs['orderBy'] }
        : { orderBy?: pricemachinetbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pricemachinetbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricemachinetbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pricemachinetb model
   */
  readonly fields: pricemachinetbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pricemachinetb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pricemachinetbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pricemachinetb model
   */ 
  interface pricemachinetbFieldRefs {
    readonly PriceMachineId: FieldRef<"pricemachinetb", 'Int'>
    readonly PriceId: FieldRef<"pricemachinetb", 'Int'>
    readonly MachineGroupId: FieldRef<"pricemachinetb", 'Int'>
    readonly Price: FieldRef<"pricemachinetb", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * pricemachinetb findUnique
   */
  export type pricemachinetbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
    /**
     * Filter, which pricemachinetb to fetch.
     */
    where: pricemachinetbWhereUniqueInput
  }

  /**
   * pricemachinetb findUniqueOrThrow
   */
  export type pricemachinetbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
    /**
     * Filter, which pricemachinetb to fetch.
     */
    where: pricemachinetbWhereUniqueInput
  }

  /**
   * pricemachinetb findFirst
   */
  export type pricemachinetbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
    /**
     * Filter, which pricemachinetb to fetch.
     */
    where?: pricemachinetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricemachinetbs to fetch.
     */
    orderBy?: pricemachinetbOrderByWithRelationInput | pricemachinetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricemachinetbs.
     */
    cursor?: pricemachinetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricemachinetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricemachinetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricemachinetbs.
     */
    distinct?: PricemachinetbScalarFieldEnum | PricemachinetbScalarFieldEnum[]
  }

  /**
   * pricemachinetb findFirstOrThrow
   */
  export type pricemachinetbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
    /**
     * Filter, which pricemachinetb to fetch.
     */
    where?: pricemachinetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricemachinetbs to fetch.
     */
    orderBy?: pricemachinetbOrderByWithRelationInput | pricemachinetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pricemachinetbs.
     */
    cursor?: pricemachinetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricemachinetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricemachinetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pricemachinetbs.
     */
    distinct?: PricemachinetbScalarFieldEnum | PricemachinetbScalarFieldEnum[]
  }

  /**
   * pricemachinetb findMany
   */
  export type pricemachinetbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
    /**
     * Filter, which pricemachinetbs to fetch.
     */
    where?: pricemachinetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pricemachinetbs to fetch.
     */
    orderBy?: pricemachinetbOrderByWithRelationInput | pricemachinetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pricemachinetbs.
     */
    cursor?: pricemachinetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pricemachinetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pricemachinetbs.
     */
    skip?: number
    distinct?: PricemachinetbScalarFieldEnum | PricemachinetbScalarFieldEnum[]
  }

  /**
   * pricemachinetb create
   */
  export type pricemachinetbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
    /**
     * The data needed to create a pricemachinetb.
     */
    data: XOR<pricemachinetbCreateInput, pricemachinetbUncheckedCreateInput>
  }

  /**
   * pricemachinetb createMany
   */
  export type pricemachinetbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pricemachinetbs.
     */
    data: pricemachinetbCreateManyInput | pricemachinetbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pricemachinetb update
   */
  export type pricemachinetbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
    /**
     * The data needed to update a pricemachinetb.
     */
    data: XOR<pricemachinetbUpdateInput, pricemachinetbUncheckedUpdateInput>
    /**
     * Choose, which pricemachinetb to update.
     */
    where: pricemachinetbWhereUniqueInput
  }

  /**
   * pricemachinetb updateMany
   */
  export type pricemachinetbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pricemachinetbs.
     */
    data: XOR<pricemachinetbUpdateManyMutationInput, pricemachinetbUncheckedUpdateManyInput>
    /**
     * Filter which pricemachinetbs to update
     */
    where?: pricemachinetbWhereInput
  }

  /**
   * pricemachinetb upsert
   */
  export type pricemachinetbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
    /**
     * The filter to search for the pricemachinetb to update in case it exists.
     */
    where: pricemachinetbWhereUniqueInput
    /**
     * In case the pricemachinetb found by the `where` argument doesn't exist, create a new pricemachinetb with this data.
     */
    create: XOR<pricemachinetbCreateInput, pricemachinetbUncheckedCreateInput>
    /**
     * In case the pricemachinetb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pricemachinetbUpdateInput, pricemachinetbUncheckedUpdateInput>
  }

  /**
   * pricemachinetb delete
   */
  export type pricemachinetbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
    /**
     * Filter which pricemachinetb to delete.
     */
    where: pricemachinetbWhereUniqueInput
  }

  /**
   * pricemachinetb deleteMany
   */
  export type pricemachinetbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pricemachinetbs to delete
     */
    where?: pricemachinetbWhereInput
  }

  /**
   * pricemachinetb without action
   */
  export type pricemachinetbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pricemachinetb
     */
    select?: pricemachinetbSelect<ExtArgs> | null
  }


  /**
   * Model printertb
   */

  export type AggregatePrintertb = {
    _count: PrintertbCountAggregateOutputType | null
    _avg: PrintertbAvgAggregateOutputType | null
    _sum: PrintertbSumAggregateOutputType | null
    _min: PrintertbMinAggregateOutputType | null
    _max: PrintertbMaxAggregateOutputType | null
  }

  export type PrintertbAvgAggregateOutputType = {
    ID: number | null
    Type: number | null
    Active: number | null
  }

  export type PrintertbSumAggregateOutputType = {
    ID: number | null
    Type: number | null
    Active: number | null
  }

  export type PrintertbMinAggregateOutputType = {
    ID: number | null
    PrinterName: string | null
    Type: number | null
    Active: number | null
  }

  export type PrintertbMaxAggregateOutputType = {
    ID: number | null
    PrinterName: string | null
    Type: number | null
    Active: number | null
  }

  export type PrintertbCountAggregateOutputType = {
    ID: number
    PrinterName: number
    Type: number
    Active: number
    _all: number
  }


  export type PrintertbAvgAggregateInputType = {
    ID?: true
    Type?: true
    Active?: true
  }

  export type PrintertbSumAggregateInputType = {
    ID?: true
    Type?: true
    Active?: true
  }

  export type PrintertbMinAggregateInputType = {
    ID?: true
    PrinterName?: true
    Type?: true
    Active?: true
  }

  export type PrintertbMaxAggregateInputType = {
    ID?: true
    PrinterName?: true
    Type?: true
    Active?: true
  }

  export type PrintertbCountAggregateInputType = {
    ID?: true
    PrinterName?: true
    Type?: true
    Active?: true
    _all?: true
  }

  export type PrintertbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which printertb to aggregate.
     */
    where?: printertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of printertbs to fetch.
     */
    orderBy?: printertbOrderByWithRelationInput | printertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: printertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` printertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` printertbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned printertbs
    **/
    _count?: true | PrintertbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrintertbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrintertbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrintertbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrintertbMaxAggregateInputType
  }

  export type GetPrintertbAggregateType<T extends PrintertbAggregateArgs> = {
        [P in keyof T & keyof AggregatePrintertb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrintertb[P]>
      : GetScalarType<T[P], AggregatePrintertb[P]>
  }




  export type printertbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: printertbWhereInput
    orderBy?: printertbOrderByWithAggregationInput | printertbOrderByWithAggregationInput[]
    by: PrintertbScalarFieldEnum[] | PrintertbScalarFieldEnum
    having?: printertbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrintertbCountAggregateInputType | true
    _avg?: PrintertbAvgAggregateInputType
    _sum?: PrintertbSumAggregateInputType
    _min?: PrintertbMinAggregateInputType
    _max?: PrintertbMaxAggregateInputType
  }

  export type PrintertbGroupByOutputType = {
    ID: number
    PrinterName: string
    Type: number
    Active: number
    _count: PrintertbCountAggregateOutputType | null
    _avg: PrintertbAvgAggregateOutputType | null
    _sum: PrintertbSumAggregateOutputType | null
    _min: PrintertbMinAggregateOutputType | null
    _max: PrintertbMaxAggregateOutputType | null
  }

  type GetPrintertbGroupByPayload<T extends printertbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrintertbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrintertbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrintertbGroupByOutputType[P]>
            : GetScalarType<T[P], PrintertbGroupByOutputType[P]>
        }
      >
    >


  export type printertbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    PrinterName?: boolean
    Type?: boolean
    Active?: boolean
  }, ExtArgs["result"]["printertb"]>


  export type printertbSelectScalar = {
    ID?: boolean
    PrinterName?: boolean
    Type?: boolean
    Active?: boolean
  }


  export type $printertbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "printertb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      PrinterName: string
      Type: number
      Active: number
    }, ExtArgs["result"]["printertb"]>
    composites: {}
  }

  type printertbGetPayload<S extends boolean | null | undefined | printertbDefaultArgs> = $Result.GetResult<Prisma.$printertbPayload, S>

  type printertbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<printertbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrintertbCountAggregateInputType | true
    }

  export interface printertbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['printertb'], meta: { name: 'printertb' } }
    /**
     * Find zero or one Printertb that matches the filter.
     * @param {printertbFindUniqueArgs} args - Arguments to find a Printertb
     * @example
     * // Get one Printertb
     * const printertb = await prisma.printertb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends printertbFindUniqueArgs>(args: SelectSubset<T, printertbFindUniqueArgs<ExtArgs>>): Prisma__printertbClient<$Result.GetResult<Prisma.$printertbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Printertb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {printertbFindUniqueOrThrowArgs} args - Arguments to find a Printertb
     * @example
     * // Get one Printertb
     * const printertb = await prisma.printertb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends printertbFindUniqueOrThrowArgs>(args: SelectSubset<T, printertbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__printertbClient<$Result.GetResult<Prisma.$printertbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Printertb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printertbFindFirstArgs} args - Arguments to find a Printertb
     * @example
     * // Get one Printertb
     * const printertb = await prisma.printertb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends printertbFindFirstArgs>(args?: SelectSubset<T, printertbFindFirstArgs<ExtArgs>>): Prisma__printertbClient<$Result.GetResult<Prisma.$printertbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Printertb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printertbFindFirstOrThrowArgs} args - Arguments to find a Printertb
     * @example
     * // Get one Printertb
     * const printertb = await prisma.printertb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends printertbFindFirstOrThrowArgs>(args?: SelectSubset<T, printertbFindFirstOrThrowArgs<ExtArgs>>): Prisma__printertbClient<$Result.GetResult<Prisma.$printertbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Printertbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printertbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Printertbs
     * const printertbs = await prisma.printertb.findMany()
     * 
     * // Get first 10 Printertbs
     * const printertbs = await prisma.printertb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const printertbWithIDOnly = await prisma.printertb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends printertbFindManyArgs>(args?: SelectSubset<T, printertbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$printertbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Printertb.
     * @param {printertbCreateArgs} args - Arguments to create a Printertb.
     * @example
     * // Create one Printertb
     * const Printertb = await prisma.printertb.create({
     *   data: {
     *     // ... data to create a Printertb
     *   }
     * })
     * 
     */
    create<T extends printertbCreateArgs>(args: SelectSubset<T, printertbCreateArgs<ExtArgs>>): Prisma__printertbClient<$Result.GetResult<Prisma.$printertbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Printertbs.
     * @param {printertbCreateManyArgs} args - Arguments to create many Printertbs.
     * @example
     * // Create many Printertbs
     * const printertb = await prisma.printertb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends printertbCreateManyArgs>(args?: SelectSubset<T, printertbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Printertb.
     * @param {printertbDeleteArgs} args - Arguments to delete one Printertb.
     * @example
     * // Delete one Printertb
     * const Printertb = await prisma.printertb.delete({
     *   where: {
     *     // ... filter to delete one Printertb
     *   }
     * })
     * 
     */
    delete<T extends printertbDeleteArgs>(args: SelectSubset<T, printertbDeleteArgs<ExtArgs>>): Prisma__printertbClient<$Result.GetResult<Prisma.$printertbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Printertb.
     * @param {printertbUpdateArgs} args - Arguments to update one Printertb.
     * @example
     * // Update one Printertb
     * const printertb = await prisma.printertb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends printertbUpdateArgs>(args: SelectSubset<T, printertbUpdateArgs<ExtArgs>>): Prisma__printertbClient<$Result.GetResult<Prisma.$printertbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Printertbs.
     * @param {printertbDeleteManyArgs} args - Arguments to filter Printertbs to delete.
     * @example
     * // Delete a few Printertbs
     * const { count } = await prisma.printertb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends printertbDeleteManyArgs>(args?: SelectSubset<T, printertbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Printertbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printertbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Printertbs
     * const printertb = await prisma.printertb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends printertbUpdateManyArgs>(args: SelectSubset<T, printertbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Printertb.
     * @param {printertbUpsertArgs} args - Arguments to update or create a Printertb.
     * @example
     * // Update or create a Printertb
     * const printertb = await prisma.printertb.upsert({
     *   create: {
     *     // ... data to create a Printertb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Printertb we want to update
     *   }
     * })
     */
    upsert<T extends printertbUpsertArgs>(args: SelectSubset<T, printertbUpsertArgs<ExtArgs>>): Prisma__printertbClient<$Result.GetResult<Prisma.$printertbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Printertbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printertbCountArgs} args - Arguments to filter Printertbs to count.
     * @example
     * // Count the number of Printertbs
     * const count = await prisma.printertb.count({
     *   where: {
     *     // ... the filter for the Printertbs we want to count
     *   }
     * })
    **/
    count<T extends printertbCountArgs>(
      args?: Subset<T, printertbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrintertbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Printertb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintertbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrintertbAggregateArgs>(args: Subset<T, PrintertbAggregateArgs>): Prisma.PrismaPromise<GetPrintertbAggregateType<T>>

    /**
     * Group by Printertb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printertbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends printertbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: printertbGroupByArgs['orderBy'] }
        : { orderBy?: printertbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, printertbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrintertbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the printertb model
   */
  readonly fields: printertbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for printertb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__printertbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the printertb model
   */ 
  interface printertbFieldRefs {
    readonly ID: FieldRef<"printertb", 'Int'>
    readonly PrinterName: FieldRef<"printertb", 'String'>
    readonly Type: FieldRef<"printertb", 'Int'>
    readonly Active: FieldRef<"printertb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * printertb findUnique
   */
  export type printertbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
    /**
     * Filter, which printertb to fetch.
     */
    where: printertbWhereUniqueInput
  }

  /**
   * printertb findUniqueOrThrow
   */
  export type printertbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
    /**
     * Filter, which printertb to fetch.
     */
    where: printertbWhereUniqueInput
  }

  /**
   * printertb findFirst
   */
  export type printertbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
    /**
     * Filter, which printertb to fetch.
     */
    where?: printertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of printertbs to fetch.
     */
    orderBy?: printertbOrderByWithRelationInput | printertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for printertbs.
     */
    cursor?: printertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` printertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` printertbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of printertbs.
     */
    distinct?: PrintertbScalarFieldEnum | PrintertbScalarFieldEnum[]
  }

  /**
   * printertb findFirstOrThrow
   */
  export type printertbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
    /**
     * Filter, which printertb to fetch.
     */
    where?: printertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of printertbs to fetch.
     */
    orderBy?: printertbOrderByWithRelationInput | printertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for printertbs.
     */
    cursor?: printertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` printertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` printertbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of printertbs.
     */
    distinct?: PrintertbScalarFieldEnum | PrintertbScalarFieldEnum[]
  }

  /**
   * printertb findMany
   */
  export type printertbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
    /**
     * Filter, which printertbs to fetch.
     */
    where?: printertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of printertbs to fetch.
     */
    orderBy?: printertbOrderByWithRelationInput | printertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing printertbs.
     */
    cursor?: printertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` printertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` printertbs.
     */
    skip?: number
    distinct?: PrintertbScalarFieldEnum | PrintertbScalarFieldEnum[]
  }

  /**
   * printertb create
   */
  export type printertbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
    /**
     * The data needed to create a printertb.
     */
    data?: XOR<printertbCreateInput, printertbUncheckedCreateInput>
  }

  /**
   * printertb createMany
   */
  export type printertbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many printertbs.
     */
    data: printertbCreateManyInput | printertbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * printertb update
   */
  export type printertbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
    /**
     * The data needed to update a printertb.
     */
    data: XOR<printertbUpdateInput, printertbUncheckedUpdateInput>
    /**
     * Choose, which printertb to update.
     */
    where: printertbWhereUniqueInput
  }

  /**
   * printertb updateMany
   */
  export type printertbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update printertbs.
     */
    data: XOR<printertbUpdateManyMutationInput, printertbUncheckedUpdateManyInput>
    /**
     * Filter which printertbs to update
     */
    where?: printertbWhereInput
  }

  /**
   * printertb upsert
   */
  export type printertbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
    /**
     * The filter to search for the printertb to update in case it exists.
     */
    where: printertbWhereUniqueInput
    /**
     * In case the printertb found by the `where` argument doesn't exist, create a new printertb with this data.
     */
    create: XOR<printertbCreateInput, printertbUncheckedCreateInput>
    /**
     * In case the printertb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<printertbUpdateInput, printertbUncheckedUpdateInput>
  }

  /**
   * printertb delete
   */
  export type printertbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
    /**
     * Filter which printertb to delete.
     */
    where: printertbWhereUniqueInput
  }

  /**
   * printertb deleteMany
   */
  export type printertbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which printertbs to delete
     */
    where?: printertbWhereInput
  }

  /**
   * printertb without action
   */
  export type printertbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printertb
     */
    select?: printertbSelect<ExtArgs> | null
  }


  /**
   * Model printservicetb
   */

  export type AggregatePrintservicetb = {
    _count: PrintservicetbCountAggregateOutputType | null
    _avg: PrintservicetbAvgAggregateOutputType | null
    _sum: PrintservicetbSumAggregateOutputType | null
    _min: PrintservicetbMinAggregateOutputType | null
    _max: PrintservicetbMaxAggregateOutputType | null
  }

  export type PrintservicetbAvgAggregateOutputType = {
    ID: number | null
    PrinterID: number | null
    ServiceID: number | null
  }

  export type PrintservicetbSumAggregateOutputType = {
    ID: number | null
    PrinterID: number | null
    ServiceID: number | null
  }

  export type PrintservicetbMinAggregateOutputType = {
    ID: number | null
    PrinterID: number | null
    ServiceID: number | null
  }

  export type PrintservicetbMaxAggregateOutputType = {
    ID: number | null
    PrinterID: number | null
    ServiceID: number | null
  }

  export type PrintservicetbCountAggregateOutputType = {
    ID: number
    PrinterID: number
    ServiceID: number
    _all: number
  }


  export type PrintservicetbAvgAggregateInputType = {
    ID?: true
    PrinterID?: true
    ServiceID?: true
  }

  export type PrintservicetbSumAggregateInputType = {
    ID?: true
    PrinterID?: true
    ServiceID?: true
  }

  export type PrintservicetbMinAggregateInputType = {
    ID?: true
    PrinterID?: true
    ServiceID?: true
  }

  export type PrintservicetbMaxAggregateInputType = {
    ID?: true
    PrinterID?: true
    ServiceID?: true
  }

  export type PrintservicetbCountAggregateInputType = {
    ID?: true
    PrinterID?: true
    ServiceID?: true
    _all?: true
  }

  export type PrintservicetbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which printservicetb to aggregate.
     */
    where?: printservicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of printservicetbs to fetch.
     */
    orderBy?: printservicetbOrderByWithRelationInput | printservicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: printservicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` printservicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` printservicetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned printservicetbs
    **/
    _count?: true | PrintservicetbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrintservicetbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrintservicetbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrintservicetbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrintservicetbMaxAggregateInputType
  }

  export type GetPrintservicetbAggregateType<T extends PrintservicetbAggregateArgs> = {
        [P in keyof T & keyof AggregatePrintservicetb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrintservicetb[P]>
      : GetScalarType<T[P], AggregatePrintservicetb[P]>
  }




  export type printservicetbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: printservicetbWhereInput
    orderBy?: printservicetbOrderByWithAggregationInput | printservicetbOrderByWithAggregationInput[]
    by: PrintservicetbScalarFieldEnum[] | PrintservicetbScalarFieldEnum
    having?: printservicetbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrintservicetbCountAggregateInputType | true
    _avg?: PrintservicetbAvgAggregateInputType
    _sum?: PrintservicetbSumAggregateInputType
    _min?: PrintservicetbMinAggregateInputType
    _max?: PrintservicetbMaxAggregateInputType
  }

  export type PrintservicetbGroupByOutputType = {
    ID: number
    PrinterID: number
    ServiceID: number
    _count: PrintservicetbCountAggregateOutputType | null
    _avg: PrintservicetbAvgAggregateOutputType | null
    _sum: PrintservicetbSumAggregateOutputType | null
    _min: PrintservicetbMinAggregateOutputType | null
    _max: PrintservicetbMaxAggregateOutputType | null
  }

  type GetPrintservicetbGroupByPayload<T extends printservicetbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrintservicetbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrintservicetbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrintservicetbGroupByOutputType[P]>
            : GetScalarType<T[P], PrintservicetbGroupByOutputType[P]>
        }
      >
    >


  export type printservicetbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    PrinterID?: boolean
    ServiceID?: boolean
  }, ExtArgs["result"]["printservicetb"]>


  export type printservicetbSelectScalar = {
    ID?: boolean
    PrinterID?: boolean
    ServiceID?: boolean
  }


  export type $printservicetbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "printservicetb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      PrinterID: number
      ServiceID: number
    }, ExtArgs["result"]["printservicetb"]>
    composites: {}
  }

  type printservicetbGetPayload<S extends boolean | null | undefined | printservicetbDefaultArgs> = $Result.GetResult<Prisma.$printservicetbPayload, S>

  type printservicetbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<printservicetbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrintservicetbCountAggregateInputType | true
    }

  export interface printservicetbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['printservicetb'], meta: { name: 'printservicetb' } }
    /**
     * Find zero or one Printservicetb that matches the filter.
     * @param {printservicetbFindUniqueArgs} args - Arguments to find a Printservicetb
     * @example
     * // Get one Printservicetb
     * const printservicetb = await prisma.printservicetb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends printservicetbFindUniqueArgs>(args: SelectSubset<T, printservicetbFindUniqueArgs<ExtArgs>>): Prisma__printservicetbClient<$Result.GetResult<Prisma.$printservicetbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Printservicetb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {printservicetbFindUniqueOrThrowArgs} args - Arguments to find a Printservicetb
     * @example
     * // Get one Printservicetb
     * const printservicetb = await prisma.printservicetb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends printservicetbFindUniqueOrThrowArgs>(args: SelectSubset<T, printservicetbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__printservicetbClient<$Result.GetResult<Prisma.$printservicetbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Printservicetb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printservicetbFindFirstArgs} args - Arguments to find a Printservicetb
     * @example
     * // Get one Printservicetb
     * const printservicetb = await prisma.printservicetb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends printservicetbFindFirstArgs>(args?: SelectSubset<T, printservicetbFindFirstArgs<ExtArgs>>): Prisma__printservicetbClient<$Result.GetResult<Prisma.$printservicetbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Printservicetb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printservicetbFindFirstOrThrowArgs} args - Arguments to find a Printservicetb
     * @example
     * // Get one Printservicetb
     * const printservicetb = await prisma.printservicetb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends printservicetbFindFirstOrThrowArgs>(args?: SelectSubset<T, printservicetbFindFirstOrThrowArgs<ExtArgs>>): Prisma__printservicetbClient<$Result.GetResult<Prisma.$printservicetbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Printservicetbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printservicetbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Printservicetbs
     * const printservicetbs = await prisma.printservicetb.findMany()
     * 
     * // Get first 10 Printservicetbs
     * const printservicetbs = await prisma.printservicetb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const printservicetbWithIDOnly = await prisma.printservicetb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends printservicetbFindManyArgs>(args?: SelectSubset<T, printservicetbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$printservicetbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Printservicetb.
     * @param {printservicetbCreateArgs} args - Arguments to create a Printservicetb.
     * @example
     * // Create one Printservicetb
     * const Printservicetb = await prisma.printservicetb.create({
     *   data: {
     *     // ... data to create a Printservicetb
     *   }
     * })
     * 
     */
    create<T extends printservicetbCreateArgs>(args: SelectSubset<T, printservicetbCreateArgs<ExtArgs>>): Prisma__printservicetbClient<$Result.GetResult<Prisma.$printservicetbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Printservicetbs.
     * @param {printservicetbCreateManyArgs} args - Arguments to create many Printservicetbs.
     * @example
     * // Create many Printservicetbs
     * const printservicetb = await prisma.printservicetb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends printservicetbCreateManyArgs>(args?: SelectSubset<T, printservicetbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Printservicetb.
     * @param {printservicetbDeleteArgs} args - Arguments to delete one Printservicetb.
     * @example
     * // Delete one Printservicetb
     * const Printservicetb = await prisma.printservicetb.delete({
     *   where: {
     *     // ... filter to delete one Printservicetb
     *   }
     * })
     * 
     */
    delete<T extends printservicetbDeleteArgs>(args: SelectSubset<T, printservicetbDeleteArgs<ExtArgs>>): Prisma__printservicetbClient<$Result.GetResult<Prisma.$printservicetbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Printservicetb.
     * @param {printservicetbUpdateArgs} args - Arguments to update one Printservicetb.
     * @example
     * // Update one Printservicetb
     * const printservicetb = await prisma.printservicetb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends printservicetbUpdateArgs>(args: SelectSubset<T, printservicetbUpdateArgs<ExtArgs>>): Prisma__printservicetbClient<$Result.GetResult<Prisma.$printservicetbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Printservicetbs.
     * @param {printservicetbDeleteManyArgs} args - Arguments to filter Printservicetbs to delete.
     * @example
     * // Delete a few Printservicetbs
     * const { count } = await prisma.printservicetb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends printservicetbDeleteManyArgs>(args?: SelectSubset<T, printservicetbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Printservicetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printservicetbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Printservicetbs
     * const printservicetb = await prisma.printservicetb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends printservicetbUpdateManyArgs>(args: SelectSubset<T, printservicetbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Printservicetb.
     * @param {printservicetbUpsertArgs} args - Arguments to update or create a Printservicetb.
     * @example
     * // Update or create a Printservicetb
     * const printservicetb = await prisma.printservicetb.upsert({
     *   create: {
     *     // ... data to create a Printservicetb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Printservicetb we want to update
     *   }
     * })
     */
    upsert<T extends printservicetbUpsertArgs>(args: SelectSubset<T, printservicetbUpsertArgs<ExtArgs>>): Prisma__printservicetbClient<$Result.GetResult<Prisma.$printservicetbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Printservicetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printservicetbCountArgs} args - Arguments to filter Printservicetbs to count.
     * @example
     * // Count the number of Printservicetbs
     * const count = await prisma.printservicetb.count({
     *   where: {
     *     // ... the filter for the Printservicetbs we want to count
     *   }
     * })
    **/
    count<T extends printservicetbCountArgs>(
      args?: Subset<T, printservicetbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrintservicetbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Printservicetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintservicetbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrintservicetbAggregateArgs>(args: Subset<T, PrintservicetbAggregateArgs>): Prisma.PrismaPromise<GetPrintservicetbAggregateType<T>>

    /**
     * Group by Printservicetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {printservicetbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends printservicetbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: printservicetbGroupByArgs['orderBy'] }
        : { orderBy?: printservicetbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, printservicetbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrintservicetbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the printservicetb model
   */
  readonly fields: printservicetbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for printservicetb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__printservicetbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the printservicetb model
   */ 
  interface printservicetbFieldRefs {
    readonly ID: FieldRef<"printservicetb", 'Int'>
    readonly PrinterID: FieldRef<"printservicetb", 'Int'>
    readonly ServiceID: FieldRef<"printservicetb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * printservicetb findUnique
   */
  export type printservicetbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
    /**
     * Filter, which printservicetb to fetch.
     */
    where: printservicetbWhereUniqueInput
  }

  /**
   * printservicetb findUniqueOrThrow
   */
  export type printservicetbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
    /**
     * Filter, which printservicetb to fetch.
     */
    where: printservicetbWhereUniqueInput
  }

  /**
   * printservicetb findFirst
   */
  export type printservicetbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
    /**
     * Filter, which printservicetb to fetch.
     */
    where?: printservicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of printservicetbs to fetch.
     */
    orderBy?: printservicetbOrderByWithRelationInput | printservicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for printservicetbs.
     */
    cursor?: printservicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` printservicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` printservicetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of printservicetbs.
     */
    distinct?: PrintservicetbScalarFieldEnum | PrintservicetbScalarFieldEnum[]
  }

  /**
   * printservicetb findFirstOrThrow
   */
  export type printservicetbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
    /**
     * Filter, which printservicetb to fetch.
     */
    where?: printservicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of printservicetbs to fetch.
     */
    orderBy?: printservicetbOrderByWithRelationInput | printservicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for printservicetbs.
     */
    cursor?: printservicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` printservicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` printservicetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of printservicetbs.
     */
    distinct?: PrintservicetbScalarFieldEnum | PrintservicetbScalarFieldEnum[]
  }

  /**
   * printservicetb findMany
   */
  export type printservicetbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
    /**
     * Filter, which printservicetbs to fetch.
     */
    where?: printservicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of printservicetbs to fetch.
     */
    orderBy?: printservicetbOrderByWithRelationInput | printservicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing printservicetbs.
     */
    cursor?: printservicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` printservicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` printservicetbs.
     */
    skip?: number
    distinct?: PrintservicetbScalarFieldEnum | PrintservicetbScalarFieldEnum[]
  }

  /**
   * printservicetb create
   */
  export type printservicetbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
    /**
     * The data needed to create a printservicetb.
     */
    data?: XOR<printservicetbCreateInput, printservicetbUncheckedCreateInput>
  }

  /**
   * printservicetb createMany
   */
  export type printservicetbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many printservicetbs.
     */
    data: printservicetbCreateManyInput | printservicetbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * printservicetb update
   */
  export type printservicetbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
    /**
     * The data needed to update a printservicetb.
     */
    data: XOR<printservicetbUpdateInput, printservicetbUncheckedUpdateInput>
    /**
     * Choose, which printservicetb to update.
     */
    where: printservicetbWhereUniqueInput
  }

  /**
   * printservicetb updateMany
   */
  export type printservicetbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update printservicetbs.
     */
    data: XOR<printservicetbUpdateManyMutationInput, printservicetbUncheckedUpdateManyInput>
    /**
     * Filter which printservicetbs to update
     */
    where?: printservicetbWhereInput
  }

  /**
   * printservicetb upsert
   */
  export type printservicetbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
    /**
     * The filter to search for the printservicetb to update in case it exists.
     */
    where: printservicetbWhereUniqueInput
    /**
     * In case the printservicetb found by the `where` argument doesn't exist, create a new printservicetb with this data.
     */
    create: XOR<printservicetbCreateInput, printservicetbUncheckedCreateInput>
    /**
     * In case the printservicetb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<printservicetbUpdateInput, printservicetbUncheckedUpdateInput>
  }

  /**
   * printservicetb delete
   */
  export type printservicetbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
    /**
     * Filter which printservicetb to delete.
     */
    where: printservicetbWhereUniqueInput
  }

  /**
   * printservicetb deleteMany
   */
  export type printservicetbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which printservicetbs to delete
     */
    where?: printservicetbWhereInput
  }

  /**
   * printservicetb without action
   */
  export type printservicetbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the printservicetb
     */
    select?: printservicetbSelect<ExtArgs> | null
  }


  /**
   * Model processtb
   */

  export type AggregateProcesstb = {
    _count: ProcesstbCountAggregateOutputType | null
    _avg: ProcesstbAvgAggregateOutputType | null
    _sum: ProcesstbSumAggregateOutputType | null
    _min: ProcesstbMinAggregateOutputType | null
    _max: ProcesstbMaxAggregateOutputType | null
  }

  export type ProcesstbAvgAggregateOutputType = {
    ID: number | null
    Type: number | null
  }

  export type ProcesstbSumAggregateOutputType = {
    ID: number | null
    Type: number | null
  }

  export type ProcesstbMinAggregateOutputType = {
    ID: number | null
    MachineName: string | null
    ProcessName: string | null
    FileLocation: string | null
    FileDescription: string | null
    Type: number | null
    PreviousDate: Date | null
    CurrentDate: Date | null
  }

  export type ProcesstbMaxAggregateOutputType = {
    ID: number | null
    MachineName: string | null
    ProcessName: string | null
    FileLocation: string | null
    FileDescription: string | null
    Type: number | null
    PreviousDate: Date | null
    CurrentDate: Date | null
  }

  export type ProcesstbCountAggregateOutputType = {
    ID: number
    MachineName: number
    ProcessName: number
    FileLocation: number
    FileDescription: number
    Type: number
    PreviousDate: number
    CurrentDate: number
    _all: number
  }


  export type ProcesstbAvgAggregateInputType = {
    ID?: true
    Type?: true
  }

  export type ProcesstbSumAggregateInputType = {
    ID?: true
    Type?: true
  }

  export type ProcesstbMinAggregateInputType = {
    ID?: true
    MachineName?: true
    ProcessName?: true
    FileLocation?: true
    FileDescription?: true
    Type?: true
    PreviousDate?: true
    CurrentDate?: true
  }

  export type ProcesstbMaxAggregateInputType = {
    ID?: true
    MachineName?: true
    ProcessName?: true
    FileLocation?: true
    FileDescription?: true
    Type?: true
    PreviousDate?: true
    CurrentDate?: true
  }

  export type ProcesstbCountAggregateInputType = {
    ID?: true
    MachineName?: true
    ProcessName?: true
    FileLocation?: true
    FileDescription?: true
    Type?: true
    PreviousDate?: true
    CurrentDate?: true
    _all?: true
  }

  export type ProcesstbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which processtb to aggregate.
     */
    where?: processtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of processtbs to fetch.
     */
    orderBy?: processtbOrderByWithRelationInput | processtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: processtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` processtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` processtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned processtbs
    **/
    _count?: true | ProcesstbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcesstbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcesstbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcesstbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcesstbMaxAggregateInputType
  }

  export type GetProcesstbAggregateType<T extends ProcesstbAggregateArgs> = {
        [P in keyof T & keyof AggregateProcesstb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcesstb[P]>
      : GetScalarType<T[P], AggregateProcesstb[P]>
  }




  export type processtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: processtbWhereInput
    orderBy?: processtbOrderByWithAggregationInput | processtbOrderByWithAggregationInput[]
    by: ProcesstbScalarFieldEnum[] | ProcesstbScalarFieldEnum
    having?: processtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcesstbCountAggregateInputType | true
    _avg?: ProcesstbAvgAggregateInputType
    _sum?: ProcesstbSumAggregateInputType
    _min?: ProcesstbMinAggregateInputType
    _max?: ProcesstbMaxAggregateInputType
  }

  export type ProcesstbGroupByOutputType = {
    ID: number
    MachineName: string
    ProcessName: string
    FileLocation: string
    FileDescription: string
    Type: number
    PreviousDate: Date
    CurrentDate: Date
    _count: ProcesstbCountAggregateOutputType | null
    _avg: ProcesstbAvgAggregateOutputType | null
    _sum: ProcesstbSumAggregateOutputType | null
    _min: ProcesstbMinAggregateOutputType | null
    _max: ProcesstbMaxAggregateOutputType | null
  }

  type GetProcesstbGroupByPayload<T extends processtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcesstbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcesstbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcesstbGroupByOutputType[P]>
            : GetScalarType<T[P], ProcesstbGroupByOutputType[P]>
        }
      >
    >


  export type processtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    MachineName?: boolean
    ProcessName?: boolean
    FileLocation?: boolean
    FileDescription?: boolean
    Type?: boolean
    PreviousDate?: boolean
    CurrentDate?: boolean
  }, ExtArgs["result"]["processtb"]>


  export type processtbSelectScalar = {
    ID?: boolean
    MachineName?: boolean
    ProcessName?: boolean
    FileLocation?: boolean
    FileDescription?: boolean
    Type?: boolean
    PreviousDate?: boolean
    CurrentDate?: boolean
  }


  export type $processtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "processtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      MachineName: string
      ProcessName: string
      FileLocation: string
      FileDescription: string
      Type: number
      PreviousDate: Date
      CurrentDate: Date
    }, ExtArgs["result"]["processtb"]>
    composites: {}
  }

  type processtbGetPayload<S extends boolean | null | undefined | processtbDefaultArgs> = $Result.GetResult<Prisma.$processtbPayload, S>

  type processtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<processtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcesstbCountAggregateInputType | true
    }

  export interface processtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['processtb'], meta: { name: 'processtb' } }
    /**
     * Find zero or one Processtb that matches the filter.
     * @param {processtbFindUniqueArgs} args - Arguments to find a Processtb
     * @example
     * // Get one Processtb
     * const processtb = await prisma.processtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends processtbFindUniqueArgs>(args: SelectSubset<T, processtbFindUniqueArgs<ExtArgs>>): Prisma__processtbClient<$Result.GetResult<Prisma.$processtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Processtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {processtbFindUniqueOrThrowArgs} args - Arguments to find a Processtb
     * @example
     * // Get one Processtb
     * const processtb = await prisma.processtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends processtbFindUniqueOrThrowArgs>(args: SelectSubset<T, processtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__processtbClient<$Result.GetResult<Prisma.$processtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Processtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {processtbFindFirstArgs} args - Arguments to find a Processtb
     * @example
     * // Get one Processtb
     * const processtb = await prisma.processtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends processtbFindFirstArgs>(args?: SelectSubset<T, processtbFindFirstArgs<ExtArgs>>): Prisma__processtbClient<$Result.GetResult<Prisma.$processtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Processtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {processtbFindFirstOrThrowArgs} args - Arguments to find a Processtb
     * @example
     * // Get one Processtb
     * const processtb = await prisma.processtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends processtbFindFirstOrThrowArgs>(args?: SelectSubset<T, processtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__processtbClient<$Result.GetResult<Prisma.$processtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Processtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {processtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Processtbs
     * const processtbs = await prisma.processtb.findMany()
     * 
     * // Get first 10 Processtbs
     * const processtbs = await prisma.processtb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const processtbWithIDOnly = await prisma.processtb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends processtbFindManyArgs>(args?: SelectSubset<T, processtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$processtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Processtb.
     * @param {processtbCreateArgs} args - Arguments to create a Processtb.
     * @example
     * // Create one Processtb
     * const Processtb = await prisma.processtb.create({
     *   data: {
     *     // ... data to create a Processtb
     *   }
     * })
     * 
     */
    create<T extends processtbCreateArgs>(args: SelectSubset<T, processtbCreateArgs<ExtArgs>>): Prisma__processtbClient<$Result.GetResult<Prisma.$processtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Processtbs.
     * @param {processtbCreateManyArgs} args - Arguments to create many Processtbs.
     * @example
     * // Create many Processtbs
     * const processtb = await prisma.processtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends processtbCreateManyArgs>(args?: SelectSubset<T, processtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Processtb.
     * @param {processtbDeleteArgs} args - Arguments to delete one Processtb.
     * @example
     * // Delete one Processtb
     * const Processtb = await prisma.processtb.delete({
     *   where: {
     *     // ... filter to delete one Processtb
     *   }
     * })
     * 
     */
    delete<T extends processtbDeleteArgs>(args: SelectSubset<T, processtbDeleteArgs<ExtArgs>>): Prisma__processtbClient<$Result.GetResult<Prisma.$processtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Processtb.
     * @param {processtbUpdateArgs} args - Arguments to update one Processtb.
     * @example
     * // Update one Processtb
     * const processtb = await prisma.processtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends processtbUpdateArgs>(args: SelectSubset<T, processtbUpdateArgs<ExtArgs>>): Prisma__processtbClient<$Result.GetResult<Prisma.$processtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Processtbs.
     * @param {processtbDeleteManyArgs} args - Arguments to filter Processtbs to delete.
     * @example
     * // Delete a few Processtbs
     * const { count } = await prisma.processtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends processtbDeleteManyArgs>(args?: SelectSubset<T, processtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Processtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {processtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Processtbs
     * const processtb = await prisma.processtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends processtbUpdateManyArgs>(args: SelectSubset<T, processtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Processtb.
     * @param {processtbUpsertArgs} args - Arguments to update or create a Processtb.
     * @example
     * // Update or create a Processtb
     * const processtb = await prisma.processtb.upsert({
     *   create: {
     *     // ... data to create a Processtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Processtb we want to update
     *   }
     * })
     */
    upsert<T extends processtbUpsertArgs>(args: SelectSubset<T, processtbUpsertArgs<ExtArgs>>): Prisma__processtbClient<$Result.GetResult<Prisma.$processtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Processtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {processtbCountArgs} args - Arguments to filter Processtbs to count.
     * @example
     * // Count the number of Processtbs
     * const count = await prisma.processtb.count({
     *   where: {
     *     // ... the filter for the Processtbs we want to count
     *   }
     * })
    **/
    count<T extends processtbCountArgs>(
      args?: Subset<T, processtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcesstbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Processtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesstbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcesstbAggregateArgs>(args: Subset<T, ProcesstbAggregateArgs>): Prisma.PrismaPromise<GetProcesstbAggregateType<T>>

    /**
     * Group by Processtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {processtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends processtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: processtbGroupByArgs['orderBy'] }
        : { orderBy?: processtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, processtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcesstbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the processtb model
   */
  readonly fields: processtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for processtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__processtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the processtb model
   */ 
  interface processtbFieldRefs {
    readonly ID: FieldRef<"processtb", 'Int'>
    readonly MachineName: FieldRef<"processtb", 'String'>
    readonly ProcessName: FieldRef<"processtb", 'String'>
    readonly FileLocation: FieldRef<"processtb", 'String'>
    readonly FileDescription: FieldRef<"processtb", 'String'>
    readonly Type: FieldRef<"processtb", 'Int'>
    readonly PreviousDate: FieldRef<"processtb", 'DateTime'>
    readonly CurrentDate: FieldRef<"processtb", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * processtb findUnique
   */
  export type processtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
    /**
     * Filter, which processtb to fetch.
     */
    where: processtbWhereUniqueInput
  }

  /**
   * processtb findUniqueOrThrow
   */
  export type processtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
    /**
     * Filter, which processtb to fetch.
     */
    where: processtbWhereUniqueInput
  }

  /**
   * processtb findFirst
   */
  export type processtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
    /**
     * Filter, which processtb to fetch.
     */
    where?: processtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of processtbs to fetch.
     */
    orderBy?: processtbOrderByWithRelationInput | processtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for processtbs.
     */
    cursor?: processtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` processtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` processtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of processtbs.
     */
    distinct?: ProcesstbScalarFieldEnum | ProcesstbScalarFieldEnum[]
  }

  /**
   * processtb findFirstOrThrow
   */
  export type processtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
    /**
     * Filter, which processtb to fetch.
     */
    where?: processtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of processtbs to fetch.
     */
    orderBy?: processtbOrderByWithRelationInput | processtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for processtbs.
     */
    cursor?: processtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` processtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` processtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of processtbs.
     */
    distinct?: ProcesstbScalarFieldEnum | ProcesstbScalarFieldEnum[]
  }

  /**
   * processtb findMany
   */
  export type processtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
    /**
     * Filter, which processtbs to fetch.
     */
    where?: processtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of processtbs to fetch.
     */
    orderBy?: processtbOrderByWithRelationInput | processtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing processtbs.
     */
    cursor?: processtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` processtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` processtbs.
     */
    skip?: number
    distinct?: ProcesstbScalarFieldEnum | ProcesstbScalarFieldEnum[]
  }

  /**
   * processtb create
   */
  export type processtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
    /**
     * The data needed to create a processtb.
     */
    data?: XOR<processtbCreateInput, processtbUncheckedCreateInput>
  }

  /**
   * processtb createMany
   */
  export type processtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many processtbs.
     */
    data: processtbCreateManyInput | processtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * processtb update
   */
  export type processtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
    /**
     * The data needed to update a processtb.
     */
    data: XOR<processtbUpdateInput, processtbUncheckedUpdateInput>
    /**
     * Choose, which processtb to update.
     */
    where: processtbWhereUniqueInput
  }

  /**
   * processtb updateMany
   */
  export type processtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update processtbs.
     */
    data: XOR<processtbUpdateManyMutationInput, processtbUncheckedUpdateManyInput>
    /**
     * Filter which processtbs to update
     */
    where?: processtbWhereInput
  }

  /**
   * processtb upsert
   */
  export type processtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
    /**
     * The filter to search for the processtb to update in case it exists.
     */
    where: processtbWhereUniqueInput
    /**
     * In case the processtb found by the `where` argument doesn't exist, create a new processtb with this data.
     */
    create: XOR<processtbCreateInput, processtbUncheckedCreateInput>
    /**
     * In case the processtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<processtbUpdateInput, processtbUncheckedUpdateInput>
  }

  /**
   * processtb delete
   */
  export type processtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
    /**
     * Filter which processtb to delete.
     */
    where: processtbWhereUniqueInput
  }

  /**
   * processtb deleteMany
   */
  export type processtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which processtbs to delete
     */
    where?: processtbWhereInput
  }

  /**
   * processtb without action
   */
  export type processtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the processtb
     */
    select?: processtbSelect<ExtArgs> | null
  }


  /**
   * Model rechargecarddetailtb
   */

  export type AggregateRechargecarddetailtb = {
    _count: RechargecarddetailtbCountAggregateOutputType | null
    _avg: RechargecarddetailtbAvgAggregateOutputType | null
    _sum: RechargecarddetailtbSumAggregateOutputType | null
    _min: RechargecarddetailtbMinAggregateOutputType | null
    _max: RechargecarddetailtbMaxAggregateOutputType | null
  }

  export type RechargecarddetailtbAvgAggregateOutputType = {
    CardDetailId: number | null
    VoucherId: number | null
    StaffId: number | null
    CardValue: Decimal | null
    CardQuantity: number | null
    CardAmount: Decimal | null
    UserId: number | null
  }

  export type RechargecarddetailtbSumAggregateOutputType = {
    CardDetailId: number | null
    VoucherId: number | null
    StaffId: number | null
    CardValue: Decimal | null
    CardQuantity: number | null
    CardAmount: Decimal | null
    UserId: number | null
  }

  export type RechargecarddetailtbMinAggregateOutputType = {
    CardDetailId: number | null
    VoucherId: number | null
    StaffId: number | null
    CardValue: Decimal | null
    CardDate: Date | null
    CardTime: Date | null
    CardQuantity: number | null
    CardAmount: Decimal | null
    UserId: number | null
    Accept: boolean | null
  }

  export type RechargecarddetailtbMaxAggregateOutputType = {
    CardDetailId: number | null
    VoucherId: number | null
    StaffId: number | null
    CardValue: Decimal | null
    CardDate: Date | null
    CardTime: Date | null
    CardQuantity: number | null
    CardAmount: Decimal | null
    UserId: number | null
    Accept: boolean | null
  }

  export type RechargecarddetailtbCountAggregateOutputType = {
    CardDetailId: number
    VoucherId: number
    StaffId: number
    CardValue: number
    CardDate: number
    CardTime: number
    CardQuantity: number
    CardAmount: number
    UserId: number
    Accept: number
    _all: number
  }


  export type RechargecarddetailtbAvgAggregateInputType = {
    CardDetailId?: true
    VoucherId?: true
    StaffId?: true
    CardValue?: true
    CardQuantity?: true
    CardAmount?: true
    UserId?: true
  }

  export type RechargecarddetailtbSumAggregateInputType = {
    CardDetailId?: true
    VoucherId?: true
    StaffId?: true
    CardValue?: true
    CardQuantity?: true
    CardAmount?: true
    UserId?: true
  }

  export type RechargecarddetailtbMinAggregateInputType = {
    CardDetailId?: true
    VoucherId?: true
    StaffId?: true
    CardValue?: true
    CardDate?: true
    CardTime?: true
    CardQuantity?: true
    CardAmount?: true
    UserId?: true
    Accept?: true
  }

  export type RechargecarddetailtbMaxAggregateInputType = {
    CardDetailId?: true
    VoucherId?: true
    StaffId?: true
    CardValue?: true
    CardDate?: true
    CardTime?: true
    CardQuantity?: true
    CardAmount?: true
    UserId?: true
    Accept?: true
  }

  export type RechargecarddetailtbCountAggregateInputType = {
    CardDetailId?: true
    VoucherId?: true
    StaffId?: true
    CardValue?: true
    CardDate?: true
    CardTime?: true
    CardQuantity?: true
    CardAmount?: true
    UserId?: true
    Accept?: true
    _all?: true
  }

  export type RechargecarddetailtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rechargecarddetailtb to aggregate.
     */
    where?: rechargecarddetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rechargecarddetailtbs to fetch.
     */
    orderBy?: rechargecarddetailtbOrderByWithRelationInput | rechargecarddetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rechargecarddetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rechargecarddetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rechargecarddetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rechargecarddetailtbs
    **/
    _count?: true | RechargecarddetailtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RechargecarddetailtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RechargecarddetailtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RechargecarddetailtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RechargecarddetailtbMaxAggregateInputType
  }

  export type GetRechargecarddetailtbAggregateType<T extends RechargecarddetailtbAggregateArgs> = {
        [P in keyof T & keyof AggregateRechargecarddetailtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRechargecarddetailtb[P]>
      : GetScalarType<T[P], AggregateRechargecarddetailtb[P]>
  }




  export type rechargecarddetailtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rechargecarddetailtbWhereInput
    orderBy?: rechargecarddetailtbOrderByWithAggregationInput | rechargecarddetailtbOrderByWithAggregationInput[]
    by: RechargecarddetailtbScalarFieldEnum[] | RechargecarddetailtbScalarFieldEnum
    having?: rechargecarddetailtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RechargecarddetailtbCountAggregateInputType | true
    _avg?: RechargecarddetailtbAvgAggregateInputType
    _sum?: RechargecarddetailtbSumAggregateInputType
    _min?: RechargecarddetailtbMinAggregateInputType
    _max?: RechargecarddetailtbMaxAggregateInputType
  }

  export type RechargecarddetailtbGroupByOutputType = {
    CardDetailId: number
    VoucherId: number
    StaffId: number
    CardValue: Decimal
    CardDate: Date
    CardTime: Date
    CardQuantity: number
    CardAmount: Decimal
    UserId: number | null
    Accept: boolean | null
    _count: RechargecarddetailtbCountAggregateOutputType | null
    _avg: RechargecarddetailtbAvgAggregateOutputType | null
    _sum: RechargecarddetailtbSumAggregateOutputType | null
    _min: RechargecarddetailtbMinAggregateOutputType | null
    _max: RechargecarddetailtbMaxAggregateOutputType | null
  }

  type GetRechargecarddetailtbGroupByPayload<T extends rechargecarddetailtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RechargecarddetailtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RechargecarddetailtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RechargecarddetailtbGroupByOutputType[P]>
            : GetScalarType<T[P], RechargecarddetailtbGroupByOutputType[P]>
        }
      >
    >


  export type rechargecarddetailtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CardDetailId?: boolean
    VoucherId?: boolean
    StaffId?: boolean
    CardValue?: boolean
    CardDate?: boolean
    CardTime?: boolean
    CardQuantity?: boolean
    CardAmount?: boolean
    UserId?: boolean
    Accept?: boolean
  }, ExtArgs["result"]["rechargecarddetailtb"]>


  export type rechargecarddetailtbSelectScalar = {
    CardDetailId?: boolean
    VoucherId?: boolean
    StaffId?: boolean
    CardValue?: boolean
    CardDate?: boolean
    CardTime?: boolean
    CardQuantity?: boolean
    CardAmount?: boolean
    UserId?: boolean
    Accept?: boolean
  }


  export type $rechargecarddetailtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rechargecarddetailtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CardDetailId: number
      VoucherId: number
      StaffId: number
      CardValue: Prisma.Decimal
      CardDate: Date
      CardTime: Date
      CardQuantity: number
      CardAmount: Prisma.Decimal
      UserId: number | null
      Accept: boolean | null
    }, ExtArgs["result"]["rechargecarddetailtb"]>
    composites: {}
  }

  type rechargecarddetailtbGetPayload<S extends boolean | null | undefined | rechargecarddetailtbDefaultArgs> = $Result.GetResult<Prisma.$rechargecarddetailtbPayload, S>

  type rechargecarddetailtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rechargecarddetailtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RechargecarddetailtbCountAggregateInputType | true
    }

  export interface rechargecarddetailtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rechargecarddetailtb'], meta: { name: 'rechargecarddetailtb' } }
    /**
     * Find zero or one Rechargecarddetailtb that matches the filter.
     * @param {rechargecarddetailtbFindUniqueArgs} args - Arguments to find a Rechargecarddetailtb
     * @example
     * // Get one Rechargecarddetailtb
     * const rechargecarddetailtb = await prisma.rechargecarddetailtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rechargecarddetailtbFindUniqueArgs>(args: SelectSubset<T, rechargecarddetailtbFindUniqueArgs<ExtArgs>>): Prisma__rechargecarddetailtbClient<$Result.GetResult<Prisma.$rechargecarddetailtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rechargecarddetailtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rechargecarddetailtbFindUniqueOrThrowArgs} args - Arguments to find a Rechargecarddetailtb
     * @example
     * // Get one Rechargecarddetailtb
     * const rechargecarddetailtb = await prisma.rechargecarddetailtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rechargecarddetailtbFindUniqueOrThrowArgs>(args: SelectSubset<T, rechargecarddetailtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rechargecarddetailtbClient<$Result.GetResult<Prisma.$rechargecarddetailtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rechargecarddetailtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecarddetailtbFindFirstArgs} args - Arguments to find a Rechargecarddetailtb
     * @example
     * // Get one Rechargecarddetailtb
     * const rechargecarddetailtb = await prisma.rechargecarddetailtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rechargecarddetailtbFindFirstArgs>(args?: SelectSubset<T, rechargecarddetailtbFindFirstArgs<ExtArgs>>): Prisma__rechargecarddetailtbClient<$Result.GetResult<Prisma.$rechargecarddetailtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rechargecarddetailtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecarddetailtbFindFirstOrThrowArgs} args - Arguments to find a Rechargecarddetailtb
     * @example
     * // Get one Rechargecarddetailtb
     * const rechargecarddetailtb = await prisma.rechargecarddetailtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rechargecarddetailtbFindFirstOrThrowArgs>(args?: SelectSubset<T, rechargecarddetailtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__rechargecarddetailtbClient<$Result.GetResult<Prisma.$rechargecarddetailtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rechargecarddetailtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecarddetailtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rechargecarddetailtbs
     * const rechargecarddetailtbs = await prisma.rechargecarddetailtb.findMany()
     * 
     * // Get first 10 Rechargecarddetailtbs
     * const rechargecarddetailtbs = await prisma.rechargecarddetailtb.findMany({ take: 10 })
     * 
     * // Only select the `CardDetailId`
     * const rechargecarddetailtbWithCardDetailIdOnly = await prisma.rechargecarddetailtb.findMany({ select: { CardDetailId: true } })
     * 
     */
    findMany<T extends rechargecarddetailtbFindManyArgs>(args?: SelectSubset<T, rechargecarddetailtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rechargecarddetailtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rechargecarddetailtb.
     * @param {rechargecarddetailtbCreateArgs} args - Arguments to create a Rechargecarddetailtb.
     * @example
     * // Create one Rechargecarddetailtb
     * const Rechargecarddetailtb = await prisma.rechargecarddetailtb.create({
     *   data: {
     *     // ... data to create a Rechargecarddetailtb
     *   }
     * })
     * 
     */
    create<T extends rechargecarddetailtbCreateArgs>(args: SelectSubset<T, rechargecarddetailtbCreateArgs<ExtArgs>>): Prisma__rechargecarddetailtbClient<$Result.GetResult<Prisma.$rechargecarddetailtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rechargecarddetailtbs.
     * @param {rechargecarddetailtbCreateManyArgs} args - Arguments to create many Rechargecarddetailtbs.
     * @example
     * // Create many Rechargecarddetailtbs
     * const rechargecarddetailtb = await prisma.rechargecarddetailtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rechargecarddetailtbCreateManyArgs>(args?: SelectSubset<T, rechargecarddetailtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rechargecarddetailtb.
     * @param {rechargecarddetailtbDeleteArgs} args - Arguments to delete one Rechargecarddetailtb.
     * @example
     * // Delete one Rechargecarddetailtb
     * const Rechargecarddetailtb = await prisma.rechargecarddetailtb.delete({
     *   where: {
     *     // ... filter to delete one Rechargecarddetailtb
     *   }
     * })
     * 
     */
    delete<T extends rechargecarddetailtbDeleteArgs>(args: SelectSubset<T, rechargecarddetailtbDeleteArgs<ExtArgs>>): Prisma__rechargecarddetailtbClient<$Result.GetResult<Prisma.$rechargecarddetailtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rechargecarddetailtb.
     * @param {rechargecarddetailtbUpdateArgs} args - Arguments to update one Rechargecarddetailtb.
     * @example
     * // Update one Rechargecarddetailtb
     * const rechargecarddetailtb = await prisma.rechargecarddetailtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rechargecarddetailtbUpdateArgs>(args: SelectSubset<T, rechargecarddetailtbUpdateArgs<ExtArgs>>): Prisma__rechargecarddetailtbClient<$Result.GetResult<Prisma.$rechargecarddetailtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rechargecarddetailtbs.
     * @param {rechargecarddetailtbDeleteManyArgs} args - Arguments to filter Rechargecarddetailtbs to delete.
     * @example
     * // Delete a few Rechargecarddetailtbs
     * const { count } = await prisma.rechargecarddetailtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rechargecarddetailtbDeleteManyArgs>(args?: SelectSubset<T, rechargecarddetailtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rechargecarddetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecarddetailtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rechargecarddetailtbs
     * const rechargecarddetailtb = await prisma.rechargecarddetailtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rechargecarddetailtbUpdateManyArgs>(args: SelectSubset<T, rechargecarddetailtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rechargecarddetailtb.
     * @param {rechargecarddetailtbUpsertArgs} args - Arguments to update or create a Rechargecarddetailtb.
     * @example
     * // Update or create a Rechargecarddetailtb
     * const rechargecarddetailtb = await prisma.rechargecarddetailtb.upsert({
     *   create: {
     *     // ... data to create a Rechargecarddetailtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rechargecarddetailtb we want to update
     *   }
     * })
     */
    upsert<T extends rechargecarddetailtbUpsertArgs>(args: SelectSubset<T, rechargecarddetailtbUpsertArgs<ExtArgs>>): Prisma__rechargecarddetailtbClient<$Result.GetResult<Prisma.$rechargecarddetailtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rechargecarddetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecarddetailtbCountArgs} args - Arguments to filter Rechargecarddetailtbs to count.
     * @example
     * // Count the number of Rechargecarddetailtbs
     * const count = await prisma.rechargecarddetailtb.count({
     *   where: {
     *     // ... the filter for the Rechargecarddetailtbs we want to count
     *   }
     * })
    **/
    count<T extends rechargecarddetailtbCountArgs>(
      args?: Subset<T, rechargecarddetailtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RechargecarddetailtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rechargecarddetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargecarddetailtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RechargecarddetailtbAggregateArgs>(args: Subset<T, RechargecarddetailtbAggregateArgs>): Prisma.PrismaPromise<GetRechargecarddetailtbAggregateType<T>>

    /**
     * Group by Rechargecarddetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecarddetailtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rechargecarddetailtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rechargecarddetailtbGroupByArgs['orderBy'] }
        : { orderBy?: rechargecarddetailtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rechargecarddetailtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRechargecarddetailtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rechargecarddetailtb model
   */
  readonly fields: rechargecarddetailtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rechargecarddetailtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rechargecarddetailtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rechargecarddetailtb model
   */ 
  interface rechargecarddetailtbFieldRefs {
    readonly CardDetailId: FieldRef<"rechargecarddetailtb", 'Int'>
    readonly VoucherId: FieldRef<"rechargecarddetailtb", 'Int'>
    readonly StaffId: FieldRef<"rechargecarddetailtb", 'Int'>
    readonly CardValue: FieldRef<"rechargecarddetailtb", 'Decimal'>
    readonly CardDate: FieldRef<"rechargecarddetailtb", 'DateTime'>
    readonly CardTime: FieldRef<"rechargecarddetailtb", 'DateTime'>
    readonly CardQuantity: FieldRef<"rechargecarddetailtb", 'Int'>
    readonly CardAmount: FieldRef<"rechargecarddetailtb", 'Decimal'>
    readonly UserId: FieldRef<"rechargecarddetailtb", 'Int'>
    readonly Accept: FieldRef<"rechargecarddetailtb", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * rechargecarddetailtb findUnique
   */
  export type rechargecarddetailtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecarddetailtb to fetch.
     */
    where: rechargecarddetailtbWhereUniqueInput
  }

  /**
   * rechargecarddetailtb findUniqueOrThrow
   */
  export type rechargecarddetailtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecarddetailtb to fetch.
     */
    where: rechargecarddetailtbWhereUniqueInput
  }

  /**
   * rechargecarddetailtb findFirst
   */
  export type rechargecarddetailtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecarddetailtb to fetch.
     */
    where?: rechargecarddetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rechargecarddetailtbs to fetch.
     */
    orderBy?: rechargecarddetailtbOrderByWithRelationInput | rechargecarddetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rechargecarddetailtbs.
     */
    cursor?: rechargecarddetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rechargecarddetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rechargecarddetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rechargecarddetailtbs.
     */
    distinct?: RechargecarddetailtbScalarFieldEnum | RechargecarddetailtbScalarFieldEnum[]
  }

  /**
   * rechargecarddetailtb findFirstOrThrow
   */
  export type rechargecarddetailtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecarddetailtb to fetch.
     */
    where?: rechargecarddetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rechargecarddetailtbs to fetch.
     */
    orderBy?: rechargecarddetailtbOrderByWithRelationInput | rechargecarddetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rechargecarddetailtbs.
     */
    cursor?: rechargecarddetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rechargecarddetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rechargecarddetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rechargecarddetailtbs.
     */
    distinct?: RechargecarddetailtbScalarFieldEnum | RechargecarddetailtbScalarFieldEnum[]
  }

  /**
   * rechargecarddetailtb findMany
   */
  export type rechargecarddetailtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecarddetailtbs to fetch.
     */
    where?: rechargecarddetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rechargecarddetailtbs to fetch.
     */
    orderBy?: rechargecarddetailtbOrderByWithRelationInput | rechargecarddetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rechargecarddetailtbs.
     */
    cursor?: rechargecarddetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rechargecarddetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rechargecarddetailtbs.
     */
    skip?: number
    distinct?: RechargecarddetailtbScalarFieldEnum | RechargecarddetailtbScalarFieldEnum[]
  }

  /**
   * rechargecarddetailtb create
   */
  export type rechargecarddetailtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
    /**
     * The data needed to create a rechargecarddetailtb.
     */
    data: XOR<rechargecarddetailtbCreateInput, rechargecarddetailtbUncheckedCreateInput>
  }

  /**
   * rechargecarddetailtb createMany
   */
  export type rechargecarddetailtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rechargecarddetailtbs.
     */
    data: rechargecarddetailtbCreateManyInput | rechargecarddetailtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rechargecarddetailtb update
   */
  export type rechargecarddetailtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
    /**
     * The data needed to update a rechargecarddetailtb.
     */
    data: XOR<rechargecarddetailtbUpdateInput, rechargecarddetailtbUncheckedUpdateInput>
    /**
     * Choose, which rechargecarddetailtb to update.
     */
    where: rechargecarddetailtbWhereUniqueInput
  }

  /**
   * rechargecarddetailtb updateMany
   */
  export type rechargecarddetailtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rechargecarddetailtbs.
     */
    data: XOR<rechargecarddetailtbUpdateManyMutationInput, rechargecarddetailtbUncheckedUpdateManyInput>
    /**
     * Filter which rechargecarddetailtbs to update
     */
    where?: rechargecarddetailtbWhereInput
  }

  /**
   * rechargecarddetailtb upsert
   */
  export type rechargecarddetailtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
    /**
     * The filter to search for the rechargecarddetailtb to update in case it exists.
     */
    where: rechargecarddetailtbWhereUniqueInput
    /**
     * In case the rechargecarddetailtb found by the `where` argument doesn't exist, create a new rechargecarddetailtb with this data.
     */
    create: XOR<rechargecarddetailtbCreateInput, rechargecarddetailtbUncheckedCreateInput>
    /**
     * In case the rechargecarddetailtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rechargecarddetailtbUpdateInput, rechargecarddetailtbUncheckedUpdateInput>
  }

  /**
   * rechargecarddetailtb delete
   */
  export type rechargecarddetailtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
    /**
     * Filter which rechargecarddetailtb to delete.
     */
    where: rechargecarddetailtbWhereUniqueInput
  }

  /**
   * rechargecarddetailtb deleteMany
   */
  export type rechargecarddetailtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rechargecarddetailtbs to delete
     */
    where?: rechargecarddetailtbWhereInput
  }

  /**
   * rechargecarddetailtb without action
   */
  export type rechargecarddetailtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecarddetailtb
     */
    select?: rechargecarddetailtbSelect<ExtArgs> | null
  }


  /**
   * Model rechargecardtb
   */

  export type AggregateRechargecardtb = {
    _count: RechargecardtbCountAggregateOutputType | null
    _avg: RechargecardtbAvgAggregateOutputType | null
    _sum: RechargecardtbSumAggregateOutputType | null
    _min: RechargecardtbMinAggregateOutputType | null
    _max: RechargecardtbMaxAggregateOutputType | null
  }

  export type RechargecardtbAvgAggregateOutputType = {
    CardId: number | null
    CardValue: Decimal | null
    UserId: number | null
  }

  export type RechargecardtbSumAggregateOutputType = {
    CardId: number | null
    CardValue: Decimal | null
    UserId: number | null
  }

  export type RechargecardtbMinAggregateOutputType = {
    CardId: number | null
    cardcode: string | null
    CardValue: Decimal | null
    ExpiryDate: Date | null
    CreateDate: Date | null
    CreateTime: Date | null
    ModifyDate: Date | null
    ModifyTime: Date | null
    Status: boolean | null
    UserId: number | null
    Note: string | null
  }

  export type RechargecardtbMaxAggregateOutputType = {
    CardId: number | null
    cardcode: string | null
    CardValue: Decimal | null
    ExpiryDate: Date | null
    CreateDate: Date | null
    CreateTime: Date | null
    ModifyDate: Date | null
    ModifyTime: Date | null
    Status: boolean | null
    UserId: number | null
    Note: string | null
  }

  export type RechargecardtbCountAggregateOutputType = {
    CardId: number
    cardcode: number
    CardValue: number
    ExpiryDate: number
    CreateDate: number
    CreateTime: number
    ModifyDate: number
    ModifyTime: number
    Status: number
    UserId: number
    Note: number
    _all: number
  }


  export type RechargecardtbAvgAggregateInputType = {
    CardId?: true
    CardValue?: true
    UserId?: true
  }

  export type RechargecardtbSumAggregateInputType = {
    CardId?: true
    CardValue?: true
    UserId?: true
  }

  export type RechargecardtbMinAggregateInputType = {
    CardId?: true
    cardcode?: true
    CardValue?: true
    ExpiryDate?: true
    CreateDate?: true
    CreateTime?: true
    ModifyDate?: true
    ModifyTime?: true
    Status?: true
    UserId?: true
    Note?: true
  }

  export type RechargecardtbMaxAggregateInputType = {
    CardId?: true
    cardcode?: true
    CardValue?: true
    ExpiryDate?: true
    CreateDate?: true
    CreateTime?: true
    ModifyDate?: true
    ModifyTime?: true
    Status?: true
    UserId?: true
    Note?: true
  }

  export type RechargecardtbCountAggregateInputType = {
    CardId?: true
    cardcode?: true
    CardValue?: true
    ExpiryDate?: true
    CreateDate?: true
    CreateTime?: true
    ModifyDate?: true
    ModifyTime?: true
    Status?: true
    UserId?: true
    Note?: true
    _all?: true
  }

  export type RechargecardtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rechargecardtb to aggregate.
     */
    where?: rechargecardtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rechargecardtbs to fetch.
     */
    orderBy?: rechargecardtbOrderByWithRelationInput | rechargecardtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rechargecardtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rechargecardtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rechargecardtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rechargecardtbs
    **/
    _count?: true | RechargecardtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RechargecardtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RechargecardtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RechargecardtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RechargecardtbMaxAggregateInputType
  }

  export type GetRechargecardtbAggregateType<T extends RechargecardtbAggregateArgs> = {
        [P in keyof T & keyof AggregateRechargecardtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRechargecardtb[P]>
      : GetScalarType<T[P], AggregateRechargecardtb[P]>
  }




  export type rechargecardtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rechargecardtbWhereInput
    orderBy?: rechargecardtbOrderByWithAggregationInput | rechargecardtbOrderByWithAggregationInput[]
    by: RechargecardtbScalarFieldEnum[] | RechargecardtbScalarFieldEnum
    having?: rechargecardtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RechargecardtbCountAggregateInputType | true
    _avg?: RechargecardtbAvgAggregateInputType
    _sum?: RechargecardtbSumAggregateInputType
    _min?: RechargecardtbMinAggregateInputType
    _max?: RechargecardtbMaxAggregateInputType
  }

  export type RechargecardtbGroupByOutputType = {
    CardId: number
    cardcode: string | null
    CardValue: Decimal
    ExpiryDate: Date
    CreateDate: Date
    CreateTime: Date
    ModifyDate: Date | null
    ModifyTime: Date | null
    Status: boolean | null
    UserId: number | null
    Note: string | null
    _count: RechargecardtbCountAggregateOutputType | null
    _avg: RechargecardtbAvgAggregateOutputType | null
    _sum: RechargecardtbSumAggregateOutputType | null
    _min: RechargecardtbMinAggregateOutputType | null
    _max: RechargecardtbMaxAggregateOutputType | null
  }

  type GetRechargecardtbGroupByPayload<T extends rechargecardtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RechargecardtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RechargecardtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RechargecardtbGroupByOutputType[P]>
            : GetScalarType<T[P], RechargecardtbGroupByOutputType[P]>
        }
      >
    >


  export type rechargecardtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CardId?: boolean
    cardcode?: boolean
    CardValue?: boolean
    ExpiryDate?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    ModifyDate?: boolean
    ModifyTime?: boolean
    Status?: boolean
    UserId?: boolean
    Note?: boolean
  }, ExtArgs["result"]["rechargecardtb"]>


  export type rechargecardtbSelectScalar = {
    CardId?: boolean
    cardcode?: boolean
    CardValue?: boolean
    ExpiryDate?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    ModifyDate?: boolean
    ModifyTime?: boolean
    Status?: boolean
    UserId?: boolean
    Note?: boolean
  }


  export type $rechargecardtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rechargecardtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      CardId: number
      cardcode: string | null
      CardValue: Prisma.Decimal
      ExpiryDate: Date
      CreateDate: Date
      CreateTime: Date
      ModifyDate: Date | null
      ModifyTime: Date | null
      Status: boolean | null
      UserId: number | null
      Note: string | null
    }, ExtArgs["result"]["rechargecardtb"]>
    composites: {}
  }

  type rechargecardtbGetPayload<S extends boolean | null | undefined | rechargecardtbDefaultArgs> = $Result.GetResult<Prisma.$rechargecardtbPayload, S>

  type rechargecardtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rechargecardtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RechargecardtbCountAggregateInputType | true
    }

  export interface rechargecardtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rechargecardtb'], meta: { name: 'rechargecardtb' } }
    /**
     * Find zero or one Rechargecardtb that matches the filter.
     * @param {rechargecardtbFindUniqueArgs} args - Arguments to find a Rechargecardtb
     * @example
     * // Get one Rechargecardtb
     * const rechargecardtb = await prisma.rechargecardtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rechargecardtbFindUniqueArgs>(args: SelectSubset<T, rechargecardtbFindUniqueArgs<ExtArgs>>): Prisma__rechargecardtbClient<$Result.GetResult<Prisma.$rechargecardtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rechargecardtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rechargecardtbFindUniqueOrThrowArgs} args - Arguments to find a Rechargecardtb
     * @example
     * // Get one Rechargecardtb
     * const rechargecardtb = await prisma.rechargecardtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rechargecardtbFindUniqueOrThrowArgs>(args: SelectSubset<T, rechargecardtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rechargecardtbClient<$Result.GetResult<Prisma.$rechargecardtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rechargecardtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecardtbFindFirstArgs} args - Arguments to find a Rechargecardtb
     * @example
     * // Get one Rechargecardtb
     * const rechargecardtb = await prisma.rechargecardtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rechargecardtbFindFirstArgs>(args?: SelectSubset<T, rechargecardtbFindFirstArgs<ExtArgs>>): Prisma__rechargecardtbClient<$Result.GetResult<Prisma.$rechargecardtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rechargecardtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecardtbFindFirstOrThrowArgs} args - Arguments to find a Rechargecardtb
     * @example
     * // Get one Rechargecardtb
     * const rechargecardtb = await prisma.rechargecardtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rechargecardtbFindFirstOrThrowArgs>(args?: SelectSubset<T, rechargecardtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__rechargecardtbClient<$Result.GetResult<Prisma.$rechargecardtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rechargecardtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecardtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rechargecardtbs
     * const rechargecardtbs = await prisma.rechargecardtb.findMany()
     * 
     * // Get first 10 Rechargecardtbs
     * const rechargecardtbs = await prisma.rechargecardtb.findMany({ take: 10 })
     * 
     * // Only select the `CardId`
     * const rechargecardtbWithCardIdOnly = await prisma.rechargecardtb.findMany({ select: { CardId: true } })
     * 
     */
    findMany<T extends rechargecardtbFindManyArgs>(args?: SelectSubset<T, rechargecardtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rechargecardtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rechargecardtb.
     * @param {rechargecardtbCreateArgs} args - Arguments to create a Rechargecardtb.
     * @example
     * // Create one Rechargecardtb
     * const Rechargecardtb = await prisma.rechargecardtb.create({
     *   data: {
     *     // ... data to create a Rechargecardtb
     *   }
     * })
     * 
     */
    create<T extends rechargecardtbCreateArgs>(args: SelectSubset<T, rechargecardtbCreateArgs<ExtArgs>>): Prisma__rechargecardtbClient<$Result.GetResult<Prisma.$rechargecardtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rechargecardtbs.
     * @param {rechargecardtbCreateManyArgs} args - Arguments to create many Rechargecardtbs.
     * @example
     * // Create many Rechargecardtbs
     * const rechargecardtb = await prisma.rechargecardtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rechargecardtbCreateManyArgs>(args?: SelectSubset<T, rechargecardtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rechargecardtb.
     * @param {rechargecardtbDeleteArgs} args - Arguments to delete one Rechargecardtb.
     * @example
     * // Delete one Rechargecardtb
     * const Rechargecardtb = await prisma.rechargecardtb.delete({
     *   where: {
     *     // ... filter to delete one Rechargecardtb
     *   }
     * })
     * 
     */
    delete<T extends rechargecardtbDeleteArgs>(args: SelectSubset<T, rechargecardtbDeleteArgs<ExtArgs>>): Prisma__rechargecardtbClient<$Result.GetResult<Prisma.$rechargecardtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rechargecardtb.
     * @param {rechargecardtbUpdateArgs} args - Arguments to update one Rechargecardtb.
     * @example
     * // Update one Rechargecardtb
     * const rechargecardtb = await prisma.rechargecardtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rechargecardtbUpdateArgs>(args: SelectSubset<T, rechargecardtbUpdateArgs<ExtArgs>>): Prisma__rechargecardtbClient<$Result.GetResult<Prisma.$rechargecardtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rechargecardtbs.
     * @param {rechargecardtbDeleteManyArgs} args - Arguments to filter Rechargecardtbs to delete.
     * @example
     * // Delete a few Rechargecardtbs
     * const { count } = await prisma.rechargecardtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rechargecardtbDeleteManyArgs>(args?: SelectSubset<T, rechargecardtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rechargecardtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecardtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rechargecardtbs
     * const rechargecardtb = await prisma.rechargecardtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rechargecardtbUpdateManyArgs>(args: SelectSubset<T, rechargecardtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rechargecardtb.
     * @param {rechargecardtbUpsertArgs} args - Arguments to update or create a Rechargecardtb.
     * @example
     * // Update or create a Rechargecardtb
     * const rechargecardtb = await prisma.rechargecardtb.upsert({
     *   create: {
     *     // ... data to create a Rechargecardtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rechargecardtb we want to update
     *   }
     * })
     */
    upsert<T extends rechargecardtbUpsertArgs>(args: SelectSubset<T, rechargecardtbUpsertArgs<ExtArgs>>): Prisma__rechargecardtbClient<$Result.GetResult<Prisma.$rechargecardtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rechargecardtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecardtbCountArgs} args - Arguments to filter Rechargecardtbs to count.
     * @example
     * // Count the number of Rechargecardtbs
     * const count = await prisma.rechargecardtb.count({
     *   where: {
     *     // ... the filter for the Rechargecardtbs we want to count
     *   }
     * })
    **/
    count<T extends rechargecardtbCountArgs>(
      args?: Subset<T, rechargecardtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RechargecardtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rechargecardtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RechargecardtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RechargecardtbAggregateArgs>(args: Subset<T, RechargecardtbAggregateArgs>): Prisma.PrismaPromise<GetRechargecardtbAggregateType<T>>

    /**
     * Group by Rechargecardtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rechargecardtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rechargecardtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rechargecardtbGroupByArgs['orderBy'] }
        : { orderBy?: rechargecardtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rechargecardtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRechargecardtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rechargecardtb model
   */
  readonly fields: rechargecardtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rechargecardtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rechargecardtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rechargecardtb model
   */ 
  interface rechargecardtbFieldRefs {
    readonly CardId: FieldRef<"rechargecardtb", 'Int'>
    readonly cardcode: FieldRef<"rechargecardtb", 'String'>
    readonly CardValue: FieldRef<"rechargecardtb", 'Decimal'>
    readonly ExpiryDate: FieldRef<"rechargecardtb", 'DateTime'>
    readonly CreateDate: FieldRef<"rechargecardtb", 'DateTime'>
    readonly CreateTime: FieldRef<"rechargecardtb", 'DateTime'>
    readonly ModifyDate: FieldRef<"rechargecardtb", 'DateTime'>
    readonly ModifyTime: FieldRef<"rechargecardtb", 'DateTime'>
    readonly Status: FieldRef<"rechargecardtb", 'Boolean'>
    readonly UserId: FieldRef<"rechargecardtb", 'Int'>
    readonly Note: FieldRef<"rechargecardtb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * rechargecardtb findUnique
   */
  export type rechargecardtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecardtb to fetch.
     */
    where: rechargecardtbWhereUniqueInput
  }

  /**
   * rechargecardtb findUniqueOrThrow
   */
  export type rechargecardtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecardtb to fetch.
     */
    where: rechargecardtbWhereUniqueInput
  }

  /**
   * rechargecardtb findFirst
   */
  export type rechargecardtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecardtb to fetch.
     */
    where?: rechargecardtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rechargecardtbs to fetch.
     */
    orderBy?: rechargecardtbOrderByWithRelationInput | rechargecardtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rechargecardtbs.
     */
    cursor?: rechargecardtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rechargecardtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rechargecardtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rechargecardtbs.
     */
    distinct?: RechargecardtbScalarFieldEnum | RechargecardtbScalarFieldEnum[]
  }

  /**
   * rechargecardtb findFirstOrThrow
   */
  export type rechargecardtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecardtb to fetch.
     */
    where?: rechargecardtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rechargecardtbs to fetch.
     */
    orderBy?: rechargecardtbOrderByWithRelationInput | rechargecardtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rechargecardtbs.
     */
    cursor?: rechargecardtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rechargecardtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rechargecardtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rechargecardtbs.
     */
    distinct?: RechargecardtbScalarFieldEnum | RechargecardtbScalarFieldEnum[]
  }

  /**
   * rechargecardtb findMany
   */
  export type rechargecardtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
    /**
     * Filter, which rechargecardtbs to fetch.
     */
    where?: rechargecardtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rechargecardtbs to fetch.
     */
    orderBy?: rechargecardtbOrderByWithRelationInput | rechargecardtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rechargecardtbs.
     */
    cursor?: rechargecardtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rechargecardtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rechargecardtbs.
     */
    skip?: number
    distinct?: RechargecardtbScalarFieldEnum | RechargecardtbScalarFieldEnum[]
  }

  /**
   * rechargecardtb create
   */
  export type rechargecardtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
    /**
     * The data needed to create a rechargecardtb.
     */
    data: XOR<rechargecardtbCreateInput, rechargecardtbUncheckedCreateInput>
  }

  /**
   * rechargecardtb createMany
   */
  export type rechargecardtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rechargecardtbs.
     */
    data: rechargecardtbCreateManyInput | rechargecardtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rechargecardtb update
   */
  export type rechargecardtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
    /**
     * The data needed to update a rechargecardtb.
     */
    data: XOR<rechargecardtbUpdateInput, rechargecardtbUncheckedUpdateInput>
    /**
     * Choose, which rechargecardtb to update.
     */
    where: rechargecardtbWhereUniqueInput
  }

  /**
   * rechargecardtb updateMany
   */
  export type rechargecardtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rechargecardtbs.
     */
    data: XOR<rechargecardtbUpdateManyMutationInput, rechargecardtbUncheckedUpdateManyInput>
    /**
     * Filter which rechargecardtbs to update
     */
    where?: rechargecardtbWhereInput
  }

  /**
   * rechargecardtb upsert
   */
  export type rechargecardtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
    /**
     * The filter to search for the rechargecardtb to update in case it exists.
     */
    where: rechargecardtbWhereUniqueInput
    /**
     * In case the rechargecardtb found by the `where` argument doesn't exist, create a new rechargecardtb with this data.
     */
    create: XOR<rechargecardtbCreateInput, rechargecardtbUncheckedCreateInput>
    /**
     * In case the rechargecardtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rechargecardtbUpdateInput, rechargecardtbUncheckedUpdateInput>
  }

  /**
   * rechargecardtb delete
   */
  export type rechargecardtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
    /**
     * Filter which rechargecardtb to delete.
     */
    where: rechargecardtbWhereUniqueInput
  }

  /**
   * rechargecardtb deleteMany
   */
  export type rechargecardtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rechargecardtbs to delete
     */
    where?: rechargecardtbWhereInput
  }

  /**
   * rechargecardtb without action
   */
  export type rechargecardtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rechargecardtb
     */
    select?: rechargecardtbSelect<ExtArgs> | null
  }


  /**
   * Model reportdaily
   */

  export type AggregateReportdaily = {
    _count: ReportdailyCountAggregateOutputType | null
    _avg: ReportdailyAvgAggregateOutputType | null
    _sum: ReportdailySumAggregateOutputType | null
    _min: ReportdailyMinAggregateOutputType | null
    _max: ReportdailyMaxAggregateOutputType | null
  }

  export type ReportdailyAvgAggregateOutputType = {
    ymd: number | null
    mode: number | null
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
  }

  export type ReportdailySumAggregateOutputType = {
    ymd: number | null
    mode: number | null
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
  }

  export type ReportdailyMinAggregateOutputType = {
    ymd: number | null
    prefix: string | null
    mode: number | null
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f10: string | null
    f11: string | null
    f12: string | null
    f13: string | null
    f14: string | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
    ext: string | null
    hash: string | null
    create_date: Date | null
    update_date: Date | null
  }

  export type ReportdailyMaxAggregateOutputType = {
    ymd: number | null
    prefix: string | null
    mode: number | null
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f10: string | null
    f11: string | null
    f12: string | null
    f13: string | null
    f14: string | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
    ext: string | null
    hash: string | null
    create_date: Date | null
    update_date: Date | null
  }

  export type ReportdailyCountAggregateOutputType = {
    ymd: number
    prefix: number
    mode: number
    f1: number
    f2: number
    f3: number
    f4: number
    f5: number
    f6: number
    f7: number
    f8: number
    f9: number
    f10: number
    f11: number
    f12: number
    f13: number
    f14: number
    f15: number
    f16: number
    f17: number
    f18: number
    f19: number
    f20: number
    ext: number
    hash: number
    create_date: number
    update_date: number
    _all: number
  }


  export type ReportdailyAvgAggregateInputType = {
    ymd?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
  }

  export type ReportdailySumAggregateInputType = {
    ymd?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
  }

  export type ReportdailyMinAggregateInputType = {
    ymd?: true
    prefix?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f10?: true
    f11?: true
    f12?: true
    f13?: true
    f14?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
    ext?: true
    hash?: true
    create_date?: true
    update_date?: true
  }

  export type ReportdailyMaxAggregateInputType = {
    ymd?: true
    prefix?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f10?: true
    f11?: true
    f12?: true
    f13?: true
    f14?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
    ext?: true
    hash?: true
    create_date?: true
    update_date?: true
  }

  export type ReportdailyCountAggregateInputType = {
    ymd?: true
    prefix?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f10?: true
    f11?: true
    f12?: true
    f13?: true
    f14?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
    ext?: true
    hash?: true
    create_date?: true
    update_date?: true
    _all?: true
  }

  export type ReportdailyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportdaily to aggregate.
     */
    where?: reportdailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportdailies to fetch.
     */
    orderBy?: reportdailyOrderByWithRelationInput | reportdailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportdailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportdailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportdailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reportdailies
    **/
    _count?: true | ReportdailyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportdailyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportdailySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportdailyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportdailyMaxAggregateInputType
  }

  export type GetReportdailyAggregateType<T extends ReportdailyAggregateArgs> = {
        [P in keyof T & keyof AggregateReportdaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportdaily[P]>
      : GetScalarType<T[P], AggregateReportdaily[P]>
  }




  export type reportdailyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportdailyWhereInput
    orderBy?: reportdailyOrderByWithAggregationInput | reportdailyOrderByWithAggregationInput[]
    by: ReportdailyScalarFieldEnum[] | ReportdailyScalarFieldEnum
    having?: reportdailyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportdailyCountAggregateInputType | true
    _avg?: ReportdailyAvgAggregateInputType
    _sum?: ReportdailySumAggregateInputType
    _min?: ReportdailyMinAggregateInputType
    _max?: ReportdailyMaxAggregateInputType
  }

  export type ReportdailyGroupByOutputType = {
    ymd: number
    prefix: string
    mode: number
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f10: string | null
    f11: string | null
    f12: string | null
    f13: string | null
    f14: string | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
    ext: string | null
    hash: string | null
    create_date: Date | null
    update_date: Date | null
    _count: ReportdailyCountAggregateOutputType | null
    _avg: ReportdailyAvgAggregateOutputType | null
    _sum: ReportdailySumAggregateOutputType | null
    _min: ReportdailyMinAggregateOutputType | null
    _max: ReportdailyMaxAggregateOutputType | null
  }

  type GetReportdailyGroupByPayload<T extends reportdailyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportdailyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportdailyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportdailyGroupByOutputType[P]>
            : GetScalarType<T[P], ReportdailyGroupByOutputType[P]>
        }
      >
    >


  export type reportdailySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ymd?: boolean
    prefix?: boolean
    mode?: boolean
    f1?: boolean
    f2?: boolean
    f3?: boolean
    f4?: boolean
    f5?: boolean
    f6?: boolean
    f7?: boolean
    f8?: boolean
    f9?: boolean
    f10?: boolean
    f11?: boolean
    f12?: boolean
    f13?: boolean
    f14?: boolean
    f15?: boolean
    f16?: boolean
    f17?: boolean
    f18?: boolean
    f19?: boolean
    f20?: boolean
    ext?: boolean
    hash?: boolean
    create_date?: boolean
    update_date?: boolean
  }, ExtArgs["result"]["reportdaily"]>


  export type reportdailySelectScalar = {
    ymd?: boolean
    prefix?: boolean
    mode?: boolean
    f1?: boolean
    f2?: boolean
    f3?: boolean
    f4?: boolean
    f5?: boolean
    f6?: boolean
    f7?: boolean
    f8?: boolean
    f9?: boolean
    f10?: boolean
    f11?: boolean
    f12?: boolean
    f13?: boolean
    f14?: boolean
    f15?: boolean
    f16?: boolean
    f17?: boolean
    f18?: boolean
    f19?: boolean
    f20?: boolean
    ext?: boolean
    hash?: boolean
    create_date?: boolean
    update_date?: boolean
  }


  export type $reportdailyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reportdaily"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ymd: number
      prefix: string
      mode: number
      f1: number | null
      f2: number | null
      f3: number | null
      f4: number | null
      f5: number | null
      f6: number | null
      f7: number | null
      f8: number | null
      f9: number | null
      f10: string | null
      f11: string | null
      f12: string | null
      f13: string | null
      f14: string | null
      f15: number | null
      f16: number | null
      f17: number | null
      f18: number | null
      f19: number | null
      f20: number | null
      ext: string | null
      hash: string | null
      create_date: Date | null
      update_date: Date | null
    }, ExtArgs["result"]["reportdaily"]>
    composites: {}
  }

  type reportdailyGetPayload<S extends boolean | null | undefined | reportdailyDefaultArgs> = $Result.GetResult<Prisma.$reportdailyPayload, S>

  type reportdailyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reportdailyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportdailyCountAggregateInputType | true
    }

  export interface reportdailyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reportdaily'], meta: { name: 'reportdaily' } }
    /**
     * Find zero or one Reportdaily that matches the filter.
     * @param {reportdailyFindUniqueArgs} args - Arguments to find a Reportdaily
     * @example
     * // Get one Reportdaily
     * const reportdaily = await prisma.reportdaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reportdailyFindUniqueArgs>(args: SelectSubset<T, reportdailyFindUniqueArgs<ExtArgs>>): Prisma__reportdailyClient<$Result.GetResult<Prisma.$reportdailyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reportdaily that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {reportdailyFindUniqueOrThrowArgs} args - Arguments to find a Reportdaily
     * @example
     * // Get one Reportdaily
     * const reportdaily = await prisma.reportdaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reportdailyFindUniqueOrThrowArgs>(args: SelectSubset<T, reportdailyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reportdailyClient<$Result.GetResult<Prisma.$reportdailyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reportdaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportdailyFindFirstArgs} args - Arguments to find a Reportdaily
     * @example
     * // Get one Reportdaily
     * const reportdaily = await prisma.reportdaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reportdailyFindFirstArgs>(args?: SelectSubset<T, reportdailyFindFirstArgs<ExtArgs>>): Prisma__reportdailyClient<$Result.GetResult<Prisma.$reportdailyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reportdaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportdailyFindFirstOrThrowArgs} args - Arguments to find a Reportdaily
     * @example
     * // Get one Reportdaily
     * const reportdaily = await prisma.reportdaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reportdailyFindFirstOrThrowArgs>(args?: SelectSubset<T, reportdailyFindFirstOrThrowArgs<ExtArgs>>): Prisma__reportdailyClient<$Result.GetResult<Prisma.$reportdailyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reportdailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportdailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reportdailies
     * const reportdailies = await prisma.reportdaily.findMany()
     * 
     * // Get first 10 Reportdailies
     * const reportdailies = await prisma.reportdaily.findMany({ take: 10 })
     * 
     * // Only select the `ymd`
     * const reportdailyWithYmdOnly = await prisma.reportdaily.findMany({ select: { ymd: true } })
     * 
     */
    findMany<T extends reportdailyFindManyArgs>(args?: SelectSubset<T, reportdailyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportdailyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reportdaily.
     * @param {reportdailyCreateArgs} args - Arguments to create a Reportdaily.
     * @example
     * // Create one Reportdaily
     * const Reportdaily = await prisma.reportdaily.create({
     *   data: {
     *     // ... data to create a Reportdaily
     *   }
     * })
     * 
     */
    create<T extends reportdailyCreateArgs>(args: SelectSubset<T, reportdailyCreateArgs<ExtArgs>>): Prisma__reportdailyClient<$Result.GetResult<Prisma.$reportdailyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reportdailies.
     * @param {reportdailyCreateManyArgs} args - Arguments to create many Reportdailies.
     * @example
     * // Create many Reportdailies
     * const reportdaily = await prisma.reportdaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reportdailyCreateManyArgs>(args?: SelectSubset<T, reportdailyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reportdaily.
     * @param {reportdailyDeleteArgs} args - Arguments to delete one Reportdaily.
     * @example
     * // Delete one Reportdaily
     * const Reportdaily = await prisma.reportdaily.delete({
     *   where: {
     *     // ... filter to delete one Reportdaily
     *   }
     * })
     * 
     */
    delete<T extends reportdailyDeleteArgs>(args: SelectSubset<T, reportdailyDeleteArgs<ExtArgs>>): Prisma__reportdailyClient<$Result.GetResult<Prisma.$reportdailyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reportdaily.
     * @param {reportdailyUpdateArgs} args - Arguments to update one Reportdaily.
     * @example
     * // Update one Reportdaily
     * const reportdaily = await prisma.reportdaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reportdailyUpdateArgs>(args: SelectSubset<T, reportdailyUpdateArgs<ExtArgs>>): Prisma__reportdailyClient<$Result.GetResult<Prisma.$reportdailyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reportdailies.
     * @param {reportdailyDeleteManyArgs} args - Arguments to filter Reportdailies to delete.
     * @example
     * // Delete a few Reportdailies
     * const { count } = await prisma.reportdaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reportdailyDeleteManyArgs>(args?: SelectSubset<T, reportdailyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reportdailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportdailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reportdailies
     * const reportdaily = await prisma.reportdaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reportdailyUpdateManyArgs>(args: SelectSubset<T, reportdailyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reportdaily.
     * @param {reportdailyUpsertArgs} args - Arguments to update or create a Reportdaily.
     * @example
     * // Update or create a Reportdaily
     * const reportdaily = await prisma.reportdaily.upsert({
     *   create: {
     *     // ... data to create a Reportdaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reportdaily we want to update
     *   }
     * })
     */
    upsert<T extends reportdailyUpsertArgs>(args: SelectSubset<T, reportdailyUpsertArgs<ExtArgs>>): Prisma__reportdailyClient<$Result.GetResult<Prisma.$reportdailyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reportdailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportdailyCountArgs} args - Arguments to filter Reportdailies to count.
     * @example
     * // Count the number of Reportdailies
     * const count = await prisma.reportdaily.count({
     *   where: {
     *     // ... the filter for the Reportdailies we want to count
     *   }
     * })
    **/
    count<T extends reportdailyCountArgs>(
      args?: Subset<T, reportdailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportdailyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reportdaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportdailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportdailyAggregateArgs>(args: Subset<T, ReportdailyAggregateArgs>): Prisma.PrismaPromise<GetReportdailyAggregateType<T>>

    /**
     * Group by Reportdaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportdailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportdailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportdailyGroupByArgs['orderBy'] }
        : { orderBy?: reportdailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportdailyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportdailyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reportdaily model
   */
  readonly fields: reportdailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reportdaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportdailyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reportdaily model
   */ 
  interface reportdailyFieldRefs {
    readonly ymd: FieldRef<"reportdaily", 'Int'>
    readonly prefix: FieldRef<"reportdaily", 'String'>
    readonly mode: FieldRef<"reportdaily", 'Int'>
    readonly f1: FieldRef<"reportdaily", 'Int'>
    readonly f2: FieldRef<"reportdaily", 'Int'>
    readonly f3: FieldRef<"reportdaily", 'Int'>
    readonly f4: FieldRef<"reportdaily", 'Int'>
    readonly f5: FieldRef<"reportdaily", 'Int'>
    readonly f6: FieldRef<"reportdaily", 'Int'>
    readonly f7: FieldRef<"reportdaily", 'Int'>
    readonly f8: FieldRef<"reportdaily", 'Int'>
    readonly f9: FieldRef<"reportdaily", 'Int'>
    readonly f10: FieldRef<"reportdaily", 'String'>
    readonly f11: FieldRef<"reportdaily", 'String'>
    readonly f12: FieldRef<"reportdaily", 'String'>
    readonly f13: FieldRef<"reportdaily", 'String'>
    readonly f14: FieldRef<"reportdaily", 'String'>
    readonly f15: FieldRef<"reportdaily", 'Float'>
    readonly f16: FieldRef<"reportdaily", 'Float'>
    readonly f17: FieldRef<"reportdaily", 'Float'>
    readonly f18: FieldRef<"reportdaily", 'Float'>
    readonly f19: FieldRef<"reportdaily", 'Float'>
    readonly f20: FieldRef<"reportdaily", 'Float'>
    readonly ext: FieldRef<"reportdaily", 'String'>
    readonly hash: FieldRef<"reportdaily", 'String'>
    readonly create_date: FieldRef<"reportdaily", 'DateTime'>
    readonly update_date: FieldRef<"reportdaily", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reportdaily findUnique
   */
  export type reportdailyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
    /**
     * Filter, which reportdaily to fetch.
     */
    where: reportdailyWhereUniqueInput
  }

  /**
   * reportdaily findUniqueOrThrow
   */
  export type reportdailyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
    /**
     * Filter, which reportdaily to fetch.
     */
    where: reportdailyWhereUniqueInput
  }

  /**
   * reportdaily findFirst
   */
  export type reportdailyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
    /**
     * Filter, which reportdaily to fetch.
     */
    where?: reportdailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportdailies to fetch.
     */
    orderBy?: reportdailyOrderByWithRelationInput | reportdailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportdailies.
     */
    cursor?: reportdailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportdailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportdailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportdailies.
     */
    distinct?: ReportdailyScalarFieldEnum | ReportdailyScalarFieldEnum[]
  }

  /**
   * reportdaily findFirstOrThrow
   */
  export type reportdailyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
    /**
     * Filter, which reportdaily to fetch.
     */
    where?: reportdailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportdailies to fetch.
     */
    orderBy?: reportdailyOrderByWithRelationInput | reportdailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportdailies.
     */
    cursor?: reportdailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportdailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportdailies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportdailies.
     */
    distinct?: ReportdailyScalarFieldEnum | ReportdailyScalarFieldEnum[]
  }

  /**
   * reportdaily findMany
   */
  export type reportdailyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
    /**
     * Filter, which reportdailies to fetch.
     */
    where?: reportdailyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportdailies to fetch.
     */
    orderBy?: reportdailyOrderByWithRelationInput | reportdailyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reportdailies.
     */
    cursor?: reportdailyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportdailies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportdailies.
     */
    skip?: number
    distinct?: ReportdailyScalarFieldEnum | ReportdailyScalarFieldEnum[]
  }

  /**
   * reportdaily create
   */
  export type reportdailyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
    /**
     * The data needed to create a reportdaily.
     */
    data: XOR<reportdailyCreateInput, reportdailyUncheckedCreateInput>
  }

  /**
   * reportdaily createMany
   */
  export type reportdailyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reportdailies.
     */
    data: reportdailyCreateManyInput | reportdailyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reportdaily update
   */
  export type reportdailyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
    /**
     * The data needed to update a reportdaily.
     */
    data: XOR<reportdailyUpdateInput, reportdailyUncheckedUpdateInput>
    /**
     * Choose, which reportdaily to update.
     */
    where: reportdailyWhereUniqueInput
  }

  /**
   * reportdaily updateMany
   */
  export type reportdailyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reportdailies.
     */
    data: XOR<reportdailyUpdateManyMutationInput, reportdailyUncheckedUpdateManyInput>
    /**
     * Filter which reportdailies to update
     */
    where?: reportdailyWhereInput
  }

  /**
   * reportdaily upsert
   */
  export type reportdailyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
    /**
     * The filter to search for the reportdaily to update in case it exists.
     */
    where: reportdailyWhereUniqueInput
    /**
     * In case the reportdaily found by the `where` argument doesn't exist, create a new reportdaily with this data.
     */
    create: XOR<reportdailyCreateInput, reportdailyUncheckedCreateInput>
    /**
     * In case the reportdaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportdailyUpdateInput, reportdailyUncheckedUpdateInput>
  }

  /**
   * reportdaily delete
   */
  export type reportdailyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
    /**
     * Filter which reportdaily to delete.
     */
    where: reportdailyWhereUniqueInput
  }

  /**
   * reportdaily deleteMany
   */
  export type reportdailyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportdailies to delete
     */
    where?: reportdailyWhereInput
  }

  /**
   * reportdaily without action
   */
  export type reportdailyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportdaily
     */
    select?: reportdailySelect<ExtArgs> | null
  }


  /**
   * Model reportmonthly
   */

  export type AggregateReportmonthly = {
    _count: ReportmonthlyCountAggregateOutputType | null
    _avg: ReportmonthlyAvgAggregateOutputType | null
    _sum: ReportmonthlySumAggregateOutputType | null
    _min: ReportmonthlyMinAggregateOutputType | null
    _max: ReportmonthlyMaxAggregateOutputType | null
  }

  export type ReportmonthlyAvgAggregateOutputType = {
    ymd: number | null
    mode: number | null
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
  }

  export type ReportmonthlySumAggregateOutputType = {
    ymd: number | null
    mode: number | null
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
  }

  export type ReportmonthlyMinAggregateOutputType = {
    ymd: number | null
    prefix: string | null
    mode: number | null
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f10: string | null
    f11: string | null
    f12: string | null
    f13: string | null
    f14: string | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
    ext: string | null
    hash: string | null
    create_date: Date | null
    update_date: Date | null
  }

  export type ReportmonthlyMaxAggregateOutputType = {
    ymd: number | null
    prefix: string | null
    mode: number | null
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f10: string | null
    f11: string | null
    f12: string | null
    f13: string | null
    f14: string | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
    ext: string | null
    hash: string | null
    create_date: Date | null
    update_date: Date | null
  }

  export type ReportmonthlyCountAggregateOutputType = {
    ymd: number
    prefix: number
    mode: number
    f1: number
    f2: number
    f3: number
    f4: number
    f5: number
    f6: number
    f7: number
    f8: number
    f9: number
    f10: number
    f11: number
    f12: number
    f13: number
    f14: number
    f15: number
    f16: number
    f17: number
    f18: number
    f19: number
    f20: number
    ext: number
    hash: number
    create_date: number
    update_date: number
    _all: number
  }


  export type ReportmonthlyAvgAggregateInputType = {
    ymd?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
  }

  export type ReportmonthlySumAggregateInputType = {
    ymd?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
  }

  export type ReportmonthlyMinAggregateInputType = {
    ymd?: true
    prefix?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f10?: true
    f11?: true
    f12?: true
    f13?: true
    f14?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
    ext?: true
    hash?: true
    create_date?: true
    update_date?: true
  }

  export type ReportmonthlyMaxAggregateInputType = {
    ymd?: true
    prefix?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f10?: true
    f11?: true
    f12?: true
    f13?: true
    f14?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
    ext?: true
    hash?: true
    create_date?: true
    update_date?: true
  }

  export type ReportmonthlyCountAggregateInputType = {
    ymd?: true
    prefix?: true
    mode?: true
    f1?: true
    f2?: true
    f3?: true
    f4?: true
    f5?: true
    f6?: true
    f7?: true
    f8?: true
    f9?: true
    f10?: true
    f11?: true
    f12?: true
    f13?: true
    f14?: true
    f15?: true
    f16?: true
    f17?: true
    f18?: true
    f19?: true
    f20?: true
    ext?: true
    hash?: true
    create_date?: true
    update_date?: true
    _all?: true
  }

  export type ReportmonthlyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportmonthly to aggregate.
     */
    where?: reportmonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportmonthlies to fetch.
     */
    orderBy?: reportmonthlyOrderByWithRelationInput | reportmonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportmonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportmonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportmonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reportmonthlies
    **/
    _count?: true | ReportmonthlyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportmonthlyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportmonthlySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportmonthlyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportmonthlyMaxAggregateInputType
  }

  export type GetReportmonthlyAggregateType<T extends ReportmonthlyAggregateArgs> = {
        [P in keyof T & keyof AggregateReportmonthly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportmonthly[P]>
      : GetScalarType<T[P], AggregateReportmonthly[P]>
  }




  export type reportmonthlyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportmonthlyWhereInput
    orderBy?: reportmonthlyOrderByWithAggregationInput | reportmonthlyOrderByWithAggregationInput[]
    by: ReportmonthlyScalarFieldEnum[] | ReportmonthlyScalarFieldEnum
    having?: reportmonthlyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportmonthlyCountAggregateInputType | true
    _avg?: ReportmonthlyAvgAggregateInputType
    _sum?: ReportmonthlySumAggregateInputType
    _min?: ReportmonthlyMinAggregateInputType
    _max?: ReportmonthlyMaxAggregateInputType
  }

  export type ReportmonthlyGroupByOutputType = {
    ymd: number
    prefix: string
    mode: number
    f1: number | null
    f2: number | null
    f3: number | null
    f4: number | null
    f5: number | null
    f6: number | null
    f7: number | null
    f8: number | null
    f9: number | null
    f10: string | null
    f11: string | null
    f12: string | null
    f13: string | null
    f14: string | null
    f15: number | null
    f16: number | null
    f17: number | null
    f18: number | null
    f19: number | null
    f20: number | null
    ext: string | null
    hash: string | null
    create_date: Date | null
    update_date: Date | null
    _count: ReportmonthlyCountAggregateOutputType | null
    _avg: ReportmonthlyAvgAggregateOutputType | null
    _sum: ReportmonthlySumAggregateOutputType | null
    _min: ReportmonthlyMinAggregateOutputType | null
    _max: ReportmonthlyMaxAggregateOutputType | null
  }

  type GetReportmonthlyGroupByPayload<T extends reportmonthlyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportmonthlyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportmonthlyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportmonthlyGroupByOutputType[P]>
            : GetScalarType<T[P], ReportmonthlyGroupByOutputType[P]>
        }
      >
    >


  export type reportmonthlySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ymd?: boolean
    prefix?: boolean
    mode?: boolean
    f1?: boolean
    f2?: boolean
    f3?: boolean
    f4?: boolean
    f5?: boolean
    f6?: boolean
    f7?: boolean
    f8?: boolean
    f9?: boolean
    f10?: boolean
    f11?: boolean
    f12?: boolean
    f13?: boolean
    f14?: boolean
    f15?: boolean
    f16?: boolean
    f17?: boolean
    f18?: boolean
    f19?: boolean
    f20?: boolean
    ext?: boolean
    hash?: boolean
    create_date?: boolean
    update_date?: boolean
  }, ExtArgs["result"]["reportmonthly"]>


  export type reportmonthlySelectScalar = {
    ymd?: boolean
    prefix?: boolean
    mode?: boolean
    f1?: boolean
    f2?: boolean
    f3?: boolean
    f4?: boolean
    f5?: boolean
    f6?: boolean
    f7?: boolean
    f8?: boolean
    f9?: boolean
    f10?: boolean
    f11?: boolean
    f12?: boolean
    f13?: boolean
    f14?: boolean
    f15?: boolean
    f16?: boolean
    f17?: boolean
    f18?: boolean
    f19?: boolean
    f20?: boolean
    ext?: boolean
    hash?: boolean
    create_date?: boolean
    update_date?: boolean
  }


  export type $reportmonthlyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reportmonthly"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ymd: number
      prefix: string
      mode: number
      f1: number | null
      f2: number | null
      f3: number | null
      f4: number | null
      f5: number | null
      f6: number | null
      f7: number | null
      f8: number | null
      f9: number | null
      f10: string | null
      f11: string | null
      f12: string | null
      f13: string | null
      f14: string | null
      f15: number | null
      f16: number | null
      f17: number | null
      f18: number | null
      f19: number | null
      f20: number | null
      ext: string | null
      hash: string | null
      create_date: Date | null
      update_date: Date | null
    }, ExtArgs["result"]["reportmonthly"]>
    composites: {}
  }

  type reportmonthlyGetPayload<S extends boolean | null | undefined | reportmonthlyDefaultArgs> = $Result.GetResult<Prisma.$reportmonthlyPayload, S>

  type reportmonthlyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reportmonthlyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportmonthlyCountAggregateInputType | true
    }

  export interface reportmonthlyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reportmonthly'], meta: { name: 'reportmonthly' } }
    /**
     * Find zero or one Reportmonthly that matches the filter.
     * @param {reportmonthlyFindUniqueArgs} args - Arguments to find a Reportmonthly
     * @example
     * // Get one Reportmonthly
     * const reportmonthly = await prisma.reportmonthly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reportmonthlyFindUniqueArgs>(args: SelectSubset<T, reportmonthlyFindUniqueArgs<ExtArgs>>): Prisma__reportmonthlyClient<$Result.GetResult<Prisma.$reportmonthlyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reportmonthly that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {reportmonthlyFindUniqueOrThrowArgs} args - Arguments to find a Reportmonthly
     * @example
     * // Get one Reportmonthly
     * const reportmonthly = await prisma.reportmonthly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reportmonthlyFindUniqueOrThrowArgs>(args: SelectSubset<T, reportmonthlyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reportmonthlyClient<$Result.GetResult<Prisma.$reportmonthlyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reportmonthly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportmonthlyFindFirstArgs} args - Arguments to find a Reportmonthly
     * @example
     * // Get one Reportmonthly
     * const reportmonthly = await prisma.reportmonthly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reportmonthlyFindFirstArgs>(args?: SelectSubset<T, reportmonthlyFindFirstArgs<ExtArgs>>): Prisma__reportmonthlyClient<$Result.GetResult<Prisma.$reportmonthlyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reportmonthly that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportmonthlyFindFirstOrThrowArgs} args - Arguments to find a Reportmonthly
     * @example
     * // Get one Reportmonthly
     * const reportmonthly = await prisma.reportmonthly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reportmonthlyFindFirstOrThrowArgs>(args?: SelectSubset<T, reportmonthlyFindFirstOrThrowArgs<ExtArgs>>): Prisma__reportmonthlyClient<$Result.GetResult<Prisma.$reportmonthlyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reportmonthlies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportmonthlyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reportmonthlies
     * const reportmonthlies = await prisma.reportmonthly.findMany()
     * 
     * // Get first 10 Reportmonthlies
     * const reportmonthlies = await prisma.reportmonthly.findMany({ take: 10 })
     * 
     * // Only select the `ymd`
     * const reportmonthlyWithYmdOnly = await prisma.reportmonthly.findMany({ select: { ymd: true } })
     * 
     */
    findMany<T extends reportmonthlyFindManyArgs>(args?: SelectSubset<T, reportmonthlyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportmonthlyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reportmonthly.
     * @param {reportmonthlyCreateArgs} args - Arguments to create a Reportmonthly.
     * @example
     * // Create one Reportmonthly
     * const Reportmonthly = await prisma.reportmonthly.create({
     *   data: {
     *     // ... data to create a Reportmonthly
     *   }
     * })
     * 
     */
    create<T extends reportmonthlyCreateArgs>(args: SelectSubset<T, reportmonthlyCreateArgs<ExtArgs>>): Prisma__reportmonthlyClient<$Result.GetResult<Prisma.$reportmonthlyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reportmonthlies.
     * @param {reportmonthlyCreateManyArgs} args - Arguments to create many Reportmonthlies.
     * @example
     * // Create many Reportmonthlies
     * const reportmonthly = await prisma.reportmonthly.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reportmonthlyCreateManyArgs>(args?: SelectSubset<T, reportmonthlyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reportmonthly.
     * @param {reportmonthlyDeleteArgs} args - Arguments to delete one Reportmonthly.
     * @example
     * // Delete one Reportmonthly
     * const Reportmonthly = await prisma.reportmonthly.delete({
     *   where: {
     *     // ... filter to delete one Reportmonthly
     *   }
     * })
     * 
     */
    delete<T extends reportmonthlyDeleteArgs>(args: SelectSubset<T, reportmonthlyDeleteArgs<ExtArgs>>): Prisma__reportmonthlyClient<$Result.GetResult<Prisma.$reportmonthlyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reportmonthly.
     * @param {reportmonthlyUpdateArgs} args - Arguments to update one Reportmonthly.
     * @example
     * // Update one Reportmonthly
     * const reportmonthly = await prisma.reportmonthly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reportmonthlyUpdateArgs>(args: SelectSubset<T, reportmonthlyUpdateArgs<ExtArgs>>): Prisma__reportmonthlyClient<$Result.GetResult<Prisma.$reportmonthlyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reportmonthlies.
     * @param {reportmonthlyDeleteManyArgs} args - Arguments to filter Reportmonthlies to delete.
     * @example
     * // Delete a few Reportmonthlies
     * const { count } = await prisma.reportmonthly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reportmonthlyDeleteManyArgs>(args?: SelectSubset<T, reportmonthlyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reportmonthlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportmonthlyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reportmonthlies
     * const reportmonthly = await prisma.reportmonthly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reportmonthlyUpdateManyArgs>(args: SelectSubset<T, reportmonthlyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reportmonthly.
     * @param {reportmonthlyUpsertArgs} args - Arguments to update or create a Reportmonthly.
     * @example
     * // Update or create a Reportmonthly
     * const reportmonthly = await prisma.reportmonthly.upsert({
     *   create: {
     *     // ... data to create a Reportmonthly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reportmonthly we want to update
     *   }
     * })
     */
    upsert<T extends reportmonthlyUpsertArgs>(args: SelectSubset<T, reportmonthlyUpsertArgs<ExtArgs>>): Prisma__reportmonthlyClient<$Result.GetResult<Prisma.$reportmonthlyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reportmonthlies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportmonthlyCountArgs} args - Arguments to filter Reportmonthlies to count.
     * @example
     * // Count the number of Reportmonthlies
     * const count = await prisma.reportmonthly.count({
     *   where: {
     *     // ... the filter for the Reportmonthlies we want to count
     *   }
     * })
    **/
    count<T extends reportmonthlyCountArgs>(
      args?: Subset<T, reportmonthlyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportmonthlyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reportmonthly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportmonthlyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportmonthlyAggregateArgs>(args: Subset<T, ReportmonthlyAggregateArgs>): Prisma.PrismaPromise<GetReportmonthlyAggregateType<T>>

    /**
     * Group by Reportmonthly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportmonthlyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportmonthlyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportmonthlyGroupByArgs['orderBy'] }
        : { orderBy?: reportmonthlyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportmonthlyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportmonthlyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reportmonthly model
   */
  readonly fields: reportmonthlyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reportmonthly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportmonthlyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reportmonthly model
   */ 
  interface reportmonthlyFieldRefs {
    readonly ymd: FieldRef<"reportmonthly", 'Int'>
    readonly prefix: FieldRef<"reportmonthly", 'String'>
    readonly mode: FieldRef<"reportmonthly", 'Int'>
    readonly f1: FieldRef<"reportmonthly", 'Int'>
    readonly f2: FieldRef<"reportmonthly", 'Int'>
    readonly f3: FieldRef<"reportmonthly", 'Int'>
    readonly f4: FieldRef<"reportmonthly", 'Int'>
    readonly f5: FieldRef<"reportmonthly", 'Int'>
    readonly f6: FieldRef<"reportmonthly", 'Int'>
    readonly f7: FieldRef<"reportmonthly", 'Int'>
    readonly f8: FieldRef<"reportmonthly", 'Int'>
    readonly f9: FieldRef<"reportmonthly", 'Int'>
    readonly f10: FieldRef<"reportmonthly", 'String'>
    readonly f11: FieldRef<"reportmonthly", 'String'>
    readonly f12: FieldRef<"reportmonthly", 'String'>
    readonly f13: FieldRef<"reportmonthly", 'String'>
    readonly f14: FieldRef<"reportmonthly", 'String'>
    readonly f15: FieldRef<"reportmonthly", 'Float'>
    readonly f16: FieldRef<"reportmonthly", 'Float'>
    readonly f17: FieldRef<"reportmonthly", 'Float'>
    readonly f18: FieldRef<"reportmonthly", 'Float'>
    readonly f19: FieldRef<"reportmonthly", 'Float'>
    readonly f20: FieldRef<"reportmonthly", 'Float'>
    readonly ext: FieldRef<"reportmonthly", 'String'>
    readonly hash: FieldRef<"reportmonthly", 'String'>
    readonly create_date: FieldRef<"reportmonthly", 'DateTime'>
    readonly update_date: FieldRef<"reportmonthly", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reportmonthly findUnique
   */
  export type reportmonthlyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
    /**
     * Filter, which reportmonthly to fetch.
     */
    where: reportmonthlyWhereUniqueInput
  }

  /**
   * reportmonthly findUniqueOrThrow
   */
  export type reportmonthlyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
    /**
     * Filter, which reportmonthly to fetch.
     */
    where: reportmonthlyWhereUniqueInput
  }

  /**
   * reportmonthly findFirst
   */
  export type reportmonthlyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
    /**
     * Filter, which reportmonthly to fetch.
     */
    where?: reportmonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportmonthlies to fetch.
     */
    orderBy?: reportmonthlyOrderByWithRelationInput | reportmonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportmonthlies.
     */
    cursor?: reportmonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportmonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportmonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportmonthlies.
     */
    distinct?: ReportmonthlyScalarFieldEnum | ReportmonthlyScalarFieldEnum[]
  }

  /**
   * reportmonthly findFirstOrThrow
   */
  export type reportmonthlyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
    /**
     * Filter, which reportmonthly to fetch.
     */
    where?: reportmonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportmonthlies to fetch.
     */
    orderBy?: reportmonthlyOrderByWithRelationInput | reportmonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportmonthlies.
     */
    cursor?: reportmonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportmonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportmonthlies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportmonthlies.
     */
    distinct?: ReportmonthlyScalarFieldEnum | ReportmonthlyScalarFieldEnum[]
  }

  /**
   * reportmonthly findMany
   */
  export type reportmonthlyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
    /**
     * Filter, which reportmonthlies to fetch.
     */
    where?: reportmonthlyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportmonthlies to fetch.
     */
    orderBy?: reportmonthlyOrderByWithRelationInput | reportmonthlyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reportmonthlies.
     */
    cursor?: reportmonthlyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportmonthlies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportmonthlies.
     */
    skip?: number
    distinct?: ReportmonthlyScalarFieldEnum | ReportmonthlyScalarFieldEnum[]
  }

  /**
   * reportmonthly create
   */
  export type reportmonthlyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
    /**
     * The data needed to create a reportmonthly.
     */
    data: XOR<reportmonthlyCreateInput, reportmonthlyUncheckedCreateInput>
  }

  /**
   * reportmonthly createMany
   */
  export type reportmonthlyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reportmonthlies.
     */
    data: reportmonthlyCreateManyInput | reportmonthlyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reportmonthly update
   */
  export type reportmonthlyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
    /**
     * The data needed to update a reportmonthly.
     */
    data: XOR<reportmonthlyUpdateInput, reportmonthlyUncheckedUpdateInput>
    /**
     * Choose, which reportmonthly to update.
     */
    where: reportmonthlyWhereUniqueInput
  }

  /**
   * reportmonthly updateMany
   */
  export type reportmonthlyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reportmonthlies.
     */
    data: XOR<reportmonthlyUpdateManyMutationInput, reportmonthlyUncheckedUpdateManyInput>
    /**
     * Filter which reportmonthlies to update
     */
    where?: reportmonthlyWhereInput
  }

  /**
   * reportmonthly upsert
   */
  export type reportmonthlyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
    /**
     * The filter to search for the reportmonthly to update in case it exists.
     */
    where: reportmonthlyWhereUniqueInput
    /**
     * In case the reportmonthly found by the `where` argument doesn't exist, create a new reportmonthly with this data.
     */
    create: XOR<reportmonthlyCreateInput, reportmonthlyUncheckedCreateInput>
    /**
     * In case the reportmonthly was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportmonthlyUpdateInput, reportmonthlyUncheckedUpdateInput>
  }

  /**
   * reportmonthly delete
   */
  export type reportmonthlyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
    /**
     * Filter which reportmonthly to delete.
     */
    where: reportmonthlyWhereUniqueInput
  }

  /**
   * reportmonthly deleteMany
   */
  export type reportmonthlyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportmonthlies to delete
     */
    where?: reportmonthlyWhereInput
  }

  /**
   * reportmonthly without action
   */
  export type reportmonthlyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportmonthly
     */
    select?: reportmonthlySelect<ExtArgs> | null
  }


  /**
   * Model righttb
   */

  export type AggregateRighttb = {
    _count: RighttbCountAggregateOutputType | null
    _avg: RighttbAvgAggregateOutputType | null
    _sum: RighttbSumAggregateOutputType | null
    _min: RighttbMinAggregateOutputType | null
    _max: RighttbMaxAggregateOutputType | null
  }

  export type RighttbAvgAggregateOutputType = {
    RightId: number | null
    UserId: number | null
  }

  export type RighttbSumAggregateOutputType = {
    RightId: number | null
    UserId: number | null
  }

  export type RighttbMinAggregateOutputType = {
    RightId: number | null
    UserId: number | null
    FunctionCode: string | null
  }

  export type RighttbMaxAggregateOutputType = {
    RightId: number | null
    UserId: number | null
    FunctionCode: string | null
  }

  export type RighttbCountAggregateOutputType = {
    RightId: number
    UserId: number
    FunctionCode: number
    _all: number
  }


  export type RighttbAvgAggregateInputType = {
    RightId?: true
    UserId?: true
  }

  export type RighttbSumAggregateInputType = {
    RightId?: true
    UserId?: true
  }

  export type RighttbMinAggregateInputType = {
    RightId?: true
    UserId?: true
    FunctionCode?: true
  }

  export type RighttbMaxAggregateInputType = {
    RightId?: true
    UserId?: true
    FunctionCode?: true
  }

  export type RighttbCountAggregateInputType = {
    RightId?: true
    UserId?: true
    FunctionCode?: true
    _all?: true
  }

  export type RighttbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which righttb to aggregate.
     */
    where?: righttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of righttbs to fetch.
     */
    orderBy?: righttbOrderByWithRelationInput | righttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: righttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` righttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` righttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned righttbs
    **/
    _count?: true | RighttbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RighttbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RighttbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RighttbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RighttbMaxAggregateInputType
  }

  export type GetRighttbAggregateType<T extends RighttbAggregateArgs> = {
        [P in keyof T & keyof AggregateRighttb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRighttb[P]>
      : GetScalarType<T[P], AggregateRighttb[P]>
  }




  export type righttbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: righttbWhereInput
    orderBy?: righttbOrderByWithAggregationInput | righttbOrderByWithAggregationInput[]
    by: RighttbScalarFieldEnum[] | RighttbScalarFieldEnum
    having?: righttbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RighttbCountAggregateInputType | true
    _avg?: RighttbAvgAggregateInputType
    _sum?: RighttbSumAggregateInputType
    _min?: RighttbMinAggregateInputType
    _max?: RighttbMaxAggregateInputType
  }

  export type RighttbGroupByOutputType = {
    RightId: number
    UserId: number
    FunctionCode: string
    _count: RighttbCountAggregateOutputType | null
    _avg: RighttbAvgAggregateOutputType | null
    _sum: RighttbSumAggregateOutputType | null
    _min: RighttbMinAggregateOutputType | null
    _max: RighttbMaxAggregateOutputType | null
  }

  type GetRighttbGroupByPayload<T extends righttbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RighttbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RighttbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RighttbGroupByOutputType[P]>
            : GetScalarType<T[P], RighttbGroupByOutputType[P]>
        }
      >
    >


  export type righttbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RightId?: boolean
    UserId?: boolean
    FunctionCode?: boolean
  }, ExtArgs["result"]["righttb"]>


  export type righttbSelectScalar = {
    RightId?: boolean
    UserId?: boolean
    FunctionCode?: boolean
  }


  export type $righttbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "righttb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      RightId: number
      UserId: number
      FunctionCode: string
    }, ExtArgs["result"]["righttb"]>
    composites: {}
  }

  type righttbGetPayload<S extends boolean | null | undefined | righttbDefaultArgs> = $Result.GetResult<Prisma.$righttbPayload, S>

  type righttbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<righttbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RighttbCountAggregateInputType | true
    }

  export interface righttbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['righttb'], meta: { name: 'righttb' } }
    /**
     * Find zero or one Righttb that matches the filter.
     * @param {righttbFindUniqueArgs} args - Arguments to find a Righttb
     * @example
     * // Get one Righttb
     * const righttb = await prisma.righttb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends righttbFindUniqueArgs>(args: SelectSubset<T, righttbFindUniqueArgs<ExtArgs>>): Prisma__righttbClient<$Result.GetResult<Prisma.$righttbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Righttb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {righttbFindUniqueOrThrowArgs} args - Arguments to find a Righttb
     * @example
     * // Get one Righttb
     * const righttb = await prisma.righttb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends righttbFindUniqueOrThrowArgs>(args: SelectSubset<T, righttbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__righttbClient<$Result.GetResult<Prisma.$righttbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Righttb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {righttbFindFirstArgs} args - Arguments to find a Righttb
     * @example
     * // Get one Righttb
     * const righttb = await prisma.righttb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends righttbFindFirstArgs>(args?: SelectSubset<T, righttbFindFirstArgs<ExtArgs>>): Prisma__righttbClient<$Result.GetResult<Prisma.$righttbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Righttb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {righttbFindFirstOrThrowArgs} args - Arguments to find a Righttb
     * @example
     * // Get one Righttb
     * const righttb = await prisma.righttb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends righttbFindFirstOrThrowArgs>(args?: SelectSubset<T, righttbFindFirstOrThrowArgs<ExtArgs>>): Prisma__righttbClient<$Result.GetResult<Prisma.$righttbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Righttbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {righttbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Righttbs
     * const righttbs = await prisma.righttb.findMany()
     * 
     * // Get first 10 Righttbs
     * const righttbs = await prisma.righttb.findMany({ take: 10 })
     * 
     * // Only select the `RightId`
     * const righttbWithRightIdOnly = await prisma.righttb.findMany({ select: { RightId: true } })
     * 
     */
    findMany<T extends righttbFindManyArgs>(args?: SelectSubset<T, righttbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$righttbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Righttb.
     * @param {righttbCreateArgs} args - Arguments to create a Righttb.
     * @example
     * // Create one Righttb
     * const Righttb = await prisma.righttb.create({
     *   data: {
     *     // ... data to create a Righttb
     *   }
     * })
     * 
     */
    create<T extends righttbCreateArgs>(args: SelectSubset<T, righttbCreateArgs<ExtArgs>>): Prisma__righttbClient<$Result.GetResult<Prisma.$righttbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Righttbs.
     * @param {righttbCreateManyArgs} args - Arguments to create many Righttbs.
     * @example
     * // Create many Righttbs
     * const righttb = await prisma.righttb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends righttbCreateManyArgs>(args?: SelectSubset<T, righttbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Righttb.
     * @param {righttbDeleteArgs} args - Arguments to delete one Righttb.
     * @example
     * // Delete one Righttb
     * const Righttb = await prisma.righttb.delete({
     *   where: {
     *     // ... filter to delete one Righttb
     *   }
     * })
     * 
     */
    delete<T extends righttbDeleteArgs>(args: SelectSubset<T, righttbDeleteArgs<ExtArgs>>): Prisma__righttbClient<$Result.GetResult<Prisma.$righttbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Righttb.
     * @param {righttbUpdateArgs} args - Arguments to update one Righttb.
     * @example
     * // Update one Righttb
     * const righttb = await prisma.righttb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends righttbUpdateArgs>(args: SelectSubset<T, righttbUpdateArgs<ExtArgs>>): Prisma__righttbClient<$Result.GetResult<Prisma.$righttbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Righttbs.
     * @param {righttbDeleteManyArgs} args - Arguments to filter Righttbs to delete.
     * @example
     * // Delete a few Righttbs
     * const { count } = await prisma.righttb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends righttbDeleteManyArgs>(args?: SelectSubset<T, righttbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Righttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {righttbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Righttbs
     * const righttb = await prisma.righttb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends righttbUpdateManyArgs>(args: SelectSubset<T, righttbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Righttb.
     * @param {righttbUpsertArgs} args - Arguments to update or create a Righttb.
     * @example
     * // Update or create a Righttb
     * const righttb = await prisma.righttb.upsert({
     *   create: {
     *     // ... data to create a Righttb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Righttb we want to update
     *   }
     * })
     */
    upsert<T extends righttbUpsertArgs>(args: SelectSubset<T, righttbUpsertArgs<ExtArgs>>): Prisma__righttbClient<$Result.GetResult<Prisma.$righttbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Righttbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {righttbCountArgs} args - Arguments to filter Righttbs to count.
     * @example
     * // Count the number of Righttbs
     * const count = await prisma.righttb.count({
     *   where: {
     *     // ... the filter for the Righttbs we want to count
     *   }
     * })
    **/
    count<T extends righttbCountArgs>(
      args?: Subset<T, righttbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RighttbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Righttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RighttbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RighttbAggregateArgs>(args: Subset<T, RighttbAggregateArgs>): Prisma.PrismaPromise<GetRighttbAggregateType<T>>

    /**
     * Group by Righttb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {righttbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends righttbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: righttbGroupByArgs['orderBy'] }
        : { orderBy?: righttbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, righttbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRighttbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the righttb model
   */
  readonly fields: righttbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for righttb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__righttbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the righttb model
   */ 
  interface righttbFieldRefs {
    readonly RightId: FieldRef<"righttb", 'Int'>
    readonly UserId: FieldRef<"righttb", 'Int'>
    readonly FunctionCode: FieldRef<"righttb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * righttb findUnique
   */
  export type righttbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
    /**
     * Filter, which righttb to fetch.
     */
    where: righttbWhereUniqueInput
  }

  /**
   * righttb findUniqueOrThrow
   */
  export type righttbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
    /**
     * Filter, which righttb to fetch.
     */
    where: righttbWhereUniqueInput
  }

  /**
   * righttb findFirst
   */
  export type righttbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
    /**
     * Filter, which righttb to fetch.
     */
    where?: righttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of righttbs to fetch.
     */
    orderBy?: righttbOrderByWithRelationInput | righttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for righttbs.
     */
    cursor?: righttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` righttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` righttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of righttbs.
     */
    distinct?: RighttbScalarFieldEnum | RighttbScalarFieldEnum[]
  }

  /**
   * righttb findFirstOrThrow
   */
  export type righttbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
    /**
     * Filter, which righttb to fetch.
     */
    where?: righttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of righttbs to fetch.
     */
    orderBy?: righttbOrderByWithRelationInput | righttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for righttbs.
     */
    cursor?: righttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` righttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` righttbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of righttbs.
     */
    distinct?: RighttbScalarFieldEnum | RighttbScalarFieldEnum[]
  }

  /**
   * righttb findMany
   */
  export type righttbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
    /**
     * Filter, which righttbs to fetch.
     */
    where?: righttbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of righttbs to fetch.
     */
    orderBy?: righttbOrderByWithRelationInput | righttbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing righttbs.
     */
    cursor?: righttbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` righttbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` righttbs.
     */
    skip?: number
    distinct?: RighttbScalarFieldEnum | RighttbScalarFieldEnum[]
  }

  /**
   * righttb create
   */
  export type righttbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
    /**
     * The data needed to create a righttb.
     */
    data: XOR<righttbCreateInput, righttbUncheckedCreateInput>
  }

  /**
   * righttb createMany
   */
  export type righttbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many righttbs.
     */
    data: righttbCreateManyInput | righttbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * righttb update
   */
  export type righttbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
    /**
     * The data needed to update a righttb.
     */
    data: XOR<righttbUpdateInput, righttbUncheckedUpdateInput>
    /**
     * Choose, which righttb to update.
     */
    where: righttbWhereUniqueInput
  }

  /**
   * righttb updateMany
   */
  export type righttbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update righttbs.
     */
    data: XOR<righttbUpdateManyMutationInput, righttbUncheckedUpdateManyInput>
    /**
     * Filter which righttbs to update
     */
    where?: righttbWhereInput
  }

  /**
   * righttb upsert
   */
  export type righttbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
    /**
     * The filter to search for the righttb to update in case it exists.
     */
    where: righttbWhereUniqueInput
    /**
     * In case the righttb found by the `where` argument doesn't exist, create a new righttb with this data.
     */
    create: XOR<righttbCreateInput, righttbUncheckedCreateInput>
    /**
     * In case the righttb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<righttbUpdateInput, righttbUncheckedUpdateInput>
  }

  /**
   * righttb delete
   */
  export type righttbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
    /**
     * Filter which righttb to delete.
     */
    where: righttbWhereUniqueInput
  }

  /**
   * righttb deleteMany
   */
  export type righttbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which righttbs to delete
     */
    where?: righttbWhereInput
  }

  /**
   * righttb without action
   */
  export type righttbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the righttb
     */
    select?: righttbSelect<ExtArgs> | null
  }


  /**
   * Model serverlogtb
   */

  export type AggregateServerlogtb = {
    _count: ServerlogtbCountAggregateOutputType | null
    _avg: ServerlogtbAvgAggregateOutputType | null
    _sum: ServerlogtbSumAggregateOutputType | null
    _min: ServerlogtbMinAggregateOutputType | null
    _max: ServerlogtbMaxAggregateOutputType | null
  }

  export type ServerlogtbAvgAggregateOutputType = {
    ServerLogId: number | null
    Period: number | null
  }

  export type ServerlogtbSumAggregateOutputType = {
    ServerLogId: number | null
    Period: number | null
  }

  export type ServerlogtbMinAggregateOutputType = {
    ServerLogId: number | null
    Status: string | null
    RecordDate: Date | null
    RecordTime: Date | null
    Period: number | null
    Note: string | null
  }

  export type ServerlogtbMaxAggregateOutputType = {
    ServerLogId: number | null
    Status: string | null
    RecordDate: Date | null
    RecordTime: Date | null
    Period: number | null
    Note: string | null
  }

  export type ServerlogtbCountAggregateOutputType = {
    ServerLogId: number
    Status: number
    RecordDate: number
    RecordTime: number
    Period: number
    Note: number
    _all: number
  }


  export type ServerlogtbAvgAggregateInputType = {
    ServerLogId?: true
    Period?: true
  }

  export type ServerlogtbSumAggregateInputType = {
    ServerLogId?: true
    Period?: true
  }

  export type ServerlogtbMinAggregateInputType = {
    ServerLogId?: true
    Status?: true
    RecordDate?: true
    RecordTime?: true
    Period?: true
    Note?: true
  }

  export type ServerlogtbMaxAggregateInputType = {
    ServerLogId?: true
    Status?: true
    RecordDate?: true
    RecordTime?: true
    Period?: true
    Note?: true
  }

  export type ServerlogtbCountAggregateInputType = {
    ServerLogId?: true
    Status?: true
    RecordDate?: true
    RecordTime?: true
    Period?: true
    Note?: true
    _all?: true
  }

  export type ServerlogtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serverlogtb to aggregate.
     */
    where?: serverlogtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serverlogtbs to fetch.
     */
    orderBy?: serverlogtbOrderByWithRelationInput | serverlogtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serverlogtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serverlogtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serverlogtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serverlogtbs
    **/
    _count?: true | ServerlogtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServerlogtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServerlogtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServerlogtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServerlogtbMaxAggregateInputType
  }

  export type GetServerlogtbAggregateType<T extends ServerlogtbAggregateArgs> = {
        [P in keyof T & keyof AggregateServerlogtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServerlogtb[P]>
      : GetScalarType<T[P], AggregateServerlogtb[P]>
  }




  export type serverlogtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serverlogtbWhereInput
    orderBy?: serverlogtbOrderByWithAggregationInput | serverlogtbOrderByWithAggregationInput[]
    by: ServerlogtbScalarFieldEnum[] | ServerlogtbScalarFieldEnum
    having?: serverlogtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServerlogtbCountAggregateInputType | true
    _avg?: ServerlogtbAvgAggregateInputType
    _sum?: ServerlogtbSumAggregateInputType
    _min?: ServerlogtbMinAggregateInputType
    _max?: ServerlogtbMaxAggregateInputType
  }

  export type ServerlogtbGroupByOutputType = {
    ServerLogId: number
    Status: string
    RecordDate: Date
    RecordTime: Date
    Period: number
    Note: string | null
    _count: ServerlogtbCountAggregateOutputType | null
    _avg: ServerlogtbAvgAggregateOutputType | null
    _sum: ServerlogtbSumAggregateOutputType | null
    _min: ServerlogtbMinAggregateOutputType | null
    _max: ServerlogtbMaxAggregateOutputType | null
  }

  type GetServerlogtbGroupByPayload<T extends serverlogtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServerlogtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServerlogtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServerlogtbGroupByOutputType[P]>
            : GetScalarType<T[P], ServerlogtbGroupByOutputType[P]>
        }
      >
    >


  export type serverlogtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ServerLogId?: boolean
    Status?: boolean
    RecordDate?: boolean
    RecordTime?: boolean
    Period?: boolean
    Note?: boolean
  }, ExtArgs["result"]["serverlogtb"]>


  export type serverlogtbSelectScalar = {
    ServerLogId?: boolean
    Status?: boolean
    RecordDate?: boolean
    RecordTime?: boolean
    Period?: boolean
    Note?: boolean
  }


  export type $serverlogtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serverlogtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ServerLogId: number
      Status: string
      RecordDate: Date
      RecordTime: Date
      Period: number
      Note: string | null
    }, ExtArgs["result"]["serverlogtb"]>
    composites: {}
  }

  type serverlogtbGetPayload<S extends boolean | null | undefined | serverlogtbDefaultArgs> = $Result.GetResult<Prisma.$serverlogtbPayload, S>

  type serverlogtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serverlogtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServerlogtbCountAggregateInputType | true
    }

  export interface serverlogtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serverlogtb'], meta: { name: 'serverlogtb' } }
    /**
     * Find zero or one Serverlogtb that matches the filter.
     * @param {serverlogtbFindUniqueArgs} args - Arguments to find a Serverlogtb
     * @example
     * // Get one Serverlogtb
     * const serverlogtb = await prisma.serverlogtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serverlogtbFindUniqueArgs>(args: SelectSubset<T, serverlogtbFindUniqueArgs<ExtArgs>>): Prisma__serverlogtbClient<$Result.GetResult<Prisma.$serverlogtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Serverlogtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {serverlogtbFindUniqueOrThrowArgs} args - Arguments to find a Serverlogtb
     * @example
     * // Get one Serverlogtb
     * const serverlogtb = await prisma.serverlogtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serverlogtbFindUniqueOrThrowArgs>(args: SelectSubset<T, serverlogtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serverlogtbClient<$Result.GetResult<Prisma.$serverlogtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Serverlogtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverlogtbFindFirstArgs} args - Arguments to find a Serverlogtb
     * @example
     * // Get one Serverlogtb
     * const serverlogtb = await prisma.serverlogtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serverlogtbFindFirstArgs>(args?: SelectSubset<T, serverlogtbFindFirstArgs<ExtArgs>>): Prisma__serverlogtbClient<$Result.GetResult<Prisma.$serverlogtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Serverlogtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverlogtbFindFirstOrThrowArgs} args - Arguments to find a Serverlogtb
     * @example
     * // Get one Serverlogtb
     * const serverlogtb = await prisma.serverlogtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serverlogtbFindFirstOrThrowArgs>(args?: SelectSubset<T, serverlogtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__serverlogtbClient<$Result.GetResult<Prisma.$serverlogtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Serverlogtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverlogtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Serverlogtbs
     * const serverlogtbs = await prisma.serverlogtb.findMany()
     * 
     * // Get first 10 Serverlogtbs
     * const serverlogtbs = await prisma.serverlogtb.findMany({ take: 10 })
     * 
     * // Only select the `ServerLogId`
     * const serverlogtbWithServerLogIdOnly = await prisma.serverlogtb.findMany({ select: { ServerLogId: true } })
     * 
     */
    findMany<T extends serverlogtbFindManyArgs>(args?: SelectSubset<T, serverlogtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serverlogtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Serverlogtb.
     * @param {serverlogtbCreateArgs} args - Arguments to create a Serverlogtb.
     * @example
     * // Create one Serverlogtb
     * const Serverlogtb = await prisma.serverlogtb.create({
     *   data: {
     *     // ... data to create a Serverlogtb
     *   }
     * })
     * 
     */
    create<T extends serverlogtbCreateArgs>(args: SelectSubset<T, serverlogtbCreateArgs<ExtArgs>>): Prisma__serverlogtbClient<$Result.GetResult<Prisma.$serverlogtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Serverlogtbs.
     * @param {serverlogtbCreateManyArgs} args - Arguments to create many Serverlogtbs.
     * @example
     * // Create many Serverlogtbs
     * const serverlogtb = await prisma.serverlogtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serverlogtbCreateManyArgs>(args?: SelectSubset<T, serverlogtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Serverlogtb.
     * @param {serverlogtbDeleteArgs} args - Arguments to delete one Serverlogtb.
     * @example
     * // Delete one Serverlogtb
     * const Serverlogtb = await prisma.serverlogtb.delete({
     *   where: {
     *     // ... filter to delete one Serverlogtb
     *   }
     * })
     * 
     */
    delete<T extends serverlogtbDeleteArgs>(args: SelectSubset<T, serverlogtbDeleteArgs<ExtArgs>>): Prisma__serverlogtbClient<$Result.GetResult<Prisma.$serverlogtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Serverlogtb.
     * @param {serverlogtbUpdateArgs} args - Arguments to update one Serverlogtb.
     * @example
     * // Update one Serverlogtb
     * const serverlogtb = await prisma.serverlogtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serverlogtbUpdateArgs>(args: SelectSubset<T, serverlogtbUpdateArgs<ExtArgs>>): Prisma__serverlogtbClient<$Result.GetResult<Prisma.$serverlogtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Serverlogtbs.
     * @param {serverlogtbDeleteManyArgs} args - Arguments to filter Serverlogtbs to delete.
     * @example
     * // Delete a few Serverlogtbs
     * const { count } = await prisma.serverlogtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serverlogtbDeleteManyArgs>(args?: SelectSubset<T, serverlogtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Serverlogtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverlogtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Serverlogtbs
     * const serverlogtb = await prisma.serverlogtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serverlogtbUpdateManyArgs>(args: SelectSubset<T, serverlogtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Serverlogtb.
     * @param {serverlogtbUpsertArgs} args - Arguments to update or create a Serverlogtb.
     * @example
     * // Update or create a Serverlogtb
     * const serverlogtb = await prisma.serverlogtb.upsert({
     *   create: {
     *     // ... data to create a Serverlogtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serverlogtb we want to update
     *   }
     * })
     */
    upsert<T extends serverlogtbUpsertArgs>(args: SelectSubset<T, serverlogtbUpsertArgs<ExtArgs>>): Prisma__serverlogtbClient<$Result.GetResult<Prisma.$serverlogtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Serverlogtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverlogtbCountArgs} args - Arguments to filter Serverlogtbs to count.
     * @example
     * // Count the number of Serverlogtbs
     * const count = await prisma.serverlogtb.count({
     *   where: {
     *     // ... the filter for the Serverlogtbs we want to count
     *   }
     * })
    **/
    count<T extends serverlogtbCountArgs>(
      args?: Subset<T, serverlogtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServerlogtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serverlogtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerlogtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServerlogtbAggregateArgs>(args: Subset<T, ServerlogtbAggregateArgs>): Prisma.PrismaPromise<GetServerlogtbAggregateType<T>>

    /**
     * Group by Serverlogtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serverlogtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serverlogtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serverlogtbGroupByArgs['orderBy'] }
        : { orderBy?: serverlogtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serverlogtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServerlogtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serverlogtb model
   */
  readonly fields: serverlogtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serverlogtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serverlogtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serverlogtb model
   */ 
  interface serverlogtbFieldRefs {
    readonly ServerLogId: FieldRef<"serverlogtb", 'Int'>
    readonly Status: FieldRef<"serverlogtb", 'String'>
    readonly RecordDate: FieldRef<"serverlogtb", 'DateTime'>
    readonly RecordTime: FieldRef<"serverlogtb", 'DateTime'>
    readonly Period: FieldRef<"serverlogtb", 'Int'>
    readonly Note: FieldRef<"serverlogtb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * serverlogtb findUnique
   */
  export type serverlogtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
    /**
     * Filter, which serverlogtb to fetch.
     */
    where: serverlogtbWhereUniqueInput
  }

  /**
   * serverlogtb findUniqueOrThrow
   */
  export type serverlogtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
    /**
     * Filter, which serverlogtb to fetch.
     */
    where: serverlogtbWhereUniqueInput
  }

  /**
   * serverlogtb findFirst
   */
  export type serverlogtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
    /**
     * Filter, which serverlogtb to fetch.
     */
    where?: serverlogtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serverlogtbs to fetch.
     */
    orderBy?: serverlogtbOrderByWithRelationInput | serverlogtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serverlogtbs.
     */
    cursor?: serverlogtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serverlogtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serverlogtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serverlogtbs.
     */
    distinct?: ServerlogtbScalarFieldEnum | ServerlogtbScalarFieldEnum[]
  }

  /**
   * serverlogtb findFirstOrThrow
   */
  export type serverlogtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
    /**
     * Filter, which serverlogtb to fetch.
     */
    where?: serverlogtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serverlogtbs to fetch.
     */
    orderBy?: serverlogtbOrderByWithRelationInput | serverlogtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serverlogtbs.
     */
    cursor?: serverlogtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serverlogtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serverlogtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serverlogtbs.
     */
    distinct?: ServerlogtbScalarFieldEnum | ServerlogtbScalarFieldEnum[]
  }

  /**
   * serverlogtb findMany
   */
  export type serverlogtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
    /**
     * Filter, which serverlogtbs to fetch.
     */
    where?: serverlogtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serverlogtbs to fetch.
     */
    orderBy?: serverlogtbOrderByWithRelationInput | serverlogtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serverlogtbs.
     */
    cursor?: serverlogtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serverlogtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serverlogtbs.
     */
    skip?: number
    distinct?: ServerlogtbScalarFieldEnum | ServerlogtbScalarFieldEnum[]
  }

  /**
   * serverlogtb create
   */
  export type serverlogtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
    /**
     * The data needed to create a serverlogtb.
     */
    data: XOR<serverlogtbCreateInput, serverlogtbUncheckedCreateInput>
  }

  /**
   * serverlogtb createMany
   */
  export type serverlogtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serverlogtbs.
     */
    data: serverlogtbCreateManyInput | serverlogtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serverlogtb update
   */
  export type serverlogtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
    /**
     * The data needed to update a serverlogtb.
     */
    data: XOR<serverlogtbUpdateInput, serverlogtbUncheckedUpdateInput>
    /**
     * Choose, which serverlogtb to update.
     */
    where: serverlogtbWhereUniqueInput
  }

  /**
   * serverlogtb updateMany
   */
  export type serverlogtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serverlogtbs.
     */
    data: XOR<serverlogtbUpdateManyMutationInput, serverlogtbUncheckedUpdateManyInput>
    /**
     * Filter which serverlogtbs to update
     */
    where?: serverlogtbWhereInput
  }

  /**
   * serverlogtb upsert
   */
  export type serverlogtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
    /**
     * The filter to search for the serverlogtb to update in case it exists.
     */
    where: serverlogtbWhereUniqueInput
    /**
     * In case the serverlogtb found by the `where` argument doesn't exist, create a new serverlogtb with this data.
     */
    create: XOR<serverlogtbCreateInput, serverlogtbUncheckedCreateInput>
    /**
     * In case the serverlogtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serverlogtbUpdateInput, serverlogtbUncheckedUpdateInput>
  }

  /**
   * serverlogtb delete
   */
  export type serverlogtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
    /**
     * Filter which serverlogtb to delete.
     */
    where: serverlogtbWhereUniqueInput
  }

  /**
   * serverlogtb deleteMany
   */
  export type serverlogtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serverlogtbs to delete
     */
    where?: serverlogtbWhereInput
  }

  /**
   * serverlogtb without action
   */
  export type serverlogtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serverlogtb
     */
    select?: serverlogtbSelect<ExtArgs> | null
  }


  /**
   * Model servicedetailtb
   */

  export type AggregateServicedetailtb = {
    _count: ServicedetailtbCountAggregateOutputType | null
    _avg: ServicedetailtbAvgAggregateOutputType | null
    _sum: ServicedetailtbSumAggregateOutputType | null
    _min: ServicedetailtbMinAggregateOutputType | null
    _max: ServicedetailtbMaxAggregateOutputType | null
  }

  export type ServicedetailtbAvgAggregateOutputType = {
    ServiceDetailId: number | null
    UserId: number | null
    ServiceId: number | null
    ServiceQuantity: number | null
    ServiceAmount: Decimal | null
    VoucherId: number | null
    StaffId: number | null
    PaymentWaitId: number | null
  }

  export type ServicedetailtbSumAggregateOutputType = {
    ServiceDetailId: number | null
    UserId: number | null
    ServiceId: number | null
    ServiceQuantity: number | null
    ServiceAmount: Decimal | null
    VoucherId: number | null
    StaffId: number | null
    PaymentWaitId: number | null
  }

  export type ServicedetailtbMinAggregateOutputType = {
    ServiceDetailId: number | null
    UserId: number | null
    ServiceId: number | null
    ServiceDate: Date | null
    ServiceTime: Date | null
    ServiceQuantity: number | null
    ServiceAmount: Decimal | null
    ServicePaid: boolean | null
    Accept: boolean | null
    VoucherId: number | null
    StaffId: number | null
    PaymentWaitId: number | null
    iCafeHash: string | null
    iCafeUsr: string | null
  }

  export type ServicedetailtbMaxAggregateOutputType = {
    ServiceDetailId: number | null
    UserId: number | null
    ServiceId: number | null
    ServiceDate: Date | null
    ServiceTime: Date | null
    ServiceQuantity: number | null
    ServiceAmount: Decimal | null
    ServicePaid: boolean | null
    Accept: boolean | null
    VoucherId: number | null
    StaffId: number | null
    PaymentWaitId: number | null
    iCafeHash: string | null
    iCafeUsr: string | null
  }

  export type ServicedetailtbCountAggregateOutputType = {
    ServiceDetailId: number
    UserId: number
    ServiceId: number
    ServiceDate: number
    ServiceTime: number
    ServiceQuantity: number
    ServiceAmount: number
    ServicePaid: number
    Accept: number
    VoucherId: number
    StaffId: number
    PaymentWaitId: number
    iCafeHash: number
    iCafeUsr: number
    _all: number
  }


  export type ServicedetailtbAvgAggregateInputType = {
    ServiceDetailId?: true
    UserId?: true
    ServiceId?: true
    ServiceQuantity?: true
    ServiceAmount?: true
    VoucherId?: true
    StaffId?: true
    PaymentWaitId?: true
  }

  export type ServicedetailtbSumAggregateInputType = {
    ServiceDetailId?: true
    UserId?: true
    ServiceId?: true
    ServiceQuantity?: true
    ServiceAmount?: true
    VoucherId?: true
    StaffId?: true
    PaymentWaitId?: true
  }

  export type ServicedetailtbMinAggregateInputType = {
    ServiceDetailId?: true
    UserId?: true
    ServiceId?: true
    ServiceDate?: true
    ServiceTime?: true
    ServiceQuantity?: true
    ServiceAmount?: true
    ServicePaid?: true
    Accept?: true
    VoucherId?: true
    StaffId?: true
    PaymentWaitId?: true
    iCafeHash?: true
    iCafeUsr?: true
  }

  export type ServicedetailtbMaxAggregateInputType = {
    ServiceDetailId?: true
    UserId?: true
    ServiceId?: true
    ServiceDate?: true
    ServiceTime?: true
    ServiceQuantity?: true
    ServiceAmount?: true
    ServicePaid?: true
    Accept?: true
    VoucherId?: true
    StaffId?: true
    PaymentWaitId?: true
    iCafeHash?: true
    iCafeUsr?: true
  }

  export type ServicedetailtbCountAggregateInputType = {
    ServiceDetailId?: true
    UserId?: true
    ServiceId?: true
    ServiceDate?: true
    ServiceTime?: true
    ServiceQuantity?: true
    ServiceAmount?: true
    ServicePaid?: true
    Accept?: true
    VoucherId?: true
    StaffId?: true
    PaymentWaitId?: true
    iCafeHash?: true
    iCafeUsr?: true
    _all?: true
  }

  export type ServicedetailtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicedetailtb to aggregate.
     */
    where?: servicedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicedetailtbs to fetch.
     */
    orderBy?: servicedetailtbOrderByWithRelationInput | servicedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicedetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicedetailtbs
    **/
    _count?: true | ServicedetailtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicedetailtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicedetailtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicedetailtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicedetailtbMaxAggregateInputType
  }

  export type GetServicedetailtbAggregateType<T extends ServicedetailtbAggregateArgs> = {
        [P in keyof T & keyof AggregateServicedetailtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicedetailtb[P]>
      : GetScalarType<T[P], AggregateServicedetailtb[P]>
  }




  export type servicedetailtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicedetailtbWhereInput
    orderBy?: servicedetailtbOrderByWithAggregationInput | servicedetailtbOrderByWithAggregationInput[]
    by: ServicedetailtbScalarFieldEnum[] | ServicedetailtbScalarFieldEnum
    having?: servicedetailtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicedetailtbCountAggregateInputType | true
    _avg?: ServicedetailtbAvgAggregateInputType
    _sum?: ServicedetailtbSumAggregateInputType
    _min?: ServicedetailtbMinAggregateInputType
    _max?: ServicedetailtbMaxAggregateInputType
  }

  export type ServicedetailtbGroupByOutputType = {
    ServiceDetailId: number
    UserId: number
    ServiceId: number
    ServiceDate: Date
    ServiceTime: Date
    ServiceQuantity: number
    ServiceAmount: Decimal
    ServicePaid: boolean
    Accept: boolean
    VoucherId: number | null
    StaffId: number
    PaymentWaitId: number
    iCafeHash: string | null
    iCafeUsr: string | null
    _count: ServicedetailtbCountAggregateOutputType | null
    _avg: ServicedetailtbAvgAggregateOutputType | null
    _sum: ServicedetailtbSumAggregateOutputType | null
    _min: ServicedetailtbMinAggregateOutputType | null
    _max: ServicedetailtbMaxAggregateOutputType | null
  }

  type GetServicedetailtbGroupByPayload<T extends servicedetailtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicedetailtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicedetailtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicedetailtbGroupByOutputType[P]>
            : GetScalarType<T[P], ServicedetailtbGroupByOutputType[P]>
        }
      >
    >


  export type servicedetailtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ServiceDetailId?: boolean
    UserId?: boolean
    ServiceId?: boolean
    ServiceDate?: boolean
    ServiceTime?: boolean
    ServiceQuantity?: boolean
    ServiceAmount?: boolean
    ServicePaid?: boolean
    Accept?: boolean
    VoucherId?: boolean
    StaffId?: boolean
    PaymentWaitId?: boolean
    iCafeHash?: boolean
    iCafeUsr?: boolean
  }, ExtArgs["result"]["servicedetailtb"]>


  export type servicedetailtbSelectScalar = {
    ServiceDetailId?: boolean
    UserId?: boolean
    ServiceId?: boolean
    ServiceDate?: boolean
    ServiceTime?: boolean
    ServiceQuantity?: boolean
    ServiceAmount?: boolean
    ServicePaid?: boolean
    Accept?: boolean
    VoucherId?: boolean
    StaffId?: boolean
    PaymentWaitId?: boolean
    iCafeHash?: boolean
    iCafeUsr?: boolean
  }


  export type $servicedetailtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "servicedetailtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ServiceDetailId: number
      UserId: number
      ServiceId: number
      ServiceDate: Date
      ServiceTime: Date
      ServiceQuantity: number
      ServiceAmount: Prisma.Decimal
      ServicePaid: boolean
      Accept: boolean
      VoucherId: number | null
      StaffId: number
      PaymentWaitId: number
      iCafeHash: string | null
      iCafeUsr: string | null
    }, ExtArgs["result"]["servicedetailtb"]>
    composites: {}
  }

  type servicedetailtbGetPayload<S extends boolean | null | undefined | servicedetailtbDefaultArgs> = $Result.GetResult<Prisma.$servicedetailtbPayload, S>

  type servicedetailtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<servicedetailtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicedetailtbCountAggregateInputType | true
    }

  export interface servicedetailtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicedetailtb'], meta: { name: 'servicedetailtb' } }
    /**
     * Find zero or one Servicedetailtb that matches the filter.
     * @param {servicedetailtbFindUniqueArgs} args - Arguments to find a Servicedetailtb
     * @example
     * // Get one Servicedetailtb
     * const servicedetailtb = await prisma.servicedetailtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends servicedetailtbFindUniqueArgs>(args: SelectSubset<T, servicedetailtbFindUniqueArgs<ExtArgs>>): Prisma__servicedetailtbClient<$Result.GetResult<Prisma.$servicedetailtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicedetailtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {servicedetailtbFindUniqueOrThrowArgs} args - Arguments to find a Servicedetailtb
     * @example
     * // Get one Servicedetailtb
     * const servicedetailtb = await prisma.servicedetailtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends servicedetailtbFindUniqueOrThrowArgs>(args: SelectSubset<T, servicedetailtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__servicedetailtbClient<$Result.GetResult<Prisma.$servicedetailtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicedetailtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicedetailtbFindFirstArgs} args - Arguments to find a Servicedetailtb
     * @example
     * // Get one Servicedetailtb
     * const servicedetailtb = await prisma.servicedetailtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends servicedetailtbFindFirstArgs>(args?: SelectSubset<T, servicedetailtbFindFirstArgs<ExtArgs>>): Prisma__servicedetailtbClient<$Result.GetResult<Prisma.$servicedetailtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicedetailtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicedetailtbFindFirstOrThrowArgs} args - Arguments to find a Servicedetailtb
     * @example
     * // Get one Servicedetailtb
     * const servicedetailtb = await prisma.servicedetailtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends servicedetailtbFindFirstOrThrowArgs>(args?: SelectSubset<T, servicedetailtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__servicedetailtbClient<$Result.GetResult<Prisma.$servicedetailtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicedetailtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicedetailtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicedetailtbs
     * const servicedetailtbs = await prisma.servicedetailtb.findMany()
     * 
     * // Get first 10 Servicedetailtbs
     * const servicedetailtbs = await prisma.servicedetailtb.findMany({ take: 10 })
     * 
     * // Only select the `ServiceDetailId`
     * const servicedetailtbWithServiceDetailIdOnly = await prisma.servicedetailtb.findMany({ select: { ServiceDetailId: true } })
     * 
     */
    findMany<T extends servicedetailtbFindManyArgs>(args?: SelectSubset<T, servicedetailtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicedetailtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicedetailtb.
     * @param {servicedetailtbCreateArgs} args - Arguments to create a Servicedetailtb.
     * @example
     * // Create one Servicedetailtb
     * const Servicedetailtb = await prisma.servicedetailtb.create({
     *   data: {
     *     // ... data to create a Servicedetailtb
     *   }
     * })
     * 
     */
    create<T extends servicedetailtbCreateArgs>(args: SelectSubset<T, servicedetailtbCreateArgs<ExtArgs>>): Prisma__servicedetailtbClient<$Result.GetResult<Prisma.$servicedetailtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicedetailtbs.
     * @param {servicedetailtbCreateManyArgs} args - Arguments to create many Servicedetailtbs.
     * @example
     * // Create many Servicedetailtbs
     * const servicedetailtb = await prisma.servicedetailtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends servicedetailtbCreateManyArgs>(args?: SelectSubset<T, servicedetailtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicedetailtb.
     * @param {servicedetailtbDeleteArgs} args - Arguments to delete one Servicedetailtb.
     * @example
     * // Delete one Servicedetailtb
     * const Servicedetailtb = await prisma.servicedetailtb.delete({
     *   where: {
     *     // ... filter to delete one Servicedetailtb
     *   }
     * })
     * 
     */
    delete<T extends servicedetailtbDeleteArgs>(args: SelectSubset<T, servicedetailtbDeleteArgs<ExtArgs>>): Prisma__servicedetailtbClient<$Result.GetResult<Prisma.$servicedetailtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicedetailtb.
     * @param {servicedetailtbUpdateArgs} args - Arguments to update one Servicedetailtb.
     * @example
     * // Update one Servicedetailtb
     * const servicedetailtb = await prisma.servicedetailtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends servicedetailtbUpdateArgs>(args: SelectSubset<T, servicedetailtbUpdateArgs<ExtArgs>>): Prisma__servicedetailtbClient<$Result.GetResult<Prisma.$servicedetailtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicedetailtbs.
     * @param {servicedetailtbDeleteManyArgs} args - Arguments to filter Servicedetailtbs to delete.
     * @example
     * // Delete a few Servicedetailtbs
     * const { count } = await prisma.servicedetailtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends servicedetailtbDeleteManyArgs>(args?: SelectSubset<T, servicedetailtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicedetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicedetailtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicedetailtbs
     * const servicedetailtb = await prisma.servicedetailtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends servicedetailtbUpdateManyArgs>(args: SelectSubset<T, servicedetailtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicedetailtb.
     * @param {servicedetailtbUpsertArgs} args - Arguments to update or create a Servicedetailtb.
     * @example
     * // Update or create a Servicedetailtb
     * const servicedetailtb = await prisma.servicedetailtb.upsert({
     *   create: {
     *     // ... data to create a Servicedetailtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicedetailtb we want to update
     *   }
     * })
     */
    upsert<T extends servicedetailtbUpsertArgs>(args: SelectSubset<T, servicedetailtbUpsertArgs<ExtArgs>>): Prisma__servicedetailtbClient<$Result.GetResult<Prisma.$servicedetailtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicedetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicedetailtbCountArgs} args - Arguments to filter Servicedetailtbs to count.
     * @example
     * // Count the number of Servicedetailtbs
     * const count = await prisma.servicedetailtb.count({
     *   where: {
     *     // ... the filter for the Servicedetailtbs we want to count
     *   }
     * })
    **/
    count<T extends servicedetailtbCountArgs>(
      args?: Subset<T, servicedetailtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicedetailtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicedetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicedetailtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicedetailtbAggregateArgs>(args: Subset<T, ServicedetailtbAggregateArgs>): Prisma.PrismaPromise<GetServicedetailtbAggregateType<T>>

    /**
     * Group by Servicedetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicedetailtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicedetailtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicedetailtbGroupByArgs['orderBy'] }
        : { orderBy?: servicedetailtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicedetailtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicedetailtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the servicedetailtb model
   */
  readonly fields: servicedetailtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicedetailtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicedetailtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the servicedetailtb model
   */ 
  interface servicedetailtbFieldRefs {
    readonly ServiceDetailId: FieldRef<"servicedetailtb", 'Int'>
    readonly UserId: FieldRef<"servicedetailtb", 'Int'>
    readonly ServiceId: FieldRef<"servicedetailtb", 'Int'>
    readonly ServiceDate: FieldRef<"servicedetailtb", 'DateTime'>
    readonly ServiceTime: FieldRef<"servicedetailtb", 'DateTime'>
    readonly ServiceQuantity: FieldRef<"servicedetailtb", 'Int'>
    readonly ServiceAmount: FieldRef<"servicedetailtb", 'Decimal'>
    readonly ServicePaid: FieldRef<"servicedetailtb", 'Boolean'>
    readonly Accept: FieldRef<"servicedetailtb", 'Boolean'>
    readonly VoucherId: FieldRef<"servicedetailtb", 'Int'>
    readonly StaffId: FieldRef<"servicedetailtb", 'Int'>
    readonly PaymentWaitId: FieldRef<"servicedetailtb", 'Int'>
    readonly iCafeHash: FieldRef<"servicedetailtb", 'String'>
    readonly iCafeUsr: FieldRef<"servicedetailtb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * servicedetailtb findUnique
   */
  export type servicedetailtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which servicedetailtb to fetch.
     */
    where: servicedetailtbWhereUniqueInput
  }

  /**
   * servicedetailtb findUniqueOrThrow
   */
  export type servicedetailtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which servicedetailtb to fetch.
     */
    where: servicedetailtbWhereUniqueInput
  }

  /**
   * servicedetailtb findFirst
   */
  export type servicedetailtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which servicedetailtb to fetch.
     */
    where?: servicedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicedetailtbs to fetch.
     */
    orderBy?: servicedetailtbOrderByWithRelationInput | servicedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicedetailtbs.
     */
    cursor?: servicedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicedetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicedetailtbs.
     */
    distinct?: ServicedetailtbScalarFieldEnum | ServicedetailtbScalarFieldEnum[]
  }

  /**
   * servicedetailtb findFirstOrThrow
   */
  export type servicedetailtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which servicedetailtb to fetch.
     */
    where?: servicedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicedetailtbs to fetch.
     */
    orderBy?: servicedetailtbOrderByWithRelationInput | servicedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicedetailtbs.
     */
    cursor?: servicedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicedetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicedetailtbs.
     */
    distinct?: ServicedetailtbScalarFieldEnum | ServicedetailtbScalarFieldEnum[]
  }

  /**
   * servicedetailtb findMany
   */
  export type servicedetailtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
    /**
     * Filter, which servicedetailtbs to fetch.
     */
    where?: servicedetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicedetailtbs to fetch.
     */
    orderBy?: servicedetailtbOrderByWithRelationInput | servicedetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicedetailtbs.
     */
    cursor?: servicedetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicedetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicedetailtbs.
     */
    skip?: number
    distinct?: ServicedetailtbScalarFieldEnum | ServicedetailtbScalarFieldEnum[]
  }

  /**
   * servicedetailtb create
   */
  export type servicedetailtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
    /**
     * The data needed to create a servicedetailtb.
     */
    data: XOR<servicedetailtbCreateInput, servicedetailtbUncheckedCreateInput>
  }

  /**
   * servicedetailtb createMany
   */
  export type servicedetailtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicedetailtbs.
     */
    data: servicedetailtbCreateManyInput | servicedetailtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * servicedetailtb update
   */
  export type servicedetailtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
    /**
     * The data needed to update a servicedetailtb.
     */
    data: XOR<servicedetailtbUpdateInput, servicedetailtbUncheckedUpdateInput>
    /**
     * Choose, which servicedetailtb to update.
     */
    where: servicedetailtbWhereUniqueInput
  }

  /**
   * servicedetailtb updateMany
   */
  export type servicedetailtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicedetailtbs.
     */
    data: XOR<servicedetailtbUpdateManyMutationInput, servicedetailtbUncheckedUpdateManyInput>
    /**
     * Filter which servicedetailtbs to update
     */
    where?: servicedetailtbWhereInput
  }

  /**
   * servicedetailtb upsert
   */
  export type servicedetailtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
    /**
     * The filter to search for the servicedetailtb to update in case it exists.
     */
    where: servicedetailtbWhereUniqueInput
    /**
     * In case the servicedetailtb found by the `where` argument doesn't exist, create a new servicedetailtb with this data.
     */
    create: XOR<servicedetailtbCreateInput, servicedetailtbUncheckedCreateInput>
    /**
     * In case the servicedetailtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicedetailtbUpdateInput, servicedetailtbUncheckedUpdateInput>
  }

  /**
   * servicedetailtb delete
   */
  export type servicedetailtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
    /**
     * Filter which servicedetailtb to delete.
     */
    where: servicedetailtbWhereUniqueInput
  }

  /**
   * servicedetailtb deleteMany
   */
  export type servicedetailtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicedetailtbs to delete
     */
    where?: servicedetailtbWhereInput
  }

  /**
   * servicedetailtb without action
   */
  export type servicedetailtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicedetailtb
     */
    select?: servicedetailtbSelect<ExtArgs> | null
  }


  /**
   * Model servicegiftsbag
   */

  export type AggregateServicegiftsbag = {
    _count: ServicegiftsbagCountAggregateOutputType | null
    _avg: ServicegiftsbagAvgAggregateOutputType | null
    _sum: ServicegiftsbagSumAggregateOutputType | null
    _min: ServicegiftsbagMinAggregateOutputType | null
    _max: ServicegiftsbagMaxAggregateOutputType | null
  }

  export type ServicegiftsbagAvgAggregateOutputType = {
    recId: number | null
    sourceType: number | null
    serviceId: number | null
    servicePrice: number | null
    status: number | null
    staffId: number | null
    ymd: number | null
    totalDay: number | null
    groupId: number | null
  }

  export type ServicegiftsbagSumAggregateOutputType = {
    recId: bigint | null
    sourceType: number | null
    serviceId: number | null
    servicePrice: number | null
    status: number | null
    staffId: number | null
    ymd: number | null
    totalDay: number | null
    groupId: number | null
  }

  export type ServicegiftsbagMinAggregateOutputType = {
    recId: bigint | null
    recUuid: string | null
    userId: string | null
    userName: string | null
    createDate: Date | null
    expDate: Date | null
    sourceType: number | null
    serviceId: number | null
    serviceName: string | null
    servicePrice: number | null
    serviceImg: string | null
    status: number | null
    requestDate: Date | null
    acceptDate: Date | null
    sign: string | null
    staffId: number | null
    staffName: string | null
    transId: string | null
    serialId: string | null
    ymd: number | null
    totalDay: number | null
    groupId: number | null
  }

  export type ServicegiftsbagMaxAggregateOutputType = {
    recId: bigint | null
    recUuid: string | null
    userId: string | null
    userName: string | null
    createDate: Date | null
    expDate: Date | null
    sourceType: number | null
    serviceId: number | null
    serviceName: string | null
    servicePrice: number | null
    serviceImg: string | null
    status: number | null
    requestDate: Date | null
    acceptDate: Date | null
    sign: string | null
    staffId: number | null
    staffName: string | null
    transId: string | null
    serialId: string | null
    ymd: number | null
    totalDay: number | null
    groupId: number | null
  }

  export type ServicegiftsbagCountAggregateOutputType = {
    recId: number
    recUuid: number
    userId: number
    userName: number
    createDate: number
    expDate: number
    sourceType: number
    serviceId: number
    serviceName: number
    servicePrice: number
    serviceImg: number
    status: number
    requestDate: number
    acceptDate: number
    sign: number
    staffId: number
    staffName: number
    transId: number
    serialId: number
    ymd: number
    totalDay: number
    groupId: number
    _all: number
  }


  export type ServicegiftsbagAvgAggregateInputType = {
    recId?: true
    sourceType?: true
    serviceId?: true
    servicePrice?: true
    status?: true
    staffId?: true
    ymd?: true
    totalDay?: true
    groupId?: true
  }

  export type ServicegiftsbagSumAggregateInputType = {
    recId?: true
    sourceType?: true
    serviceId?: true
    servicePrice?: true
    status?: true
    staffId?: true
    ymd?: true
    totalDay?: true
    groupId?: true
  }

  export type ServicegiftsbagMinAggregateInputType = {
    recId?: true
    recUuid?: true
    userId?: true
    userName?: true
    createDate?: true
    expDate?: true
    sourceType?: true
    serviceId?: true
    serviceName?: true
    servicePrice?: true
    serviceImg?: true
    status?: true
    requestDate?: true
    acceptDate?: true
    sign?: true
    staffId?: true
    staffName?: true
    transId?: true
    serialId?: true
    ymd?: true
    totalDay?: true
    groupId?: true
  }

  export type ServicegiftsbagMaxAggregateInputType = {
    recId?: true
    recUuid?: true
    userId?: true
    userName?: true
    createDate?: true
    expDate?: true
    sourceType?: true
    serviceId?: true
    serviceName?: true
    servicePrice?: true
    serviceImg?: true
    status?: true
    requestDate?: true
    acceptDate?: true
    sign?: true
    staffId?: true
    staffName?: true
    transId?: true
    serialId?: true
    ymd?: true
    totalDay?: true
    groupId?: true
  }

  export type ServicegiftsbagCountAggregateInputType = {
    recId?: true
    recUuid?: true
    userId?: true
    userName?: true
    createDate?: true
    expDate?: true
    sourceType?: true
    serviceId?: true
    serviceName?: true
    servicePrice?: true
    serviceImg?: true
    status?: true
    requestDate?: true
    acceptDate?: true
    sign?: true
    staffId?: true
    staffName?: true
    transId?: true
    serialId?: true
    ymd?: true
    totalDay?: true
    groupId?: true
    _all?: true
  }

  export type ServicegiftsbagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicegiftsbag to aggregate.
     */
    where?: servicegiftsbagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicegiftsbags to fetch.
     */
    orderBy?: servicegiftsbagOrderByWithRelationInput | servicegiftsbagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicegiftsbagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicegiftsbags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicegiftsbags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicegiftsbags
    **/
    _count?: true | ServicegiftsbagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicegiftsbagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicegiftsbagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicegiftsbagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicegiftsbagMaxAggregateInputType
  }

  export type GetServicegiftsbagAggregateType<T extends ServicegiftsbagAggregateArgs> = {
        [P in keyof T & keyof AggregateServicegiftsbag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicegiftsbag[P]>
      : GetScalarType<T[P], AggregateServicegiftsbag[P]>
  }




  export type servicegiftsbagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicegiftsbagWhereInput
    orderBy?: servicegiftsbagOrderByWithAggregationInput | servicegiftsbagOrderByWithAggregationInput[]
    by: ServicegiftsbagScalarFieldEnum[] | ServicegiftsbagScalarFieldEnum
    having?: servicegiftsbagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicegiftsbagCountAggregateInputType | true
    _avg?: ServicegiftsbagAvgAggregateInputType
    _sum?: ServicegiftsbagSumAggregateInputType
    _min?: ServicegiftsbagMinAggregateInputType
    _max?: ServicegiftsbagMaxAggregateInputType
  }

  export type ServicegiftsbagGroupByOutputType = {
    recId: bigint
    recUuid: string
    userId: string | null
    userName: string | null
    createDate: Date | null
    expDate: Date | null
    sourceType: number | null
    serviceId: number | null
    serviceName: string | null
    servicePrice: number | null
    serviceImg: string | null
    status: number | null
    requestDate: Date | null
    acceptDate: Date | null
    sign: string | null
    staffId: number | null
    staffName: string | null
    transId: string | null
    serialId: string | null
    ymd: number | null
    totalDay: number | null
    groupId: number | null
    _count: ServicegiftsbagCountAggregateOutputType | null
    _avg: ServicegiftsbagAvgAggregateOutputType | null
    _sum: ServicegiftsbagSumAggregateOutputType | null
    _min: ServicegiftsbagMinAggregateOutputType | null
    _max: ServicegiftsbagMaxAggregateOutputType | null
  }

  type GetServicegiftsbagGroupByPayload<T extends servicegiftsbagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicegiftsbagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicegiftsbagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicegiftsbagGroupByOutputType[P]>
            : GetScalarType<T[P], ServicegiftsbagGroupByOutputType[P]>
        }
      >
    >


  export type servicegiftsbagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recId?: boolean
    recUuid?: boolean
    userId?: boolean
    userName?: boolean
    createDate?: boolean
    expDate?: boolean
    sourceType?: boolean
    serviceId?: boolean
    serviceName?: boolean
    servicePrice?: boolean
    serviceImg?: boolean
    status?: boolean
    requestDate?: boolean
    acceptDate?: boolean
    sign?: boolean
    staffId?: boolean
    staffName?: boolean
    transId?: boolean
    serialId?: boolean
    ymd?: boolean
    totalDay?: boolean
    groupId?: boolean
  }, ExtArgs["result"]["servicegiftsbag"]>


  export type servicegiftsbagSelectScalar = {
    recId?: boolean
    recUuid?: boolean
    userId?: boolean
    userName?: boolean
    createDate?: boolean
    expDate?: boolean
    sourceType?: boolean
    serviceId?: boolean
    serviceName?: boolean
    servicePrice?: boolean
    serviceImg?: boolean
    status?: boolean
    requestDate?: boolean
    acceptDate?: boolean
    sign?: boolean
    staffId?: boolean
    staffName?: boolean
    transId?: boolean
    serialId?: boolean
    ymd?: boolean
    totalDay?: boolean
    groupId?: boolean
  }


  export type $servicegiftsbagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "servicegiftsbag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      recId: bigint
      recUuid: string
      userId: string | null
      userName: string | null
      createDate: Date | null
      expDate: Date | null
      sourceType: number | null
      serviceId: number | null
      serviceName: string | null
      servicePrice: number | null
      serviceImg: string | null
      status: number | null
      requestDate: Date | null
      acceptDate: Date | null
      sign: string | null
      staffId: number | null
      staffName: string | null
      transId: string | null
      serialId: string | null
      ymd: number | null
      totalDay: number | null
      groupId: number | null
    }, ExtArgs["result"]["servicegiftsbag"]>
    composites: {}
  }

  type servicegiftsbagGetPayload<S extends boolean | null | undefined | servicegiftsbagDefaultArgs> = $Result.GetResult<Prisma.$servicegiftsbagPayload, S>

  type servicegiftsbagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<servicegiftsbagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicegiftsbagCountAggregateInputType | true
    }

  export interface servicegiftsbagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicegiftsbag'], meta: { name: 'servicegiftsbag' } }
    /**
     * Find zero or one Servicegiftsbag that matches the filter.
     * @param {servicegiftsbagFindUniqueArgs} args - Arguments to find a Servicegiftsbag
     * @example
     * // Get one Servicegiftsbag
     * const servicegiftsbag = await prisma.servicegiftsbag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends servicegiftsbagFindUniqueArgs>(args: SelectSubset<T, servicegiftsbagFindUniqueArgs<ExtArgs>>): Prisma__servicegiftsbagClient<$Result.GetResult<Prisma.$servicegiftsbagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicegiftsbag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {servicegiftsbagFindUniqueOrThrowArgs} args - Arguments to find a Servicegiftsbag
     * @example
     * // Get one Servicegiftsbag
     * const servicegiftsbag = await prisma.servicegiftsbag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends servicegiftsbagFindUniqueOrThrowArgs>(args: SelectSubset<T, servicegiftsbagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__servicegiftsbagClient<$Result.GetResult<Prisma.$servicegiftsbagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicegiftsbag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegiftsbagFindFirstArgs} args - Arguments to find a Servicegiftsbag
     * @example
     * // Get one Servicegiftsbag
     * const servicegiftsbag = await prisma.servicegiftsbag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends servicegiftsbagFindFirstArgs>(args?: SelectSubset<T, servicegiftsbagFindFirstArgs<ExtArgs>>): Prisma__servicegiftsbagClient<$Result.GetResult<Prisma.$servicegiftsbagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicegiftsbag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegiftsbagFindFirstOrThrowArgs} args - Arguments to find a Servicegiftsbag
     * @example
     * // Get one Servicegiftsbag
     * const servicegiftsbag = await prisma.servicegiftsbag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends servicegiftsbagFindFirstOrThrowArgs>(args?: SelectSubset<T, servicegiftsbagFindFirstOrThrowArgs<ExtArgs>>): Prisma__servicegiftsbagClient<$Result.GetResult<Prisma.$servicegiftsbagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicegiftsbags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegiftsbagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicegiftsbags
     * const servicegiftsbags = await prisma.servicegiftsbag.findMany()
     * 
     * // Get first 10 Servicegiftsbags
     * const servicegiftsbags = await prisma.servicegiftsbag.findMany({ take: 10 })
     * 
     * // Only select the `recId`
     * const servicegiftsbagWithRecIdOnly = await prisma.servicegiftsbag.findMany({ select: { recId: true } })
     * 
     */
    findMany<T extends servicegiftsbagFindManyArgs>(args?: SelectSubset<T, servicegiftsbagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicegiftsbagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicegiftsbag.
     * @param {servicegiftsbagCreateArgs} args - Arguments to create a Servicegiftsbag.
     * @example
     * // Create one Servicegiftsbag
     * const Servicegiftsbag = await prisma.servicegiftsbag.create({
     *   data: {
     *     // ... data to create a Servicegiftsbag
     *   }
     * })
     * 
     */
    create<T extends servicegiftsbagCreateArgs>(args: SelectSubset<T, servicegiftsbagCreateArgs<ExtArgs>>): Prisma__servicegiftsbagClient<$Result.GetResult<Prisma.$servicegiftsbagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicegiftsbags.
     * @param {servicegiftsbagCreateManyArgs} args - Arguments to create many Servicegiftsbags.
     * @example
     * // Create many Servicegiftsbags
     * const servicegiftsbag = await prisma.servicegiftsbag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends servicegiftsbagCreateManyArgs>(args?: SelectSubset<T, servicegiftsbagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicegiftsbag.
     * @param {servicegiftsbagDeleteArgs} args - Arguments to delete one Servicegiftsbag.
     * @example
     * // Delete one Servicegiftsbag
     * const Servicegiftsbag = await prisma.servicegiftsbag.delete({
     *   where: {
     *     // ... filter to delete one Servicegiftsbag
     *   }
     * })
     * 
     */
    delete<T extends servicegiftsbagDeleteArgs>(args: SelectSubset<T, servicegiftsbagDeleteArgs<ExtArgs>>): Prisma__servicegiftsbagClient<$Result.GetResult<Prisma.$servicegiftsbagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicegiftsbag.
     * @param {servicegiftsbagUpdateArgs} args - Arguments to update one Servicegiftsbag.
     * @example
     * // Update one Servicegiftsbag
     * const servicegiftsbag = await prisma.servicegiftsbag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends servicegiftsbagUpdateArgs>(args: SelectSubset<T, servicegiftsbagUpdateArgs<ExtArgs>>): Prisma__servicegiftsbagClient<$Result.GetResult<Prisma.$servicegiftsbagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicegiftsbags.
     * @param {servicegiftsbagDeleteManyArgs} args - Arguments to filter Servicegiftsbags to delete.
     * @example
     * // Delete a few Servicegiftsbags
     * const { count } = await prisma.servicegiftsbag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends servicegiftsbagDeleteManyArgs>(args?: SelectSubset<T, servicegiftsbagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicegiftsbags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegiftsbagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicegiftsbags
     * const servicegiftsbag = await prisma.servicegiftsbag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends servicegiftsbagUpdateManyArgs>(args: SelectSubset<T, servicegiftsbagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicegiftsbag.
     * @param {servicegiftsbagUpsertArgs} args - Arguments to update or create a Servicegiftsbag.
     * @example
     * // Update or create a Servicegiftsbag
     * const servicegiftsbag = await prisma.servicegiftsbag.upsert({
     *   create: {
     *     // ... data to create a Servicegiftsbag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicegiftsbag we want to update
     *   }
     * })
     */
    upsert<T extends servicegiftsbagUpsertArgs>(args: SelectSubset<T, servicegiftsbagUpsertArgs<ExtArgs>>): Prisma__servicegiftsbagClient<$Result.GetResult<Prisma.$servicegiftsbagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicegiftsbags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegiftsbagCountArgs} args - Arguments to filter Servicegiftsbags to count.
     * @example
     * // Count the number of Servicegiftsbags
     * const count = await prisma.servicegiftsbag.count({
     *   where: {
     *     // ... the filter for the Servicegiftsbags we want to count
     *   }
     * })
    **/
    count<T extends servicegiftsbagCountArgs>(
      args?: Subset<T, servicegiftsbagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicegiftsbagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicegiftsbag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicegiftsbagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicegiftsbagAggregateArgs>(args: Subset<T, ServicegiftsbagAggregateArgs>): Prisma.PrismaPromise<GetServicegiftsbagAggregateType<T>>

    /**
     * Group by Servicegiftsbag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegiftsbagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicegiftsbagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicegiftsbagGroupByArgs['orderBy'] }
        : { orderBy?: servicegiftsbagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicegiftsbagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicegiftsbagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the servicegiftsbag model
   */
  readonly fields: servicegiftsbagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicegiftsbag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicegiftsbagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the servicegiftsbag model
   */ 
  interface servicegiftsbagFieldRefs {
    readonly recId: FieldRef<"servicegiftsbag", 'BigInt'>
    readonly recUuid: FieldRef<"servicegiftsbag", 'String'>
    readonly userId: FieldRef<"servicegiftsbag", 'String'>
    readonly userName: FieldRef<"servicegiftsbag", 'String'>
    readonly createDate: FieldRef<"servicegiftsbag", 'DateTime'>
    readonly expDate: FieldRef<"servicegiftsbag", 'DateTime'>
    readonly sourceType: FieldRef<"servicegiftsbag", 'Int'>
    readonly serviceId: FieldRef<"servicegiftsbag", 'Int'>
    readonly serviceName: FieldRef<"servicegiftsbag", 'String'>
    readonly servicePrice: FieldRef<"servicegiftsbag", 'Int'>
    readonly serviceImg: FieldRef<"servicegiftsbag", 'String'>
    readonly status: FieldRef<"servicegiftsbag", 'Int'>
    readonly requestDate: FieldRef<"servicegiftsbag", 'DateTime'>
    readonly acceptDate: FieldRef<"servicegiftsbag", 'DateTime'>
    readonly sign: FieldRef<"servicegiftsbag", 'String'>
    readonly staffId: FieldRef<"servicegiftsbag", 'Int'>
    readonly staffName: FieldRef<"servicegiftsbag", 'String'>
    readonly transId: FieldRef<"servicegiftsbag", 'String'>
    readonly serialId: FieldRef<"servicegiftsbag", 'String'>
    readonly ymd: FieldRef<"servicegiftsbag", 'Int'>
    readonly totalDay: FieldRef<"servicegiftsbag", 'Int'>
    readonly groupId: FieldRef<"servicegiftsbag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * servicegiftsbag findUnique
   */
  export type servicegiftsbagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
    /**
     * Filter, which servicegiftsbag to fetch.
     */
    where: servicegiftsbagWhereUniqueInput
  }

  /**
   * servicegiftsbag findUniqueOrThrow
   */
  export type servicegiftsbagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
    /**
     * Filter, which servicegiftsbag to fetch.
     */
    where: servicegiftsbagWhereUniqueInput
  }

  /**
   * servicegiftsbag findFirst
   */
  export type servicegiftsbagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
    /**
     * Filter, which servicegiftsbag to fetch.
     */
    where?: servicegiftsbagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicegiftsbags to fetch.
     */
    orderBy?: servicegiftsbagOrderByWithRelationInput | servicegiftsbagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicegiftsbags.
     */
    cursor?: servicegiftsbagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicegiftsbags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicegiftsbags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicegiftsbags.
     */
    distinct?: ServicegiftsbagScalarFieldEnum | ServicegiftsbagScalarFieldEnum[]
  }

  /**
   * servicegiftsbag findFirstOrThrow
   */
  export type servicegiftsbagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
    /**
     * Filter, which servicegiftsbag to fetch.
     */
    where?: servicegiftsbagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicegiftsbags to fetch.
     */
    orderBy?: servicegiftsbagOrderByWithRelationInput | servicegiftsbagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicegiftsbags.
     */
    cursor?: servicegiftsbagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicegiftsbags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicegiftsbags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicegiftsbags.
     */
    distinct?: ServicegiftsbagScalarFieldEnum | ServicegiftsbagScalarFieldEnum[]
  }

  /**
   * servicegiftsbag findMany
   */
  export type servicegiftsbagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
    /**
     * Filter, which servicegiftsbags to fetch.
     */
    where?: servicegiftsbagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicegiftsbags to fetch.
     */
    orderBy?: servicegiftsbagOrderByWithRelationInput | servicegiftsbagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicegiftsbags.
     */
    cursor?: servicegiftsbagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicegiftsbags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicegiftsbags.
     */
    skip?: number
    distinct?: ServicegiftsbagScalarFieldEnum | ServicegiftsbagScalarFieldEnum[]
  }

  /**
   * servicegiftsbag create
   */
  export type servicegiftsbagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
    /**
     * The data needed to create a servicegiftsbag.
     */
    data: XOR<servicegiftsbagCreateInput, servicegiftsbagUncheckedCreateInput>
  }

  /**
   * servicegiftsbag createMany
   */
  export type servicegiftsbagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicegiftsbags.
     */
    data: servicegiftsbagCreateManyInput | servicegiftsbagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * servicegiftsbag update
   */
  export type servicegiftsbagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
    /**
     * The data needed to update a servicegiftsbag.
     */
    data: XOR<servicegiftsbagUpdateInput, servicegiftsbagUncheckedUpdateInput>
    /**
     * Choose, which servicegiftsbag to update.
     */
    where: servicegiftsbagWhereUniqueInput
  }

  /**
   * servicegiftsbag updateMany
   */
  export type servicegiftsbagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicegiftsbags.
     */
    data: XOR<servicegiftsbagUpdateManyMutationInput, servicegiftsbagUncheckedUpdateManyInput>
    /**
     * Filter which servicegiftsbags to update
     */
    where?: servicegiftsbagWhereInput
  }

  /**
   * servicegiftsbag upsert
   */
  export type servicegiftsbagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
    /**
     * The filter to search for the servicegiftsbag to update in case it exists.
     */
    where: servicegiftsbagWhereUniqueInput
    /**
     * In case the servicegiftsbag found by the `where` argument doesn't exist, create a new servicegiftsbag with this data.
     */
    create: XOR<servicegiftsbagCreateInput, servicegiftsbagUncheckedCreateInput>
    /**
     * In case the servicegiftsbag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicegiftsbagUpdateInput, servicegiftsbagUncheckedUpdateInput>
  }

  /**
   * servicegiftsbag delete
   */
  export type servicegiftsbagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
    /**
     * Filter which servicegiftsbag to delete.
     */
    where: servicegiftsbagWhereUniqueInput
  }

  /**
   * servicegiftsbag deleteMany
   */
  export type servicegiftsbagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicegiftsbags to delete
     */
    where?: servicegiftsbagWhereInput
  }

  /**
   * servicegiftsbag without action
   */
  export type servicegiftsbagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegiftsbag
     */
    select?: servicegiftsbagSelect<ExtArgs> | null
  }


  /**
   * Model servicegrouptb
   */

  export type AggregateServicegrouptb = {
    _count: ServicegrouptbCountAggregateOutputType | null
    _avg: ServicegrouptbAvgAggregateOutputType | null
    _sum: ServicegrouptbSumAggregateOutputType | null
    _min: ServicegrouptbMinAggregateOutputType | null
    _max: ServicegrouptbMaxAggregateOutputType | null
  }

  export type ServicegrouptbAvgAggregateOutputType = {
    ID: number | null
    IsOrder: number | null
    Active: number | null
    TypeID: number | null
  }

  export type ServicegrouptbSumAggregateOutputType = {
    ID: number | null
    IsOrder: number | null
    Active: number | null
    TypeID: number | null
  }

  export type ServicegrouptbMinAggregateOutputType = {
    ID: number | null
    ServiceGroupName: string | null
    IsOrder: number | null
    Active: number | null
    TypeID: number | null
  }

  export type ServicegrouptbMaxAggregateOutputType = {
    ID: number | null
    ServiceGroupName: string | null
    IsOrder: number | null
    Active: number | null
    TypeID: number | null
  }

  export type ServicegrouptbCountAggregateOutputType = {
    ID: number
    ServiceGroupName: number
    IsOrder: number
    Active: number
    TypeID: number
    _all: number
  }


  export type ServicegrouptbAvgAggregateInputType = {
    ID?: true
    IsOrder?: true
    Active?: true
    TypeID?: true
  }

  export type ServicegrouptbSumAggregateInputType = {
    ID?: true
    IsOrder?: true
    Active?: true
    TypeID?: true
  }

  export type ServicegrouptbMinAggregateInputType = {
    ID?: true
    ServiceGroupName?: true
    IsOrder?: true
    Active?: true
    TypeID?: true
  }

  export type ServicegrouptbMaxAggregateInputType = {
    ID?: true
    ServiceGroupName?: true
    IsOrder?: true
    Active?: true
    TypeID?: true
  }

  export type ServicegrouptbCountAggregateInputType = {
    ID?: true
    ServiceGroupName?: true
    IsOrder?: true
    Active?: true
    TypeID?: true
    _all?: true
  }

  export type ServicegrouptbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicegrouptb to aggregate.
     */
    where?: servicegrouptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicegrouptbs to fetch.
     */
    orderBy?: servicegrouptbOrderByWithRelationInput | servicegrouptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicegrouptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicegrouptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicegrouptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicegrouptbs
    **/
    _count?: true | ServicegrouptbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicegrouptbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicegrouptbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicegrouptbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicegrouptbMaxAggregateInputType
  }

  export type GetServicegrouptbAggregateType<T extends ServicegrouptbAggregateArgs> = {
        [P in keyof T & keyof AggregateServicegrouptb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicegrouptb[P]>
      : GetScalarType<T[P], AggregateServicegrouptb[P]>
  }




  export type servicegrouptbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicegrouptbWhereInput
    orderBy?: servicegrouptbOrderByWithAggregationInput | servicegrouptbOrderByWithAggregationInput[]
    by: ServicegrouptbScalarFieldEnum[] | ServicegrouptbScalarFieldEnum
    having?: servicegrouptbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicegrouptbCountAggregateInputType | true
    _avg?: ServicegrouptbAvgAggregateInputType
    _sum?: ServicegrouptbSumAggregateInputType
    _min?: ServicegrouptbMinAggregateInputType
    _max?: ServicegrouptbMaxAggregateInputType
  }

  export type ServicegrouptbGroupByOutputType = {
    ID: number
    ServiceGroupName: string
    IsOrder: number
    Active: number | null
    TypeID: number
    _count: ServicegrouptbCountAggregateOutputType | null
    _avg: ServicegrouptbAvgAggregateOutputType | null
    _sum: ServicegrouptbSumAggregateOutputType | null
    _min: ServicegrouptbMinAggregateOutputType | null
    _max: ServicegrouptbMaxAggregateOutputType | null
  }

  type GetServicegrouptbGroupByPayload<T extends servicegrouptbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicegrouptbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicegrouptbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicegrouptbGroupByOutputType[P]>
            : GetScalarType<T[P], ServicegrouptbGroupByOutputType[P]>
        }
      >
    >


  export type servicegrouptbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    ServiceGroupName?: boolean
    IsOrder?: boolean
    Active?: boolean
    TypeID?: boolean
  }, ExtArgs["result"]["servicegrouptb"]>


  export type servicegrouptbSelectScalar = {
    ID?: boolean
    ServiceGroupName?: boolean
    IsOrder?: boolean
    Active?: boolean
    TypeID?: boolean
  }


  export type $servicegrouptbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "servicegrouptb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      ServiceGroupName: string
      IsOrder: number
      Active: number | null
      TypeID: number
    }, ExtArgs["result"]["servicegrouptb"]>
    composites: {}
  }

  type servicegrouptbGetPayload<S extends boolean | null | undefined | servicegrouptbDefaultArgs> = $Result.GetResult<Prisma.$servicegrouptbPayload, S>

  type servicegrouptbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<servicegrouptbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicegrouptbCountAggregateInputType | true
    }

  export interface servicegrouptbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicegrouptb'], meta: { name: 'servicegrouptb' } }
    /**
     * Find zero or one Servicegrouptb that matches the filter.
     * @param {servicegrouptbFindUniqueArgs} args - Arguments to find a Servicegrouptb
     * @example
     * // Get one Servicegrouptb
     * const servicegrouptb = await prisma.servicegrouptb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends servicegrouptbFindUniqueArgs>(args: SelectSubset<T, servicegrouptbFindUniqueArgs<ExtArgs>>): Prisma__servicegrouptbClient<$Result.GetResult<Prisma.$servicegrouptbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicegrouptb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {servicegrouptbFindUniqueOrThrowArgs} args - Arguments to find a Servicegrouptb
     * @example
     * // Get one Servicegrouptb
     * const servicegrouptb = await prisma.servicegrouptb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends servicegrouptbFindUniqueOrThrowArgs>(args: SelectSubset<T, servicegrouptbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__servicegrouptbClient<$Result.GetResult<Prisma.$servicegrouptbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicegrouptb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegrouptbFindFirstArgs} args - Arguments to find a Servicegrouptb
     * @example
     * // Get one Servicegrouptb
     * const servicegrouptb = await prisma.servicegrouptb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends servicegrouptbFindFirstArgs>(args?: SelectSubset<T, servicegrouptbFindFirstArgs<ExtArgs>>): Prisma__servicegrouptbClient<$Result.GetResult<Prisma.$servicegrouptbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicegrouptb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegrouptbFindFirstOrThrowArgs} args - Arguments to find a Servicegrouptb
     * @example
     * // Get one Servicegrouptb
     * const servicegrouptb = await prisma.servicegrouptb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends servicegrouptbFindFirstOrThrowArgs>(args?: SelectSubset<T, servicegrouptbFindFirstOrThrowArgs<ExtArgs>>): Prisma__servicegrouptbClient<$Result.GetResult<Prisma.$servicegrouptbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicegrouptbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegrouptbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicegrouptbs
     * const servicegrouptbs = await prisma.servicegrouptb.findMany()
     * 
     * // Get first 10 Servicegrouptbs
     * const servicegrouptbs = await prisma.servicegrouptb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const servicegrouptbWithIDOnly = await prisma.servicegrouptb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends servicegrouptbFindManyArgs>(args?: SelectSubset<T, servicegrouptbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicegrouptbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicegrouptb.
     * @param {servicegrouptbCreateArgs} args - Arguments to create a Servicegrouptb.
     * @example
     * // Create one Servicegrouptb
     * const Servicegrouptb = await prisma.servicegrouptb.create({
     *   data: {
     *     // ... data to create a Servicegrouptb
     *   }
     * })
     * 
     */
    create<T extends servicegrouptbCreateArgs>(args: SelectSubset<T, servicegrouptbCreateArgs<ExtArgs>>): Prisma__servicegrouptbClient<$Result.GetResult<Prisma.$servicegrouptbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicegrouptbs.
     * @param {servicegrouptbCreateManyArgs} args - Arguments to create many Servicegrouptbs.
     * @example
     * // Create many Servicegrouptbs
     * const servicegrouptb = await prisma.servicegrouptb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends servicegrouptbCreateManyArgs>(args?: SelectSubset<T, servicegrouptbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicegrouptb.
     * @param {servicegrouptbDeleteArgs} args - Arguments to delete one Servicegrouptb.
     * @example
     * // Delete one Servicegrouptb
     * const Servicegrouptb = await prisma.servicegrouptb.delete({
     *   where: {
     *     // ... filter to delete one Servicegrouptb
     *   }
     * })
     * 
     */
    delete<T extends servicegrouptbDeleteArgs>(args: SelectSubset<T, servicegrouptbDeleteArgs<ExtArgs>>): Prisma__servicegrouptbClient<$Result.GetResult<Prisma.$servicegrouptbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicegrouptb.
     * @param {servicegrouptbUpdateArgs} args - Arguments to update one Servicegrouptb.
     * @example
     * // Update one Servicegrouptb
     * const servicegrouptb = await prisma.servicegrouptb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends servicegrouptbUpdateArgs>(args: SelectSubset<T, servicegrouptbUpdateArgs<ExtArgs>>): Prisma__servicegrouptbClient<$Result.GetResult<Prisma.$servicegrouptbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicegrouptbs.
     * @param {servicegrouptbDeleteManyArgs} args - Arguments to filter Servicegrouptbs to delete.
     * @example
     * // Delete a few Servicegrouptbs
     * const { count } = await prisma.servicegrouptb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends servicegrouptbDeleteManyArgs>(args?: SelectSubset<T, servicegrouptbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicegrouptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegrouptbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicegrouptbs
     * const servicegrouptb = await prisma.servicegrouptb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends servicegrouptbUpdateManyArgs>(args: SelectSubset<T, servicegrouptbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicegrouptb.
     * @param {servicegrouptbUpsertArgs} args - Arguments to update or create a Servicegrouptb.
     * @example
     * // Update or create a Servicegrouptb
     * const servicegrouptb = await prisma.servicegrouptb.upsert({
     *   create: {
     *     // ... data to create a Servicegrouptb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicegrouptb we want to update
     *   }
     * })
     */
    upsert<T extends servicegrouptbUpsertArgs>(args: SelectSubset<T, servicegrouptbUpsertArgs<ExtArgs>>): Prisma__servicegrouptbClient<$Result.GetResult<Prisma.$servicegrouptbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicegrouptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegrouptbCountArgs} args - Arguments to filter Servicegrouptbs to count.
     * @example
     * // Count the number of Servicegrouptbs
     * const count = await prisma.servicegrouptb.count({
     *   where: {
     *     // ... the filter for the Servicegrouptbs we want to count
     *   }
     * })
    **/
    count<T extends servicegrouptbCountArgs>(
      args?: Subset<T, servicegrouptbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicegrouptbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicegrouptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicegrouptbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicegrouptbAggregateArgs>(args: Subset<T, ServicegrouptbAggregateArgs>): Prisma.PrismaPromise<GetServicegrouptbAggregateType<T>>

    /**
     * Group by Servicegrouptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicegrouptbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicegrouptbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicegrouptbGroupByArgs['orderBy'] }
        : { orderBy?: servicegrouptbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicegrouptbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicegrouptbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the servicegrouptb model
   */
  readonly fields: servicegrouptbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicegrouptb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicegrouptbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the servicegrouptb model
   */ 
  interface servicegrouptbFieldRefs {
    readonly ID: FieldRef<"servicegrouptb", 'Int'>
    readonly ServiceGroupName: FieldRef<"servicegrouptb", 'String'>
    readonly IsOrder: FieldRef<"servicegrouptb", 'Int'>
    readonly Active: FieldRef<"servicegrouptb", 'Int'>
    readonly TypeID: FieldRef<"servicegrouptb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * servicegrouptb findUnique
   */
  export type servicegrouptbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which servicegrouptb to fetch.
     */
    where: servicegrouptbWhereUniqueInput
  }

  /**
   * servicegrouptb findUniqueOrThrow
   */
  export type servicegrouptbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which servicegrouptb to fetch.
     */
    where: servicegrouptbWhereUniqueInput
  }

  /**
   * servicegrouptb findFirst
   */
  export type servicegrouptbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which servicegrouptb to fetch.
     */
    where?: servicegrouptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicegrouptbs to fetch.
     */
    orderBy?: servicegrouptbOrderByWithRelationInput | servicegrouptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicegrouptbs.
     */
    cursor?: servicegrouptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicegrouptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicegrouptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicegrouptbs.
     */
    distinct?: ServicegrouptbScalarFieldEnum | ServicegrouptbScalarFieldEnum[]
  }

  /**
   * servicegrouptb findFirstOrThrow
   */
  export type servicegrouptbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which servicegrouptb to fetch.
     */
    where?: servicegrouptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicegrouptbs to fetch.
     */
    orderBy?: servicegrouptbOrderByWithRelationInput | servicegrouptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicegrouptbs.
     */
    cursor?: servicegrouptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicegrouptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicegrouptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicegrouptbs.
     */
    distinct?: ServicegrouptbScalarFieldEnum | ServicegrouptbScalarFieldEnum[]
  }

  /**
   * servicegrouptb findMany
   */
  export type servicegrouptbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
    /**
     * Filter, which servicegrouptbs to fetch.
     */
    where?: servicegrouptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicegrouptbs to fetch.
     */
    orderBy?: servicegrouptbOrderByWithRelationInput | servicegrouptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicegrouptbs.
     */
    cursor?: servicegrouptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicegrouptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicegrouptbs.
     */
    skip?: number
    distinct?: ServicegrouptbScalarFieldEnum | ServicegrouptbScalarFieldEnum[]
  }

  /**
   * servicegrouptb create
   */
  export type servicegrouptbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
    /**
     * The data needed to create a servicegrouptb.
     */
    data?: XOR<servicegrouptbCreateInput, servicegrouptbUncheckedCreateInput>
  }

  /**
   * servicegrouptb createMany
   */
  export type servicegrouptbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicegrouptbs.
     */
    data: servicegrouptbCreateManyInput | servicegrouptbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * servicegrouptb update
   */
  export type servicegrouptbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
    /**
     * The data needed to update a servicegrouptb.
     */
    data: XOR<servicegrouptbUpdateInput, servicegrouptbUncheckedUpdateInput>
    /**
     * Choose, which servicegrouptb to update.
     */
    where: servicegrouptbWhereUniqueInput
  }

  /**
   * servicegrouptb updateMany
   */
  export type servicegrouptbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicegrouptbs.
     */
    data: XOR<servicegrouptbUpdateManyMutationInput, servicegrouptbUncheckedUpdateManyInput>
    /**
     * Filter which servicegrouptbs to update
     */
    where?: servicegrouptbWhereInput
  }

  /**
   * servicegrouptb upsert
   */
  export type servicegrouptbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
    /**
     * The filter to search for the servicegrouptb to update in case it exists.
     */
    where: servicegrouptbWhereUniqueInput
    /**
     * In case the servicegrouptb found by the `where` argument doesn't exist, create a new servicegrouptb with this data.
     */
    create: XOR<servicegrouptbCreateInput, servicegrouptbUncheckedCreateInput>
    /**
     * In case the servicegrouptb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicegrouptbUpdateInput, servicegrouptbUncheckedUpdateInput>
  }

  /**
   * servicegrouptb delete
   */
  export type servicegrouptbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
    /**
     * Filter which servicegrouptb to delete.
     */
    where: servicegrouptbWhereUniqueInput
  }

  /**
   * servicegrouptb deleteMany
   */
  export type servicegrouptbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicegrouptbs to delete
     */
    where?: servicegrouptbWhereInput
  }

  /**
   * servicegrouptb without action
   */
  export type servicegrouptbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicegrouptb
     */
    select?: servicegrouptbSelect<ExtArgs> | null
  }


  /**
   * Model serviceinfologtb
   */

  export type AggregateServiceinfologtb = {
    _count: ServiceinfologtbCountAggregateOutputType | null
    _avg: ServiceinfologtbAvgAggregateOutputType | null
    _sum: ServiceinfologtbSumAggregateOutputType | null
    _min: ServiceinfologtbMinAggregateOutputType | null
    _max: ServiceinfologtbMaxAggregateOutputType | null
  }

  export type ServiceinfologtbAvgAggregateOutputType = {
    logId: number | null
    serviceId: number | null
    status: number | null
    mode: number | null
  }

  export type ServiceinfologtbSumAggregateOutputType = {
    logId: number | null
    serviceId: number | null
    status: number | null
    mode: number | null
  }

  export type ServiceinfologtbMinAggregateOutputType = {
    logId: number | null
    serviceId: number | null
    prefix: string | null
    info: string | null
    status: number | null
    createDate: Date | null
    mode: number | null
    hash: string | null
  }

  export type ServiceinfologtbMaxAggregateOutputType = {
    logId: number | null
    serviceId: number | null
    prefix: string | null
    info: string | null
    status: number | null
    createDate: Date | null
    mode: number | null
    hash: string | null
  }

  export type ServiceinfologtbCountAggregateOutputType = {
    logId: number
    serviceId: number
    prefix: number
    info: number
    status: number
    createDate: number
    mode: number
    hash: number
    _all: number
  }


  export type ServiceinfologtbAvgAggregateInputType = {
    logId?: true
    serviceId?: true
    status?: true
    mode?: true
  }

  export type ServiceinfologtbSumAggregateInputType = {
    logId?: true
    serviceId?: true
    status?: true
    mode?: true
  }

  export type ServiceinfologtbMinAggregateInputType = {
    logId?: true
    serviceId?: true
    prefix?: true
    info?: true
    status?: true
    createDate?: true
    mode?: true
    hash?: true
  }

  export type ServiceinfologtbMaxAggregateInputType = {
    logId?: true
    serviceId?: true
    prefix?: true
    info?: true
    status?: true
    createDate?: true
    mode?: true
    hash?: true
  }

  export type ServiceinfologtbCountAggregateInputType = {
    logId?: true
    serviceId?: true
    prefix?: true
    info?: true
    status?: true
    createDate?: true
    mode?: true
    hash?: true
    _all?: true
  }

  export type ServiceinfologtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceinfologtb to aggregate.
     */
    where?: serviceinfologtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceinfologtbs to fetch.
     */
    orderBy?: serviceinfologtbOrderByWithRelationInput | serviceinfologtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceinfologtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceinfologtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceinfologtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serviceinfologtbs
    **/
    _count?: true | ServiceinfologtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceinfologtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceinfologtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceinfologtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceinfologtbMaxAggregateInputType
  }

  export type GetServiceinfologtbAggregateType<T extends ServiceinfologtbAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceinfologtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceinfologtb[P]>
      : GetScalarType<T[P], AggregateServiceinfologtb[P]>
  }




  export type serviceinfologtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceinfologtbWhereInput
    orderBy?: serviceinfologtbOrderByWithAggregationInput | serviceinfologtbOrderByWithAggregationInput[]
    by: ServiceinfologtbScalarFieldEnum[] | ServiceinfologtbScalarFieldEnum
    having?: serviceinfologtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceinfologtbCountAggregateInputType | true
    _avg?: ServiceinfologtbAvgAggregateInputType
    _sum?: ServiceinfologtbSumAggregateInputType
    _min?: ServiceinfologtbMinAggregateInputType
    _max?: ServiceinfologtbMaxAggregateInputType
  }

  export type ServiceinfologtbGroupByOutputType = {
    logId: number
    serviceId: number | null
    prefix: string
    info: string | null
    status: number | null
    createDate: Date | null
    mode: number | null
    hash: string | null
    _count: ServiceinfologtbCountAggregateOutputType | null
    _avg: ServiceinfologtbAvgAggregateOutputType | null
    _sum: ServiceinfologtbSumAggregateOutputType | null
    _min: ServiceinfologtbMinAggregateOutputType | null
    _max: ServiceinfologtbMaxAggregateOutputType | null
  }

  type GetServiceinfologtbGroupByPayload<T extends serviceinfologtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceinfologtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceinfologtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceinfologtbGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceinfologtbGroupByOutputType[P]>
        }
      >
    >


  export type serviceinfologtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    logId?: boolean
    serviceId?: boolean
    prefix?: boolean
    info?: boolean
    status?: boolean
    createDate?: boolean
    mode?: boolean
    hash?: boolean
  }, ExtArgs["result"]["serviceinfologtb"]>


  export type serviceinfologtbSelectScalar = {
    logId?: boolean
    serviceId?: boolean
    prefix?: boolean
    info?: boolean
    status?: boolean
    createDate?: boolean
    mode?: boolean
    hash?: boolean
  }


  export type $serviceinfologtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serviceinfologtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      logId: number
      serviceId: number | null
      prefix: string
      info: string | null
      status: number | null
      createDate: Date | null
      mode: number | null
      hash: string | null
    }, ExtArgs["result"]["serviceinfologtb"]>
    composites: {}
  }

  type serviceinfologtbGetPayload<S extends boolean | null | undefined | serviceinfologtbDefaultArgs> = $Result.GetResult<Prisma.$serviceinfologtbPayload, S>

  type serviceinfologtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serviceinfologtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceinfologtbCountAggregateInputType | true
    }

  export interface serviceinfologtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serviceinfologtb'], meta: { name: 'serviceinfologtb' } }
    /**
     * Find zero or one Serviceinfologtb that matches the filter.
     * @param {serviceinfologtbFindUniqueArgs} args - Arguments to find a Serviceinfologtb
     * @example
     * // Get one Serviceinfologtb
     * const serviceinfologtb = await prisma.serviceinfologtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceinfologtbFindUniqueArgs>(args: SelectSubset<T, serviceinfologtbFindUniqueArgs<ExtArgs>>): Prisma__serviceinfologtbClient<$Result.GetResult<Prisma.$serviceinfologtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Serviceinfologtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {serviceinfologtbFindUniqueOrThrowArgs} args - Arguments to find a Serviceinfologtb
     * @example
     * // Get one Serviceinfologtb
     * const serviceinfologtb = await prisma.serviceinfologtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceinfologtbFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceinfologtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceinfologtbClient<$Result.GetResult<Prisma.$serviceinfologtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Serviceinfologtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfologtbFindFirstArgs} args - Arguments to find a Serviceinfologtb
     * @example
     * // Get one Serviceinfologtb
     * const serviceinfologtb = await prisma.serviceinfologtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceinfologtbFindFirstArgs>(args?: SelectSubset<T, serviceinfologtbFindFirstArgs<ExtArgs>>): Prisma__serviceinfologtbClient<$Result.GetResult<Prisma.$serviceinfologtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Serviceinfologtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfologtbFindFirstOrThrowArgs} args - Arguments to find a Serviceinfologtb
     * @example
     * // Get one Serviceinfologtb
     * const serviceinfologtb = await prisma.serviceinfologtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceinfologtbFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceinfologtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceinfologtbClient<$Result.GetResult<Prisma.$serviceinfologtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Serviceinfologtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfologtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Serviceinfologtbs
     * const serviceinfologtbs = await prisma.serviceinfologtb.findMany()
     * 
     * // Get first 10 Serviceinfologtbs
     * const serviceinfologtbs = await prisma.serviceinfologtb.findMany({ take: 10 })
     * 
     * // Only select the `logId`
     * const serviceinfologtbWithLogIdOnly = await prisma.serviceinfologtb.findMany({ select: { logId: true } })
     * 
     */
    findMany<T extends serviceinfologtbFindManyArgs>(args?: SelectSubset<T, serviceinfologtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceinfologtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Serviceinfologtb.
     * @param {serviceinfologtbCreateArgs} args - Arguments to create a Serviceinfologtb.
     * @example
     * // Create one Serviceinfologtb
     * const Serviceinfologtb = await prisma.serviceinfologtb.create({
     *   data: {
     *     // ... data to create a Serviceinfologtb
     *   }
     * })
     * 
     */
    create<T extends serviceinfologtbCreateArgs>(args: SelectSubset<T, serviceinfologtbCreateArgs<ExtArgs>>): Prisma__serviceinfologtbClient<$Result.GetResult<Prisma.$serviceinfologtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Serviceinfologtbs.
     * @param {serviceinfologtbCreateManyArgs} args - Arguments to create many Serviceinfologtbs.
     * @example
     * // Create many Serviceinfologtbs
     * const serviceinfologtb = await prisma.serviceinfologtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceinfologtbCreateManyArgs>(args?: SelectSubset<T, serviceinfologtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Serviceinfologtb.
     * @param {serviceinfologtbDeleteArgs} args - Arguments to delete one Serviceinfologtb.
     * @example
     * // Delete one Serviceinfologtb
     * const Serviceinfologtb = await prisma.serviceinfologtb.delete({
     *   where: {
     *     // ... filter to delete one Serviceinfologtb
     *   }
     * })
     * 
     */
    delete<T extends serviceinfologtbDeleteArgs>(args: SelectSubset<T, serviceinfologtbDeleteArgs<ExtArgs>>): Prisma__serviceinfologtbClient<$Result.GetResult<Prisma.$serviceinfologtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Serviceinfologtb.
     * @param {serviceinfologtbUpdateArgs} args - Arguments to update one Serviceinfologtb.
     * @example
     * // Update one Serviceinfologtb
     * const serviceinfologtb = await prisma.serviceinfologtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceinfologtbUpdateArgs>(args: SelectSubset<T, serviceinfologtbUpdateArgs<ExtArgs>>): Prisma__serviceinfologtbClient<$Result.GetResult<Prisma.$serviceinfologtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Serviceinfologtbs.
     * @param {serviceinfologtbDeleteManyArgs} args - Arguments to filter Serviceinfologtbs to delete.
     * @example
     * // Delete a few Serviceinfologtbs
     * const { count } = await prisma.serviceinfologtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceinfologtbDeleteManyArgs>(args?: SelectSubset<T, serviceinfologtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Serviceinfologtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfologtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Serviceinfologtbs
     * const serviceinfologtb = await prisma.serviceinfologtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceinfologtbUpdateManyArgs>(args: SelectSubset<T, serviceinfologtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Serviceinfologtb.
     * @param {serviceinfologtbUpsertArgs} args - Arguments to update or create a Serviceinfologtb.
     * @example
     * // Update or create a Serviceinfologtb
     * const serviceinfologtb = await prisma.serviceinfologtb.upsert({
     *   create: {
     *     // ... data to create a Serviceinfologtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serviceinfologtb we want to update
     *   }
     * })
     */
    upsert<T extends serviceinfologtbUpsertArgs>(args: SelectSubset<T, serviceinfologtbUpsertArgs<ExtArgs>>): Prisma__serviceinfologtbClient<$Result.GetResult<Prisma.$serviceinfologtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Serviceinfologtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfologtbCountArgs} args - Arguments to filter Serviceinfologtbs to count.
     * @example
     * // Count the number of Serviceinfologtbs
     * const count = await prisma.serviceinfologtb.count({
     *   where: {
     *     // ... the filter for the Serviceinfologtbs we want to count
     *   }
     * })
    **/
    count<T extends serviceinfologtbCountArgs>(
      args?: Subset<T, serviceinfologtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceinfologtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serviceinfologtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceinfologtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceinfologtbAggregateArgs>(args: Subset<T, ServiceinfologtbAggregateArgs>): Prisma.PrismaPromise<GetServiceinfologtbAggregateType<T>>

    /**
     * Group by Serviceinfologtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfologtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceinfologtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceinfologtbGroupByArgs['orderBy'] }
        : { orderBy?: serviceinfologtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceinfologtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceinfologtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serviceinfologtb model
   */
  readonly fields: serviceinfologtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serviceinfologtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceinfologtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serviceinfologtb model
   */ 
  interface serviceinfologtbFieldRefs {
    readonly logId: FieldRef<"serviceinfologtb", 'Int'>
    readonly serviceId: FieldRef<"serviceinfologtb", 'Int'>
    readonly prefix: FieldRef<"serviceinfologtb", 'String'>
    readonly info: FieldRef<"serviceinfologtb", 'String'>
    readonly status: FieldRef<"serviceinfologtb", 'Int'>
    readonly createDate: FieldRef<"serviceinfologtb", 'DateTime'>
    readonly mode: FieldRef<"serviceinfologtb", 'Int'>
    readonly hash: FieldRef<"serviceinfologtb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * serviceinfologtb findUnique
   */
  export type serviceinfologtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfologtb to fetch.
     */
    where: serviceinfologtbWhereUniqueInput
  }

  /**
   * serviceinfologtb findUniqueOrThrow
   */
  export type serviceinfologtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfologtb to fetch.
     */
    where: serviceinfologtbWhereUniqueInput
  }

  /**
   * serviceinfologtb findFirst
   */
  export type serviceinfologtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfologtb to fetch.
     */
    where?: serviceinfologtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceinfologtbs to fetch.
     */
    orderBy?: serviceinfologtbOrderByWithRelationInput | serviceinfologtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceinfologtbs.
     */
    cursor?: serviceinfologtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceinfologtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceinfologtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceinfologtbs.
     */
    distinct?: ServiceinfologtbScalarFieldEnum | ServiceinfologtbScalarFieldEnum[]
  }

  /**
   * serviceinfologtb findFirstOrThrow
   */
  export type serviceinfologtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfologtb to fetch.
     */
    where?: serviceinfologtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceinfologtbs to fetch.
     */
    orderBy?: serviceinfologtbOrderByWithRelationInput | serviceinfologtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceinfologtbs.
     */
    cursor?: serviceinfologtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceinfologtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceinfologtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceinfologtbs.
     */
    distinct?: ServiceinfologtbScalarFieldEnum | ServiceinfologtbScalarFieldEnum[]
  }

  /**
   * serviceinfologtb findMany
   */
  export type serviceinfologtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfologtbs to fetch.
     */
    where?: serviceinfologtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceinfologtbs to fetch.
     */
    orderBy?: serviceinfologtbOrderByWithRelationInput | serviceinfologtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serviceinfologtbs.
     */
    cursor?: serviceinfologtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceinfologtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceinfologtbs.
     */
    skip?: number
    distinct?: ServiceinfologtbScalarFieldEnum | ServiceinfologtbScalarFieldEnum[]
  }

  /**
   * serviceinfologtb create
   */
  export type serviceinfologtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
    /**
     * The data needed to create a serviceinfologtb.
     */
    data: XOR<serviceinfologtbCreateInput, serviceinfologtbUncheckedCreateInput>
  }

  /**
   * serviceinfologtb createMany
   */
  export type serviceinfologtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serviceinfologtbs.
     */
    data: serviceinfologtbCreateManyInput | serviceinfologtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serviceinfologtb update
   */
  export type serviceinfologtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
    /**
     * The data needed to update a serviceinfologtb.
     */
    data: XOR<serviceinfologtbUpdateInput, serviceinfologtbUncheckedUpdateInput>
    /**
     * Choose, which serviceinfologtb to update.
     */
    where: serviceinfologtbWhereUniqueInput
  }

  /**
   * serviceinfologtb updateMany
   */
  export type serviceinfologtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serviceinfologtbs.
     */
    data: XOR<serviceinfologtbUpdateManyMutationInput, serviceinfologtbUncheckedUpdateManyInput>
    /**
     * Filter which serviceinfologtbs to update
     */
    where?: serviceinfologtbWhereInput
  }

  /**
   * serviceinfologtb upsert
   */
  export type serviceinfologtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
    /**
     * The filter to search for the serviceinfologtb to update in case it exists.
     */
    where: serviceinfologtbWhereUniqueInput
    /**
     * In case the serviceinfologtb found by the `where` argument doesn't exist, create a new serviceinfologtb with this data.
     */
    create: XOR<serviceinfologtbCreateInput, serviceinfologtbUncheckedCreateInput>
    /**
     * In case the serviceinfologtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceinfologtbUpdateInput, serviceinfologtbUncheckedUpdateInput>
  }

  /**
   * serviceinfologtb delete
   */
  export type serviceinfologtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
    /**
     * Filter which serviceinfologtb to delete.
     */
    where: serviceinfologtbWhereUniqueInput
  }

  /**
   * serviceinfologtb deleteMany
   */
  export type serviceinfologtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceinfologtbs to delete
     */
    where?: serviceinfologtbWhereInput
  }

  /**
   * serviceinfologtb without action
   */
  export type serviceinfologtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfologtb
     */
    select?: serviceinfologtbSelect<ExtArgs> | null
  }


  /**
   * Model serviceinfotb
   */

  export type AggregateServiceinfotb = {
    _count: ServiceinfotbCountAggregateOutputType | null
    _avg: ServiceinfotbAvgAggregateOutputType | null
    _sum: ServiceinfotbSumAggregateOutputType | null
    _min: ServiceinfotbMinAggregateOutputType | null
    _max: ServiceinfotbMaxAggregateOutputType | null
  }

  export type ServiceinfotbAvgAggregateOutputType = {
    serviceId: number | null
    status: number | null
    mode: number | null
  }

  export type ServiceinfotbSumAggregateOutputType = {
    serviceId: number | null
    status: number | null
    mode: number | null
  }

  export type ServiceinfotbMinAggregateOutputType = {
    serviceId: number | null
    prefix: string | null
    info: string | null
    status: number | null
    createDate: Date | null
    mode: number | null
    hash: string | null
  }

  export type ServiceinfotbMaxAggregateOutputType = {
    serviceId: number | null
    prefix: string | null
    info: string | null
    status: number | null
    createDate: Date | null
    mode: number | null
    hash: string | null
  }

  export type ServiceinfotbCountAggregateOutputType = {
    serviceId: number
    prefix: number
    info: number
    status: number
    createDate: number
    mode: number
    hash: number
    _all: number
  }


  export type ServiceinfotbAvgAggregateInputType = {
    serviceId?: true
    status?: true
    mode?: true
  }

  export type ServiceinfotbSumAggregateInputType = {
    serviceId?: true
    status?: true
    mode?: true
  }

  export type ServiceinfotbMinAggregateInputType = {
    serviceId?: true
    prefix?: true
    info?: true
    status?: true
    createDate?: true
    mode?: true
    hash?: true
  }

  export type ServiceinfotbMaxAggregateInputType = {
    serviceId?: true
    prefix?: true
    info?: true
    status?: true
    createDate?: true
    mode?: true
    hash?: true
  }

  export type ServiceinfotbCountAggregateInputType = {
    serviceId?: true
    prefix?: true
    info?: true
    status?: true
    createDate?: true
    mode?: true
    hash?: true
    _all?: true
  }

  export type ServiceinfotbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceinfotb to aggregate.
     */
    where?: serviceinfotbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceinfotbs to fetch.
     */
    orderBy?: serviceinfotbOrderByWithRelationInput | serviceinfotbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceinfotbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceinfotbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceinfotbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serviceinfotbs
    **/
    _count?: true | ServiceinfotbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceinfotbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceinfotbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceinfotbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceinfotbMaxAggregateInputType
  }

  export type GetServiceinfotbAggregateType<T extends ServiceinfotbAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceinfotb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceinfotb[P]>
      : GetScalarType<T[P], AggregateServiceinfotb[P]>
  }




  export type serviceinfotbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceinfotbWhereInput
    orderBy?: serviceinfotbOrderByWithAggregationInput | serviceinfotbOrderByWithAggregationInput[]
    by: ServiceinfotbScalarFieldEnum[] | ServiceinfotbScalarFieldEnum
    having?: serviceinfotbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceinfotbCountAggregateInputType | true
    _avg?: ServiceinfotbAvgAggregateInputType
    _sum?: ServiceinfotbSumAggregateInputType
    _min?: ServiceinfotbMinAggregateInputType
    _max?: ServiceinfotbMaxAggregateInputType
  }

  export type ServiceinfotbGroupByOutputType = {
    serviceId: number
    prefix: string
    info: string | null
    status: number | null
    createDate: Date | null
    mode: number | null
    hash: string | null
    _count: ServiceinfotbCountAggregateOutputType | null
    _avg: ServiceinfotbAvgAggregateOutputType | null
    _sum: ServiceinfotbSumAggregateOutputType | null
    _min: ServiceinfotbMinAggregateOutputType | null
    _max: ServiceinfotbMaxAggregateOutputType | null
  }

  type GetServiceinfotbGroupByPayload<T extends serviceinfotbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceinfotbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceinfotbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceinfotbGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceinfotbGroupByOutputType[P]>
        }
      >
    >


  export type serviceinfotbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    serviceId?: boolean
    prefix?: boolean
    info?: boolean
    status?: boolean
    createDate?: boolean
    mode?: boolean
    hash?: boolean
  }, ExtArgs["result"]["serviceinfotb"]>


  export type serviceinfotbSelectScalar = {
    serviceId?: boolean
    prefix?: boolean
    info?: boolean
    status?: boolean
    createDate?: boolean
    mode?: boolean
    hash?: boolean
  }


  export type $serviceinfotbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serviceinfotb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      serviceId: number
      prefix: string
      info: string | null
      status: number | null
      createDate: Date | null
      mode: number | null
      hash: string | null
    }, ExtArgs["result"]["serviceinfotb"]>
    composites: {}
  }

  type serviceinfotbGetPayload<S extends boolean | null | undefined | serviceinfotbDefaultArgs> = $Result.GetResult<Prisma.$serviceinfotbPayload, S>

  type serviceinfotbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serviceinfotbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceinfotbCountAggregateInputType | true
    }

  export interface serviceinfotbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serviceinfotb'], meta: { name: 'serviceinfotb' } }
    /**
     * Find zero or one Serviceinfotb that matches the filter.
     * @param {serviceinfotbFindUniqueArgs} args - Arguments to find a Serviceinfotb
     * @example
     * // Get one Serviceinfotb
     * const serviceinfotb = await prisma.serviceinfotb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceinfotbFindUniqueArgs>(args: SelectSubset<T, serviceinfotbFindUniqueArgs<ExtArgs>>): Prisma__serviceinfotbClient<$Result.GetResult<Prisma.$serviceinfotbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Serviceinfotb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {serviceinfotbFindUniqueOrThrowArgs} args - Arguments to find a Serviceinfotb
     * @example
     * // Get one Serviceinfotb
     * const serviceinfotb = await prisma.serviceinfotb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceinfotbFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceinfotbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceinfotbClient<$Result.GetResult<Prisma.$serviceinfotbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Serviceinfotb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfotbFindFirstArgs} args - Arguments to find a Serviceinfotb
     * @example
     * // Get one Serviceinfotb
     * const serviceinfotb = await prisma.serviceinfotb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceinfotbFindFirstArgs>(args?: SelectSubset<T, serviceinfotbFindFirstArgs<ExtArgs>>): Prisma__serviceinfotbClient<$Result.GetResult<Prisma.$serviceinfotbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Serviceinfotb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfotbFindFirstOrThrowArgs} args - Arguments to find a Serviceinfotb
     * @example
     * // Get one Serviceinfotb
     * const serviceinfotb = await prisma.serviceinfotb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceinfotbFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceinfotbFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceinfotbClient<$Result.GetResult<Prisma.$serviceinfotbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Serviceinfotbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfotbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Serviceinfotbs
     * const serviceinfotbs = await prisma.serviceinfotb.findMany()
     * 
     * // Get first 10 Serviceinfotbs
     * const serviceinfotbs = await prisma.serviceinfotb.findMany({ take: 10 })
     * 
     * // Only select the `serviceId`
     * const serviceinfotbWithServiceIdOnly = await prisma.serviceinfotb.findMany({ select: { serviceId: true } })
     * 
     */
    findMany<T extends serviceinfotbFindManyArgs>(args?: SelectSubset<T, serviceinfotbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceinfotbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Serviceinfotb.
     * @param {serviceinfotbCreateArgs} args - Arguments to create a Serviceinfotb.
     * @example
     * // Create one Serviceinfotb
     * const Serviceinfotb = await prisma.serviceinfotb.create({
     *   data: {
     *     // ... data to create a Serviceinfotb
     *   }
     * })
     * 
     */
    create<T extends serviceinfotbCreateArgs>(args: SelectSubset<T, serviceinfotbCreateArgs<ExtArgs>>): Prisma__serviceinfotbClient<$Result.GetResult<Prisma.$serviceinfotbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Serviceinfotbs.
     * @param {serviceinfotbCreateManyArgs} args - Arguments to create many Serviceinfotbs.
     * @example
     * // Create many Serviceinfotbs
     * const serviceinfotb = await prisma.serviceinfotb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceinfotbCreateManyArgs>(args?: SelectSubset<T, serviceinfotbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Serviceinfotb.
     * @param {serviceinfotbDeleteArgs} args - Arguments to delete one Serviceinfotb.
     * @example
     * // Delete one Serviceinfotb
     * const Serviceinfotb = await prisma.serviceinfotb.delete({
     *   where: {
     *     // ... filter to delete one Serviceinfotb
     *   }
     * })
     * 
     */
    delete<T extends serviceinfotbDeleteArgs>(args: SelectSubset<T, serviceinfotbDeleteArgs<ExtArgs>>): Prisma__serviceinfotbClient<$Result.GetResult<Prisma.$serviceinfotbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Serviceinfotb.
     * @param {serviceinfotbUpdateArgs} args - Arguments to update one Serviceinfotb.
     * @example
     * // Update one Serviceinfotb
     * const serviceinfotb = await prisma.serviceinfotb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceinfotbUpdateArgs>(args: SelectSubset<T, serviceinfotbUpdateArgs<ExtArgs>>): Prisma__serviceinfotbClient<$Result.GetResult<Prisma.$serviceinfotbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Serviceinfotbs.
     * @param {serviceinfotbDeleteManyArgs} args - Arguments to filter Serviceinfotbs to delete.
     * @example
     * // Delete a few Serviceinfotbs
     * const { count } = await prisma.serviceinfotb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceinfotbDeleteManyArgs>(args?: SelectSubset<T, serviceinfotbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Serviceinfotbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfotbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Serviceinfotbs
     * const serviceinfotb = await prisma.serviceinfotb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceinfotbUpdateManyArgs>(args: SelectSubset<T, serviceinfotbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Serviceinfotb.
     * @param {serviceinfotbUpsertArgs} args - Arguments to update or create a Serviceinfotb.
     * @example
     * // Update or create a Serviceinfotb
     * const serviceinfotb = await prisma.serviceinfotb.upsert({
     *   create: {
     *     // ... data to create a Serviceinfotb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serviceinfotb we want to update
     *   }
     * })
     */
    upsert<T extends serviceinfotbUpsertArgs>(args: SelectSubset<T, serviceinfotbUpsertArgs<ExtArgs>>): Prisma__serviceinfotbClient<$Result.GetResult<Prisma.$serviceinfotbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Serviceinfotbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfotbCountArgs} args - Arguments to filter Serviceinfotbs to count.
     * @example
     * // Count the number of Serviceinfotbs
     * const count = await prisma.serviceinfotb.count({
     *   where: {
     *     // ... the filter for the Serviceinfotbs we want to count
     *   }
     * })
    **/
    count<T extends serviceinfotbCountArgs>(
      args?: Subset<T, serviceinfotbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceinfotbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serviceinfotb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceinfotbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceinfotbAggregateArgs>(args: Subset<T, ServiceinfotbAggregateArgs>): Prisma.PrismaPromise<GetServiceinfotbAggregateType<T>>

    /**
     * Group by Serviceinfotb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceinfotbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceinfotbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceinfotbGroupByArgs['orderBy'] }
        : { orderBy?: serviceinfotbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceinfotbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceinfotbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serviceinfotb model
   */
  readonly fields: serviceinfotbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serviceinfotb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceinfotbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serviceinfotb model
   */ 
  interface serviceinfotbFieldRefs {
    readonly serviceId: FieldRef<"serviceinfotb", 'Int'>
    readonly prefix: FieldRef<"serviceinfotb", 'String'>
    readonly info: FieldRef<"serviceinfotb", 'String'>
    readonly status: FieldRef<"serviceinfotb", 'Int'>
    readonly createDate: FieldRef<"serviceinfotb", 'DateTime'>
    readonly mode: FieldRef<"serviceinfotb", 'Int'>
    readonly hash: FieldRef<"serviceinfotb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * serviceinfotb findUnique
   */
  export type serviceinfotbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfotb to fetch.
     */
    where: serviceinfotbWhereUniqueInput
  }

  /**
   * serviceinfotb findUniqueOrThrow
   */
  export type serviceinfotbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfotb to fetch.
     */
    where: serviceinfotbWhereUniqueInput
  }

  /**
   * serviceinfotb findFirst
   */
  export type serviceinfotbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfotb to fetch.
     */
    where?: serviceinfotbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceinfotbs to fetch.
     */
    orderBy?: serviceinfotbOrderByWithRelationInput | serviceinfotbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceinfotbs.
     */
    cursor?: serviceinfotbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceinfotbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceinfotbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceinfotbs.
     */
    distinct?: ServiceinfotbScalarFieldEnum | ServiceinfotbScalarFieldEnum[]
  }

  /**
   * serviceinfotb findFirstOrThrow
   */
  export type serviceinfotbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfotb to fetch.
     */
    where?: serviceinfotbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceinfotbs to fetch.
     */
    orderBy?: serviceinfotbOrderByWithRelationInput | serviceinfotbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceinfotbs.
     */
    cursor?: serviceinfotbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceinfotbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceinfotbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceinfotbs.
     */
    distinct?: ServiceinfotbScalarFieldEnum | ServiceinfotbScalarFieldEnum[]
  }

  /**
   * serviceinfotb findMany
   */
  export type serviceinfotbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
    /**
     * Filter, which serviceinfotbs to fetch.
     */
    where?: serviceinfotbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceinfotbs to fetch.
     */
    orderBy?: serviceinfotbOrderByWithRelationInput | serviceinfotbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serviceinfotbs.
     */
    cursor?: serviceinfotbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceinfotbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceinfotbs.
     */
    skip?: number
    distinct?: ServiceinfotbScalarFieldEnum | ServiceinfotbScalarFieldEnum[]
  }

  /**
   * serviceinfotb create
   */
  export type serviceinfotbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
    /**
     * The data needed to create a serviceinfotb.
     */
    data: XOR<serviceinfotbCreateInput, serviceinfotbUncheckedCreateInput>
  }

  /**
   * serviceinfotb createMany
   */
  export type serviceinfotbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serviceinfotbs.
     */
    data: serviceinfotbCreateManyInput | serviceinfotbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serviceinfotb update
   */
  export type serviceinfotbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
    /**
     * The data needed to update a serviceinfotb.
     */
    data: XOR<serviceinfotbUpdateInput, serviceinfotbUncheckedUpdateInput>
    /**
     * Choose, which serviceinfotb to update.
     */
    where: serviceinfotbWhereUniqueInput
  }

  /**
   * serviceinfotb updateMany
   */
  export type serviceinfotbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serviceinfotbs.
     */
    data: XOR<serviceinfotbUpdateManyMutationInput, serviceinfotbUncheckedUpdateManyInput>
    /**
     * Filter which serviceinfotbs to update
     */
    where?: serviceinfotbWhereInput
  }

  /**
   * serviceinfotb upsert
   */
  export type serviceinfotbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
    /**
     * The filter to search for the serviceinfotb to update in case it exists.
     */
    where: serviceinfotbWhereUniqueInput
    /**
     * In case the serviceinfotb found by the `where` argument doesn't exist, create a new serviceinfotb with this data.
     */
    create: XOR<serviceinfotbCreateInput, serviceinfotbUncheckedCreateInput>
    /**
     * In case the serviceinfotb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceinfotbUpdateInput, serviceinfotbUncheckedUpdateInput>
  }

  /**
   * serviceinfotb delete
   */
  export type serviceinfotbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
    /**
     * Filter which serviceinfotb to delete.
     */
    where: serviceinfotbWhereUniqueInput
  }

  /**
   * serviceinfotb deleteMany
   */
  export type serviceinfotbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceinfotbs to delete
     */
    where?: serviceinfotbWhereInput
  }

  /**
   * serviceinfotb without action
   */
  export type serviceinfotbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceinfotb
     */
    select?: serviceinfotbSelect<ExtArgs> | null
  }


  /**
   * Model servicetb
   */

  export type AggregateServicetb = {
    _count: ServicetbCountAggregateOutputType | null
    _avg: ServicetbAvgAggregateOutputType | null
    _sum: ServicetbSumAggregateOutputType | null
    _min: ServicetbMinAggregateOutputType | null
    _max: ServicetbMaxAggregateOutputType | null
  }

  export type ServicetbAvgAggregateOutputType = {
    ServiceId: number | null
    ServicePrice: Decimal | null
    Inventory: number | null
    WarningInventory: number | null
    ServiceGroupID: number | null
    NumInventoryExpected: number | null
    UnitID: number | null
    SuggestID: number | null
  }

  export type ServicetbSumAggregateOutputType = {
    ServiceId: number | null
    ServicePrice: Decimal | null
    Inventory: number | null
    WarningInventory: number | null
    ServiceGroupID: number | null
    NumInventoryExpected: number | null
    UnitID: number | null
    SuggestID: number | null
  }

  export type ServicetbMinAggregateOutputType = {
    ServiceId: number | null
    ServiceName: string | null
    ServicePrice: Decimal | null
    Unit: string | null
    Active: boolean | null
    InventoryManagement: boolean | null
    Inventory: number | null
    WarningInventory: number | null
    ServiceGroupID: number | null
    NumInventoryExpected: number | null
    UnitID: number | null
    SuggestID: number | null
    ServiceImg: string | null
    ServiceDate: Date | null
  }

  export type ServicetbMaxAggregateOutputType = {
    ServiceId: number | null
    ServiceName: string | null
    ServicePrice: Decimal | null
    Unit: string | null
    Active: boolean | null
    InventoryManagement: boolean | null
    Inventory: number | null
    WarningInventory: number | null
    ServiceGroupID: number | null
    NumInventoryExpected: number | null
    UnitID: number | null
    SuggestID: number | null
    ServiceImg: string | null
    ServiceDate: Date | null
  }

  export type ServicetbCountAggregateOutputType = {
    ServiceId: number
    ServiceName: number
    ServicePrice: number
    Unit: number
    Active: number
    InventoryManagement: number
    Inventory: number
    WarningInventory: number
    ServiceGroupID: number
    NumInventoryExpected: number
    UnitID: number
    SuggestID: number
    ServiceImg: number
    ServiceDate: number
    _all: number
  }


  export type ServicetbAvgAggregateInputType = {
    ServiceId?: true
    ServicePrice?: true
    Inventory?: true
    WarningInventory?: true
    ServiceGroupID?: true
    NumInventoryExpected?: true
    UnitID?: true
    SuggestID?: true
  }

  export type ServicetbSumAggregateInputType = {
    ServiceId?: true
    ServicePrice?: true
    Inventory?: true
    WarningInventory?: true
    ServiceGroupID?: true
    NumInventoryExpected?: true
    UnitID?: true
    SuggestID?: true
  }

  export type ServicetbMinAggregateInputType = {
    ServiceId?: true
    ServiceName?: true
    ServicePrice?: true
    Unit?: true
    Active?: true
    InventoryManagement?: true
    Inventory?: true
    WarningInventory?: true
    ServiceGroupID?: true
    NumInventoryExpected?: true
    UnitID?: true
    SuggestID?: true
    ServiceImg?: true
    ServiceDate?: true
  }

  export type ServicetbMaxAggregateInputType = {
    ServiceId?: true
    ServiceName?: true
    ServicePrice?: true
    Unit?: true
    Active?: true
    InventoryManagement?: true
    Inventory?: true
    WarningInventory?: true
    ServiceGroupID?: true
    NumInventoryExpected?: true
    UnitID?: true
    SuggestID?: true
    ServiceImg?: true
    ServiceDate?: true
  }

  export type ServicetbCountAggregateInputType = {
    ServiceId?: true
    ServiceName?: true
    ServicePrice?: true
    Unit?: true
    Active?: true
    InventoryManagement?: true
    Inventory?: true
    WarningInventory?: true
    ServiceGroupID?: true
    NumInventoryExpected?: true
    UnitID?: true
    SuggestID?: true
    ServiceImg?: true
    ServiceDate?: true
    _all?: true
  }

  export type ServicetbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicetb to aggregate.
     */
    where?: servicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicetbs to fetch.
     */
    orderBy?: servicetbOrderByWithRelationInput | servicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicetbs
    **/
    _count?: true | ServicetbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicetbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicetbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicetbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicetbMaxAggregateInputType
  }

  export type GetServicetbAggregateType<T extends ServicetbAggregateArgs> = {
        [P in keyof T & keyof AggregateServicetb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicetb[P]>
      : GetScalarType<T[P], AggregateServicetb[P]>
  }




  export type servicetbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicetbWhereInput
    orderBy?: servicetbOrderByWithAggregationInput | servicetbOrderByWithAggregationInput[]
    by: ServicetbScalarFieldEnum[] | ServicetbScalarFieldEnum
    having?: servicetbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicetbCountAggregateInputType | true
    _avg?: ServicetbAvgAggregateInputType
    _sum?: ServicetbSumAggregateInputType
    _min?: ServicetbMinAggregateInputType
    _max?: ServicetbMaxAggregateInputType
  }

  export type ServicetbGroupByOutputType = {
    ServiceId: number
    ServiceName: string
    ServicePrice: Decimal
    Unit: string
    Active: boolean
    InventoryManagement: boolean
    Inventory: number
    WarningInventory: number
    ServiceGroupID: number
    NumInventoryExpected: number
    UnitID: number
    SuggestID: number
    ServiceImg: string | null
    ServiceDate: Date | null
    _count: ServicetbCountAggregateOutputType | null
    _avg: ServicetbAvgAggregateOutputType | null
    _sum: ServicetbSumAggregateOutputType | null
    _min: ServicetbMinAggregateOutputType | null
    _max: ServicetbMaxAggregateOutputType | null
  }

  type GetServicetbGroupByPayload<T extends servicetbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicetbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicetbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicetbGroupByOutputType[P]>
            : GetScalarType<T[P], ServicetbGroupByOutputType[P]>
        }
      >
    >


  export type servicetbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ServiceId?: boolean
    ServiceName?: boolean
    ServicePrice?: boolean
    Unit?: boolean
    Active?: boolean
    InventoryManagement?: boolean
    Inventory?: boolean
    WarningInventory?: boolean
    ServiceGroupID?: boolean
    NumInventoryExpected?: boolean
    UnitID?: boolean
    SuggestID?: boolean
    ServiceImg?: boolean
    ServiceDate?: boolean
  }, ExtArgs["result"]["servicetb"]>


  export type servicetbSelectScalar = {
    ServiceId?: boolean
    ServiceName?: boolean
    ServicePrice?: boolean
    Unit?: boolean
    Active?: boolean
    InventoryManagement?: boolean
    Inventory?: boolean
    WarningInventory?: boolean
    ServiceGroupID?: boolean
    NumInventoryExpected?: boolean
    UnitID?: boolean
    SuggestID?: boolean
    ServiceImg?: boolean
    ServiceDate?: boolean
  }


  export type $servicetbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "servicetb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ServiceId: number
      ServiceName: string
      ServicePrice: Prisma.Decimal
      Unit: string
      Active: boolean
      InventoryManagement: boolean
      Inventory: number
      WarningInventory: number
      ServiceGroupID: number
      NumInventoryExpected: number
      UnitID: number
      SuggestID: number
      ServiceImg: string | null
      ServiceDate: Date | null
    }, ExtArgs["result"]["servicetb"]>
    composites: {}
  }

  type servicetbGetPayload<S extends boolean | null | undefined | servicetbDefaultArgs> = $Result.GetResult<Prisma.$servicetbPayload, S>

  type servicetbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<servicetbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicetbCountAggregateInputType | true
    }

  export interface servicetbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicetb'], meta: { name: 'servicetb' } }
    /**
     * Find zero or one Servicetb that matches the filter.
     * @param {servicetbFindUniqueArgs} args - Arguments to find a Servicetb
     * @example
     * // Get one Servicetb
     * const servicetb = await prisma.servicetb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends servicetbFindUniqueArgs>(args: SelectSubset<T, servicetbFindUniqueArgs<ExtArgs>>): Prisma__servicetbClient<$Result.GetResult<Prisma.$servicetbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicetb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {servicetbFindUniqueOrThrowArgs} args - Arguments to find a Servicetb
     * @example
     * // Get one Servicetb
     * const servicetb = await prisma.servicetb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends servicetbFindUniqueOrThrowArgs>(args: SelectSubset<T, servicetbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__servicetbClient<$Result.GetResult<Prisma.$servicetbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicetb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicetbFindFirstArgs} args - Arguments to find a Servicetb
     * @example
     * // Get one Servicetb
     * const servicetb = await prisma.servicetb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends servicetbFindFirstArgs>(args?: SelectSubset<T, servicetbFindFirstArgs<ExtArgs>>): Prisma__servicetbClient<$Result.GetResult<Prisma.$servicetbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicetb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicetbFindFirstOrThrowArgs} args - Arguments to find a Servicetb
     * @example
     * // Get one Servicetb
     * const servicetb = await prisma.servicetb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends servicetbFindFirstOrThrowArgs>(args?: SelectSubset<T, servicetbFindFirstOrThrowArgs<ExtArgs>>): Prisma__servicetbClient<$Result.GetResult<Prisma.$servicetbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicetbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicetbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicetbs
     * const servicetbs = await prisma.servicetb.findMany()
     * 
     * // Get first 10 Servicetbs
     * const servicetbs = await prisma.servicetb.findMany({ take: 10 })
     * 
     * // Only select the `ServiceId`
     * const servicetbWithServiceIdOnly = await prisma.servicetb.findMany({ select: { ServiceId: true } })
     * 
     */
    findMany<T extends servicetbFindManyArgs>(args?: SelectSubset<T, servicetbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicetbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicetb.
     * @param {servicetbCreateArgs} args - Arguments to create a Servicetb.
     * @example
     * // Create one Servicetb
     * const Servicetb = await prisma.servicetb.create({
     *   data: {
     *     // ... data to create a Servicetb
     *   }
     * })
     * 
     */
    create<T extends servicetbCreateArgs>(args: SelectSubset<T, servicetbCreateArgs<ExtArgs>>): Prisma__servicetbClient<$Result.GetResult<Prisma.$servicetbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicetbs.
     * @param {servicetbCreateManyArgs} args - Arguments to create many Servicetbs.
     * @example
     * // Create many Servicetbs
     * const servicetb = await prisma.servicetb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends servicetbCreateManyArgs>(args?: SelectSubset<T, servicetbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicetb.
     * @param {servicetbDeleteArgs} args - Arguments to delete one Servicetb.
     * @example
     * // Delete one Servicetb
     * const Servicetb = await prisma.servicetb.delete({
     *   where: {
     *     // ... filter to delete one Servicetb
     *   }
     * })
     * 
     */
    delete<T extends servicetbDeleteArgs>(args: SelectSubset<T, servicetbDeleteArgs<ExtArgs>>): Prisma__servicetbClient<$Result.GetResult<Prisma.$servicetbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicetb.
     * @param {servicetbUpdateArgs} args - Arguments to update one Servicetb.
     * @example
     * // Update one Servicetb
     * const servicetb = await prisma.servicetb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends servicetbUpdateArgs>(args: SelectSubset<T, servicetbUpdateArgs<ExtArgs>>): Prisma__servicetbClient<$Result.GetResult<Prisma.$servicetbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicetbs.
     * @param {servicetbDeleteManyArgs} args - Arguments to filter Servicetbs to delete.
     * @example
     * // Delete a few Servicetbs
     * const { count } = await prisma.servicetb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends servicetbDeleteManyArgs>(args?: SelectSubset<T, servicetbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicetbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicetbs
     * const servicetb = await prisma.servicetb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends servicetbUpdateManyArgs>(args: SelectSubset<T, servicetbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicetb.
     * @param {servicetbUpsertArgs} args - Arguments to update or create a Servicetb.
     * @example
     * // Update or create a Servicetb
     * const servicetb = await prisma.servicetb.upsert({
     *   create: {
     *     // ... data to create a Servicetb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicetb we want to update
     *   }
     * })
     */
    upsert<T extends servicetbUpsertArgs>(args: SelectSubset<T, servicetbUpsertArgs<ExtArgs>>): Prisma__servicetbClient<$Result.GetResult<Prisma.$servicetbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicetbCountArgs} args - Arguments to filter Servicetbs to count.
     * @example
     * // Count the number of Servicetbs
     * const count = await prisma.servicetb.count({
     *   where: {
     *     // ... the filter for the Servicetbs we want to count
     *   }
     * })
    **/
    count<T extends servicetbCountArgs>(
      args?: Subset<T, servicetbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicetbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicetbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicetbAggregateArgs>(args: Subset<T, ServicetbAggregateArgs>): Prisma.PrismaPromise<GetServicetbAggregateType<T>>

    /**
     * Group by Servicetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicetbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicetbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicetbGroupByArgs['orderBy'] }
        : { orderBy?: servicetbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicetbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicetbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the servicetb model
   */
  readonly fields: servicetbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicetb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicetbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the servicetb model
   */ 
  interface servicetbFieldRefs {
    readonly ServiceId: FieldRef<"servicetb", 'Int'>
    readonly ServiceName: FieldRef<"servicetb", 'String'>
    readonly ServicePrice: FieldRef<"servicetb", 'Decimal'>
    readonly Unit: FieldRef<"servicetb", 'String'>
    readonly Active: FieldRef<"servicetb", 'Boolean'>
    readonly InventoryManagement: FieldRef<"servicetb", 'Boolean'>
    readonly Inventory: FieldRef<"servicetb", 'Int'>
    readonly WarningInventory: FieldRef<"servicetb", 'Int'>
    readonly ServiceGroupID: FieldRef<"servicetb", 'Int'>
    readonly NumInventoryExpected: FieldRef<"servicetb", 'Int'>
    readonly UnitID: FieldRef<"servicetb", 'Int'>
    readonly SuggestID: FieldRef<"servicetb", 'Int'>
    readonly ServiceImg: FieldRef<"servicetb", 'String'>
    readonly ServiceDate: FieldRef<"servicetb", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * servicetb findUnique
   */
  export type servicetbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
    /**
     * Filter, which servicetb to fetch.
     */
    where: servicetbWhereUniqueInput
  }

  /**
   * servicetb findUniqueOrThrow
   */
  export type servicetbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
    /**
     * Filter, which servicetb to fetch.
     */
    where: servicetbWhereUniqueInput
  }

  /**
   * servicetb findFirst
   */
  export type servicetbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
    /**
     * Filter, which servicetb to fetch.
     */
    where?: servicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicetbs to fetch.
     */
    orderBy?: servicetbOrderByWithRelationInput | servicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicetbs.
     */
    cursor?: servicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicetbs.
     */
    distinct?: ServicetbScalarFieldEnum | ServicetbScalarFieldEnum[]
  }

  /**
   * servicetb findFirstOrThrow
   */
  export type servicetbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
    /**
     * Filter, which servicetb to fetch.
     */
    where?: servicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicetbs to fetch.
     */
    orderBy?: servicetbOrderByWithRelationInput | servicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicetbs.
     */
    cursor?: servicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicetbs.
     */
    distinct?: ServicetbScalarFieldEnum | ServicetbScalarFieldEnum[]
  }

  /**
   * servicetb findMany
   */
  export type servicetbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
    /**
     * Filter, which servicetbs to fetch.
     */
    where?: servicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicetbs to fetch.
     */
    orderBy?: servicetbOrderByWithRelationInput | servicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicetbs.
     */
    cursor?: servicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicetbs.
     */
    skip?: number
    distinct?: ServicetbScalarFieldEnum | ServicetbScalarFieldEnum[]
  }

  /**
   * servicetb create
   */
  export type servicetbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
    /**
     * The data needed to create a servicetb.
     */
    data: XOR<servicetbCreateInput, servicetbUncheckedCreateInput>
  }

  /**
   * servicetb createMany
   */
  export type servicetbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicetbs.
     */
    data: servicetbCreateManyInput | servicetbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * servicetb update
   */
  export type servicetbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
    /**
     * The data needed to update a servicetb.
     */
    data: XOR<servicetbUpdateInput, servicetbUncheckedUpdateInput>
    /**
     * Choose, which servicetb to update.
     */
    where: servicetbWhereUniqueInput
  }

  /**
   * servicetb updateMany
   */
  export type servicetbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicetbs.
     */
    data: XOR<servicetbUpdateManyMutationInput, servicetbUncheckedUpdateManyInput>
    /**
     * Filter which servicetbs to update
     */
    where?: servicetbWhereInput
  }

  /**
   * servicetb upsert
   */
  export type servicetbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
    /**
     * The filter to search for the servicetb to update in case it exists.
     */
    where: servicetbWhereUniqueInput
    /**
     * In case the servicetb found by the `where` argument doesn't exist, create a new servicetb with this data.
     */
    create: XOR<servicetbCreateInput, servicetbUncheckedCreateInput>
    /**
     * In case the servicetb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicetbUpdateInput, servicetbUncheckedUpdateInput>
  }

  /**
   * servicetb delete
   */
  export type servicetbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
    /**
     * Filter which servicetb to delete.
     */
    where: servicetbWhereUniqueInput
  }

  /**
   * servicetb deleteMany
   */
  export type servicetbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicetbs to delete
     */
    where?: servicetbWhereInput
  }

  /**
   * servicetb without action
   */
  export type servicetbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicetb
     */
    select?: servicetbSelect<ExtArgs> | null
  }


  /**
   * Model serviceunittb
   */

  export type AggregateServiceunittb = {
    _count: ServiceunittbCountAggregateOutputType | null
    _avg: ServiceunittbAvgAggregateOutputType | null
    _sum: ServiceunittbSumAggregateOutputType | null
    _min: ServiceunittbMinAggregateOutputType | null
    _max: ServiceunittbMaxAggregateOutputType | null
  }

  export type ServiceunittbAvgAggregateOutputType = {
    ID: number | null
  }

  export type ServiceunittbSumAggregateOutputType = {
    ID: number | null
  }

  export type ServiceunittbMinAggregateOutputType = {
    ID: number | null
    Unit: string | null
    IsActive: boolean | null
  }

  export type ServiceunittbMaxAggregateOutputType = {
    ID: number | null
    Unit: string | null
    IsActive: boolean | null
  }

  export type ServiceunittbCountAggregateOutputType = {
    ID: number
    Unit: number
    IsActive: number
    _all: number
  }


  export type ServiceunittbAvgAggregateInputType = {
    ID?: true
  }

  export type ServiceunittbSumAggregateInputType = {
    ID?: true
  }

  export type ServiceunittbMinAggregateInputType = {
    ID?: true
    Unit?: true
    IsActive?: true
  }

  export type ServiceunittbMaxAggregateInputType = {
    ID?: true
    Unit?: true
    IsActive?: true
  }

  export type ServiceunittbCountAggregateInputType = {
    ID?: true
    Unit?: true
    IsActive?: true
    _all?: true
  }

  export type ServiceunittbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceunittb to aggregate.
     */
    where?: serviceunittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceunittbs to fetch.
     */
    orderBy?: serviceunittbOrderByWithRelationInput | serviceunittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: serviceunittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceunittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceunittbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned serviceunittbs
    **/
    _count?: true | ServiceunittbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceunittbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceunittbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceunittbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceunittbMaxAggregateInputType
  }

  export type GetServiceunittbAggregateType<T extends ServiceunittbAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceunittb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceunittb[P]>
      : GetScalarType<T[P], AggregateServiceunittb[P]>
  }




  export type serviceunittbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: serviceunittbWhereInput
    orderBy?: serviceunittbOrderByWithAggregationInput | serviceunittbOrderByWithAggregationInput[]
    by: ServiceunittbScalarFieldEnum[] | ServiceunittbScalarFieldEnum
    having?: serviceunittbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceunittbCountAggregateInputType | true
    _avg?: ServiceunittbAvgAggregateInputType
    _sum?: ServiceunittbSumAggregateInputType
    _min?: ServiceunittbMinAggregateInputType
    _max?: ServiceunittbMaxAggregateInputType
  }

  export type ServiceunittbGroupByOutputType = {
    ID: number
    Unit: string
    IsActive: boolean
    _count: ServiceunittbCountAggregateOutputType | null
    _avg: ServiceunittbAvgAggregateOutputType | null
    _sum: ServiceunittbSumAggregateOutputType | null
    _min: ServiceunittbMinAggregateOutputType | null
    _max: ServiceunittbMaxAggregateOutputType | null
  }

  type GetServiceunittbGroupByPayload<T extends serviceunittbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceunittbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceunittbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceunittbGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceunittbGroupByOutputType[P]>
        }
      >
    >


  export type serviceunittbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Unit?: boolean
    IsActive?: boolean
  }, ExtArgs["result"]["serviceunittb"]>


  export type serviceunittbSelectScalar = {
    ID?: boolean
    Unit?: boolean
    IsActive?: boolean
  }


  export type $serviceunittbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "serviceunittb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Unit: string
      IsActive: boolean
    }, ExtArgs["result"]["serviceunittb"]>
    composites: {}
  }

  type serviceunittbGetPayload<S extends boolean | null | undefined | serviceunittbDefaultArgs> = $Result.GetResult<Prisma.$serviceunittbPayload, S>

  type serviceunittbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<serviceunittbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceunittbCountAggregateInputType | true
    }

  export interface serviceunittbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['serviceunittb'], meta: { name: 'serviceunittb' } }
    /**
     * Find zero or one Serviceunittb that matches the filter.
     * @param {serviceunittbFindUniqueArgs} args - Arguments to find a Serviceunittb
     * @example
     * // Get one Serviceunittb
     * const serviceunittb = await prisma.serviceunittb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends serviceunittbFindUniqueArgs>(args: SelectSubset<T, serviceunittbFindUniqueArgs<ExtArgs>>): Prisma__serviceunittbClient<$Result.GetResult<Prisma.$serviceunittbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Serviceunittb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {serviceunittbFindUniqueOrThrowArgs} args - Arguments to find a Serviceunittb
     * @example
     * // Get one Serviceunittb
     * const serviceunittb = await prisma.serviceunittb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends serviceunittbFindUniqueOrThrowArgs>(args: SelectSubset<T, serviceunittbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__serviceunittbClient<$Result.GetResult<Prisma.$serviceunittbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Serviceunittb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceunittbFindFirstArgs} args - Arguments to find a Serviceunittb
     * @example
     * // Get one Serviceunittb
     * const serviceunittb = await prisma.serviceunittb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends serviceunittbFindFirstArgs>(args?: SelectSubset<T, serviceunittbFindFirstArgs<ExtArgs>>): Prisma__serviceunittbClient<$Result.GetResult<Prisma.$serviceunittbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Serviceunittb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceunittbFindFirstOrThrowArgs} args - Arguments to find a Serviceunittb
     * @example
     * // Get one Serviceunittb
     * const serviceunittb = await prisma.serviceunittb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends serviceunittbFindFirstOrThrowArgs>(args?: SelectSubset<T, serviceunittbFindFirstOrThrowArgs<ExtArgs>>): Prisma__serviceunittbClient<$Result.GetResult<Prisma.$serviceunittbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Serviceunittbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceunittbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Serviceunittbs
     * const serviceunittbs = await prisma.serviceunittb.findMany()
     * 
     * // Get first 10 Serviceunittbs
     * const serviceunittbs = await prisma.serviceunittb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const serviceunittbWithIDOnly = await prisma.serviceunittb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends serviceunittbFindManyArgs>(args?: SelectSubset<T, serviceunittbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$serviceunittbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Serviceunittb.
     * @param {serviceunittbCreateArgs} args - Arguments to create a Serviceunittb.
     * @example
     * // Create one Serviceunittb
     * const Serviceunittb = await prisma.serviceunittb.create({
     *   data: {
     *     // ... data to create a Serviceunittb
     *   }
     * })
     * 
     */
    create<T extends serviceunittbCreateArgs>(args: SelectSubset<T, serviceunittbCreateArgs<ExtArgs>>): Prisma__serviceunittbClient<$Result.GetResult<Prisma.$serviceunittbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Serviceunittbs.
     * @param {serviceunittbCreateManyArgs} args - Arguments to create many Serviceunittbs.
     * @example
     * // Create many Serviceunittbs
     * const serviceunittb = await prisma.serviceunittb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends serviceunittbCreateManyArgs>(args?: SelectSubset<T, serviceunittbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Serviceunittb.
     * @param {serviceunittbDeleteArgs} args - Arguments to delete one Serviceunittb.
     * @example
     * // Delete one Serviceunittb
     * const Serviceunittb = await prisma.serviceunittb.delete({
     *   where: {
     *     // ... filter to delete one Serviceunittb
     *   }
     * })
     * 
     */
    delete<T extends serviceunittbDeleteArgs>(args: SelectSubset<T, serviceunittbDeleteArgs<ExtArgs>>): Prisma__serviceunittbClient<$Result.GetResult<Prisma.$serviceunittbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Serviceunittb.
     * @param {serviceunittbUpdateArgs} args - Arguments to update one Serviceunittb.
     * @example
     * // Update one Serviceunittb
     * const serviceunittb = await prisma.serviceunittb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends serviceunittbUpdateArgs>(args: SelectSubset<T, serviceunittbUpdateArgs<ExtArgs>>): Prisma__serviceunittbClient<$Result.GetResult<Prisma.$serviceunittbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Serviceunittbs.
     * @param {serviceunittbDeleteManyArgs} args - Arguments to filter Serviceunittbs to delete.
     * @example
     * // Delete a few Serviceunittbs
     * const { count } = await prisma.serviceunittb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends serviceunittbDeleteManyArgs>(args?: SelectSubset<T, serviceunittbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Serviceunittbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceunittbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Serviceunittbs
     * const serviceunittb = await prisma.serviceunittb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends serviceunittbUpdateManyArgs>(args: SelectSubset<T, serviceunittbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Serviceunittb.
     * @param {serviceunittbUpsertArgs} args - Arguments to update or create a Serviceunittb.
     * @example
     * // Update or create a Serviceunittb
     * const serviceunittb = await prisma.serviceunittb.upsert({
     *   create: {
     *     // ... data to create a Serviceunittb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serviceunittb we want to update
     *   }
     * })
     */
    upsert<T extends serviceunittbUpsertArgs>(args: SelectSubset<T, serviceunittbUpsertArgs<ExtArgs>>): Prisma__serviceunittbClient<$Result.GetResult<Prisma.$serviceunittbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Serviceunittbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceunittbCountArgs} args - Arguments to filter Serviceunittbs to count.
     * @example
     * // Count the number of Serviceunittbs
     * const count = await prisma.serviceunittb.count({
     *   where: {
     *     // ... the filter for the Serviceunittbs we want to count
     *   }
     * })
    **/
    count<T extends serviceunittbCountArgs>(
      args?: Subset<T, serviceunittbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceunittbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serviceunittb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceunittbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceunittbAggregateArgs>(args: Subset<T, ServiceunittbAggregateArgs>): Prisma.PrismaPromise<GetServiceunittbAggregateType<T>>

    /**
     * Group by Serviceunittb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {serviceunittbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends serviceunittbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: serviceunittbGroupByArgs['orderBy'] }
        : { orderBy?: serviceunittbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, serviceunittbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceunittbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the serviceunittb model
   */
  readonly fields: serviceunittbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for serviceunittb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__serviceunittbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the serviceunittb model
   */ 
  interface serviceunittbFieldRefs {
    readonly ID: FieldRef<"serviceunittb", 'Int'>
    readonly Unit: FieldRef<"serviceunittb", 'String'>
    readonly IsActive: FieldRef<"serviceunittb", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * serviceunittb findUnique
   */
  export type serviceunittbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
    /**
     * Filter, which serviceunittb to fetch.
     */
    where: serviceunittbWhereUniqueInput
  }

  /**
   * serviceunittb findUniqueOrThrow
   */
  export type serviceunittbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
    /**
     * Filter, which serviceunittb to fetch.
     */
    where: serviceunittbWhereUniqueInput
  }

  /**
   * serviceunittb findFirst
   */
  export type serviceunittbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
    /**
     * Filter, which serviceunittb to fetch.
     */
    where?: serviceunittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceunittbs to fetch.
     */
    orderBy?: serviceunittbOrderByWithRelationInput | serviceunittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceunittbs.
     */
    cursor?: serviceunittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceunittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceunittbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceunittbs.
     */
    distinct?: ServiceunittbScalarFieldEnum | ServiceunittbScalarFieldEnum[]
  }

  /**
   * serviceunittb findFirstOrThrow
   */
  export type serviceunittbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
    /**
     * Filter, which serviceunittb to fetch.
     */
    where?: serviceunittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceunittbs to fetch.
     */
    orderBy?: serviceunittbOrderByWithRelationInput | serviceunittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for serviceunittbs.
     */
    cursor?: serviceunittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceunittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceunittbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of serviceunittbs.
     */
    distinct?: ServiceunittbScalarFieldEnum | ServiceunittbScalarFieldEnum[]
  }

  /**
   * serviceunittb findMany
   */
  export type serviceunittbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
    /**
     * Filter, which serviceunittbs to fetch.
     */
    where?: serviceunittbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of serviceunittbs to fetch.
     */
    orderBy?: serviceunittbOrderByWithRelationInput | serviceunittbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing serviceunittbs.
     */
    cursor?: serviceunittbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` serviceunittbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` serviceunittbs.
     */
    skip?: number
    distinct?: ServiceunittbScalarFieldEnum | ServiceunittbScalarFieldEnum[]
  }

  /**
   * serviceunittb create
   */
  export type serviceunittbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
    /**
     * The data needed to create a serviceunittb.
     */
    data?: XOR<serviceunittbCreateInput, serviceunittbUncheckedCreateInput>
  }

  /**
   * serviceunittb createMany
   */
  export type serviceunittbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many serviceunittbs.
     */
    data: serviceunittbCreateManyInput | serviceunittbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * serviceunittb update
   */
  export type serviceunittbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
    /**
     * The data needed to update a serviceunittb.
     */
    data: XOR<serviceunittbUpdateInput, serviceunittbUncheckedUpdateInput>
    /**
     * Choose, which serviceunittb to update.
     */
    where: serviceunittbWhereUniqueInput
  }

  /**
   * serviceunittb updateMany
   */
  export type serviceunittbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update serviceunittbs.
     */
    data: XOR<serviceunittbUpdateManyMutationInput, serviceunittbUncheckedUpdateManyInput>
    /**
     * Filter which serviceunittbs to update
     */
    where?: serviceunittbWhereInput
  }

  /**
   * serviceunittb upsert
   */
  export type serviceunittbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
    /**
     * The filter to search for the serviceunittb to update in case it exists.
     */
    where: serviceunittbWhereUniqueInput
    /**
     * In case the serviceunittb found by the `where` argument doesn't exist, create a new serviceunittb with this data.
     */
    create: XOR<serviceunittbCreateInput, serviceunittbUncheckedCreateInput>
    /**
     * In case the serviceunittb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<serviceunittbUpdateInput, serviceunittbUncheckedUpdateInput>
  }

  /**
   * serviceunittb delete
   */
  export type serviceunittbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
    /**
     * Filter which serviceunittb to delete.
     */
    where: serviceunittbWhereUniqueInput
  }

  /**
   * serviceunittb deleteMany
   */
  export type serviceunittbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which serviceunittbs to delete
     */
    where?: serviceunittbWhereInput
  }

  /**
   * serviceunittb without action
   */
  export type serviceunittbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the serviceunittb
     */
    select?: serviceunittbSelect<ExtArgs> | null
  }


  /**
   * Model servicevisit
   */

  export type AggregateServicevisit = {
    _count: ServicevisitCountAggregateOutputType | null
    _avg: ServicevisitAvgAggregateOutputType | null
    _sum: ServicevisitSumAggregateOutputType | null
    _min: ServicevisitMinAggregateOutputType | null
    _max: ServicevisitMaxAggregateOutputType | null
  }

  export type ServicevisitAvgAggregateOutputType = {
    vstotal: number | null
    ym: number | null
    reset: number | null
  }

  export type ServicevisitSumAggregateOutputType = {
    vstotal: number | null
    ym: number | null
    reset: number | null
  }

  export type ServicevisitMinAggregateOutputType = {
    uid: string | null
    vstotal: number | null
    vsdetail: string | null
    ym: number | null
    last_update: Date | null
    sign: string | null
    ssid: string | null
    reset: number | null
  }

  export type ServicevisitMaxAggregateOutputType = {
    uid: string | null
    vstotal: number | null
    vsdetail: string | null
    ym: number | null
    last_update: Date | null
    sign: string | null
    ssid: string | null
    reset: number | null
  }

  export type ServicevisitCountAggregateOutputType = {
    uid: number
    vstotal: number
    vsdetail: number
    ym: number
    last_update: number
    sign: number
    ssid: number
    reset: number
    _all: number
  }


  export type ServicevisitAvgAggregateInputType = {
    vstotal?: true
    ym?: true
    reset?: true
  }

  export type ServicevisitSumAggregateInputType = {
    vstotal?: true
    ym?: true
    reset?: true
  }

  export type ServicevisitMinAggregateInputType = {
    uid?: true
    vstotal?: true
    vsdetail?: true
    ym?: true
    last_update?: true
    sign?: true
    ssid?: true
    reset?: true
  }

  export type ServicevisitMaxAggregateInputType = {
    uid?: true
    vstotal?: true
    vsdetail?: true
    ym?: true
    last_update?: true
    sign?: true
    ssid?: true
    reset?: true
  }

  export type ServicevisitCountAggregateInputType = {
    uid?: true
    vstotal?: true
    vsdetail?: true
    ym?: true
    last_update?: true
    sign?: true
    ssid?: true
    reset?: true
    _all?: true
  }

  export type ServicevisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicevisit to aggregate.
     */
    where?: servicevisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicevisits to fetch.
     */
    orderBy?: servicevisitOrderByWithRelationInput | servicevisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: servicevisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicevisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicevisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned servicevisits
    **/
    _count?: true | ServicevisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicevisitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicevisitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicevisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicevisitMaxAggregateInputType
  }

  export type GetServicevisitAggregateType<T extends ServicevisitAggregateArgs> = {
        [P in keyof T & keyof AggregateServicevisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicevisit[P]>
      : GetScalarType<T[P], AggregateServicevisit[P]>
  }




  export type servicevisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: servicevisitWhereInput
    orderBy?: servicevisitOrderByWithAggregationInput | servicevisitOrderByWithAggregationInput[]
    by: ServicevisitScalarFieldEnum[] | ServicevisitScalarFieldEnum
    having?: servicevisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicevisitCountAggregateInputType | true
    _avg?: ServicevisitAvgAggregateInputType
    _sum?: ServicevisitSumAggregateInputType
    _min?: ServicevisitMinAggregateInputType
    _max?: ServicevisitMaxAggregateInputType
  }

  export type ServicevisitGroupByOutputType = {
    uid: string
    vstotal: number | null
    vsdetail: string | null
    ym: number
    last_update: Date | null
    sign: string | null
    ssid: string | null
    reset: number | null
    _count: ServicevisitCountAggregateOutputType | null
    _avg: ServicevisitAvgAggregateOutputType | null
    _sum: ServicevisitSumAggregateOutputType | null
    _min: ServicevisitMinAggregateOutputType | null
    _max: ServicevisitMaxAggregateOutputType | null
  }

  type GetServicevisitGroupByPayload<T extends servicevisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicevisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicevisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicevisitGroupByOutputType[P]>
            : GetScalarType<T[P], ServicevisitGroupByOutputType[P]>
        }
      >
    >


  export type servicevisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    vstotal?: boolean
    vsdetail?: boolean
    ym?: boolean
    last_update?: boolean
    sign?: boolean
    ssid?: boolean
    reset?: boolean
  }, ExtArgs["result"]["servicevisit"]>


  export type servicevisitSelectScalar = {
    uid?: boolean
    vstotal?: boolean
    vsdetail?: boolean
    ym?: boolean
    last_update?: boolean
    sign?: boolean
    ssid?: boolean
    reset?: boolean
  }


  export type $servicevisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "servicevisit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      vstotal: number | null
      vsdetail: string | null
      ym: number
      last_update: Date | null
      sign: string | null
      ssid: string | null
      reset: number | null
    }, ExtArgs["result"]["servicevisit"]>
    composites: {}
  }

  type servicevisitGetPayload<S extends boolean | null | undefined | servicevisitDefaultArgs> = $Result.GetResult<Prisma.$servicevisitPayload, S>

  type servicevisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<servicevisitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicevisitCountAggregateInputType | true
    }

  export interface servicevisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['servicevisit'], meta: { name: 'servicevisit' } }
    /**
     * Find zero or one Servicevisit that matches the filter.
     * @param {servicevisitFindUniqueArgs} args - Arguments to find a Servicevisit
     * @example
     * // Get one Servicevisit
     * const servicevisit = await prisma.servicevisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends servicevisitFindUniqueArgs>(args: SelectSubset<T, servicevisitFindUniqueArgs<ExtArgs>>): Prisma__servicevisitClient<$Result.GetResult<Prisma.$servicevisitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicevisit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {servicevisitFindUniqueOrThrowArgs} args - Arguments to find a Servicevisit
     * @example
     * // Get one Servicevisit
     * const servicevisit = await prisma.servicevisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends servicevisitFindUniqueOrThrowArgs>(args: SelectSubset<T, servicevisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__servicevisitClient<$Result.GetResult<Prisma.$servicevisitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicevisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicevisitFindFirstArgs} args - Arguments to find a Servicevisit
     * @example
     * // Get one Servicevisit
     * const servicevisit = await prisma.servicevisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends servicevisitFindFirstArgs>(args?: SelectSubset<T, servicevisitFindFirstArgs<ExtArgs>>): Prisma__servicevisitClient<$Result.GetResult<Prisma.$servicevisitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicevisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicevisitFindFirstOrThrowArgs} args - Arguments to find a Servicevisit
     * @example
     * // Get one Servicevisit
     * const servicevisit = await prisma.servicevisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends servicevisitFindFirstOrThrowArgs>(args?: SelectSubset<T, servicevisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__servicevisitClient<$Result.GetResult<Prisma.$servicevisitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicevisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicevisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicevisits
     * const servicevisits = await prisma.servicevisit.findMany()
     * 
     * // Get first 10 Servicevisits
     * const servicevisits = await prisma.servicevisit.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const servicevisitWithUidOnly = await prisma.servicevisit.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends servicevisitFindManyArgs>(args?: SelectSubset<T, servicevisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$servicevisitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicevisit.
     * @param {servicevisitCreateArgs} args - Arguments to create a Servicevisit.
     * @example
     * // Create one Servicevisit
     * const Servicevisit = await prisma.servicevisit.create({
     *   data: {
     *     // ... data to create a Servicevisit
     *   }
     * })
     * 
     */
    create<T extends servicevisitCreateArgs>(args: SelectSubset<T, servicevisitCreateArgs<ExtArgs>>): Prisma__servicevisitClient<$Result.GetResult<Prisma.$servicevisitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicevisits.
     * @param {servicevisitCreateManyArgs} args - Arguments to create many Servicevisits.
     * @example
     * // Create many Servicevisits
     * const servicevisit = await prisma.servicevisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends servicevisitCreateManyArgs>(args?: SelectSubset<T, servicevisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicevisit.
     * @param {servicevisitDeleteArgs} args - Arguments to delete one Servicevisit.
     * @example
     * // Delete one Servicevisit
     * const Servicevisit = await prisma.servicevisit.delete({
     *   where: {
     *     // ... filter to delete one Servicevisit
     *   }
     * })
     * 
     */
    delete<T extends servicevisitDeleteArgs>(args: SelectSubset<T, servicevisitDeleteArgs<ExtArgs>>): Prisma__servicevisitClient<$Result.GetResult<Prisma.$servicevisitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicevisit.
     * @param {servicevisitUpdateArgs} args - Arguments to update one Servicevisit.
     * @example
     * // Update one Servicevisit
     * const servicevisit = await prisma.servicevisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends servicevisitUpdateArgs>(args: SelectSubset<T, servicevisitUpdateArgs<ExtArgs>>): Prisma__servicevisitClient<$Result.GetResult<Prisma.$servicevisitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicevisits.
     * @param {servicevisitDeleteManyArgs} args - Arguments to filter Servicevisits to delete.
     * @example
     * // Delete a few Servicevisits
     * const { count } = await prisma.servicevisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends servicevisitDeleteManyArgs>(args?: SelectSubset<T, servicevisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicevisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicevisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicevisits
     * const servicevisit = await prisma.servicevisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends servicevisitUpdateManyArgs>(args: SelectSubset<T, servicevisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicevisit.
     * @param {servicevisitUpsertArgs} args - Arguments to update or create a Servicevisit.
     * @example
     * // Update or create a Servicevisit
     * const servicevisit = await prisma.servicevisit.upsert({
     *   create: {
     *     // ... data to create a Servicevisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicevisit we want to update
     *   }
     * })
     */
    upsert<T extends servicevisitUpsertArgs>(args: SelectSubset<T, servicevisitUpsertArgs<ExtArgs>>): Prisma__servicevisitClient<$Result.GetResult<Prisma.$servicevisitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Servicevisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicevisitCountArgs} args - Arguments to filter Servicevisits to count.
     * @example
     * // Count the number of Servicevisits
     * const count = await prisma.servicevisit.count({
     *   where: {
     *     // ... the filter for the Servicevisits we want to count
     *   }
     * })
    **/
    count<T extends servicevisitCountArgs>(
      args?: Subset<T, servicevisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicevisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicevisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicevisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicevisitAggregateArgs>(args: Subset<T, ServicevisitAggregateArgs>): Prisma.PrismaPromise<GetServicevisitAggregateType<T>>

    /**
     * Group by Servicevisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {servicevisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends servicevisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: servicevisitGroupByArgs['orderBy'] }
        : { orderBy?: servicevisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, servicevisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicevisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the servicevisit model
   */
  readonly fields: servicevisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for servicevisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__servicevisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the servicevisit model
   */ 
  interface servicevisitFieldRefs {
    readonly uid: FieldRef<"servicevisit", 'String'>
    readonly vstotal: FieldRef<"servicevisit", 'Int'>
    readonly vsdetail: FieldRef<"servicevisit", 'String'>
    readonly ym: FieldRef<"servicevisit", 'Int'>
    readonly last_update: FieldRef<"servicevisit", 'DateTime'>
    readonly sign: FieldRef<"servicevisit", 'String'>
    readonly ssid: FieldRef<"servicevisit", 'String'>
    readonly reset: FieldRef<"servicevisit", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * servicevisit findUnique
   */
  export type servicevisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
    /**
     * Filter, which servicevisit to fetch.
     */
    where: servicevisitWhereUniqueInput
  }

  /**
   * servicevisit findUniqueOrThrow
   */
  export type servicevisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
    /**
     * Filter, which servicevisit to fetch.
     */
    where: servicevisitWhereUniqueInput
  }

  /**
   * servicevisit findFirst
   */
  export type servicevisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
    /**
     * Filter, which servicevisit to fetch.
     */
    where?: servicevisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicevisits to fetch.
     */
    orderBy?: servicevisitOrderByWithRelationInput | servicevisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicevisits.
     */
    cursor?: servicevisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicevisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicevisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicevisits.
     */
    distinct?: ServicevisitScalarFieldEnum | ServicevisitScalarFieldEnum[]
  }

  /**
   * servicevisit findFirstOrThrow
   */
  export type servicevisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
    /**
     * Filter, which servicevisit to fetch.
     */
    where?: servicevisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicevisits to fetch.
     */
    orderBy?: servicevisitOrderByWithRelationInput | servicevisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for servicevisits.
     */
    cursor?: servicevisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicevisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicevisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of servicevisits.
     */
    distinct?: ServicevisitScalarFieldEnum | ServicevisitScalarFieldEnum[]
  }

  /**
   * servicevisit findMany
   */
  export type servicevisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
    /**
     * Filter, which servicevisits to fetch.
     */
    where?: servicevisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of servicevisits to fetch.
     */
    orderBy?: servicevisitOrderByWithRelationInput | servicevisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing servicevisits.
     */
    cursor?: servicevisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` servicevisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` servicevisits.
     */
    skip?: number
    distinct?: ServicevisitScalarFieldEnum | ServicevisitScalarFieldEnum[]
  }

  /**
   * servicevisit create
   */
  export type servicevisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
    /**
     * The data needed to create a servicevisit.
     */
    data: XOR<servicevisitCreateInput, servicevisitUncheckedCreateInput>
  }

  /**
   * servicevisit createMany
   */
  export type servicevisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many servicevisits.
     */
    data: servicevisitCreateManyInput | servicevisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * servicevisit update
   */
  export type servicevisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
    /**
     * The data needed to update a servicevisit.
     */
    data: XOR<servicevisitUpdateInput, servicevisitUncheckedUpdateInput>
    /**
     * Choose, which servicevisit to update.
     */
    where: servicevisitWhereUniqueInput
  }

  /**
   * servicevisit updateMany
   */
  export type servicevisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update servicevisits.
     */
    data: XOR<servicevisitUpdateManyMutationInput, servicevisitUncheckedUpdateManyInput>
    /**
     * Filter which servicevisits to update
     */
    where?: servicevisitWhereInput
  }

  /**
   * servicevisit upsert
   */
  export type servicevisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
    /**
     * The filter to search for the servicevisit to update in case it exists.
     */
    where: servicevisitWhereUniqueInput
    /**
     * In case the servicevisit found by the `where` argument doesn't exist, create a new servicevisit with this data.
     */
    create: XOR<servicevisitCreateInput, servicevisitUncheckedCreateInput>
    /**
     * In case the servicevisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<servicevisitUpdateInput, servicevisitUncheckedUpdateInput>
  }

  /**
   * servicevisit delete
   */
  export type servicevisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
    /**
     * Filter which servicevisit to delete.
     */
    where: servicevisitWhereUniqueInput
  }

  /**
   * servicevisit deleteMany
   */
  export type servicevisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which servicevisits to delete
     */
    where?: servicevisitWhereInput
  }

  /**
   * servicevisit without action
   */
  export type servicevisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the servicevisit
     */
    select?: servicevisitSelect<ExtArgs> | null
  }


  /**
   * Model settingtb
   */

  export type AggregateSettingtb = {
    _count: SettingtbCountAggregateOutputType | null
    _avg: SettingtbAvgAggregateOutputType | null
    _sum: SettingtbSumAggregateOutputType | null
    _min: SettingtbMinAggregateOutputType | null
    _max: SettingtbMaxAggregateOutputType | null
  }

  export type SettingtbAvgAggregateOutputType = {
    SettingId: number | null
    Value: number | null
  }

  export type SettingtbSumAggregateOutputType = {
    SettingId: number | null
    Value: number | null
  }

  export type SettingtbMinAggregateOutputType = {
    SettingId: number | null
    Value: number | null
    Data: string | null
    Active: boolean | null
  }

  export type SettingtbMaxAggregateOutputType = {
    SettingId: number | null
    Value: number | null
    Data: string | null
    Active: boolean | null
  }

  export type SettingtbCountAggregateOutputType = {
    SettingId: number
    Value: number
    Data: number
    Active: number
    _all: number
  }


  export type SettingtbAvgAggregateInputType = {
    SettingId?: true
    Value?: true
  }

  export type SettingtbSumAggregateInputType = {
    SettingId?: true
    Value?: true
  }

  export type SettingtbMinAggregateInputType = {
    SettingId?: true
    Value?: true
    Data?: true
    Active?: true
  }

  export type SettingtbMaxAggregateInputType = {
    SettingId?: true
    Value?: true
    Data?: true
    Active?: true
  }

  export type SettingtbCountAggregateInputType = {
    SettingId?: true
    Value?: true
    Data?: true
    Active?: true
    _all?: true
  }

  export type SettingtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settingtb to aggregate.
     */
    where?: settingtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settingtbs to fetch.
     */
    orderBy?: settingtbOrderByWithRelationInput | settingtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settingtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settingtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settingtbs
    **/
    _count?: true | SettingtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingtbMaxAggregateInputType
  }

  export type GetSettingtbAggregateType<T extends SettingtbAggregateArgs> = {
        [P in keyof T & keyof AggregateSettingtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettingtb[P]>
      : GetScalarType<T[P], AggregateSettingtb[P]>
  }




  export type settingtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingtbWhereInput
    orderBy?: settingtbOrderByWithAggregationInput | settingtbOrderByWithAggregationInput[]
    by: SettingtbScalarFieldEnum[] | SettingtbScalarFieldEnum
    having?: settingtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingtbCountAggregateInputType | true
    _avg?: SettingtbAvgAggregateInputType
    _sum?: SettingtbSumAggregateInputType
    _min?: SettingtbMinAggregateInputType
    _max?: SettingtbMaxAggregateInputType
  }

  export type SettingtbGroupByOutputType = {
    SettingId: number
    Value: number
    Data: string
    Active: boolean
    _count: SettingtbCountAggregateOutputType | null
    _avg: SettingtbAvgAggregateOutputType | null
    _sum: SettingtbSumAggregateOutputType | null
    _min: SettingtbMinAggregateOutputType | null
    _max: SettingtbMaxAggregateOutputType | null
  }

  type GetSettingtbGroupByPayload<T extends settingtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingtbGroupByOutputType[P]>
            : GetScalarType<T[P], SettingtbGroupByOutputType[P]>
        }
      >
    >


  export type settingtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SettingId?: boolean
    Value?: boolean
    Data?: boolean
    Active?: boolean
  }, ExtArgs["result"]["settingtb"]>


  export type settingtbSelectScalar = {
    SettingId?: boolean
    Value?: boolean
    Data?: boolean
    Active?: boolean
  }


  export type $settingtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "settingtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SettingId: number
      Value: number
      Data: string
      Active: boolean
    }, ExtArgs["result"]["settingtb"]>
    composites: {}
  }

  type settingtbGetPayload<S extends boolean | null | undefined | settingtbDefaultArgs> = $Result.GetResult<Prisma.$settingtbPayload, S>

  type settingtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<settingtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingtbCountAggregateInputType | true
    }

  export interface settingtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['settingtb'], meta: { name: 'settingtb' } }
    /**
     * Find zero or one Settingtb that matches the filter.
     * @param {settingtbFindUniqueArgs} args - Arguments to find a Settingtb
     * @example
     * // Get one Settingtb
     * const settingtb = await prisma.settingtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settingtbFindUniqueArgs>(args: SelectSubset<T, settingtbFindUniqueArgs<ExtArgs>>): Prisma__settingtbClient<$Result.GetResult<Prisma.$settingtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Settingtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {settingtbFindUniqueOrThrowArgs} args - Arguments to find a Settingtb
     * @example
     * // Get one Settingtb
     * const settingtb = await prisma.settingtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settingtbFindUniqueOrThrowArgs>(args: SelectSubset<T, settingtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__settingtbClient<$Result.GetResult<Prisma.$settingtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Settingtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingtbFindFirstArgs} args - Arguments to find a Settingtb
     * @example
     * // Get one Settingtb
     * const settingtb = await prisma.settingtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settingtbFindFirstArgs>(args?: SelectSubset<T, settingtbFindFirstArgs<ExtArgs>>): Prisma__settingtbClient<$Result.GetResult<Prisma.$settingtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Settingtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingtbFindFirstOrThrowArgs} args - Arguments to find a Settingtb
     * @example
     * // Get one Settingtb
     * const settingtb = await prisma.settingtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settingtbFindFirstOrThrowArgs>(args?: SelectSubset<T, settingtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__settingtbClient<$Result.GetResult<Prisma.$settingtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settingtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settingtbs
     * const settingtbs = await prisma.settingtb.findMany()
     * 
     * // Get first 10 Settingtbs
     * const settingtbs = await prisma.settingtb.findMany({ take: 10 })
     * 
     * // Only select the `SettingId`
     * const settingtbWithSettingIdOnly = await prisma.settingtb.findMany({ select: { SettingId: true } })
     * 
     */
    findMany<T extends settingtbFindManyArgs>(args?: SelectSubset<T, settingtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Settingtb.
     * @param {settingtbCreateArgs} args - Arguments to create a Settingtb.
     * @example
     * // Create one Settingtb
     * const Settingtb = await prisma.settingtb.create({
     *   data: {
     *     // ... data to create a Settingtb
     *   }
     * })
     * 
     */
    create<T extends settingtbCreateArgs>(args: SelectSubset<T, settingtbCreateArgs<ExtArgs>>): Prisma__settingtbClient<$Result.GetResult<Prisma.$settingtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settingtbs.
     * @param {settingtbCreateManyArgs} args - Arguments to create many Settingtbs.
     * @example
     * // Create many Settingtbs
     * const settingtb = await prisma.settingtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends settingtbCreateManyArgs>(args?: SelectSubset<T, settingtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Settingtb.
     * @param {settingtbDeleteArgs} args - Arguments to delete one Settingtb.
     * @example
     * // Delete one Settingtb
     * const Settingtb = await prisma.settingtb.delete({
     *   where: {
     *     // ... filter to delete one Settingtb
     *   }
     * })
     * 
     */
    delete<T extends settingtbDeleteArgs>(args: SelectSubset<T, settingtbDeleteArgs<ExtArgs>>): Prisma__settingtbClient<$Result.GetResult<Prisma.$settingtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Settingtb.
     * @param {settingtbUpdateArgs} args - Arguments to update one Settingtb.
     * @example
     * // Update one Settingtb
     * const settingtb = await prisma.settingtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends settingtbUpdateArgs>(args: SelectSubset<T, settingtbUpdateArgs<ExtArgs>>): Prisma__settingtbClient<$Result.GetResult<Prisma.$settingtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settingtbs.
     * @param {settingtbDeleteManyArgs} args - Arguments to filter Settingtbs to delete.
     * @example
     * // Delete a few Settingtbs
     * const { count } = await prisma.settingtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends settingtbDeleteManyArgs>(args?: SelectSubset<T, settingtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settingtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settingtbs
     * const settingtb = await prisma.settingtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends settingtbUpdateManyArgs>(args: SelectSubset<T, settingtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settingtb.
     * @param {settingtbUpsertArgs} args - Arguments to update or create a Settingtb.
     * @example
     * // Update or create a Settingtb
     * const settingtb = await prisma.settingtb.upsert({
     *   create: {
     *     // ... data to create a Settingtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settingtb we want to update
     *   }
     * })
     */
    upsert<T extends settingtbUpsertArgs>(args: SelectSubset<T, settingtbUpsertArgs<ExtArgs>>): Prisma__settingtbClient<$Result.GetResult<Prisma.$settingtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Settingtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingtbCountArgs} args - Arguments to filter Settingtbs to count.
     * @example
     * // Count the number of Settingtbs
     * const count = await prisma.settingtb.count({
     *   where: {
     *     // ... the filter for the Settingtbs we want to count
     *   }
     * })
    **/
    count<T extends settingtbCountArgs>(
      args?: Subset<T, settingtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settingtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingtbAggregateArgs>(args: Subset<T, SettingtbAggregateArgs>): Prisma.PrismaPromise<GetSettingtbAggregateType<T>>

    /**
     * Group by Settingtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends settingtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingtbGroupByArgs['orderBy'] }
        : { orderBy?: settingtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, settingtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the settingtb model
   */
  readonly fields: settingtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settingtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the settingtb model
   */ 
  interface settingtbFieldRefs {
    readonly SettingId: FieldRef<"settingtb", 'Int'>
    readonly Value: FieldRef<"settingtb", 'Int'>
    readonly Data: FieldRef<"settingtb", 'String'>
    readonly Active: FieldRef<"settingtb", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * settingtb findUnique
   */
  export type settingtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
    /**
     * Filter, which settingtb to fetch.
     */
    where: settingtbWhereUniqueInput
  }

  /**
   * settingtb findUniqueOrThrow
   */
  export type settingtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
    /**
     * Filter, which settingtb to fetch.
     */
    where: settingtbWhereUniqueInput
  }

  /**
   * settingtb findFirst
   */
  export type settingtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
    /**
     * Filter, which settingtb to fetch.
     */
    where?: settingtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settingtbs to fetch.
     */
    orderBy?: settingtbOrderByWithRelationInput | settingtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settingtbs.
     */
    cursor?: settingtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settingtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settingtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settingtbs.
     */
    distinct?: SettingtbScalarFieldEnum | SettingtbScalarFieldEnum[]
  }

  /**
   * settingtb findFirstOrThrow
   */
  export type settingtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
    /**
     * Filter, which settingtb to fetch.
     */
    where?: settingtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settingtbs to fetch.
     */
    orderBy?: settingtbOrderByWithRelationInput | settingtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settingtbs.
     */
    cursor?: settingtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settingtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settingtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settingtbs.
     */
    distinct?: SettingtbScalarFieldEnum | SettingtbScalarFieldEnum[]
  }

  /**
   * settingtb findMany
   */
  export type settingtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
    /**
     * Filter, which settingtbs to fetch.
     */
    where?: settingtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settingtbs to fetch.
     */
    orderBy?: settingtbOrderByWithRelationInput | settingtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settingtbs.
     */
    cursor?: settingtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settingtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settingtbs.
     */
    skip?: number
    distinct?: SettingtbScalarFieldEnum | SettingtbScalarFieldEnum[]
  }

  /**
   * settingtb create
   */
  export type settingtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
    /**
     * The data needed to create a settingtb.
     */
    data: XOR<settingtbCreateInput, settingtbUncheckedCreateInput>
  }

  /**
   * settingtb createMany
   */
  export type settingtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settingtbs.
     */
    data: settingtbCreateManyInput | settingtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * settingtb update
   */
  export type settingtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
    /**
     * The data needed to update a settingtb.
     */
    data: XOR<settingtbUpdateInput, settingtbUncheckedUpdateInput>
    /**
     * Choose, which settingtb to update.
     */
    where: settingtbWhereUniqueInput
  }

  /**
   * settingtb updateMany
   */
  export type settingtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settingtbs.
     */
    data: XOR<settingtbUpdateManyMutationInput, settingtbUncheckedUpdateManyInput>
    /**
     * Filter which settingtbs to update
     */
    where?: settingtbWhereInput
  }

  /**
   * settingtb upsert
   */
  export type settingtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
    /**
     * The filter to search for the settingtb to update in case it exists.
     */
    where: settingtbWhereUniqueInput
    /**
     * In case the settingtb found by the `where` argument doesn't exist, create a new settingtb with this data.
     */
    create: XOR<settingtbCreateInput, settingtbUncheckedCreateInput>
    /**
     * In case the settingtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingtbUpdateInput, settingtbUncheckedUpdateInput>
  }

  /**
   * settingtb delete
   */
  export type settingtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
    /**
     * Filter which settingtb to delete.
     */
    where: settingtbWhereUniqueInput
  }

  /**
   * settingtb deleteMany
   */
  export type settingtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settingtbs to delete
     */
    where?: settingtbWhereInput
  }

  /**
   * settingtb without action
   */
  export type settingtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settingtb
     */
    select?: settingtbSelect<ExtArgs> | null
  }


  /**
   * Model softwaretb
   */

  export type AggregateSoftwaretb = {
    _count: SoftwaretbCountAggregateOutputType | null
    _avg: SoftwaretbAvgAggregateOutputType | null
    _sum: SoftwaretbSumAggregateOutputType | null
    _min: SoftwaretbMinAggregateOutputType | null
    _max: SoftwaretbMaxAggregateOutputType | null
  }

  export type SoftwaretbAvgAggregateOutputType = {
    ID: number | null
    UserId: number | null
    Active: number | null
  }

  export type SoftwaretbSumAggregateOutputType = {
    ID: number | null
    UserId: number | null
    Active: number | null
  }

  export type SoftwaretbMinAggregateOutputType = {
    ID: number | null
    UserId: number | null
    Name: string | null
    Version: string | null
    MAC: string | null
    Active: number | null
  }

  export type SoftwaretbMaxAggregateOutputType = {
    ID: number | null
    UserId: number | null
    Name: string | null
    Version: string | null
    MAC: string | null
    Active: number | null
  }

  export type SoftwaretbCountAggregateOutputType = {
    ID: number
    UserId: number
    Name: number
    Version: number
    MAC: number
    Active: number
    _all: number
  }


  export type SoftwaretbAvgAggregateInputType = {
    ID?: true
    UserId?: true
    Active?: true
  }

  export type SoftwaretbSumAggregateInputType = {
    ID?: true
    UserId?: true
    Active?: true
  }

  export type SoftwaretbMinAggregateInputType = {
    ID?: true
    UserId?: true
    Name?: true
    Version?: true
    MAC?: true
    Active?: true
  }

  export type SoftwaretbMaxAggregateInputType = {
    ID?: true
    UserId?: true
    Name?: true
    Version?: true
    MAC?: true
    Active?: true
  }

  export type SoftwaretbCountAggregateInputType = {
    ID?: true
    UserId?: true
    Name?: true
    Version?: true
    MAC?: true
    Active?: true
    _all?: true
  }

  export type SoftwaretbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which softwaretb to aggregate.
     */
    where?: softwaretbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of softwaretbs to fetch.
     */
    orderBy?: softwaretbOrderByWithRelationInput | softwaretbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: softwaretbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` softwaretbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` softwaretbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned softwaretbs
    **/
    _count?: true | SoftwaretbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SoftwaretbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SoftwaretbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SoftwaretbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SoftwaretbMaxAggregateInputType
  }

  export type GetSoftwaretbAggregateType<T extends SoftwaretbAggregateArgs> = {
        [P in keyof T & keyof AggregateSoftwaretb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSoftwaretb[P]>
      : GetScalarType<T[P], AggregateSoftwaretb[P]>
  }




  export type softwaretbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: softwaretbWhereInput
    orderBy?: softwaretbOrderByWithAggregationInput | softwaretbOrderByWithAggregationInput[]
    by: SoftwaretbScalarFieldEnum[] | SoftwaretbScalarFieldEnum
    having?: softwaretbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SoftwaretbCountAggregateInputType | true
    _avg?: SoftwaretbAvgAggregateInputType
    _sum?: SoftwaretbSumAggregateInputType
    _min?: SoftwaretbMinAggregateInputType
    _max?: SoftwaretbMaxAggregateInputType
  }

  export type SoftwaretbGroupByOutputType = {
    ID: number
    UserId: number
    Name: string
    Version: string
    MAC: string
    Active: number
    _count: SoftwaretbCountAggregateOutputType | null
    _avg: SoftwaretbAvgAggregateOutputType | null
    _sum: SoftwaretbSumAggregateOutputType | null
    _min: SoftwaretbMinAggregateOutputType | null
    _max: SoftwaretbMaxAggregateOutputType | null
  }

  type GetSoftwaretbGroupByPayload<T extends softwaretbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SoftwaretbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SoftwaretbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SoftwaretbGroupByOutputType[P]>
            : GetScalarType<T[P], SoftwaretbGroupByOutputType[P]>
        }
      >
    >


  export type softwaretbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    UserId?: boolean
    Name?: boolean
    Version?: boolean
    MAC?: boolean
    Active?: boolean
  }, ExtArgs["result"]["softwaretb"]>


  export type softwaretbSelectScalar = {
    ID?: boolean
    UserId?: boolean
    Name?: boolean
    Version?: boolean
    MAC?: boolean
    Active?: boolean
  }


  export type $softwaretbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "softwaretb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      UserId: number
      Name: string
      Version: string
      MAC: string
      Active: number
    }, ExtArgs["result"]["softwaretb"]>
    composites: {}
  }

  type softwaretbGetPayload<S extends boolean | null | undefined | softwaretbDefaultArgs> = $Result.GetResult<Prisma.$softwaretbPayload, S>

  type softwaretbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<softwaretbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SoftwaretbCountAggregateInputType | true
    }

  export interface softwaretbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['softwaretb'], meta: { name: 'softwaretb' } }
    /**
     * Find zero or one Softwaretb that matches the filter.
     * @param {softwaretbFindUniqueArgs} args - Arguments to find a Softwaretb
     * @example
     * // Get one Softwaretb
     * const softwaretb = await prisma.softwaretb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends softwaretbFindUniqueArgs>(args: SelectSubset<T, softwaretbFindUniqueArgs<ExtArgs>>): Prisma__softwaretbClient<$Result.GetResult<Prisma.$softwaretbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Softwaretb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {softwaretbFindUniqueOrThrowArgs} args - Arguments to find a Softwaretb
     * @example
     * // Get one Softwaretb
     * const softwaretb = await prisma.softwaretb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends softwaretbFindUniqueOrThrowArgs>(args: SelectSubset<T, softwaretbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__softwaretbClient<$Result.GetResult<Prisma.$softwaretbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Softwaretb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwaretbFindFirstArgs} args - Arguments to find a Softwaretb
     * @example
     * // Get one Softwaretb
     * const softwaretb = await prisma.softwaretb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends softwaretbFindFirstArgs>(args?: SelectSubset<T, softwaretbFindFirstArgs<ExtArgs>>): Prisma__softwaretbClient<$Result.GetResult<Prisma.$softwaretbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Softwaretb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwaretbFindFirstOrThrowArgs} args - Arguments to find a Softwaretb
     * @example
     * // Get one Softwaretb
     * const softwaretb = await prisma.softwaretb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends softwaretbFindFirstOrThrowArgs>(args?: SelectSubset<T, softwaretbFindFirstOrThrowArgs<ExtArgs>>): Prisma__softwaretbClient<$Result.GetResult<Prisma.$softwaretbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Softwaretbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwaretbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Softwaretbs
     * const softwaretbs = await prisma.softwaretb.findMany()
     * 
     * // Get first 10 Softwaretbs
     * const softwaretbs = await prisma.softwaretb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const softwaretbWithIDOnly = await prisma.softwaretb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends softwaretbFindManyArgs>(args?: SelectSubset<T, softwaretbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$softwaretbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Softwaretb.
     * @param {softwaretbCreateArgs} args - Arguments to create a Softwaretb.
     * @example
     * // Create one Softwaretb
     * const Softwaretb = await prisma.softwaretb.create({
     *   data: {
     *     // ... data to create a Softwaretb
     *   }
     * })
     * 
     */
    create<T extends softwaretbCreateArgs>(args: SelectSubset<T, softwaretbCreateArgs<ExtArgs>>): Prisma__softwaretbClient<$Result.GetResult<Prisma.$softwaretbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Softwaretbs.
     * @param {softwaretbCreateManyArgs} args - Arguments to create many Softwaretbs.
     * @example
     * // Create many Softwaretbs
     * const softwaretb = await prisma.softwaretb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends softwaretbCreateManyArgs>(args?: SelectSubset<T, softwaretbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Softwaretb.
     * @param {softwaretbDeleteArgs} args - Arguments to delete one Softwaretb.
     * @example
     * // Delete one Softwaretb
     * const Softwaretb = await prisma.softwaretb.delete({
     *   where: {
     *     // ... filter to delete one Softwaretb
     *   }
     * })
     * 
     */
    delete<T extends softwaretbDeleteArgs>(args: SelectSubset<T, softwaretbDeleteArgs<ExtArgs>>): Prisma__softwaretbClient<$Result.GetResult<Prisma.$softwaretbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Softwaretb.
     * @param {softwaretbUpdateArgs} args - Arguments to update one Softwaretb.
     * @example
     * // Update one Softwaretb
     * const softwaretb = await prisma.softwaretb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends softwaretbUpdateArgs>(args: SelectSubset<T, softwaretbUpdateArgs<ExtArgs>>): Prisma__softwaretbClient<$Result.GetResult<Prisma.$softwaretbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Softwaretbs.
     * @param {softwaretbDeleteManyArgs} args - Arguments to filter Softwaretbs to delete.
     * @example
     * // Delete a few Softwaretbs
     * const { count } = await prisma.softwaretb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends softwaretbDeleteManyArgs>(args?: SelectSubset<T, softwaretbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Softwaretbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwaretbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Softwaretbs
     * const softwaretb = await prisma.softwaretb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends softwaretbUpdateManyArgs>(args: SelectSubset<T, softwaretbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Softwaretb.
     * @param {softwaretbUpsertArgs} args - Arguments to update or create a Softwaretb.
     * @example
     * // Update or create a Softwaretb
     * const softwaretb = await prisma.softwaretb.upsert({
     *   create: {
     *     // ... data to create a Softwaretb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Softwaretb we want to update
     *   }
     * })
     */
    upsert<T extends softwaretbUpsertArgs>(args: SelectSubset<T, softwaretbUpsertArgs<ExtArgs>>): Prisma__softwaretbClient<$Result.GetResult<Prisma.$softwaretbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Softwaretbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwaretbCountArgs} args - Arguments to filter Softwaretbs to count.
     * @example
     * // Count the number of Softwaretbs
     * const count = await prisma.softwaretb.count({
     *   where: {
     *     // ... the filter for the Softwaretbs we want to count
     *   }
     * })
    **/
    count<T extends softwaretbCountArgs>(
      args?: Subset<T, softwaretbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SoftwaretbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Softwaretb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SoftwaretbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SoftwaretbAggregateArgs>(args: Subset<T, SoftwaretbAggregateArgs>): Prisma.PrismaPromise<GetSoftwaretbAggregateType<T>>

    /**
     * Group by Softwaretb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {softwaretbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends softwaretbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: softwaretbGroupByArgs['orderBy'] }
        : { orderBy?: softwaretbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, softwaretbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSoftwaretbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the softwaretb model
   */
  readonly fields: softwaretbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for softwaretb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__softwaretbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the softwaretb model
   */ 
  interface softwaretbFieldRefs {
    readonly ID: FieldRef<"softwaretb", 'Int'>
    readonly UserId: FieldRef<"softwaretb", 'Int'>
    readonly Name: FieldRef<"softwaretb", 'String'>
    readonly Version: FieldRef<"softwaretb", 'String'>
    readonly MAC: FieldRef<"softwaretb", 'String'>
    readonly Active: FieldRef<"softwaretb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * softwaretb findUnique
   */
  export type softwaretbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
    /**
     * Filter, which softwaretb to fetch.
     */
    where: softwaretbWhereUniqueInput
  }

  /**
   * softwaretb findUniqueOrThrow
   */
  export type softwaretbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
    /**
     * Filter, which softwaretb to fetch.
     */
    where: softwaretbWhereUniqueInput
  }

  /**
   * softwaretb findFirst
   */
  export type softwaretbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
    /**
     * Filter, which softwaretb to fetch.
     */
    where?: softwaretbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of softwaretbs to fetch.
     */
    orderBy?: softwaretbOrderByWithRelationInput | softwaretbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for softwaretbs.
     */
    cursor?: softwaretbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` softwaretbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` softwaretbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of softwaretbs.
     */
    distinct?: SoftwaretbScalarFieldEnum | SoftwaretbScalarFieldEnum[]
  }

  /**
   * softwaretb findFirstOrThrow
   */
  export type softwaretbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
    /**
     * Filter, which softwaretb to fetch.
     */
    where?: softwaretbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of softwaretbs to fetch.
     */
    orderBy?: softwaretbOrderByWithRelationInput | softwaretbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for softwaretbs.
     */
    cursor?: softwaretbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` softwaretbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` softwaretbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of softwaretbs.
     */
    distinct?: SoftwaretbScalarFieldEnum | SoftwaretbScalarFieldEnum[]
  }

  /**
   * softwaretb findMany
   */
  export type softwaretbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
    /**
     * Filter, which softwaretbs to fetch.
     */
    where?: softwaretbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of softwaretbs to fetch.
     */
    orderBy?: softwaretbOrderByWithRelationInput | softwaretbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing softwaretbs.
     */
    cursor?: softwaretbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` softwaretbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` softwaretbs.
     */
    skip?: number
    distinct?: SoftwaretbScalarFieldEnum | SoftwaretbScalarFieldEnum[]
  }

  /**
   * softwaretb create
   */
  export type softwaretbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
    /**
     * The data needed to create a softwaretb.
     */
    data?: XOR<softwaretbCreateInput, softwaretbUncheckedCreateInput>
  }

  /**
   * softwaretb createMany
   */
  export type softwaretbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many softwaretbs.
     */
    data: softwaretbCreateManyInput | softwaretbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * softwaretb update
   */
  export type softwaretbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
    /**
     * The data needed to update a softwaretb.
     */
    data: XOR<softwaretbUpdateInput, softwaretbUncheckedUpdateInput>
    /**
     * Choose, which softwaretb to update.
     */
    where: softwaretbWhereUniqueInput
  }

  /**
   * softwaretb updateMany
   */
  export type softwaretbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update softwaretbs.
     */
    data: XOR<softwaretbUpdateManyMutationInput, softwaretbUncheckedUpdateManyInput>
    /**
     * Filter which softwaretbs to update
     */
    where?: softwaretbWhereInput
  }

  /**
   * softwaretb upsert
   */
  export type softwaretbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
    /**
     * The filter to search for the softwaretb to update in case it exists.
     */
    where: softwaretbWhereUniqueInput
    /**
     * In case the softwaretb found by the `where` argument doesn't exist, create a new softwaretb with this data.
     */
    create: XOR<softwaretbCreateInput, softwaretbUncheckedCreateInput>
    /**
     * In case the softwaretb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<softwaretbUpdateInput, softwaretbUncheckedUpdateInput>
  }

  /**
   * softwaretb delete
   */
  export type softwaretbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
    /**
     * Filter which softwaretb to delete.
     */
    where: softwaretbWhereUniqueInput
  }

  /**
   * softwaretb deleteMany
   */
  export type softwaretbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which softwaretbs to delete
     */
    where?: softwaretbWhereInput
  }

  /**
   * softwaretb without action
   */
  export type softwaretbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the softwaretb
     */
    select?: softwaretbSelect<ExtArgs> | null
  }


  /**
   * Model specappdetailtb
   */

  export type AggregateSpecappdetailtb = {
    _count: SpecappdetailtbCountAggregateOutputType | null
    _avg: SpecappdetailtbAvgAggregateOutputType | null
    _sum: SpecappdetailtbSumAggregateOutputType | null
    _min: SpecappdetailtbMinAggregateOutputType | null
    _max: SpecappdetailtbMaxAggregateOutputType | null
  }

  export type SpecappdetailtbAvgAggregateOutputType = {
    ID: number | null
  }

  export type SpecappdetailtbSumAggregateOutputType = {
    ID: number | null
  }

  export type SpecappdetailtbMinAggregateOutputType = {
    ID: number | null
    MachineName: string | null
    AppName: string | null
    Shortcut: string | null
    InstallName: string | null
    InstallVersion: string | null
    InstallLocation: string | null
    LastUpdateDate: Date | null
    Sent: boolean | null
    AppRun: boolean | null
    SubRun: boolean | null
    SubRun2: boolean | null
  }

  export type SpecappdetailtbMaxAggregateOutputType = {
    ID: number | null
    MachineName: string | null
    AppName: string | null
    Shortcut: string | null
    InstallName: string | null
    InstallVersion: string | null
    InstallLocation: string | null
    LastUpdateDate: Date | null
    Sent: boolean | null
    AppRun: boolean | null
    SubRun: boolean | null
    SubRun2: boolean | null
  }

  export type SpecappdetailtbCountAggregateOutputType = {
    ID: number
    MachineName: number
    AppName: number
    Shortcut: number
    InstallName: number
    InstallVersion: number
    InstallLocation: number
    LastUpdateDate: number
    Sent: number
    AppRun: number
    SubRun: number
    SubRun2: number
    _all: number
  }


  export type SpecappdetailtbAvgAggregateInputType = {
    ID?: true
  }

  export type SpecappdetailtbSumAggregateInputType = {
    ID?: true
  }

  export type SpecappdetailtbMinAggregateInputType = {
    ID?: true
    MachineName?: true
    AppName?: true
    Shortcut?: true
    InstallName?: true
    InstallVersion?: true
    InstallLocation?: true
    LastUpdateDate?: true
    Sent?: true
    AppRun?: true
    SubRun?: true
    SubRun2?: true
  }

  export type SpecappdetailtbMaxAggregateInputType = {
    ID?: true
    MachineName?: true
    AppName?: true
    Shortcut?: true
    InstallName?: true
    InstallVersion?: true
    InstallLocation?: true
    LastUpdateDate?: true
    Sent?: true
    AppRun?: true
    SubRun?: true
    SubRun2?: true
  }

  export type SpecappdetailtbCountAggregateInputType = {
    ID?: true
    MachineName?: true
    AppName?: true
    Shortcut?: true
    InstallName?: true
    InstallVersion?: true
    InstallLocation?: true
    LastUpdateDate?: true
    Sent?: true
    AppRun?: true
    SubRun?: true
    SubRun2?: true
    _all?: true
  }

  export type SpecappdetailtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which specappdetailtb to aggregate.
     */
    where?: specappdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specappdetailtbs to fetch.
     */
    orderBy?: specappdetailtbOrderByWithRelationInput | specappdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: specappdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specappdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specappdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned specappdetailtbs
    **/
    _count?: true | SpecappdetailtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecappdetailtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecappdetailtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecappdetailtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecappdetailtbMaxAggregateInputType
  }

  export type GetSpecappdetailtbAggregateType<T extends SpecappdetailtbAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecappdetailtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecappdetailtb[P]>
      : GetScalarType<T[P], AggregateSpecappdetailtb[P]>
  }




  export type specappdetailtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: specappdetailtbWhereInput
    orderBy?: specappdetailtbOrderByWithAggregationInput | specappdetailtbOrderByWithAggregationInput[]
    by: SpecappdetailtbScalarFieldEnum[] | SpecappdetailtbScalarFieldEnum
    having?: specappdetailtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecappdetailtbCountAggregateInputType | true
    _avg?: SpecappdetailtbAvgAggregateInputType
    _sum?: SpecappdetailtbSumAggregateInputType
    _min?: SpecappdetailtbMinAggregateInputType
    _max?: SpecappdetailtbMaxAggregateInputType
  }

  export type SpecappdetailtbGroupByOutputType = {
    ID: number
    MachineName: string
    AppName: string
    Shortcut: string
    InstallName: string
    InstallVersion: string
    InstallLocation: string
    LastUpdateDate: Date
    Sent: boolean
    AppRun: boolean
    SubRun: boolean
    SubRun2: boolean
    _count: SpecappdetailtbCountAggregateOutputType | null
    _avg: SpecappdetailtbAvgAggregateOutputType | null
    _sum: SpecappdetailtbSumAggregateOutputType | null
    _min: SpecappdetailtbMinAggregateOutputType | null
    _max: SpecappdetailtbMaxAggregateOutputType | null
  }

  type GetSpecappdetailtbGroupByPayload<T extends specappdetailtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpecappdetailtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecappdetailtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecappdetailtbGroupByOutputType[P]>
            : GetScalarType<T[P], SpecappdetailtbGroupByOutputType[P]>
        }
      >
    >


  export type specappdetailtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    MachineName?: boolean
    AppName?: boolean
    Shortcut?: boolean
    InstallName?: boolean
    InstallVersion?: boolean
    InstallLocation?: boolean
    LastUpdateDate?: boolean
    Sent?: boolean
    AppRun?: boolean
    SubRun?: boolean
    SubRun2?: boolean
  }, ExtArgs["result"]["specappdetailtb"]>


  export type specappdetailtbSelectScalar = {
    ID?: boolean
    MachineName?: boolean
    AppName?: boolean
    Shortcut?: boolean
    InstallName?: boolean
    InstallVersion?: boolean
    InstallLocation?: boolean
    LastUpdateDate?: boolean
    Sent?: boolean
    AppRun?: boolean
    SubRun?: boolean
    SubRun2?: boolean
  }


  export type $specappdetailtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "specappdetailtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      MachineName: string
      AppName: string
      Shortcut: string
      InstallName: string
      InstallVersion: string
      InstallLocation: string
      LastUpdateDate: Date
      Sent: boolean
      AppRun: boolean
      SubRun: boolean
      SubRun2: boolean
    }, ExtArgs["result"]["specappdetailtb"]>
    composites: {}
  }

  type specappdetailtbGetPayload<S extends boolean | null | undefined | specappdetailtbDefaultArgs> = $Result.GetResult<Prisma.$specappdetailtbPayload, S>

  type specappdetailtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<specappdetailtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpecappdetailtbCountAggregateInputType | true
    }

  export interface specappdetailtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['specappdetailtb'], meta: { name: 'specappdetailtb' } }
    /**
     * Find zero or one Specappdetailtb that matches the filter.
     * @param {specappdetailtbFindUniqueArgs} args - Arguments to find a Specappdetailtb
     * @example
     * // Get one Specappdetailtb
     * const specappdetailtb = await prisma.specappdetailtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends specappdetailtbFindUniqueArgs>(args: SelectSubset<T, specappdetailtbFindUniqueArgs<ExtArgs>>): Prisma__specappdetailtbClient<$Result.GetResult<Prisma.$specappdetailtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Specappdetailtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {specappdetailtbFindUniqueOrThrowArgs} args - Arguments to find a Specappdetailtb
     * @example
     * // Get one Specappdetailtb
     * const specappdetailtb = await prisma.specappdetailtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends specappdetailtbFindUniqueOrThrowArgs>(args: SelectSubset<T, specappdetailtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__specappdetailtbClient<$Result.GetResult<Prisma.$specappdetailtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Specappdetailtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specappdetailtbFindFirstArgs} args - Arguments to find a Specappdetailtb
     * @example
     * // Get one Specappdetailtb
     * const specappdetailtb = await prisma.specappdetailtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends specappdetailtbFindFirstArgs>(args?: SelectSubset<T, specappdetailtbFindFirstArgs<ExtArgs>>): Prisma__specappdetailtbClient<$Result.GetResult<Prisma.$specappdetailtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Specappdetailtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specappdetailtbFindFirstOrThrowArgs} args - Arguments to find a Specappdetailtb
     * @example
     * // Get one Specappdetailtb
     * const specappdetailtb = await prisma.specappdetailtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends specappdetailtbFindFirstOrThrowArgs>(args?: SelectSubset<T, specappdetailtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__specappdetailtbClient<$Result.GetResult<Prisma.$specappdetailtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Specappdetailtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specappdetailtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specappdetailtbs
     * const specappdetailtbs = await prisma.specappdetailtb.findMany()
     * 
     * // Get first 10 Specappdetailtbs
     * const specappdetailtbs = await prisma.specappdetailtb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const specappdetailtbWithIDOnly = await prisma.specappdetailtb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends specappdetailtbFindManyArgs>(args?: SelectSubset<T, specappdetailtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$specappdetailtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Specappdetailtb.
     * @param {specappdetailtbCreateArgs} args - Arguments to create a Specappdetailtb.
     * @example
     * // Create one Specappdetailtb
     * const Specappdetailtb = await prisma.specappdetailtb.create({
     *   data: {
     *     // ... data to create a Specappdetailtb
     *   }
     * })
     * 
     */
    create<T extends specappdetailtbCreateArgs>(args: SelectSubset<T, specappdetailtbCreateArgs<ExtArgs>>): Prisma__specappdetailtbClient<$Result.GetResult<Prisma.$specappdetailtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Specappdetailtbs.
     * @param {specappdetailtbCreateManyArgs} args - Arguments to create many Specappdetailtbs.
     * @example
     * // Create many Specappdetailtbs
     * const specappdetailtb = await prisma.specappdetailtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends specappdetailtbCreateManyArgs>(args?: SelectSubset<T, specappdetailtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Specappdetailtb.
     * @param {specappdetailtbDeleteArgs} args - Arguments to delete one Specappdetailtb.
     * @example
     * // Delete one Specappdetailtb
     * const Specappdetailtb = await prisma.specappdetailtb.delete({
     *   where: {
     *     // ... filter to delete one Specappdetailtb
     *   }
     * })
     * 
     */
    delete<T extends specappdetailtbDeleteArgs>(args: SelectSubset<T, specappdetailtbDeleteArgs<ExtArgs>>): Prisma__specappdetailtbClient<$Result.GetResult<Prisma.$specappdetailtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Specappdetailtb.
     * @param {specappdetailtbUpdateArgs} args - Arguments to update one Specappdetailtb.
     * @example
     * // Update one Specappdetailtb
     * const specappdetailtb = await prisma.specappdetailtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends specappdetailtbUpdateArgs>(args: SelectSubset<T, specappdetailtbUpdateArgs<ExtArgs>>): Prisma__specappdetailtbClient<$Result.GetResult<Prisma.$specappdetailtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Specappdetailtbs.
     * @param {specappdetailtbDeleteManyArgs} args - Arguments to filter Specappdetailtbs to delete.
     * @example
     * // Delete a few Specappdetailtbs
     * const { count } = await prisma.specappdetailtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends specappdetailtbDeleteManyArgs>(args?: SelectSubset<T, specappdetailtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specappdetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specappdetailtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specappdetailtbs
     * const specappdetailtb = await prisma.specappdetailtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends specappdetailtbUpdateManyArgs>(args: SelectSubset<T, specappdetailtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Specappdetailtb.
     * @param {specappdetailtbUpsertArgs} args - Arguments to update or create a Specappdetailtb.
     * @example
     * // Update or create a Specappdetailtb
     * const specappdetailtb = await prisma.specappdetailtb.upsert({
     *   create: {
     *     // ... data to create a Specappdetailtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specappdetailtb we want to update
     *   }
     * })
     */
    upsert<T extends specappdetailtbUpsertArgs>(args: SelectSubset<T, specappdetailtbUpsertArgs<ExtArgs>>): Prisma__specappdetailtbClient<$Result.GetResult<Prisma.$specappdetailtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Specappdetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specappdetailtbCountArgs} args - Arguments to filter Specappdetailtbs to count.
     * @example
     * // Count the number of Specappdetailtbs
     * const count = await prisma.specappdetailtb.count({
     *   where: {
     *     // ... the filter for the Specappdetailtbs we want to count
     *   }
     * })
    **/
    count<T extends specappdetailtbCountArgs>(
      args?: Subset<T, specappdetailtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecappdetailtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specappdetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecappdetailtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecappdetailtbAggregateArgs>(args: Subset<T, SpecappdetailtbAggregateArgs>): Prisma.PrismaPromise<GetSpecappdetailtbAggregateType<T>>

    /**
     * Group by Specappdetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {specappdetailtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends specappdetailtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: specappdetailtbGroupByArgs['orderBy'] }
        : { orderBy?: specappdetailtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, specappdetailtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecappdetailtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the specappdetailtb model
   */
  readonly fields: specappdetailtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for specappdetailtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__specappdetailtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the specappdetailtb model
   */ 
  interface specappdetailtbFieldRefs {
    readonly ID: FieldRef<"specappdetailtb", 'Int'>
    readonly MachineName: FieldRef<"specappdetailtb", 'String'>
    readonly AppName: FieldRef<"specappdetailtb", 'String'>
    readonly Shortcut: FieldRef<"specappdetailtb", 'String'>
    readonly InstallName: FieldRef<"specappdetailtb", 'String'>
    readonly InstallVersion: FieldRef<"specappdetailtb", 'String'>
    readonly InstallLocation: FieldRef<"specappdetailtb", 'String'>
    readonly LastUpdateDate: FieldRef<"specappdetailtb", 'DateTime'>
    readonly Sent: FieldRef<"specappdetailtb", 'Boolean'>
    readonly AppRun: FieldRef<"specappdetailtb", 'Boolean'>
    readonly SubRun: FieldRef<"specappdetailtb", 'Boolean'>
    readonly SubRun2: FieldRef<"specappdetailtb", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * specappdetailtb findUnique
   */
  export type specappdetailtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which specappdetailtb to fetch.
     */
    where: specappdetailtbWhereUniqueInput
  }

  /**
   * specappdetailtb findUniqueOrThrow
   */
  export type specappdetailtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which specappdetailtb to fetch.
     */
    where: specappdetailtbWhereUniqueInput
  }

  /**
   * specappdetailtb findFirst
   */
  export type specappdetailtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which specappdetailtb to fetch.
     */
    where?: specappdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specappdetailtbs to fetch.
     */
    orderBy?: specappdetailtbOrderByWithRelationInput | specappdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for specappdetailtbs.
     */
    cursor?: specappdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specappdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specappdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of specappdetailtbs.
     */
    distinct?: SpecappdetailtbScalarFieldEnum | SpecappdetailtbScalarFieldEnum[]
  }

  /**
   * specappdetailtb findFirstOrThrow
   */
  export type specappdetailtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which specappdetailtb to fetch.
     */
    where?: specappdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specappdetailtbs to fetch.
     */
    orderBy?: specappdetailtbOrderByWithRelationInput | specappdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for specappdetailtbs.
     */
    cursor?: specappdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specappdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specappdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of specappdetailtbs.
     */
    distinct?: SpecappdetailtbScalarFieldEnum | SpecappdetailtbScalarFieldEnum[]
  }

  /**
   * specappdetailtb findMany
   */
  export type specappdetailtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which specappdetailtbs to fetch.
     */
    where?: specappdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of specappdetailtbs to fetch.
     */
    orderBy?: specappdetailtbOrderByWithRelationInput | specappdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing specappdetailtbs.
     */
    cursor?: specappdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` specappdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` specappdetailtbs.
     */
    skip?: number
    distinct?: SpecappdetailtbScalarFieldEnum | SpecappdetailtbScalarFieldEnum[]
  }

  /**
   * specappdetailtb create
   */
  export type specappdetailtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
    /**
     * The data needed to create a specappdetailtb.
     */
    data: XOR<specappdetailtbCreateInput, specappdetailtbUncheckedCreateInput>
  }

  /**
   * specappdetailtb createMany
   */
  export type specappdetailtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many specappdetailtbs.
     */
    data: specappdetailtbCreateManyInput | specappdetailtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * specappdetailtb update
   */
  export type specappdetailtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
    /**
     * The data needed to update a specappdetailtb.
     */
    data: XOR<specappdetailtbUpdateInput, specappdetailtbUncheckedUpdateInput>
    /**
     * Choose, which specappdetailtb to update.
     */
    where: specappdetailtbWhereUniqueInput
  }

  /**
   * specappdetailtb updateMany
   */
  export type specappdetailtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update specappdetailtbs.
     */
    data: XOR<specappdetailtbUpdateManyMutationInput, specappdetailtbUncheckedUpdateManyInput>
    /**
     * Filter which specappdetailtbs to update
     */
    where?: specappdetailtbWhereInput
  }

  /**
   * specappdetailtb upsert
   */
  export type specappdetailtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
    /**
     * The filter to search for the specappdetailtb to update in case it exists.
     */
    where: specappdetailtbWhereUniqueInput
    /**
     * In case the specappdetailtb found by the `where` argument doesn't exist, create a new specappdetailtb with this data.
     */
    create: XOR<specappdetailtbCreateInput, specappdetailtbUncheckedCreateInput>
    /**
     * In case the specappdetailtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<specappdetailtbUpdateInput, specappdetailtbUncheckedUpdateInput>
  }

  /**
   * specappdetailtb delete
   */
  export type specappdetailtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
    /**
     * Filter which specappdetailtb to delete.
     */
    where: specappdetailtbWhereUniqueInput
  }

  /**
   * specappdetailtb deleteMany
   */
  export type specappdetailtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which specappdetailtbs to delete
     */
    where?: specappdetailtbWhereInput
  }

  /**
   * specappdetailtb without action
   */
  export type specappdetailtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the specappdetailtb
     */
    select?: specappdetailtbSelect<ExtArgs> | null
  }


  /**
   * Model standardservicetb
   */

  export type AggregateStandardservicetb = {
    _count: StandardservicetbCountAggregateOutputType | null
    _avg: StandardservicetbAvgAggregateOutputType | null
    _sum: StandardservicetbSumAggregateOutputType | null
    _min: StandardservicetbMinAggregateOutputType | null
    _max: StandardservicetbMaxAggregateOutputType | null
  }

  export type StandardservicetbAvgAggregateOutputType = {
    StandardServiceId: number | null
    StandardServiceGroupID: number | null
    Active: number | null
  }

  export type StandardservicetbSumAggregateOutputType = {
    StandardServiceId: number | null
    StandardServiceGroupID: number | null
    Active: number | null
  }

  export type StandardservicetbMinAggregateOutputType = {
    StandardServiceId: number | null
    StandardServiceName: string | null
    StandardServiceGroupID: number | null
    Active: number | null
  }

  export type StandardservicetbMaxAggregateOutputType = {
    StandardServiceId: number | null
    StandardServiceName: string | null
    StandardServiceGroupID: number | null
    Active: number | null
  }

  export type StandardservicetbCountAggregateOutputType = {
    StandardServiceId: number
    StandardServiceName: number
    StandardServiceGroupID: number
    Active: number
    _all: number
  }


  export type StandardservicetbAvgAggregateInputType = {
    StandardServiceId?: true
    StandardServiceGroupID?: true
    Active?: true
  }

  export type StandardservicetbSumAggregateInputType = {
    StandardServiceId?: true
    StandardServiceGroupID?: true
    Active?: true
  }

  export type StandardservicetbMinAggregateInputType = {
    StandardServiceId?: true
    StandardServiceName?: true
    StandardServiceGroupID?: true
    Active?: true
  }

  export type StandardservicetbMaxAggregateInputType = {
    StandardServiceId?: true
    StandardServiceName?: true
    StandardServiceGroupID?: true
    Active?: true
  }

  export type StandardservicetbCountAggregateInputType = {
    StandardServiceId?: true
    StandardServiceName?: true
    StandardServiceGroupID?: true
    Active?: true
    _all?: true
  }

  export type StandardservicetbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which standardservicetb to aggregate.
     */
    where?: standardservicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of standardservicetbs to fetch.
     */
    orderBy?: standardservicetbOrderByWithRelationInput | standardservicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: standardservicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` standardservicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` standardservicetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned standardservicetbs
    **/
    _count?: true | StandardservicetbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StandardservicetbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StandardservicetbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StandardservicetbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StandardservicetbMaxAggregateInputType
  }

  export type GetStandardservicetbAggregateType<T extends StandardservicetbAggregateArgs> = {
        [P in keyof T & keyof AggregateStandardservicetb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStandardservicetb[P]>
      : GetScalarType<T[P], AggregateStandardservicetb[P]>
  }




  export type standardservicetbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: standardservicetbWhereInput
    orderBy?: standardservicetbOrderByWithAggregationInput | standardservicetbOrderByWithAggregationInput[]
    by: StandardservicetbScalarFieldEnum[] | StandardservicetbScalarFieldEnum
    having?: standardservicetbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StandardservicetbCountAggregateInputType | true
    _avg?: StandardservicetbAvgAggregateInputType
    _sum?: StandardservicetbSumAggregateInputType
    _min?: StandardservicetbMinAggregateInputType
    _max?: StandardservicetbMaxAggregateInputType
  }

  export type StandardservicetbGroupByOutputType = {
    StandardServiceId: number
    StandardServiceName: string
    StandardServiceGroupID: number
    Active: number
    _count: StandardservicetbCountAggregateOutputType | null
    _avg: StandardservicetbAvgAggregateOutputType | null
    _sum: StandardservicetbSumAggregateOutputType | null
    _min: StandardservicetbMinAggregateOutputType | null
    _max: StandardservicetbMaxAggregateOutputType | null
  }

  type GetStandardservicetbGroupByPayload<T extends standardservicetbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StandardservicetbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StandardservicetbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StandardservicetbGroupByOutputType[P]>
            : GetScalarType<T[P], StandardservicetbGroupByOutputType[P]>
        }
      >
    >


  export type standardservicetbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    StandardServiceId?: boolean
    StandardServiceName?: boolean
    StandardServiceGroupID?: boolean
    Active?: boolean
  }, ExtArgs["result"]["standardservicetb"]>


  export type standardservicetbSelectScalar = {
    StandardServiceId?: boolean
    StandardServiceName?: boolean
    StandardServiceGroupID?: boolean
    Active?: boolean
  }


  export type $standardservicetbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "standardservicetb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      StandardServiceId: number
      StandardServiceName: string
      StandardServiceGroupID: number
      Active: number
    }, ExtArgs["result"]["standardservicetb"]>
    composites: {}
  }

  type standardservicetbGetPayload<S extends boolean | null | undefined | standardservicetbDefaultArgs> = $Result.GetResult<Prisma.$standardservicetbPayload, S>

  type standardservicetbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<standardservicetbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StandardservicetbCountAggregateInputType | true
    }

  export interface standardservicetbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['standardservicetb'], meta: { name: 'standardservicetb' } }
    /**
     * Find zero or one Standardservicetb that matches the filter.
     * @param {standardservicetbFindUniqueArgs} args - Arguments to find a Standardservicetb
     * @example
     * // Get one Standardservicetb
     * const standardservicetb = await prisma.standardservicetb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends standardservicetbFindUniqueArgs>(args: SelectSubset<T, standardservicetbFindUniqueArgs<ExtArgs>>): Prisma__standardservicetbClient<$Result.GetResult<Prisma.$standardservicetbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Standardservicetb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {standardservicetbFindUniqueOrThrowArgs} args - Arguments to find a Standardservicetb
     * @example
     * // Get one Standardservicetb
     * const standardservicetb = await prisma.standardservicetb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends standardservicetbFindUniqueOrThrowArgs>(args: SelectSubset<T, standardservicetbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__standardservicetbClient<$Result.GetResult<Prisma.$standardservicetbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Standardservicetb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {standardservicetbFindFirstArgs} args - Arguments to find a Standardservicetb
     * @example
     * // Get one Standardservicetb
     * const standardservicetb = await prisma.standardservicetb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends standardservicetbFindFirstArgs>(args?: SelectSubset<T, standardservicetbFindFirstArgs<ExtArgs>>): Prisma__standardservicetbClient<$Result.GetResult<Prisma.$standardservicetbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Standardservicetb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {standardservicetbFindFirstOrThrowArgs} args - Arguments to find a Standardservicetb
     * @example
     * // Get one Standardservicetb
     * const standardservicetb = await prisma.standardservicetb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends standardservicetbFindFirstOrThrowArgs>(args?: SelectSubset<T, standardservicetbFindFirstOrThrowArgs<ExtArgs>>): Prisma__standardservicetbClient<$Result.GetResult<Prisma.$standardservicetbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Standardservicetbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {standardservicetbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Standardservicetbs
     * const standardservicetbs = await prisma.standardservicetb.findMany()
     * 
     * // Get first 10 Standardservicetbs
     * const standardservicetbs = await prisma.standardservicetb.findMany({ take: 10 })
     * 
     * // Only select the `StandardServiceId`
     * const standardservicetbWithStandardServiceIdOnly = await prisma.standardservicetb.findMany({ select: { StandardServiceId: true } })
     * 
     */
    findMany<T extends standardservicetbFindManyArgs>(args?: SelectSubset<T, standardservicetbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$standardservicetbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Standardservicetb.
     * @param {standardservicetbCreateArgs} args - Arguments to create a Standardservicetb.
     * @example
     * // Create one Standardservicetb
     * const Standardservicetb = await prisma.standardservicetb.create({
     *   data: {
     *     // ... data to create a Standardservicetb
     *   }
     * })
     * 
     */
    create<T extends standardservicetbCreateArgs>(args: SelectSubset<T, standardservicetbCreateArgs<ExtArgs>>): Prisma__standardservicetbClient<$Result.GetResult<Prisma.$standardservicetbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Standardservicetbs.
     * @param {standardservicetbCreateManyArgs} args - Arguments to create many Standardservicetbs.
     * @example
     * // Create many Standardservicetbs
     * const standardservicetb = await prisma.standardservicetb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends standardservicetbCreateManyArgs>(args?: SelectSubset<T, standardservicetbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Standardservicetb.
     * @param {standardservicetbDeleteArgs} args - Arguments to delete one Standardservicetb.
     * @example
     * // Delete one Standardservicetb
     * const Standardservicetb = await prisma.standardservicetb.delete({
     *   where: {
     *     // ... filter to delete one Standardservicetb
     *   }
     * })
     * 
     */
    delete<T extends standardservicetbDeleteArgs>(args: SelectSubset<T, standardservicetbDeleteArgs<ExtArgs>>): Prisma__standardservicetbClient<$Result.GetResult<Prisma.$standardservicetbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Standardservicetb.
     * @param {standardservicetbUpdateArgs} args - Arguments to update one Standardservicetb.
     * @example
     * // Update one Standardservicetb
     * const standardservicetb = await prisma.standardservicetb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends standardservicetbUpdateArgs>(args: SelectSubset<T, standardservicetbUpdateArgs<ExtArgs>>): Prisma__standardservicetbClient<$Result.GetResult<Prisma.$standardservicetbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Standardservicetbs.
     * @param {standardservicetbDeleteManyArgs} args - Arguments to filter Standardservicetbs to delete.
     * @example
     * // Delete a few Standardservicetbs
     * const { count } = await prisma.standardservicetb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends standardservicetbDeleteManyArgs>(args?: SelectSubset<T, standardservicetbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Standardservicetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {standardservicetbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Standardservicetbs
     * const standardservicetb = await prisma.standardservicetb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends standardservicetbUpdateManyArgs>(args: SelectSubset<T, standardservicetbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Standardservicetb.
     * @param {standardservicetbUpsertArgs} args - Arguments to update or create a Standardservicetb.
     * @example
     * // Update or create a Standardservicetb
     * const standardservicetb = await prisma.standardservicetb.upsert({
     *   create: {
     *     // ... data to create a Standardservicetb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Standardservicetb we want to update
     *   }
     * })
     */
    upsert<T extends standardservicetbUpsertArgs>(args: SelectSubset<T, standardservicetbUpsertArgs<ExtArgs>>): Prisma__standardservicetbClient<$Result.GetResult<Prisma.$standardservicetbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Standardservicetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {standardservicetbCountArgs} args - Arguments to filter Standardservicetbs to count.
     * @example
     * // Count the number of Standardservicetbs
     * const count = await prisma.standardservicetb.count({
     *   where: {
     *     // ... the filter for the Standardservicetbs we want to count
     *   }
     * })
    **/
    count<T extends standardservicetbCountArgs>(
      args?: Subset<T, standardservicetbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StandardservicetbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Standardservicetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StandardservicetbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StandardservicetbAggregateArgs>(args: Subset<T, StandardservicetbAggregateArgs>): Prisma.PrismaPromise<GetStandardservicetbAggregateType<T>>

    /**
     * Group by Standardservicetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {standardservicetbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends standardservicetbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: standardservicetbGroupByArgs['orderBy'] }
        : { orderBy?: standardservicetbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, standardservicetbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStandardservicetbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the standardservicetb model
   */
  readonly fields: standardservicetbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for standardservicetb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__standardservicetbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the standardservicetb model
   */ 
  interface standardservicetbFieldRefs {
    readonly StandardServiceId: FieldRef<"standardservicetb", 'Int'>
    readonly StandardServiceName: FieldRef<"standardservicetb", 'String'>
    readonly StandardServiceGroupID: FieldRef<"standardservicetb", 'Int'>
    readonly Active: FieldRef<"standardservicetb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * standardservicetb findUnique
   */
  export type standardservicetbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
    /**
     * Filter, which standardservicetb to fetch.
     */
    where: standardservicetbWhereUniqueInput
  }

  /**
   * standardservicetb findUniqueOrThrow
   */
  export type standardservicetbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
    /**
     * Filter, which standardservicetb to fetch.
     */
    where: standardservicetbWhereUniqueInput
  }

  /**
   * standardservicetb findFirst
   */
  export type standardservicetbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
    /**
     * Filter, which standardservicetb to fetch.
     */
    where?: standardservicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of standardservicetbs to fetch.
     */
    orderBy?: standardservicetbOrderByWithRelationInput | standardservicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for standardservicetbs.
     */
    cursor?: standardservicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` standardservicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` standardservicetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of standardservicetbs.
     */
    distinct?: StandardservicetbScalarFieldEnum | StandardservicetbScalarFieldEnum[]
  }

  /**
   * standardservicetb findFirstOrThrow
   */
  export type standardservicetbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
    /**
     * Filter, which standardservicetb to fetch.
     */
    where?: standardservicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of standardservicetbs to fetch.
     */
    orderBy?: standardservicetbOrderByWithRelationInput | standardservicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for standardservicetbs.
     */
    cursor?: standardservicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` standardservicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` standardservicetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of standardservicetbs.
     */
    distinct?: StandardservicetbScalarFieldEnum | StandardservicetbScalarFieldEnum[]
  }

  /**
   * standardservicetb findMany
   */
  export type standardservicetbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
    /**
     * Filter, which standardservicetbs to fetch.
     */
    where?: standardservicetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of standardservicetbs to fetch.
     */
    orderBy?: standardservicetbOrderByWithRelationInput | standardservicetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing standardservicetbs.
     */
    cursor?: standardservicetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` standardservicetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` standardservicetbs.
     */
    skip?: number
    distinct?: StandardservicetbScalarFieldEnum | StandardservicetbScalarFieldEnum[]
  }

  /**
   * standardservicetb create
   */
  export type standardservicetbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
    /**
     * The data needed to create a standardservicetb.
     */
    data?: XOR<standardservicetbCreateInput, standardservicetbUncheckedCreateInput>
  }

  /**
   * standardservicetb createMany
   */
  export type standardservicetbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many standardservicetbs.
     */
    data: standardservicetbCreateManyInput | standardservicetbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * standardservicetb update
   */
  export type standardservicetbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
    /**
     * The data needed to update a standardservicetb.
     */
    data: XOR<standardservicetbUpdateInput, standardservicetbUncheckedUpdateInput>
    /**
     * Choose, which standardservicetb to update.
     */
    where: standardservicetbWhereUniqueInput
  }

  /**
   * standardservicetb updateMany
   */
  export type standardservicetbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update standardservicetbs.
     */
    data: XOR<standardservicetbUpdateManyMutationInput, standardservicetbUncheckedUpdateManyInput>
    /**
     * Filter which standardservicetbs to update
     */
    where?: standardservicetbWhereInput
  }

  /**
   * standardservicetb upsert
   */
  export type standardservicetbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
    /**
     * The filter to search for the standardservicetb to update in case it exists.
     */
    where: standardservicetbWhereUniqueInput
    /**
     * In case the standardservicetb found by the `where` argument doesn't exist, create a new standardservicetb with this data.
     */
    create: XOR<standardservicetbCreateInput, standardservicetbUncheckedCreateInput>
    /**
     * In case the standardservicetb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<standardservicetbUpdateInput, standardservicetbUncheckedUpdateInput>
  }

  /**
   * standardservicetb delete
   */
  export type standardservicetbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
    /**
     * Filter which standardservicetb to delete.
     */
    where: standardservicetbWhereUniqueInput
  }

  /**
   * standardservicetb deleteMany
   */
  export type standardservicetbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which standardservicetbs to delete
     */
    where?: standardservicetbWhereInput
  }

  /**
   * standardservicetb without action
   */
  export type standardservicetbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the standardservicetb
     */
    select?: standardservicetbSelect<ExtArgs> | null
  }


  /**
   * Model stocktakingtb
   */

  export type AggregateStocktakingtb = {
    _count: StocktakingtbCountAggregateOutputType | null
    _avg: StocktakingtbAvgAggregateOutputType | null
    _sum: StocktakingtbSumAggregateOutputType | null
    _min: StocktakingtbMinAggregateOutputType | null
    _max: StocktakingtbMaxAggregateOutputType | null
  }

  export type StocktakingtbAvgAggregateOutputType = {
    ID: number | null
    StaffID: number | null
    NumInventoryExpected: number | null
    NumInventoryReal: number | null
    NumAdjust: number | null
    NumPreAdjust: number | null
    ServiceID: number | null
  }

  export type StocktakingtbSumAggregateOutputType = {
    ID: number | null
    StaffID: number | null
    NumInventoryExpected: number | null
    NumInventoryReal: number | null
    NumAdjust: number | null
    NumPreAdjust: number | null
    ServiceID: number | null
  }

  export type StocktakingtbMinAggregateOutputType = {
    ID: number | null
    CreateDate: Date | null
    CreateTime: Date | null
    StaffID: number | null
    NumInventoryExpected: number | null
    NumInventoryReal: number | null
    NumAdjust: number | null
    NumPreAdjust: number | null
    Note: string | null
    ServiceID: number | null
  }

  export type StocktakingtbMaxAggregateOutputType = {
    ID: number | null
    CreateDate: Date | null
    CreateTime: Date | null
    StaffID: number | null
    NumInventoryExpected: number | null
    NumInventoryReal: number | null
    NumAdjust: number | null
    NumPreAdjust: number | null
    Note: string | null
    ServiceID: number | null
  }

  export type StocktakingtbCountAggregateOutputType = {
    ID: number
    CreateDate: number
    CreateTime: number
    StaffID: number
    NumInventoryExpected: number
    NumInventoryReal: number
    NumAdjust: number
    NumPreAdjust: number
    Note: number
    ServiceID: number
    _all: number
  }


  export type StocktakingtbAvgAggregateInputType = {
    ID?: true
    StaffID?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    NumPreAdjust?: true
    ServiceID?: true
  }

  export type StocktakingtbSumAggregateInputType = {
    ID?: true
    StaffID?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    NumPreAdjust?: true
    ServiceID?: true
  }

  export type StocktakingtbMinAggregateInputType = {
    ID?: true
    CreateDate?: true
    CreateTime?: true
    StaffID?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    NumPreAdjust?: true
    Note?: true
    ServiceID?: true
  }

  export type StocktakingtbMaxAggregateInputType = {
    ID?: true
    CreateDate?: true
    CreateTime?: true
    StaffID?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    NumPreAdjust?: true
    Note?: true
    ServiceID?: true
  }

  export type StocktakingtbCountAggregateInputType = {
    ID?: true
    CreateDate?: true
    CreateTime?: true
    StaffID?: true
    NumInventoryExpected?: true
    NumInventoryReal?: true
    NumAdjust?: true
    NumPreAdjust?: true
    Note?: true
    ServiceID?: true
    _all?: true
  }

  export type StocktakingtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stocktakingtb to aggregate.
     */
    where?: stocktakingtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stocktakingtbs to fetch.
     */
    orderBy?: stocktakingtbOrderByWithRelationInput | stocktakingtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: stocktakingtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stocktakingtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stocktakingtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stocktakingtbs
    **/
    _count?: true | StocktakingtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StocktakingtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StocktakingtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StocktakingtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StocktakingtbMaxAggregateInputType
  }

  export type GetStocktakingtbAggregateType<T extends StocktakingtbAggregateArgs> = {
        [P in keyof T & keyof AggregateStocktakingtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStocktakingtb[P]>
      : GetScalarType<T[P], AggregateStocktakingtb[P]>
  }




  export type stocktakingtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: stocktakingtbWhereInput
    orderBy?: stocktakingtbOrderByWithAggregationInput | stocktakingtbOrderByWithAggregationInput[]
    by: StocktakingtbScalarFieldEnum[] | StocktakingtbScalarFieldEnum
    having?: stocktakingtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StocktakingtbCountAggregateInputType | true
    _avg?: StocktakingtbAvgAggregateInputType
    _sum?: StocktakingtbSumAggregateInputType
    _min?: StocktakingtbMinAggregateInputType
    _max?: StocktakingtbMaxAggregateInputType
  }

  export type StocktakingtbGroupByOutputType = {
    ID: number
    CreateDate: Date
    CreateTime: Date
    StaffID: number
    NumInventoryExpected: number
    NumInventoryReal: number
    NumAdjust: number
    NumPreAdjust: number
    Note: string | null
    ServiceID: number
    _count: StocktakingtbCountAggregateOutputType | null
    _avg: StocktakingtbAvgAggregateOutputType | null
    _sum: StocktakingtbSumAggregateOutputType | null
    _min: StocktakingtbMinAggregateOutputType | null
    _max: StocktakingtbMaxAggregateOutputType | null
  }

  type GetStocktakingtbGroupByPayload<T extends stocktakingtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StocktakingtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StocktakingtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StocktakingtbGroupByOutputType[P]>
            : GetScalarType<T[P], StocktakingtbGroupByOutputType[P]>
        }
      >
    >


  export type stocktakingtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    StaffID?: boolean
    NumInventoryExpected?: boolean
    NumInventoryReal?: boolean
    NumAdjust?: boolean
    NumPreAdjust?: boolean
    Note?: boolean
    ServiceID?: boolean
  }, ExtArgs["result"]["stocktakingtb"]>


  export type stocktakingtbSelectScalar = {
    ID?: boolean
    CreateDate?: boolean
    CreateTime?: boolean
    StaffID?: boolean
    NumInventoryExpected?: boolean
    NumInventoryReal?: boolean
    NumAdjust?: boolean
    NumPreAdjust?: boolean
    Note?: boolean
    ServiceID?: boolean
  }


  export type $stocktakingtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stocktakingtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      CreateDate: Date
      CreateTime: Date
      StaffID: number
      NumInventoryExpected: number
      NumInventoryReal: number
      NumAdjust: number
      NumPreAdjust: number
      Note: string | null
      ServiceID: number
    }, ExtArgs["result"]["stocktakingtb"]>
    composites: {}
  }

  type stocktakingtbGetPayload<S extends boolean | null | undefined | stocktakingtbDefaultArgs> = $Result.GetResult<Prisma.$stocktakingtbPayload, S>

  type stocktakingtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<stocktakingtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StocktakingtbCountAggregateInputType | true
    }

  export interface stocktakingtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stocktakingtb'], meta: { name: 'stocktakingtb' } }
    /**
     * Find zero or one Stocktakingtb that matches the filter.
     * @param {stocktakingtbFindUniqueArgs} args - Arguments to find a Stocktakingtb
     * @example
     * // Get one Stocktakingtb
     * const stocktakingtb = await prisma.stocktakingtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends stocktakingtbFindUniqueArgs>(args: SelectSubset<T, stocktakingtbFindUniqueArgs<ExtArgs>>): Prisma__stocktakingtbClient<$Result.GetResult<Prisma.$stocktakingtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stocktakingtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {stocktakingtbFindUniqueOrThrowArgs} args - Arguments to find a Stocktakingtb
     * @example
     * // Get one Stocktakingtb
     * const stocktakingtb = await prisma.stocktakingtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends stocktakingtbFindUniqueOrThrowArgs>(args: SelectSubset<T, stocktakingtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__stocktakingtbClient<$Result.GetResult<Prisma.$stocktakingtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stocktakingtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stocktakingtbFindFirstArgs} args - Arguments to find a Stocktakingtb
     * @example
     * // Get one Stocktakingtb
     * const stocktakingtb = await prisma.stocktakingtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends stocktakingtbFindFirstArgs>(args?: SelectSubset<T, stocktakingtbFindFirstArgs<ExtArgs>>): Prisma__stocktakingtbClient<$Result.GetResult<Prisma.$stocktakingtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stocktakingtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stocktakingtbFindFirstOrThrowArgs} args - Arguments to find a Stocktakingtb
     * @example
     * // Get one Stocktakingtb
     * const stocktakingtb = await prisma.stocktakingtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends stocktakingtbFindFirstOrThrowArgs>(args?: SelectSubset<T, stocktakingtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__stocktakingtbClient<$Result.GetResult<Prisma.$stocktakingtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stocktakingtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stocktakingtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocktakingtbs
     * const stocktakingtbs = await prisma.stocktakingtb.findMany()
     * 
     * // Get first 10 Stocktakingtbs
     * const stocktakingtbs = await prisma.stocktakingtb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const stocktakingtbWithIDOnly = await prisma.stocktakingtb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends stocktakingtbFindManyArgs>(args?: SelectSubset<T, stocktakingtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$stocktakingtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stocktakingtb.
     * @param {stocktakingtbCreateArgs} args - Arguments to create a Stocktakingtb.
     * @example
     * // Create one Stocktakingtb
     * const Stocktakingtb = await prisma.stocktakingtb.create({
     *   data: {
     *     // ... data to create a Stocktakingtb
     *   }
     * })
     * 
     */
    create<T extends stocktakingtbCreateArgs>(args: SelectSubset<T, stocktakingtbCreateArgs<ExtArgs>>): Prisma__stocktakingtbClient<$Result.GetResult<Prisma.$stocktakingtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stocktakingtbs.
     * @param {stocktakingtbCreateManyArgs} args - Arguments to create many Stocktakingtbs.
     * @example
     * // Create many Stocktakingtbs
     * const stocktakingtb = await prisma.stocktakingtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends stocktakingtbCreateManyArgs>(args?: SelectSubset<T, stocktakingtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stocktakingtb.
     * @param {stocktakingtbDeleteArgs} args - Arguments to delete one Stocktakingtb.
     * @example
     * // Delete one Stocktakingtb
     * const Stocktakingtb = await prisma.stocktakingtb.delete({
     *   where: {
     *     // ... filter to delete one Stocktakingtb
     *   }
     * })
     * 
     */
    delete<T extends stocktakingtbDeleteArgs>(args: SelectSubset<T, stocktakingtbDeleteArgs<ExtArgs>>): Prisma__stocktakingtbClient<$Result.GetResult<Prisma.$stocktakingtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stocktakingtb.
     * @param {stocktakingtbUpdateArgs} args - Arguments to update one Stocktakingtb.
     * @example
     * // Update one Stocktakingtb
     * const stocktakingtb = await prisma.stocktakingtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends stocktakingtbUpdateArgs>(args: SelectSubset<T, stocktakingtbUpdateArgs<ExtArgs>>): Prisma__stocktakingtbClient<$Result.GetResult<Prisma.$stocktakingtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stocktakingtbs.
     * @param {stocktakingtbDeleteManyArgs} args - Arguments to filter Stocktakingtbs to delete.
     * @example
     * // Delete a few Stocktakingtbs
     * const { count } = await prisma.stocktakingtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends stocktakingtbDeleteManyArgs>(args?: SelectSubset<T, stocktakingtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocktakingtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stocktakingtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocktakingtbs
     * const stocktakingtb = await prisma.stocktakingtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends stocktakingtbUpdateManyArgs>(args: SelectSubset<T, stocktakingtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stocktakingtb.
     * @param {stocktakingtbUpsertArgs} args - Arguments to update or create a Stocktakingtb.
     * @example
     * // Update or create a Stocktakingtb
     * const stocktakingtb = await prisma.stocktakingtb.upsert({
     *   create: {
     *     // ... data to create a Stocktakingtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stocktakingtb we want to update
     *   }
     * })
     */
    upsert<T extends stocktakingtbUpsertArgs>(args: SelectSubset<T, stocktakingtbUpsertArgs<ExtArgs>>): Prisma__stocktakingtbClient<$Result.GetResult<Prisma.$stocktakingtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stocktakingtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stocktakingtbCountArgs} args - Arguments to filter Stocktakingtbs to count.
     * @example
     * // Count the number of Stocktakingtbs
     * const count = await prisma.stocktakingtb.count({
     *   where: {
     *     // ... the filter for the Stocktakingtbs we want to count
     *   }
     * })
    **/
    count<T extends stocktakingtbCountArgs>(
      args?: Subset<T, stocktakingtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StocktakingtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stocktakingtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StocktakingtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StocktakingtbAggregateArgs>(args: Subset<T, StocktakingtbAggregateArgs>): Prisma.PrismaPromise<GetStocktakingtbAggregateType<T>>

    /**
     * Group by Stocktakingtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stocktakingtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends stocktakingtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: stocktakingtbGroupByArgs['orderBy'] }
        : { orderBy?: stocktakingtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, stocktakingtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStocktakingtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stocktakingtb model
   */
  readonly fields: stocktakingtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stocktakingtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__stocktakingtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stocktakingtb model
   */ 
  interface stocktakingtbFieldRefs {
    readonly ID: FieldRef<"stocktakingtb", 'Int'>
    readonly CreateDate: FieldRef<"stocktakingtb", 'DateTime'>
    readonly CreateTime: FieldRef<"stocktakingtb", 'DateTime'>
    readonly StaffID: FieldRef<"stocktakingtb", 'Int'>
    readonly NumInventoryExpected: FieldRef<"stocktakingtb", 'Int'>
    readonly NumInventoryReal: FieldRef<"stocktakingtb", 'Int'>
    readonly NumAdjust: FieldRef<"stocktakingtb", 'Int'>
    readonly NumPreAdjust: FieldRef<"stocktakingtb", 'Int'>
    readonly Note: FieldRef<"stocktakingtb", 'String'>
    readonly ServiceID: FieldRef<"stocktakingtb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * stocktakingtb findUnique
   */
  export type stocktakingtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
    /**
     * Filter, which stocktakingtb to fetch.
     */
    where: stocktakingtbWhereUniqueInput
  }

  /**
   * stocktakingtb findUniqueOrThrow
   */
  export type stocktakingtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
    /**
     * Filter, which stocktakingtb to fetch.
     */
    where: stocktakingtbWhereUniqueInput
  }

  /**
   * stocktakingtb findFirst
   */
  export type stocktakingtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
    /**
     * Filter, which stocktakingtb to fetch.
     */
    where?: stocktakingtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stocktakingtbs to fetch.
     */
    orderBy?: stocktakingtbOrderByWithRelationInput | stocktakingtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stocktakingtbs.
     */
    cursor?: stocktakingtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stocktakingtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stocktakingtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stocktakingtbs.
     */
    distinct?: StocktakingtbScalarFieldEnum | StocktakingtbScalarFieldEnum[]
  }

  /**
   * stocktakingtb findFirstOrThrow
   */
  export type stocktakingtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
    /**
     * Filter, which stocktakingtb to fetch.
     */
    where?: stocktakingtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stocktakingtbs to fetch.
     */
    orderBy?: stocktakingtbOrderByWithRelationInput | stocktakingtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stocktakingtbs.
     */
    cursor?: stocktakingtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stocktakingtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stocktakingtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stocktakingtbs.
     */
    distinct?: StocktakingtbScalarFieldEnum | StocktakingtbScalarFieldEnum[]
  }

  /**
   * stocktakingtb findMany
   */
  export type stocktakingtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
    /**
     * Filter, which stocktakingtbs to fetch.
     */
    where?: stocktakingtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stocktakingtbs to fetch.
     */
    orderBy?: stocktakingtbOrderByWithRelationInput | stocktakingtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stocktakingtbs.
     */
    cursor?: stocktakingtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stocktakingtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stocktakingtbs.
     */
    skip?: number
    distinct?: StocktakingtbScalarFieldEnum | StocktakingtbScalarFieldEnum[]
  }

  /**
   * stocktakingtb create
   */
  export type stocktakingtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
    /**
     * The data needed to create a stocktakingtb.
     */
    data?: XOR<stocktakingtbCreateInput, stocktakingtbUncheckedCreateInput>
  }

  /**
   * stocktakingtb createMany
   */
  export type stocktakingtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stocktakingtbs.
     */
    data: stocktakingtbCreateManyInput | stocktakingtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stocktakingtb update
   */
  export type stocktakingtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
    /**
     * The data needed to update a stocktakingtb.
     */
    data: XOR<stocktakingtbUpdateInput, stocktakingtbUncheckedUpdateInput>
    /**
     * Choose, which stocktakingtb to update.
     */
    where: stocktakingtbWhereUniqueInput
  }

  /**
   * stocktakingtb updateMany
   */
  export type stocktakingtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stocktakingtbs.
     */
    data: XOR<stocktakingtbUpdateManyMutationInput, stocktakingtbUncheckedUpdateManyInput>
    /**
     * Filter which stocktakingtbs to update
     */
    where?: stocktakingtbWhereInput
  }

  /**
   * stocktakingtb upsert
   */
  export type stocktakingtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
    /**
     * The filter to search for the stocktakingtb to update in case it exists.
     */
    where: stocktakingtbWhereUniqueInput
    /**
     * In case the stocktakingtb found by the `where` argument doesn't exist, create a new stocktakingtb with this data.
     */
    create: XOR<stocktakingtbCreateInput, stocktakingtbUncheckedCreateInput>
    /**
     * In case the stocktakingtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<stocktakingtbUpdateInput, stocktakingtbUncheckedUpdateInput>
  }

  /**
   * stocktakingtb delete
   */
  export type stocktakingtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
    /**
     * Filter which stocktakingtb to delete.
     */
    where: stocktakingtbWhereUniqueInput
  }

  /**
   * stocktakingtb deleteMany
   */
  export type stocktakingtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stocktakingtbs to delete
     */
    where?: stocktakingtbWhereInput
  }

  /**
   * stocktakingtb without action
   */
  export type stocktakingtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stocktakingtb
     */
    select?: stocktakingtbSelect<ExtArgs> | null
  }


  /**
   * Model supports
   */

  export type AggregateSupports = {
    _count: SupportsCountAggregateOutputType | null
    _avg: SupportsAvgAggregateOutputType | null
    _sum: SupportsSumAggregateOutputType | null
    _min: SupportsMinAggregateOutputType | null
    _max: SupportsMaxAggregateOutputType | null
  }

  export type SupportsAvgAggregateOutputType = {
    supportId: number | null
    suportCode: number | null
    status: number | null
    order: number | null
    totalClick: number | null
  }

  export type SupportsSumAggregateOutputType = {
    supportId: number | null
    suportCode: number | null
    status: number | null
    order: number | null
    totalClick: number | null
  }

  export type SupportsMinAggregateOutputType = {
    supportId: number | null
    supportTitle: string | null
    supportImage: string | null
    suportCode: number | null
    supportHash: string | null
    status: number | null
    order: number | null
    supportCat: string | null
    totalClick: number | null
    ssId: string | null
    createDate: Date | null
    modifyDate: Date | null
  }

  export type SupportsMaxAggregateOutputType = {
    supportId: number | null
    supportTitle: string | null
    supportImage: string | null
    suportCode: number | null
    supportHash: string | null
    status: number | null
    order: number | null
    supportCat: string | null
    totalClick: number | null
    ssId: string | null
    createDate: Date | null
    modifyDate: Date | null
  }

  export type SupportsCountAggregateOutputType = {
    supportId: number
    supportTitle: number
    supportImage: number
    suportCode: number
    supportHash: number
    status: number
    order: number
    supportCat: number
    totalClick: number
    ssId: number
    createDate: number
    modifyDate: number
    _all: number
  }


  export type SupportsAvgAggregateInputType = {
    supportId?: true
    suportCode?: true
    status?: true
    order?: true
    totalClick?: true
  }

  export type SupportsSumAggregateInputType = {
    supportId?: true
    suportCode?: true
    status?: true
    order?: true
    totalClick?: true
  }

  export type SupportsMinAggregateInputType = {
    supportId?: true
    supportTitle?: true
    supportImage?: true
    suportCode?: true
    supportHash?: true
    status?: true
    order?: true
    supportCat?: true
    totalClick?: true
    ssId?: true
    createDate?: true
    modifyDate?: true
  }

  export type SupportsMaxAggregateInputType = {
    supportId?: true
    supportTitle?: true
    supportImage?: true
    suportCode?: true
    supportHash?: true
    status?: true
    order?: true
    supportCat?: true
    totalClick?: true
    ssId?: true
    createDate?: true
    modifyDate?: true
  }

  export type SupportsCountAggregateInputType = {
    supportId?: true
    supportTitle?: true
    supportImage?: true
    suportCode?: true
    supportHash?: true
    status?: true
    order?: true
    supportCat?: true
    totalClick?: true
    ssId?: true
    createDate?: true
    modifyDate?: true
    _all?: true
  }

  export type SupportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supports to aggregate.
     */
    where?: supportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supports to fetch.
     */
    orderBy?: supportsOrderByWithRelationInput | supportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned supports
    **/
    _count?: true | SupportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupportsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupportsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportsMaxAggregateInputType
  }

  export type GetSupportsAggregateType<T extends SupportsAggregateArgs> = {
        [P in keyof T & keyof AggregateSupports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupports[P]>
      : GetScalarType<T[P], AggregateSupports[P]>
  }




  export type supportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supportsWhereInput
    orderBy?: supportsOrderByWithAggregationInput | supportsOrderByWithAggregationInput[]
    by: SupportsScalarFieldEnum[] | SupportsScalarFieldEnum
    having?: supportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportsCountAggregateInputType | true
    _avg?: SupportsAvgAggregateInputType
    _sum?: SupportsSumAggregateInputType
    _min?: SupportsMinAggregateInputType
    _max?: SupportsMaxAggregateInputType
  }

  export type SupportsGroupByOutputType = {
    supportId: number
    supportTitle: string
    supportImage: string | null
    suportCode: number | null
    supportHash: string | null
    status: number | null
    order: number | null
    supportCat: string | null
    totalClick: number | null
    ssId: string | null
    createDate: Date | null
    modifyDate: Date | null
    _count: SupportsCountAggregateOutputType | null
    _avg: SupportsAvgAggregateOutputType | null
    _sum: SupportsSumAggregateOutputType | null
    _min: SupportsMinAggregateOutputType | null
    _max: SupportsMaxAggregateOutputType | null
  }

  type GetSupportsGroupByPayload<T extends supportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportsGroupByOutputType[P]>
            : GetScalarType<T[P], SupportsGroupByOutputType[P]>
        }
      >
    >


  export type supportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    supportId?: boolean
    supportTitle?: boolean
    supportImage?: boolean
    suportCode?: boolean
    supportHash?: boolean
    status?: boolean
    order?: boolean
    supportCat?: boolean
    totalClick?: boolean
    ssId?: boolean
    createDate?: boolean
    modifyDate?: boolean
  }, ExtArgs["result"]["supports"]>


  export type supportsSelectScalar = {
    supportId?: boolean
    supportTitle?: boolean
    supportImage?: boolean
    suportCode?: boolean
    supportHash?: boolean
    status?: boolean
    order?: boolean
    supportCat?: boolean
    totalClick?: boolean
    ssId?: boolean
    createDate?: boolean
    modifyDate?: boolean
  }


  export type $supportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supports"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      supportId: number
      supportTitle: string
      supportImage: string | null
      suportCode: number | null
      supportHash: string | null
      status: number | null
      order: number | null
      supportCat: string | null
      totalClick: number | null
      ssId: string | null
      createDate: Date | null
      modifyDate: Date | null
    }, ExtArgs["result"]["supports"]>
    composites: {}
  }

  type supportsGetPayload<S extends boolean | null | undefined | supportsDefaultArgs> = $Result.GetResult<Prisma.$supportsPayload, S>

  type supportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<supportsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupportsCountAggregateInputType | true
    }

  export interface supportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supports'], meta: { name: 'supports' } }
    /**
     * Find zero or one Supports that matches the filter.
     * @param {supportsFindUniqueArgs} args - Arguments to find a Supports
     * @example
     * // Get one Supports
     * const supports = await prisma.supports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends supportsFindUniqueArgs>(args: SelectSubset<T, supportsFindUniqueArgs<ExtArgs>>): Prisma__supportsClient<$Result.GetResult<Prisma.$supportsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supports that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {supportsFindUniqueOrThrowArgs} args - Arguments to find a Supports
     * @example
     * // Get one Supports
     * const supports = await prisma.supports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends supportsFindUniqueOrThrowArgs>(args: SelectSubset<T, supportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__supportsClient<$Result.GetResult<Prisma.$supportsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportsFindFirstArgs} args - Arguments to find a Supports
     * @example
     * // Get one Supports
     * const supports = await prisma.supports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends supportsFindFirstArgs>(args?: SelectSubset<T, supportsFindFirstArgs<ExtArgs>>): Prisma__supportsClient<$Result.GetResult<Prisma.$supportsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportsFindFirstOrThrowArgs} args - Arguments to find a Supports
     * @example
     * // Get one Supports
     * const supports = await prisma.supports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends supportsFindFirstOrThrowArgs>(args?: SelectSubset<T, supportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__supportsClient<$Result.GetResult<Prisma.$supportsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Supports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supports
     * const supports = await prisma.supports.findMany()
     * 
     * // Get first 10 Supports
     * const supports = await prisma.supports.findMany({ take: 10 })
     * 
     * // Only select the `supportId`
     * const supportsWithSupportIdOnly = await prisma.supports.findMany({ select: { supportId: true } })
     * 
     */
    findMany<T extends supportsFindManyArgs>(args?: SelectSubset<T, supportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supportsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supports.
     * @param {supportsCreateArgs} args - Arguments to create a Supports.
     * @example
     * // Create one Supports
     * const Supports = await prisma.supports.create({
     *   data: {
     *     // ... data to create a Supports
     *   }
     * })
     * 
     */
    create<T extends supportsCreateArgs>(args: SelectSubset<T, supportsCreateArgs<ExtArgs>>): Prisma__supportsClient<$Result.GetResult<Prisma.$supportsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Supports.
     * @param {supportsCreateManyArgs} args - Arguments to create many Supports.
     * @example
     * // Create many Supports
     * const supports = await prisma.supports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends supportsCreateManyArgs>(args?: SelectSubset<T, supportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supports.
     * @param {supportsDeleteArgs} args - Arguments to delete one Supports.
     * @example
     * // Delete one Supports
     * const Supports = await prisma.supports.delete({
     *   where: {
     *     // ... filter to delete one Supports
     *   }
     * })
     * 
     */
    delete<T extends supportsDeleteArgs>(args: SelectSubset<T, supportsDeleteArgs<ExtArgs>>): Prisma__supportsClient<$Result.GetResult<Prisma.$supportsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supports.
     * @param {supportsUpdateArgs} args - Arguments to update one Supports.
     * @example
     * // Update one Supports
     * const supports = await prisma.supports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends supportsUpdateArgs>(args: SelectSubset<T, supportsUpdateArgs<ExtArgs>>): Prisma__supportsClient<$Result.GetResult<Prisma.$supportsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Supports.
     * @param {supportsDeleteManyArgs} args - Arguments to filter Supports to delete.
     * @example
     * // Delete a few Supports
     * const { count } = await prisma.supports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends supportsDeleteManyArgs>(args?: SelectSubset<T, supportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supports
     * const supports = await prisma.supports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends supportsUpdateManyArgs>(args: SelectSubset<T, supportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supports.
     * @param {supportsUpsertArgs} args - Arguments to update or create a Supports.
     * @example
     * // Update or create a Supports
     * const supports = await prisma.supports.upsert({
     *   create: {
     *     // ... data to create a Supports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supports we want to update
     *   }
     * })
     */
    upsert<T extends supportsUpsertArgs>(args: SelectSubset<T, supportsUpsertArgs<ExtArgs>>): Prisma__supportsClient<$Result.GetResult<Prisma.$supportsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Supports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportsCountArgs} args - Arguments to filter Supports to count.
     * @example
     * // Count the number of Supports
     * const count = await prisma.supports.count({
     *   where: {
     *     // ... the filter for the Supports we want to count
     *   }
     * })
    **/
    count<T extends supportsCountArgs>(
      args?: Subset<T, supportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportsAggregateArgs>(args: Subset<T, SupportsAggregateArgs>): Prisma.PrismaPromise<GetSupportsAggregateType<T>>

    /**
     * Group by Supports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supportsGroupByArgs['orderBy'] }
        : { orderBy?: supportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supports model
   */
  readonly fields: supportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the supports model
   */ 
  interface supportsFieldRefs {
    readonly supportId: FieldRef<"supports", 'Int'>
    readonly supportTitle: FieldRef<"supports", 'String'>
    readonly supportImage: FieldRef<"supports", 'String'>
    readonly suportCode: FieldRef<"supports", 'Int'>
    readonly supportHash: FieldRef<"supports", 'String'>
    readonly status: FieldRef<"supports", 'Int'>
    readonly order: FieldRef<"supports", 'Int'>
    readonly supportCat: FieldRef<"supports", 'String'>
    readonly totalClick: FieldRef<"supports", 'Int'>
    readonly ssId: FieldRef<"supports", 'String'>
    readonly createDate: FieldRef<"supports", 'DateTime'>
    readonly modifyDate: FieldRef<"supports", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * supports findUnique
   */
  export type supportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
    /**
     * Filter, which supports to fetch.
     */
    where: supportsWhereUniqueInput
  }

  /**
   * supports findUniqueOrThrow
   */
  export type supportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
    /**
     * Filter, which supports to fetch.
     */
    where: supportsWhereUniqueInput
  }

  /**
   * supports findFirst
   */
  export type supportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
    /**
     * Filter, which supports to fetch.
     */
    where?: supportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supports to fetch.
     */
    orderBy?: supportsOrderByWithRelationInput | supportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supports.
     */
    cursor?: supportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supports.
     */
    distinct?: SupportsScalarFieldEnum | SupportsScalarFieldEnum[]
  }

  /**
   * supports findFirstOrThrow
   */
  export type supportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
    /**
     * Filter, which supports to fetch.
     */
    where?: supportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supports to fetch.
     */
    orderBy?: supportsOrderByWithRelationInput | supportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supports.
     */
    cursor?: supportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supports.
     */
    distinct?: SupportsScalarFieldEnum | SupportsScalarFieldEnum[]
  }

  /**
   * supports findMany
   */
  export type supportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
    /**
     * Filter, which supports to fetch.
     */
    where?: supportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supports to fetch.
     */
    orderBy?: supportsOrderByWithRelationInput | supportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing supports.
     */
    cursor?: supportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supports.
     */
    skip?: number
    distinct?: SupportsScalarFieldEnum | SupportsScalarFieldEnum[]
  }

  /**
   * supports create
   */
  export type supportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
    /**
     * The data needed to create a supports.
     */
    data: XOR<supportsCreateInput, supportsUncheckedCreateInput>
  }

  /**
   * supports createMany
   */
  export type supportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many supports.
     */
    data: supportsCreateManyInput | supportsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * supports update
   */
  export type supportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
    /**
     * The data needed to update a supports.
     */
    data: XOR<supportsUpdateInput, supportsUncheckedUpdateInput>
    /**
     * Choose, which supports to update.
     */
    where: supportsWhereUniqueInput
  }

  /**
   * supports updateMany
   */
  export type supportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update supports.
     */
    data: XOR<supportsUpdateManyMutationInput, supportsUncheckedUpdateManyInput>
    /**
     * Filter which supports to update
     */
    where?: supportsWhereInput
  }

  /**
   * supports upsert
   */
  export type supportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
    /**
     * The filter to search for the supports to update in case it exists.
     */
    where: supportsWhereUniqueInput
    /**
     * In case the supports found by the `where` argument doesn't exist, create a new supports with this data.
     */
    create: XOR<supportsCreateInput, supportsUncheckedCreateInput>
    /**
     * In case the supports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supportsUpdateInput, supportsUncheckedUpdateInput>
  }

  /**
   * supports delete
   */
  export type supportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
    /**
     * Filter which supports to delete.
     */
    where: supportsWhereUniqueInput
  }

  /**
   * supports deleteMany
   */
  export type supportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supports to delete
     */
    where?: supportsWhereInput
  }

  /**
   * supports without action
   */
  export type supportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supports
     */
    select?: supportsSelect<ExtArgs> | null
  }


  /**
   * Model systemfunctiontb
   */

  export type AggregateSystemfunctiontb = {
    _count: SystemfunctiontbCountAggregateOutputType | null
    _avg: SystemfunctiontbAvgAggregateOutputType | null
    _sum: SystemfunctiontbSumAggregateOutputType | null
    _min: SystemfunctiontbMinAggregateOutputType | null
    _max: SystemfunctiontbMaxAggregateOutputType | null
  }

  export type SystemfunctiontbAvgAggregateOutputType = {
    ResourceID: number | null
    Status: number | null
  }

  export type SystemfunctiontbSumAggregateOutputType = {
    ResourceID: number | null
    Status: number | null
  }

  export type SystemfunctiontbMinAggregateOutputType = {
    ResourceID: number | null
    Status: number | null
  }

  export type SystemfunctiontbMaxAggregateOutputType = {
    ResourceID: number | null
    Status: number | null
  }

  export type SystemfunctiontbCountAggregateOutputType = {
    ResourceID: number
    Status: number
    _all: number
  }


  export type SystemfunctiontbAvgAggregateInputType = {
    ResourceID?: true
    Status?: true
  }

  export type SystemfunctiontbSumAggregateInputType = {
    ResourceID?: true
    Status?: true
  }

  export type SystemfunctiontbMinAggregateInputType = {
    ResourceID?: true
    Status?: true
  }

  export type SystemfunctiontbMaxAggregateInputType = {
    ResourceID?: true
    Status?: true
  }

  export type SystemfunctiontbCountAggregateInputType = {
    ResourceID?: true
    Status?: true
    _all?: true
  }

  export type SystemfunctiontbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which systemfunctiontb to aggregate.
     */
    where?: systemfunctiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemfunctiontbs to fetch.
     */
    orderBy?: systemfunctiontbOrderByWithRelationInput | systemfunctiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: systemfunctiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemfunctiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemfunctiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned systemfunctiontbs
    **/
    _count?: true | SystemfunctiontbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemfunctiontbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemfunctiontbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemfunctiontbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemfunctiontbMaxAggregateInputType
  }

  export type GetSystemfunctiontbAggregateType<T extends SystemfunctiontbAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemfunctiontb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemfunctiontb[P]>
      : GetScalarType<T[P], AggregateSystemfunctiontb[P]>
  }




  export type systemfunctiontbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: systemfunctiontbWhereInput
    orderBy?: systemfunctiontbOrderByWithAggregationInput | systemfunctiontbOrderByWithAggregationInput[]
    by: SystemfunctiontbScalarFieldEnum[] | SystemfunctiontbScalarFieldEnum
    having?: systemfunctiontbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemfunctiontbCountAggregateInputType | true
    _avg?: SystemfunctiontbAvgAggregateInputType
    _sum?: SystemfunctiontbSumAggregateInputType
    _min?: SystemfunctiontbMinAggregateInputType
    _max?: SystemfunctiontbMaxAggregateInputType
  }

  export type SystemfunctiontbGroupByOutputType = {
    ResourceID: number
    Status: number
    _count: SystemfunctiontbCountAggregateOutputType | null
    _avg: SystemfunctiontbAvgAggregateOutputType | null
    _sum: SystemfunctiontbSumAggregateOutputType | null
    _min: SystemfunctiontbMinAggregateOutputType | null
    _max: SystemfunctiontbMaxAggregateOutputType | null
  }

  type GetSystemfunctiontbGroupByPayload<T extends systemfunctiontbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemfunctiontbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemfunctiontbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemfunctiontbGroupByOutputType[P]>
            : GetScalarType<T[P], SystemfunctiontbGroupByOutputType[P]>
        }
      >
    >


  export type systemfunctiontbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ResourceID?: boolean
    Status?: boolean
  }, ExtArgs["result"]["systemfunctiontb"]>


  export type systemfunctiontbSelectScalar = {
    ResourceID?: boolean
    Status?: boolean
  }


  export type $systemfunctiontbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "systemfunctiontb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ResourceID: number
      Status: number
    }, ExtArgs["result"]["systemfunctiontb"]>
    composites: {}
  }

  type systemfunctiontbGetPayload<S extends boolean | null | undefined | systemfunctiontbDefaultArgs> = $Result.GetResult<Prisma.$systemfunctiontbPayload, S>

  type systemfunctiontbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<systemfunctiontbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemfunctiontbCountAggregateInputType | true
    }

  export interface systemfunctiontbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['systemfunctiontb'], meta: { name: 'systemfunctiontb' } }
    /**
     * Find zero or one Systemfunctiontb that matches the filter.
     * @param {systemfunctiontbFindUniqueArgs} args - Arguments to find a Systemfunctiontb
     * @example
     * // Get one Systemfunctiontb
     * const systemfunctiontb = await prisma.systemfunctiontb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends systemfunctiontbFindUniqueArgs>(args: SelectSubset<T, systemfunctiontbFindUniqueArgs<ExtArgs>>): Prisma__systemfunctiontbClient<$Result.GetResult<Prisma.$systemfunctiontbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Systemfunctiontb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {systemfunctiontbFindUniqueOrThrowArgs} args - Arguments to find a Systemfunctiontb
     * @example
     * // Get one Systemfunctiontb
     * const systemfunctiontb = await prisma.systemfunctiontb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends systemfunctiontbFindUniqueOrThrowArgs>(args: SelectSubset<T, systemfunctiontbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__systemfunctiontbClient<$Result.GetResult<Prisma.$systemfunctiontbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Systemfunctiontb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemfunctiontbFindFirstArgs} args - Arguments to find a Systemfunctiontb
     * @example
     * // Get one Systemfunctiontb
     * const systemfunctiontb = await prisma.systemfunctiontb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends systemfunctiontbFindFirstArgs>(args?: SelectSubset<T, systemfunctiontbFindFirstArgs<ExtArgs>>): Prisma__systemfunctiontbClient<$Result.GetResult<Prisma.$systemfunctiontbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Systemfunctiontb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemfunctiontbFindFirstOrThrowArgs} args - Arguments to find a Systemfunctiontb
     * @example
     * // Get one Systemfunctiontb
     * const systemfunctiontb = await prisma.systemfunctiontb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends systemfunctiontbFindFirstOrThrowArgs>(args?: SelectSubset<T, systemfunctiontbFindFirstOrThrowArgs<ExtArgs>>): Prisma__systemfunctiontbClient<$Result.GetResult<Prisma.$systemfunctiontbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Systemfunctiontbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemfunctiontbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Systemfunctiontbs
     * const systemfunctiontbs = await prisma.systemfunctiontb.findMany()
     * 
     * // Get first 10 Systemfunctiontbs
     * const systemfunctiontbs = await prisma.systemfunctiontb.findMany({ take: 10 })
     * 
     * // Only select the `ResourceID`
     * const systemfunctiontbWithResourceIDOnly = await prisma.systemfunctiontb.findMany({ select: { ResourceID: true } })
     * 
     */
    findMany<T extends systemfunctiontbFindManyArgs>(args?: SelectSubset<T, systemfunctiontbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$systemfunctiontbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Systemfunctiontb.
     * @param {systemfunctiontbCreateArgs} args - Arguments to create a Systemfunctiontb.
     * @example
     * // Create one Systemfunctiontb
     * const Systemfunctiontb = await prisma.systemfunctiontb.create({
     *   data: {
     *     // ... data to create a Systemfunctiontb
     *   }
     * })
     * 
     */
    create<T extends systemfunctiontbCreateArgs>(args: SelectSubset<T, systemfunctiontbCreateArgs<ExtArgs>>): Prisma__systemfunctiontbClient<$Result.GetResult<Prisma.$systemfunctiontbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Systemfunctiontbs.
     * @param {systemfunctiontbCreateManyArgs} args - Arguments to create many Systemfunctiontbs.
     * @example
     * // Create many Systemfunctiontbs
     * const systemfunctiontb = await prisma.systemfunctiontb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends systemfunctiontbCreateManyArgs>(args?: SelectSubset<T, systemfunctiontbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Systemfunctiontb.
     * @param {systemfunctiontbDeleteArgs} args - Arguments to delete one Systemfunctiontb.
     * @example
     * // Delete one Systemfunctiontb
     * const Systemfunctiontb = await prisma.systemfunctiontb.delete({
     *   where: {
     *     // ... filter to delete one Systemfunctiontb
     *   }
     * })
     * 
     */
    delete<T extends systemfunctiontbDeleteArgs>(args: SelectSubset<T, systemfunctiontbDeleteArgs<ExtArgs>>): Prisma__systemfunctiontbClient<$Result.GetResult<Prisma.$systemfunctiontbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Systemfunctiontb.
     * @param {systemfunctiontbUpdateArgs} args - Arguments to update one Systemfunctiontb.
     * @example
     * // Update one Systemfunctiontb
     * const systemfunctiontb = await prisma.systemfunctiontb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends systemfunctiontbUpdateArgs>(args: SelectSubset<T, systemfunctiontbUpdateArgs<ExtArgs>>): Prisma__systemfunctiontbClient<$Result.GetResult<Prisma.$systemfunctiontbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Systemfunctiontbs.
     * @param {systemfunctiontbDeleteManyArgs} args - Arguments to filter Systemfunctiontbs to delete.
     * @example
     * // Delete a few Systemfunctiontbs
     * const { count } = await prisma.systemfunctiontb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends systemfunctiontbDeleteManyArgs>(args?: SelectSubset<T, systemfunctiontbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Systemfunctiontbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemfunctiontbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Systemfunctiontbs
     * const systemfunctiontb = await prisma.systemfunctiontb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends systemfunctiontbUpdateManyArgs>(args: SelectSubset<T, systemfunctiontbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Systemfunctiontb.
     * @param {systemfunctiontbUpsertArgs} args - Arguments to update or create a Systemfunctiontb.
     * @example
     * // Update or create a Systemfunctiontb
     * const systemfunctiontb = await prisma.systemfunctiontb.upsert({
     *   create: {
     *     // ... data to create a Systemfunctiontb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Systemfunctiontb we want to update
     *   }
     * })
     */
    upsert<T extends systemfunctiontbUpsertArgs>(args: SelectSubset<T, systemfunctiontbUpsertArgs<ExtArgs>>): Prisma__systemfunctiontbClient<$Result.GetResult<Prisma.$systemfunctiontbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Systemfunctiontbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemfunctiontbCountArgs} args - Arguments to filter Systemfunctiontbs to count.
     * @example
     * // Count the number of Systemfunctiontbs
     * const count = await prisma.systemfunctiontb.count({
     *   where: {
     *     // ... the filter for the Systemfunctiontbs we want to count
     *   }
     * })
    **/
    count<T extends systemfunctiontbCountArgs>(
      args?: Subset<T, systemfunctiontbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemfunctiontbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Systemfunctiontb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemfunctiontbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemfunctiontbAggregateArgs>(args: Subset<T, SystemfunctiontbAggregateArgs>): Prisma.PrismaPromise<GetSystemfunctiontbAggregateType<T>>

    /**
     * Group by Systemfunctiontb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemfunctiontbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends systemfunctiontbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: systemfunctiontbGroupByArgs['orderBy'] }
        : { orderBy?: systemfunctiontbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, systemfunctiontbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemfunctiontbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the systemfunctiontb model
   */
  readonly fields: systemfunctiontbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for systemfunctiontb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__systemfunctiontbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the systemfunctiontb model
   */ 
  interface systemfunctiontbFieldRefs {
    readonly ResourceID: FieldRef<"systemfunctiontb", 'Int'>
    readonly Status: FieldRef<"systemfunctiontb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * systemfunctiontb findUnique
   */
  export type systemfunctiontbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
    /**
     * Filter, which systemfunctiontb to fetch.
     */
    where: systemfunctiontbWhereUniqueInput
  }

  /**
   * systemfunctiontb findUniqueOrThrow
   */
  export type systemfunctiontbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
    /**
     * Filter, which systemfunctiontb to fetch.
     */
    where: systemfunctiontbWhereUniqueInput
  }

  /**
   * systemfunctiontb findFirst
   */
  export type systemfunctiontbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
    /**
     * Filter, which systemfunctiontb to fetch.
     */
    where?: systemfunctiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemfunctiontbs to fetch.
     */
    orderBy?: systemfunctiontbOrderByWithRelationInput | systemfunctiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for systemfunctiontbs.
     */
    cursor?: systemfunctiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemfunctiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemfunctiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of systemfunctiontbs.
     */
    distinct?: SystemfunctiontbScalarFieldEnum | SystemfunctiontbScalarFieldEnum[]
  }

  /**
   * systemfunctiontb findFirstOrThrow
   */
  export type systemfunctiontbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
    /**
     * Filter, which systemfunctiontb to fetch.
     */
    where?: systemfunctiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemfunctiontbs to fetch.
     */
    orderBy?: systemfunctiontbOrderByWithRelationInput | systemfunctiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for systemfunctiontbs.
     */
    cursor?: systemfunctiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemfunctiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemfunctiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of systemfunctiontbs.
     */
    distinct?: SystemfunctiontbScalarFieldEnum | SystemfunctiontbScalarFieldEnum[]
  }

  /**
   * systemfunctiontb findMany
   */
  export type systemfunctiontbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
    /**
     * Filter, which systemfunctiontbs to fetch.
     */
    where?: systemfunctiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemfunctiontbs to fetch.
     */
    orderBy?: systemfunctiontbOrderByWithRelationInput | systemfunctiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing systemfunctiontbs.
     */
    cursor?: systemfunctiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemfunctiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemfunctiontbs.
     */
    skip?: number
    distinct?: SystemfunctiontbScalarFieldEnum | SystemfunctiontbScalarFieldEnum[]
  }

  /**
   * systemfunctiontb create
   */
  export type systemfunctiontbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
    /**
     * The data needed to create a systemfunctiontb.
     */
    data?: XOR<systemfunctiontbCreateInput, systemfunctiontbUncheckedCreateInput>
  }

  /**
   * systemfunctiontb createMany
   */
  export type systemfunctiontbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many systemfunctiontbs.
     */
    data: systemfunctiontbCreateManyInput | systemfunctiontbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * systemfunctiontb update
   */
  export type systemfunctiontbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
    /**
     * The data needed to update a systemfunctiontb.
     */
    data: XOR<systemfunctiontbUpdateInput, systemfunctiontbUncheckedUpdateInput>
    /**
     * Choose, which systemfunctiontb to update.
     */
    where: systemfunctiontbWhereUniqueInput
  }

  /**
   * systemfunctiontb updateMany
   */
  export type systemfunctiontbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update systemfunctiontbs.
     */
    data: XOR<systemfunctiontbUpdateManyMutationInput, systemfunctiontbUncheckedUpdateManyInput>
    /**
     * Filter which systemfunctiontbs to update
     */
    where?: systemfunctiontbWhereInput
  }

  /**
   * systemfunctiontb upsert
   */
  export type systemfunctiontbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
    /**
     * The filter to search for the systemfunctiontb to update in case it exists.
     */
    where: systemfunctiontbWhereUniqueInput
    /**
     * In case the systemfunctiontb found by the `where` argument doesn't exist, create a new systemfunctiontb with this data.
     */
    create: XOR<systemfunctiontbCreateInput, systemfunctiontbUncheckedCreateInput>
    /**
     * In case the systemfunctiontb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<systemfunctiontbUpdateInput, systemfunctiontbUncheckedUpdateInput>
  }

  /**
   * systemfunctiontb delete
   */
  export type systemfunctiontbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
    /**
     * Filter which systemfunctiontb to delete.
     */
    where: systemfunctiontbWhereUniqueInput
  }

  /**
   * systemfunctiontb deleteMany
   */
  export type systemfunctiontbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which systemfunctiontbs to delete
     */
    where?: systemfunctiontbWhereInput
  }

  /**
   * systemfunctiontb without action
   */
  export type systemfunctiontbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemfunctiontb
     */
    select?: systemfunctiontbSelect<ExtArgs> | null
  }


  /**
   * Model systemlogtb
   */

  export type AggregateSystemlogtb = {
    _count: SystemlogtbCountAggregateOutputType | null
    _avg: SystemlogtbAvgAggregateOutputType | null
    _sum: SystemlogtbSumAggregateOutputType | null
    _min: SystemlogtbMinAggregateOutputType | null
    _max: SystemlogtbMaxAggregateOutputType | null
  }

  export type SystemlogtbAvgAggregateOutputType = {
    SystemLogId: number | null
    UserId: number | null
    Status: number | null
    TimeUsed: number | null
    MoneyUsed: number | null
    PriceAppRentID: number | null
    AppRentMoneyUsed: number | null
  }

  export type SystemlogtbSumAggregateOutputType = {
    SystemLogId: number | null
    UserId: number | null
    Status: number | null
    TimeUsed: number | null
    MoneyUsed: number | null
    PriceAppRentID: number | null
    AppRentMoneyUsed: number | null
  }

  export type SystemlogtbMinAggregateOutputType = {
    SystemLogId: number | null
    UserId: number | null
    MachineName: string | null
    IPAddress: string | null
    EnterDate: Date | null
    EnterTime: Date | null
    EndDate: Date | null
    EndTime: Date | null
    Status: number | null
    Note: string | null
    TimeUsed: number | null
    MoneyUsed: number | null
    PriceAppRentID: number | null
    AppRentMoneyUsed: number | null
  }

  export type SystemlogtbMaxAggregateOutputType = {
    SystemLogId: number | null
    UserId: number | null
    MachineName: string | null
    IPAddress: string | null
    EnterDate: Date | null
    EnterTime: Date | null
    EndDate: Date | null
    EndTime: Date | null
    Status: number | null
    Note: string | null
    TimeUsed: number | null
    MoneyUsed: number | null
    PriceAppRentID: number | null
    AppRentMoneyUsed: number | null
  }

  export type SystemlogtbCountAggregateOutputType = {
    SystemLogId: number
    UserId: number
    MachineName: number
    IPAddress: number
    EnterDate: number
    EnterTime: number
    EndDate: number
    EndTime: number
    Status: number
    Note: number
    TimeUsed: number
    MoneyUsed: number
    PriceAppRentID: number
    AppRentMoneyUsed: number
    _all: number
  }


  export type SystemlogtbAvgAggregateInputType = {
    SystemLogId?: true
    UserId?: true
    Status?: true
    TimeUsed?: true
    MoneyUsed?: true
    PriceAppRentID?: true
    AppRentMoneyUsed?: true
  }

  export type SystemlogtbSumAggregateInputType = {
    SystemLogId?: true
    UserId?: true
    Status?: true
    TimeUsed?: true
    MoneyUsed?: true
    PriceAppRentID?: true
    AppRentMoneyUsed?: true
  }

  export type SystemlogtbMinAggregateInputType = {
    SystemLogId?: true
    UserId?: true
    MachineName?: true
    IPAddress?: true
    EnterDate?: true
    EnterTime?: true
    EndDate?: true
    EndTime?: true
    Status?: true
    Note?: true
    TimeUsed?: true
    MoneyUsed?: true
    PriceAppRentID?: true
    AppRentMoneyUsed?: true
  }

  export type SystemlogtbMaxAggregateInputType = {
    SystemLogId?: true
    UserId?: true
    MachineName?: true
    IPAddress?: true
    EnterDate?: true
    EnterTime?: true
    EndDate?: true
    EndTime?: true
    Status?: true
    Note?: true
    TimeUsed?: true
    MoneyUsed?: true
    PriceAppRentID?: true
    AppRentMoneyUsed?: true
  }

  export type SystemlogtbCountAggregateInputType = {
    SystemLogId?: true
    UserId?: true
    MachineName?: true
    IPAddress?: true
    EnterDate?: true
    EnterTime?: true
    EndDate?: true
    EndTime?: true
    Status?: true
    Note?: true
    TimeUsed?: true
    MoneyUsed?: true
    PriceAppRentID?: true
    AppRentMoneyUsed?: true
    _all?: true
  }

  export type SystemlogtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which systemlogtb to aggregate.
     */
    where?: systemlogtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemlogtbs to fetch.
     */
    orderBy?: systemlogtbOrderByWithRelationInput | systemlogtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: systemlogtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemlogtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemlogtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned systemlogtbs
    **/
    _count?: true | SystemlogtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemlogtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemlogtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemlogtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemlogtbMaxAggregateInputType
  }

  export type GetSystemlogtbAggregateType<T extends SystemlogtbAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemlogtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemlogtb[P]>
      : GetScalarType<T[P], AggregateSystemlogtb[P]>
  }




  export type systemlogtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: systemlogtbWhereInput
    orderBy?: systemlogtbOrderByWithAggregationInput | systemlogtbOrderByWithAggregationInput[]
    by: SystemlogtbScalarFieldEnum[] | SystemlogtbScalarFieldEnum
    having?: systemlogtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemlogtbCountAggregateInputType | true
    _avg?: SystemlogtbAvgAggregateInputType
    _sum?: SystemlogtbSumAggregateInputType
    _min?: SystemlogtbMinAggregateInputType
    _max?: SystemlogtbMaxAggregateInputType
  }

  export type SystemlogtbGroupByOutputType = {
    SystemLogId: number
    UserId: number | null
    MachineName: string
    IPAddress: string
    EnterDate: Date
    EnterTime: Date
    EndDate: Date | null
    EndTime: Date | null
    Status: number
    Note: string
    TimeUsed: number
    MoneyUsed: number
    PriceAppRentID: number
    AppRentMoneyUsed: number
    _count: SystemlogtbCountAggregateOutputType | null
    _avg: SystemlogtbAvgAggregateOutputType | null
    _sum: SystemlogtbSumAggregateOutputType | null
    _min: SystemlogtbMinAggregateOutputType | null
    _max: SystemlogtbMaxAggregateOutputType | null
  }

  type GetSystemlogtbGroupByPayload<T extends systemlogtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemlogtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemlogtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemlogtbGroupByOutputType[P]>
            : GetScalarType<T[P], SystemlogtbGroupByOutputType[P]>
        }
      >
    >


  export type systemlogtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SystemLogId?: boolean
    UserId?: boolean
    MachineName?: boolean
    IPAddress?: boolean
    EnterDate?: boolean
    EnterTime?: boolean
    EndDate?: boolean
    EndTime?: boolean
    Status?: boolean
    Note?: boolean
    TimeUsed?: boolean
    MoneyUsed?: boolean
    PriceAppRentID?: boolean
    AppRentMoneyUsed?: boolean
  }, ExtArgs["result"]["systemlogtb"]>


  export type systemlogtbSelectScalar = {
    SystemLogId?: boolean
    UserId?: boolean
    MachineName?: boolean
    IPAddress?: boolean
    EnterDate?: boolean
    EnterTime?: boolean
    EndDate?: boolean
    EndTime?: boolean
    Status?: boolean
    Note?: boolean
    TimeUsed?: boolean
    MoneyUsed?: boolean
    PriceAppRentID?: boolean
    AppRentMoneyUsed?: boolean
  }


  export type $systemlogtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "systemlogtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      SystemLogId: number
      UserId: number | null
      MachineName: string
      IPAddress: string
      EnterDate: Date
      EnterTime: Date
      EndDate: Date | null
      EndTime: Date | null
      Status: number
      Note: string
      TimeUsed: number
      MoneyUsed: number
      PriceAppRentID: number
      AppRentMoneyUsed: number
    }, ExtArgs["result"]["systemlogtb"]>
    composites: {}
  }

  type systemlogtbGetPayload<S extends boolean | null | undefined | systemlogtbDefaultArgs> = $Result.GetResult<Prisma.$systemlogtbPayload, S>

  type systemlogtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<systemlogtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemlogtbCountAggregateInputType | true
    }

  export interface systemlogtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['systemlogtb'], meta: { name: 'systemlogtb' } }
    /**
     * Find zero or one Systemlogtb that matches the filter.
     * @param {systemlogtbFindUniqueArgs} args - Arguments to find a Systemlogtb
     * @example
     * // Get one Systemlogtb
     * const systemlogtb = await prisma.systemlogtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends systemlogtbFindUniqueArgs>(args: SelectSubset<T, systemlogtbFindUniqueArgs<ExtArgs>>): Prisma__systemlogtbClient<$Result.GetResult<Prisma.$systemlogtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Systemlogtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {systemlogtbFindUniqueOrThrowArgs} args - Arguments to find a Systemlogtb
     * @example
     * // Get one Systemlogtb
     * const systemlogtb = await prisma.systemlogtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends systemlogtbFindUniqueOrThrowArgs>(args: SelectSubset<T, systemlogtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__systemlogtbClient<$Result.GetResult<Prisma.$systemlogtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Systemlogtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemlogtbFindFirstArgs} args - Arguments to find a Systemlogtb
     * @example
     * // Get one Systemlogtb
     * const systemlogtb = await prisma.systemlogtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends systemlogtbFindFirstArgs>(args?: SelectSubset<T, systemlogtbFindFirstArgs<ExtArgs>>): Prisma__systemlogtbClient<$Result.GetResult<Prisma.$systemlogtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Systemlogtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemlogtbFindFirstOrThrowArgs} args - Arguments to find a Systemlogtb
     * @example
     * // Get one Systemlogtb
     * const systemlogtb = await prisma.systemlogtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends systemlogtbFindFirstOrThrowArgs>(args?: SelectSubset<T, systemlogtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__systemlogtbClient<$Result.GetResult<Prisma.$systemlogtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Systemlogtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemlogtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Systemlogtbs
     * const systemlogtbs = await prisma.systemlogtb.findMany()
     * 
     * // Get first 10 Systemlogtbs
     * const systemlogtbs = await prisma.systemlogtb.findMany({ take: 10 })
     * 
     * // Only select the `SystemLogId`
     * const systemlogtbWithSystemLogIdOnly = await prisma.systemlogtb.findMany({ select: { SystemLogId: true } })
     * 
     */
    findMany<T extends systemlogtbFindManyArgs>(args?: SelectSubset<T, systemlogtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$systemlogtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Systemlogtb.
     * @param {systemlogtbCreateArgs} args - Arguments to create a Systemlogtb.
     * @example
     * // Create one Systemlogtb
     * const Systemlogtb = await prisma.systemlogtb.create({
     *   data: {
     *     // ... data to create a Systemlogtb
     *   }
     * })
     * 
     */
    create<T extends systemlogtbCreateArgs>(args: SelectSubset<T, systemlogtbCreateArgs<ExtArgs>>): Prisma__systemlogtbClient<$Result.GetResult<Prisma.$systemlogtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Systemlogtbs.
     * @param {systemlogtbCreateManyArgs} args - Arguments to create many Systemlogtbs.
     * @example
     * // Create many Systemlogtbs
     * const systemlogtb = await prisma.systemlogtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends systemlogtbCreateManyArgs>(args?: SelectSubset<T, systemlogtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Systemlogtb.
     * @param {systemlogtbDeleteArgs} args - Arguments to delete one Systemlogtb.
     * @example
     * // Delete one Systemlogtb
     * const Systemlogtb = await prisma.systemlogtb.delete({
     *   where: {
     *     // ... filter to delete one Systemlogtb
     *   }
     * })
     * 
     */
    delete<T extends systemlogtbDeleteArgs>(args: SelectSubset<T, systemlogtbDeleteArgs<ExtArgs>>): Prisma__systemlogtbClient<$Result.GetResult<Prisma.$systemlogtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Systemlogtb.
     * @param {systemlogtbUpdateArgs} args - Arguments to update one Systemlogtb.
     * @example
     * // Update one Systemlogtb
     * const systemlogtb = await prisma.systemlogtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends systemlogtbUpdateArgs>(args: SelectSubset<T, systemlogtbUpdateArgs<ExtArgs>>): Prisma__systemlogtbClient<$Result.GetResult<Prisma.$systemlogtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Systemlogtbs.
     * @param {systemlogtbDeleteManyArgs} args - Arguments to filter Systemlogtbs to delete.
     * @example
     * // Delete a few Systemlogtbs
     * const { count } = await prisma.systemlogtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends systemlogtbDeleteManyArgs>(args?: SelectSubset<T, systemlogtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Systemlogtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemlogtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Systemlogtbs
     * const systemlogtb = await prisma.systemlogtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends systemlogtbUpdateManyArgs>(args: SelectSubset<T, systemlogtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Systemlogtb.
     * @param {systemlogtbUpsertArgs} args - Arguments to update or create a Systemlogtb.
     * @example
     * // Update or create a Systemlogtb
     * const systemlogtb = await prisma.systemlogtb.upsert({
     *   create: {
     *     // ... data to create a Systemlogtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Systemlogtb we want to update
     *   }
     * })
     */
    upsert<T extends systemlogtbUpsertArgs>(args: SelectSubset<T, systemlogtbUpsertArgs<ExtArgs>>): Prisma__systemlogtbClient<$Result.GetResult<Prisma.$systemlogtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Systemlogtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemlogtbCountArgs} args - Arguments to filter Systemlogtbs to count.
     * @example
     * // Count the number of Systemlogtbs
     * const count = await prisma.systemlogtb.count({
     *   where: {
     *     // ... the filter for the Systemlogtbs we want to count
     *   }
     * })
    **/
    count<T extends systemlogtbCountArgs>(
      args?: Subset<T, systemlogtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemlogtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Systemlogtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemlogtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemlogtbAggregateArgs>(args: Subset<T, SystemlogtbAggregateArgs>): Prisma.PrismaPromise<GetSystemlogtbAggregateType<T>>

    /**
     * Group by Systemlogtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {systemlogtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends systemlogtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: systemlogtbGroupByArgs['orderBy'] }
        : { orderBy?: systemlogtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, systemlogtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemlogtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the systemlogtb model
   */
  readonly fields: systemlogtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for systemlogtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__systemlogtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the systemlogtb model
   */ 
  interface systemlogtbFieldRefs {
    readonly SystemLogId: FieldRef<"systemlogtb", 'Int'>
    readonly UserId: FieldRef<"systemlogtb", 'Int'>
    readonly MachineName: FieldRef<"systemlogtb", 'String'>
    readonly IPAddress: FieldRef<"systemlogtb", 'String'>
    readonly EnterDate: FieldRef<"systemlogtb", 'DateTime'>
    readonly EnterTime: FieldRef<"systemlogtb", 'DateTime'>
    readonly EndDate: FieldRef<"systemlogtb", 'DateTime'>
    readonly EndTime: FieldRef<"systemlogtb", 'DateTime'>
    readonly Status: FieldRef<"systemlogtb", 'Int'>
    readonly Note: FieldRef<"systemlogtb", 'String'>
    readonly TimeUsed: FieldRef<"systemlogtb", 'Int'>
    readonly MoneyUsed: FieldRef<"systemlogtb", 'Int'>
    readonly PriceAppRentID: FieldRef<"systemlogtb", 'Int'>
    readonly AppRentMoneyUsed: FieldRef<"systemlogtb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * systemlogtb findUnique
   */
  export type systemlogtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
    /**
     * Filter, which systemlogtb to fetch.
     */
    where: systemlogtbWhereUniqueInput
  }

  /**
   * systemlogtb findUniqueOrThrow
   */
  export type systemlogtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
    /**
     * Filter, which systemlogtb to fetch.
     */
    where: systemlogtbWhereUniqueInput
  }

  /**
   * systemlogtb findFirst
   */
  export type systemlogtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
    /**
     * Filter, which systemlogtb to fetch.
     */
    where?: systemlogtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemlogtbs to fetch.
     */
    orderBy?: systemlogtbOrderByWithRelationInput | systemlogtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for systemlogtbs.
     */
    cursor?: systemlogtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemlogtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemlogtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of systemlogtbs.
     */
    distinct?: SystemlogtbScalarFieldEnum | SystemlogtbScalarFieldEnum[]
  }

  /**
   * systemlogtb findFirstOrThrow
   */
  export type systemlogtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
    /**
     * Filter, which systemlogtb to fetch.
     */
    where?: systemlogtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemlogtbs to fetch.
     */
    orderBy?: systemlogtbOrderByWithRelationInput | systemlogtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for systemlogtbs.
     */
    cursor?: systemlogtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemlogtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemlogtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of systemlogtbs.
     */
    distinct?: SystemlogtbScalarFieldEnum | SystemlogtbScalarFieldEnum[]
  }

  /**
   * systemlogtb findMany
   */
  export type systemlogtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
    /**
     * Filter, which systemlogtbs to fetch.
     */
    where?: systemlogtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of systemlogtbs to fetch.
     */
    orderBy?: systemlogtbOrderByWithRelationInput | systemlogtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing systemlogtbs.
     */
    cursor?: systemlogtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` systemlogtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` systemlogtbs.
     */
    skip?: number
    distinct?: SystemlogtbScalarFieldEnum | SystemlogtbScalarFieldEnum[]
  }

  /**
   * systemlogtb create
   */
  export type systemlogtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
    /**
     * The data needed to create a systemlogtb.
     */
    data: XOR<systemlogtbCreateInput, systemlogtbUncheckedCreateInput>
  }

  /**
   * systemlogtb createMany
   */
  export type systemlogtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many systemlogtbs.
     */
    data: systemlogtbCreateManyInput | systemlogtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * systemlogtb update
   */
  export type systemlogtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
    /**
     * The data needed to update a systemlogtb.
     */
    data: XOR<systemlogtbUpdateInput, systemlogtbUncheckedUpdateInput>
    /**
     * Choose, which systemlogtb to update.
     */
    where: systemlogtbWhereUniqueInput
  }

  /**
   * systemlogtb updateMany
   */
  export type systemlogtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update systemlogtbs.
     */
    data: XOR<systemlogtbUpdateManyMutationInput, systemlogtbUncheckedUpdateManyInput>
    /**
     * Filter which systemlogtbs to update
     */
    where?: systemlogtbWhereInput
  }

  /**
   * systemlogtb upsert
   */
  export type systemlogtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
    /**
     * The filter to search for the systemlogtb to update in case it exists.
     */
    where: systemlogtbWhereUniqueInput
    /**
     * In case the systemlogtb found by the `where` argument doesn't exist, create a new systemlogtb with this data.
     */
    create: XOR<systemlogtbCreateInput, systemlogtbUncheckedCreateInput>
    /**
     * In case the systemlogtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<systemlogtbUpdateInput, systemlogtbUncheckedUpdateInput>
  }

  /**
   * systemlogtb delete
   */
  export type systemlogtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
    /**
     * Filter which systemlogtb to delete.
     */
    where: systemlogtbWhereUniqueInput
  }

  /**
   * systemlogtb deleteMany
   */
  export type systemlogtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which systemlogtbs to delete
     */
    where?: systemlogtbWhereInput
  }

  /**
   * systemlogtb without action
   */
  export type systemlogtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the systemlogtb
     */
    select?: systemlogtbSelect<ExtArgs> | null
  }


  /**
   * Model trackappdetailtb
   */

  export type AggregateTrackappdetailtb = {
    _count: TrackappdetailtbCountAggregateOutputType | null
    _avg: TrackappdetailtbAvgAggregateOutputType | null
    _sum: TrackappdetailtbSumAggregateOutputType | null
    _min: TrackappdetailtbMinAggregateOutputType | null
    _max: TrackappdetailtbMaxAggregateOutputType | null
  }

  export type TrackappdetailtbAvgAggregateOutputType = {
    TrackAppDetailId: number | null
    TimeTotal: number | null
    SessionId: number | null
  }

  export type TrackappdetailtbSumAggregateOutputType = {
    TrackAppDetailId: number | null
    TimeTotal: number | null
    SessionId: number | null
  }

  export type TrackappdetailtbMinAggregateOutputType = {
    TrackAppDetailId: number | null
    AppName: string | null
    UserName: string | null
    TrackingDate: Date | null
    TrackingTime: Date | null
    TimeTotal: number | null
    AppSession: boolean | null
    Sent: boolean | null
    Machine: string | null
    SessionId: number | null
    ETT: string | null
  }

  export type TrackappdetailtbMaxAggregateOutputType = {
    TrackAppDetailId: number | null
    AppName: string | null
    UserName: string | null
    TrackingDate: Date | null
    TrackingTime: Date | null
    TimeTotal: number | null
    AppSession: boolean | null
    Sent: boolean | null
    Machine: string | null
    SessionId: number | null
    ETT: string | null
  }

  export type TrackappdetailtbCountAggregateOutputType = {
    TrackAppDetailId: number
    AppName: number
    UserName: number
    TrackingDate: number
    TrackingTime: number
    TimeTotal: number
    AppSession: number
    Sent: number
    Machine: number
    SessionId: number
    ETT: number
    _all: number
  }


  export type TrackappdetailtbAvgAggregateInputType = {
    TrackAppDetailId?: true
    TimeTotal?: true
    SessionId?: true
  }

  export type TrackappdetailtbSumAggregateInputType = {
    TrackAppDetailId?: true
    TimeTotal?: true
    SessionId?: true
  }

  export type TrackappdetailtbMinAggregateInputType = {
    TrackAppDetailId?: true
    AppName?: true
    UserName?: true
    TrackingDate?: true
    TrackingTime?: true
    TimeTotal?: true
    AppSession?: true
    Sent?: true
    Machine?: true
    SessionId?: true
    ETT?: true
  }

  export type TrackappdetailtbMaxAggregateInputType = {
    TrackAppDetailId?: true
    AppName?: true
    UserName?: true
    TrackingDate?: true
    TrackingTime?: true
    TimeTotal?: true
    AppSession?: true
    Sent?: true
    Machine?: true
    SessionId?: true
    ETT?: true
  }

  export type TrackappdetailtbCountAggregateInputType = {
    TrackAppDetailId?: true
    AppName?: true
    UserName?: true
    TrackingDate?: true
    TrackingTime?: true
    TimeTotal?: true
    AppSession?: true
    Sent?: true
    Machine?: true
    SessionId?: true
    ETT?: true
    _all?: true
  }

  export type TrackappdetailtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trackappdetailtb to aggregate.
     */
    where?: trackappdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackappdetailtbs to fetch.
     */
    orderBy?: trackappdetailtbOrderByWithRelationInput | trackappdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trackappdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackappdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackappdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trackappdetailtbs
    **/
    _count?: true | TrackappdetailtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrackappdetailtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrackappdetailtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackappdetailtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackappdetailtbMaxAggregateInputType
  }

  export type GetTrackappdetailtbAggregateType<T extends TrackappdetailtbAggregateArgs> = {
        [P in keyof T & keyof AggregateTrackappdetailtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrackappdetailtb[P]>
      : GetScalarType<T[P], AggregateTrackappdetailtb[P]>
  }




  export type trackappdetailtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trackappdetailtbWhereInput
    orderBy?: trackappdetailtbOrderByWithAggregationInput | trackappdetailtbOrderByWithAggregationInput[]
    by: TrackappdetailtbScalarFieldEnum[] | TrackappdetailtbScalarFieldEnum
    having?: trackappdetailtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackappdetailtbCountAggregateInputType | true
    _avg?: TrackappdetailtbAvgAggregateInputType
    _sum?: TrackappdetailtbSumAggregateInputType
    _min?: TrackappdetailtbMinAggregateInputType
    _max?: TrackappdetailtbMaxAggregateInputType
  }

  export type TrackappdetailtbGroupByOutputType = {
    TrackAppDetailId: number
    AppName: string
    UserName: string
    TrackingDate: Date
    TrackingTime: Date
    TimeTotal: number
    AppSession: boolean
    Sent: boolean
    Machine: string
    SessionId: number
    ETT: string
    _count: TrackappdetailtbCountAggregateOutputType | null
    _avg: TrackappdetailtbAvgAggregateOutputType | null
    _sum: TrackappdetailtbSumAggregateOutputType | null
    _min: TrackappdetailtbMinAggregateOutputType | null
    _max: TrackappdetailtbMaxAggregateOutputType | null
  }

  type GetTrackappdetailtbGroupByPayload<T extends trackappdetailtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackappdetailtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackappdetailtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackappdetailtbGroupByOutputType[P]>
            : GetScalarType<T[P], TrackappdetailtbGroupByOutputType[P]>
        }
      >
    >


  export type trackappdetailtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TrackAppDetailId?: boolean
    AppName?: boolean
    UserName?: boolean
    TrackingDate?: boolean
    TrackingTime?: boolean
    TimeTotal?: boolean
    AppSession?: boolean
    Sent?: boolean
    Machine?: boolean
    SessionId?: boolean
    ETT?: boolean
  }, ExtArgs["result"]["trackappdetailtb"]>


  export type trackappdetailtbSelectScalar = {
    TrackAppDetailId?: boolean
    AppName?: boolean
    UserName?: boolean
    TrackingDate?: boolean
    TrackingTime?: boolean
    TimeTotal?: boolean
    AppSession?: boolean
    Sent?: boolean
    Machine?: boolean
    SessionId?: boolean
    ETT?: boolean
  }


  export type $trackappdetailtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trackappdetailtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      TrackAppDetailId: number
      AppName: string
      UserName: string
      TrackingDate: Date
      TrackingTime: Date
      TimeTotal: number
      AppSession: boolean
      Sent: boolean
      Machine: string
      SessionId: number
      ETT: string
    }, ExtArgs["result"]["trackappdetailtb"]>
    composites: {}
  }

  type trackappdetailtbGetPayload<S extends boolean | null | undefined | trackappdetailtbDefaultArgs> = $Result.GetResult<Prisma.$trackappdetailtbPayload, S>

  type trackappdetailtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<trackappdetailtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrackappdetailtbCountAggregateInputType | true
    }

  export interface trackappdetailtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trackappdetailtb'], meta: { name: 'trackappdetailtb' } }
    /**
     * Find zero or one Trackappdetailtb that matches the filter.
     * @param {trackappdetailtbFindUniqueArgs} args - Arguments to find a Trackappdetailtb
     * @example
     * // Get one Trackappdetailtb
     * const trackappdetailtb = await prisma.trackappdetailtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trackappdetailtbFindUniqueArgs>(args: SelectSubset<T, trackappdetailtbFindUniqueArgs<ExtArgs>>): Prisma__trackappdetailtbClient<$Result.GetResult<Prisma.$trackappdetailtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trackappdetailtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {trackappdetailtbFindUniqueOrThrowArgs} args - Arguments to find a Trackappdetailtb
     * @example
     * // Get one Trackappdetailtb
     * const trackappdetailtb = await prisma.trackappdetailtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trackappdetailtbFindUniqueOrThrowArgs>(args: SelectSubset<T, trackappdetailtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trackappdetailtbClient<$Result.GetResult<Prisma.$trackappdetailtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trackappdetailtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackappdetailtbFindFirstArgs} args - Arguments to find a Trackappdetailtb
     * @example
     * // Get one Trackappdetailtb
     * const trackappdetailtb = await prisma.trackappdetailtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trackappdetailtbFindFirstArgs>(args?: SelectSubset<T, trackappdetailtbFindFirstArgs<ExtArgs>>): Prisma__trackappdetailtbClient<$Result.GetResult<Prisma.$trackappdetailtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trackappdetailtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackappdetailtbFindFirstOrThrowArgs} args - Arguments to find a Trackappdetailtb
     * @example
     * // Get one Trackappdetailtb
     * const trackappdetailtb = await prisma.trackappdetailtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trackappdetailtbFindFirstOrThrowArgs>(args?: SelectSubset<T, trackappdetailtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__trackappdetailtbClient<$Result.GetResult<Prisma.$trackappdetailtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trackappdetailtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackappdetailtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trackappdetailtbs
     * const trackappdetailtbs = await prisma.trackappdetailtb.findMany()
     * 
     * // Get first 10 Trackappdetailtbs
     * const trackappdetailtbs = await prisma.trackappdetailtb.findMany({ take: 10 })
     * 
     * // Only select the `TrackAppDetailId`
     * const trackappdetailtbWithTrackAppDetailIdOnly = await prisma.trackappdetailtb.findMany({ select: { TrackAppDetailId: true } })
     * 
     */
    findMany<T extends trackappdetailtbFindManyArgs>(args?: SelectSubset<T, trackappdetailtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trackappdetailtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trackappdetailtb.
     * @param {trackappdetailtbCreateArgs} args - Arguments to create a Trackappdetailtb.
     * @example
     * // Create one Trackappdetailtb
     * const Trackappdetailtb = await prisma.trackappdetailtb.create({
     *   data: {
     *     // ... data to create a Trackappdetailtb
     *   }
     * })
     * 
     */
    create<T extends trackappdetailtbCreateArgs>(args: SelectSubset<T, trackappdetailtbCreateArgs<ExtArgs>>): Prisma__trackappdetailtbClient<$Result.GetResult<Prisma.$trackappdetailtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trackappdetailtbs.
     * @param {trackappdetailtbCreateManyArgs} args - Arguments to create many Trackappdetailtbs.
     * @example
     * // Create many Trackappdetailtbs
     * const trackappdetailtb = await prisma.trackappdetailtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trackappdetailtbCreateManyArgs>(args?: SelectSubset<T, trackappdetailtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trackappdetailtb.
     * @param {trackappdetailtbDeleteArgs} args - Arguments to delete one Trackappdetailtb.
     * @example
     * // Delete one Trackappdetailtb
     * const Trackappdetailtb = await prisma.trackappdetailtb.delete({
     *   where: {
     *     // ... filter to delete one Trackappdetailtb
     *   }
     * })
     * 
     */
    delete<T extends trackappdetailtbDeleteArgs>(args: SelectSubset<T, trackappdetailtbDeleteArgs<ExtArgs>>): Prisma__trackappdetailtbClient<$Result.GetResult<Prisma.$trackappdetailtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trackappdetailtb.
     * @param {trackappdetailtbUpdateArgs} args - Arguments to update one Trackappdetailtb.
     * @example
     * // Update one Trackappdetailtb
     * const trackappdetailtb = await prisma.trackappdetailtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trackappdetailtbUpdateArgs>(args: SelectSubset<T, trackappdetailtbUpdateArgs<ExtArgs>>): Prisma__trackappdetailtbClient<$Result.GetResult<Prisma.$trackappdetailtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trackappdetailtbs.
     * @param {trackappdetailtbDeleteManyArgs} args - Arguments to filter Trackappdetailtbs to delete.
     * @example
     * // Delete a few Trackappdetailtbs
     * const { count } = await prisma.trackappdetailtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trackappdetailtbDeleteManyArgs>(args?: SelectSubset<T, trackappdetailtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trackappdetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackappdetailtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trackappdetailtbs
     * const trackappdetailtb = await prisma.trackappdetailtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trackappdetailtbUpdateManyArgs>(args: SelectSubset<T, trackappdetailtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trackappdetailtb.
     * @param {trackappdetailtbUpsertArgs} args - Arguments to update or create a Trackappdetailtb.
     * @example
     * // Update or create a Trackappdetailtb
     * const trackappdetailtb = await prisma.trackappdetailtb.upsert({
     *   create: {
     *     // ... data to create a Trackappdetailtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trackappdetailtb we want to update
     *   }
     * })
     */
    upsert<T extends trackappdetailtbUpsertArgs>(args: SelectSubset<T, trackappdetailtbUpsertArgs<ExtArgs>>): Prisma__trackappdetailtbClient<$Result.GetResult<Prisma.$trackappdetailtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trackappdetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackappdetailtbCountArgs} args - Arguments to filter Trackappdetailtbs to count.
     * @example
     * // Count the number of Trackappdetailtbs
     * const count = await prisma.trackappdetailtb.count({
     *   where: {
     *     // ... the filter for the Trackappdetailtbs we want to count
     *   }
     * })
    **/
    count<T extends trackappdetailtbCountArgs>(
      args?: Subset<T, trackappdetailtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackappdetailtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trackappdetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackappdetailtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackappdetailtbAggregateArgs>(args: Subset<T, TrackappdetailtbAggregateArgs>): Prisma.PrismaPromise<GetTrackappdetailtbAggregateType<T>>

    /**
     * Group by Trackappdetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackappdetailtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trackappdetailtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trackappdetailtbGroupByArgs['orderBy'] }
        : { orderBy?: trackappdetailtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trackappdetailtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackappdetailtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trackappdetailtb model
   */
  readonly fields: trackappdetailtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trackappdetailtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trackappdetailtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trackappdetailtb model
   */ 
  interface trackappdetailtbFieldRefs {
    readonly TrackAppDetailId: FieldRef<"trackappdetailtb", 'Int'>
    readonly AppName: FieldRef<"trackappdetailtb", 'String'>
    readonly UserName: FieldRef<"trackappdetailtb", 'String'>
    readonly TrackingDate: FieldRef<"trackappdetailtb", 'DateTime'>
    readonly TrackingTime: FieldRef<"trackappdetailtb", 'DateTime'>
    readonly TimeTotal: FieldRef<"trackappdetailtb", 'Int'>
    readonly AppSession: FieldRef<"trackappdetailtb", 'Boolean'>
    readonly Sent: FieldRef<"trackappdetailtb", 'Boolean'>
    readonly Machine: FieldRef<"trackappdetailtb", 'String'>
    readonly SessionId: FieldRef<"trackappdetailtb", 'Int'>
    readonly ETT: FieldRef<"trackappdetailtb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * trackappdetailtb findUnique
   */
  export type trackappdetailtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which trackappdetailtb to fetch.
     */
    where: trackappdetailtbWhereUniqueInput
  }

  /**
   * trackappdetailtb findUniqueOrThrow
   */
  export type trackappdetailtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which trackappdetailtb to fetch.
     */
    where: trackappdetailtbWhereUniqueInput
  }

  /**
   * trackappdetailtb findFirst
   */
  export type trackappdetailtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which trackappdetailtb to fetch.
     */
    where?: trackappdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackappdetailtbs to fetch.
     */
    orderBy?: trackappdetailtbOrderByWithRelationInput | trackappdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trackappdetailtbs.
     */
    cursor?: trackappdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackappdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackappdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trackappdetailtbs.
     */
    distinct?: TrackappdetailtbScalarFieldEnum | TrackappdetailtbScalarFieldEnum[]
  }

  /**
   * trackappdetailtb findFirstOrThrow
   */
  export type trackappdetailtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which trackappdetailtb to fetch.
     */
    where?: trackappdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackappdetailtbs to fetch.
     */
    orderBy?: trackappdetailtbOrderByWithRelationInput | trackappdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trackappdetailtbs.
     */
    cursor?: trackappdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackappdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackappdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trackappdetailtbs.
     */
    distinct?: TrackappdetailtbScalarFieldEnum | TrackappdetailtbScalarFieldEnum[]
  }

  /**
   * trackappdetailtb findMany
   */
  export type trackappdetailtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which trackappdetailtbs to fetch.
     */
    where?: trackappdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackappdetailtbs to fetch.
     */
    orderBy?: trackappdetailtbOrderByWithRelationInput | trackappdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trackappdetailtbs.
     */
    cursor?: trackappdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackappdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackappdetailtbs.
     */
    skip?: number
    distinct?: TrackappdetailtbScalarFieldEnum | TrackappdetailtbScalarFieldEnum[]
  }

  /**
   * trackappdetailtb create
   */
  export type trackappdetailtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
    /**
     * The data needed to create a trackappdetailtb.
     */
    data: XOR<trackappdetailtbCreateInput, trackappdetailtbUncheckedCreateInput>
  }

  /**
   * trackappdetailtb createMany
   */
  export type trackappdetailtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trackappdetailtbs.
     */
    data: trackappdetailtbCreateManyInput | trackappdetailtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trackappdetailtb update
   */
  export type trackappdetailtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
    /**
     * The data needed to update a trackappdetailtb.
     */
    data: XOR<trackappdetailtbUpdateInput, trackappdetailtbUncheckedUpdateInput>
    /**
     * Choose, which trackappdetailtb to update.
     */
    where: trackappdetailtbWhereUniqueInput
  }

  /**
   * trackappdetailtb updateMany
   */
  export type trackappdetailtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trackappdetailtbs.
     */
    data: XOR<trackappdetailtbUpdateManyMutationInput, trackappdetailtbUncheckedUpdateManyInput>
    /**
     * Filter which trackappdetailtbs to update
     */
    where?: trackappdetailtbWhereInput
  }

  /**
   * trackappdetailtb upsert
   */
  export type trackappdetailtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
    /**
     * The filter to search for the trackappdetailtb to update in case it exists.
     */
    where: trackappdetailtbWhereUniqueInput
    /**
     * In case the trackappdetailtb found by the `where` argument doesn't exist, create a new trackappdetailtb with this data.
     */
    create: XOR<trackappdetailtbCreateInput, trackappdetailtbUncheckedCreateInput>
    /**
     * In case the trackappdetailtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trackappdetailtbUpdateInput, trackappdetailtbUncheckedUpdateInput>
  }

  /**
   * trackappdetailtb delete
   */
  export type trackappdetailtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
    /**
     * Filter which trackappdetailtb to delete.
     */
    where: trackappdetailtbWhereUniqueInput
  }

  /**
   * trackappdetailtb deleteMany
   */
  export type trackappdetailtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trackappdetailtbs to delete
     */
    where?: trackappdetailtbWhereInput
  }

  /**
   * trackappdetailtb without action
   */
  export type trackappdetailtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackappdetailtb
     */
    select?: trackappdetailtbSelect<ExtArgs> | null
  }


  /**
   * Model trackapptb
   */

  export type AggregateTrackapptb = {
    _count: TrackapptbCountAggregateOutputType | null
    _avg: TrackapptbAvgAggregateOutputType | null
    _sum: TrackapptbSumAggregateOutputType | null
    _min: TrackapptbMinAggregateOutputType | null
    _max: TrackapptbMaxAggregateOutputType | null
  }

  export type TrackapptbAvgAggregateOutputType = {
    TrackingType: number | null
  }

  export type TrackapptbSumAggregateOutputType = {
    TrackingType: number | null
  }

  export type TrackapptbMinAggregateOutputType = {
    AppName: string | null
    TrackingType: number | null
  }

  export type TrackapptbMaxAggregateOutputType = {
    AppName: string | null
    TrackingType: number | null
  }

  export type TrackapptbCountAggregateOutputType = {
    AppName: number
    TrackingType: number
    _all: number
  }


  export type TrackapptbAvgAggregateInputType = {
    TrackingType?: true
  }

  export type TrackapptbSumAggregateInputType = {
    TrackingType?: true
  }

  export type TrackapptbMinAggregateInputType = {
    AppName?: true
    TrackingType?: true
  }

  export type TrackapptbMaxAggregateInputType = {
    AppName?: true
    TrackingType?: true
  }

  export type TrackapptbCountAggregateInputType = {
    AppName?: true
    TrackingType?: true
    _all?: true
  }

  export type TrackapptbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trackapptb to aggregate.
     */
    where?: trackapptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackapptbs to fetch.
     */
    orderBy?: trackapptbOrderByWithRelationInput | trackapptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trackapptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackapptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackapptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trackapptbs
    **/
    _count?: true | TrackapptbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrackapptbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrackapptbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackapptbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackapptbMaxAggregateInputType
  }

  export type GetTrackapptbAggregateType<T extends TrackapptbAggregateArgs> = {
        [P in keyof T & keyof AggregateTrackapptb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrackapptb[P]>
      : GetScalarType<T[P], AggregateTrackapptb[P]>
  }




  export type trackapptbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trackapptbWhereInput
    orderBy?: trackapptbOrderByWithAggregationInput | trackapptbOrderByWithAggregationInput[]
    by: TrackapptbScalarFieldEnum[] | TrackapptbScalarFieldEnum
    having?: trackapptbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackapptbCountAggregateInputType | true
    _avg?: TrackapptbAvgAggregateInputType
    _sum?: TrackapptbSumAggregateInputType
    _min?: TrackapptbMinAggregateInputType
    _max?: TrackapptbMaxAggregateInputType
  }

  export type TrackapptbGroupByOutputType = {
    AppName: string
    TrackingType: number
    _count: TrackapptbCountAggregateOutputType | null
    _avg: TrackapptbAvgAggregateOutputType | null
    _sum: TrackapptbSumAggregateOutputType | null
    _min: TrackapptbMinAggregateOutputType | null
    _max: TrackapptbMaxAggregateOutputType | null
  }

  type GetTrackapptbGroupByPayload<T extends trackapptbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackapptbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackapptbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackapptbGroupByOutputType[P]>
            : GetScalarType<T[P], TrackapptbGroupByOutputType[P]>
        }
      >
    >


  export type trackapptbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AppName?: boolean
    TrackingType?: boolean
  }, ExtArgs["result"]["trackapptb"]>


  export type trackapptbSelectScalar = {
    AppName?: boolean
    TrackingType?: boolean
  }


  export type $trackapptbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trackapptb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      AppName: string
      TrackingType: number
    }, ExtArgs["result"]["trackapptb"]>
    composites: {}
  }

  type trackapptbGetPayload<S extends boolean | null | undefined | trackapptbDefaultArgs> = $Result.GetResult<Prisma.$trackapptbPayload, S>

  type trackapptbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<trackapptbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrackapptbCountAggregateInputType | true
    }

  export interface trackapptbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trackapptb'], meta: { name: 'trackapptb' } }
    /**
     * Find zero or one Trackapptb that matches the filter.
     * @param {trackapptbFindUniqueArgs} args - Arguments to find a Trackapptb
     * @example
     * // Get one Trackapptb
     * const trackapptb = await prisma.trackapptb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trackapptbFindUniqueArgs>(args: SelectSubset<T, trackapptbFindUniqueArgs<ExtArgs>>): Prisma__trackapptbClient<$Result.GetResult<Prisma.$trackapptbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trackapptb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {trackapptbFindUniqueOrThrowArgs} args - Arguments to find a Trackapptb
     * @example
     * // Get one Trackapptb
     * const trackapptb = await prisma.trackapptb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trackapptbFindUniqueOrThrowArgs>(args: SelectSubset<T, trackapptbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trackapptbClient<$Result.GetResult<Prisma.$trackapptbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trackapptb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackapptbFindFirstArgs} args - Arguments to find a Trackapptb
     * @example
     * // Get one Trackapptb
     * const trackapptb = await prisma.trackapptb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trackapptbFindFirstArgs>(args?: SelectSubset<T, trackapptbFindFirstArgs<ExtArgs>>): Prisma__trackapptbClient<$Result.GetResult<Prisma.$trackapptbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trackapptb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackapptbFindFirstOrThrowArgs} args - Arguments to find a Trackapptb
     * @example
     * // Get one Trackapptb
     * const trackapptb = await prisma.trackapptb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trackapptbFindFirstOrThrowArgs>(args?: SelectSubset<T, trackapptbFindFirstOrThrowArgs<ExtArgs>>): Prisma__trackapptbClient<$Result.GetResult<Prisma.$trackapptbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trackapptbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackapptbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trackapptbs
     * const trackapptbs = await prisma.trackapptb.findMany()
     * 
     * // Get first 10 Trackapptbs
     * const trackapptbs = await prisma.trackapptb.findMany({ take: 10 })
     * 
     * // Only select the `AppName`
     * const trackapptbWithAppNameOnly = await prisma.trackapptb.findMany({ select: { AppName: true } })
     * 
     */
    findMany<T extends trackapptbFindManyArgs>(args?: SelectSubset<T, trackapptbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trackapptbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trackapptb.
     * @param {trackapptbCreateArgs} args - Arguments to create a Trackapptb.
     * @example
     * // Create one Trackapptb
     * const Trackapptb = await prisma.trackapptb.create({
     *   data: {
     *     // ... data to create a Trackapptb
     *   }
     * })
     * 
     */
    create<T extends trackapptbCreateArgs>(args: SelectSubset<T, trackapptbCreateArgs<ExtArgs>>): Prisma__trackapptbClient<$Result.GetResult<Prisma.$trackapptbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trackapptbs.
     * @param {trackapptbCreateManyArgs} args - Arguments to create many Trackapptbs.
     * @example
     * // Create many Trackapptbs
     * const trackapptb = await prisma.trackapptb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trackapptbCreateManyArgs>(args?: SelectSubset<T, trackapptbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trackapptb.
     * @param {trackapptbDeleteArgs} args - Arguments to delete one Trackapptb.
     * @example
     * // Delete one Trackapptb
     * const Trackapptb = await prisma.trackapptb.delete({
     *   where: {
     *     // ... filter to delete one Trackapptb
     *   }
     * })
     * 
     */
    delete<T extends trackapptbDeleteArgs>(args: SelectSubset<T, trackapptbDeleteArgs<ExtArgs>>): Prisma__trackapptbClient<$Result.GetResult<Prisma.$trackapptbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trackapptb.
     * @param {trackapptbUpdateArgs} args - Arguments to update one Trackapptb.
     * @example
     * // Update one Trackapptb
     * const trackapptb = await prisma.trackapptb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trackapptbUpdateArgs>(args: SelectSubset<T, trackapptbUpdateArgs<ExtArgs>>): Prisma__trackapptbClient<$Result.GetResult<Prisma.$trackapptbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trackapptbs.
     * @param {trackapptbDeleteManyArgs} args - Arguments to filter Trackapptbs to delete.
     * @example
     * // Delete a few Trackapptbs
     * const { count } = await prisma.trackapptb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trackapptbDeleteManyArgs>(args?: SelectSubset<T, trackapptbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trackapptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackapptbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trackapptbs
     * const trackapptb = await prisma.trackapptb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trackapptbUpdateManyArgs>(args: SelectSubset<T, trackapptbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trackapptb.
     * @param {trackapptbUpsertArgs} args - Arguments to update or create a Trackapptb.
     * @example
     * // Update or create a Trackapptb
     * const trackapptb = await prisma.trackapptb.upsert({
     *   create: {
     *     // ... data to create a Trackapptb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trackapptb we want to update
     *   }
     * })
     */
    upsert<T extends trackapptbUpsertArgs>(args: SelectSubset<T, trackapptbUpsertArgs<ExtArgs>>): Prisma__trackapptbClient<$Result.GetResult<Prisma.$trackapptbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trackapptbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackapptbCountArgs} args - Arguments to filter Trackapptbs to count.
     * @example
     * // Count the number of Trackapptbs
     * const count = await prisma.trackapptb.count({
     *   where: {
     *     // ... the filter for the Trackapptbs we want to count
     *   }
     * })
    **/
    count<T extends trackapptbCountArgs>(
      args?: Subset<T, trackapptbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackapptbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trackapptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackapptbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackapptbAggregateArgs>(args: Subset<T, TrackapptbAggregateArgs>): Prisma.PrismaPromise<GetTrackapptbAggregateType<T>>

    /**
     * Group by Trackapptb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackapptbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trackapptbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trackapptbGroupByArgs['orderBy'] }
        : { orderBy?: trackapptbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trackapptbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackapptbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trackapptb model
   */
  readonly fields: trackapptbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trackapptb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trackapptbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trackapptb model
   */ 
  interface trackapptbFieldRefs {
    readonly AppName: FieldRef<"trackapptb", 'String'>
    readonly TrackingType: FieldRef<"trackapptb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * trackapptb findUnique
   */
  export type trackapptbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
    /**
     * Filter, which trackapptb to fetch.
     */
    where: trackapptbWhereUniqueInput
  }

  /**
   * trackapptb findUniqueOrThrow
   */
  export type trackapptbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
    /**
     * Filter, which trackapptb to fetch.
     */
    where: trackapptbWhereUniqueInput
  }

  /**
   * trackapptb findFirst
   */
  export type trackapptbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
    /**
     * Filter, which trackapptb to fetch.
     */
    where?: trackapptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackapptbs to fetch.
     */
    orderBy?: trackapptbOrderByWithRelationInput | trackapptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trackapptbs.
     */
    cursor?: trackapptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackapptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackapptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trackapptbs.
     */
    distinct?: TrackapptbScalarFieldEnum | TrackapptbScalarFieldEnum[]
  }

  /**
   * trackapptb findFirstOrThrow
   */
  export type trackapptbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
    /**
     * Filter, which trackapptb to fetch.
     */
    where?: trackapptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackapptbs to fetch.
     */
    orderBy?: trackapptbOrderByWithRelationInput | trackapptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trackapptbs.
     */
    cursor?: trackapptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackapptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackapptbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trackapptbs.
     */
    distinct?: TrackapptbScalarFieldEnum | TrackapptbScalarFieldEnum[]
  }

  /**
   * trackapptb findMany
   */
  export type trackapptbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
    /**
     * Filter, which trackapptbs to fetch.
     */
    where?: trackapptbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackapptbs to fetch.
     */
    orderBy?: trackapptbOrderByWithRelationInput | trackapptbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trackapptbs.
     */
    cursor?: trackapptbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackapptbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackapptbs.
     */
    skip?: number
    distinct?: TrackapptbScalarFieldEnum | TrackapptbScalarFieldEnum[]
  }

  /**
   * trackapptb create
   */
  export type trackapptbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
    /**
     * The data needed to create a trackapptb.
     */
    data: XOR<trackapptbCreateInput, trackapptbUncheckedCreateInput>
  }

  /**
   * trackapptb createMany
   */
  export type trackapptbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trackapptbs.
     */
    data: trackapptbCreateManyInput | trackapptbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trackapptb update
   */
  export type trackapptbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
    /**
     * The data needed to update a trackapptb.
     */
    data: XOR<trackapptbUpdateInput, trackapptbUncheckedUpdateInput>
    /**
     * Choose, which trackapptb to update.
     */
    where: trackapptbWhereUniqueInput
  }

  /**
   * trackapptb updateMany
   */
  export type trackapptbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trackapptbs.
     */
    data: XOR<trackapptbUpdateManyMutationInput, trackapptbUncheckedUpdateManyInput>
    /**
     * Filter which trackapptbs to update
     */
    where?: trackapptbWhereInput
  }

  /**
   * trackapptb upsert
   */
  export type trackapptbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
    /**
     * The filter to search for the trackapptb to update in case it exists.
     */
    where: trackapptbWhereUniqueInput
    /**
     * In case the trackapptb found by the `where` argument doesn't exist, create a new trackapptb with this data.
     */
    create: XOR<trackapptbCreateInput, trackapptbUncheckedCreateInput>
    /**
     * In case the trackapptb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trackapptbUpdateInput, trackapptbUncheckedUpdateInput>
  }

  /**
   * trackapptb delete
   */
  export type trackapptbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
    /**
     * Filter which trackapptb to delete.
     */
    where: trackapptbWhereUniqueInput
  }

  /**
   * trackapptb deleteMany
   */
  export type trackapptbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trackapptbs to delete
     */
    where?: trackapptbWhereInput
  }

  /**
   * trackapptb without action
   */
  export type trackapptbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackapptb
     */
    select?: trackapptbSelect<ExtArgs> | null
  }


  /**
   * Model trackguitb
   */

  export type AggregateTrackguitb = {
    _count: TrackguitbCountAggregateOutputType | null
    _avg: TrackguitbAvgAggregateOutputType | null
    _sum: TrackguitbSumAggregateOutputType | null
    _min: TrackguitbMinAggregateOutputType | null
    _max: TrackguitbMaxAggregateOutputType | null
  }

  export type TrackguitbAvgAggregateOutputType = {
    ID: number | null
    DialogID: number | null
    ControlID: number | null
    Type: number | null
    ActionCount: number | null
  }

  export type TrackguitbSumAggregateOutputType = {
    ID: number | null
    DialogID: number | null
    ControlID: number | null
    Type: number | null
    ActionCount: number | null
  }

  export type TrackguitbMinAggregateOutputType = {
    ID: number | null
    RecordDate: Date | null
    FromTime: Date | null
    ToTime: Date | null
    DialogID: number | null
    PrePath: string | null
    ControlID: number | null
    Type: number | null
    Param: string | null
    ActionCount: number | null
  }

  export type TrackguitbMaxAggregateOutputType = {
    ID: number | null
    RecordDate: Date | null
    FromTime: Date | null
    ToTime: Date | null
    DialogID: number | null
    PrePath: string | null
    ControlID: number | null
    Type: number | null
    Param: string | null
    ActionCount: number | null
  }

  export type TrackguitbCountAggregateOutputType = {
    ID: number
    RecordDate: number
    FromTime: number
    ToTime: number
    DialogID: number
    PrePath: number
    ControlID: number
    Type: number
    Param: number
    ActionCount: number
    _all: number
  }


  export type TrackguitbAvgAggregateInputType = {
    ID?: true
    DialogID?: true
    ControlID?: true
    Type?: true
    ActionCount?: true
  }

  export type TrackguitbSumAggregateInputType = {
    ID?: true
    DialogID?: true
    ControlID?: true
    Type?: true
    ActionCount?: true
  }

  export type TrackguitbMinAggregateInputType = {
    ID?: true
    RecordDate?: true
    FromTime?: true
    ToTime?: true
    DialogID?: true
    PrePath?: true
    ControlID?: true
    Type?: true
    Param?: true
    ActionCount?: true
  }

  export type TrackguitbMaxAggregateInputType = {
    ID?: true
    RecordDate?: true
    FromTime?: true
    ToTime?: true
    DialogID?: true
    PrePath?: true
    ControlID?: true
    Type?: true
    Param?: true
    ActionCount?: true
  }

  export type TrackguitbCountAggregateInputType = {
    ID?: true
    RecordDate?: true
    FromTime?: true
    ToTime?: true
    DialogID?: true
    PrePath?: true
    ControlID?: true
    Type?: true
    Param?: true
    ActionCount?: true
    _all?: true
  }

  export type TrackguitbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trackguitb to aggregate.
     */
    where?: trackguitbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackguitbs to fetch.
     */
    orderBy?: trackguitbOrderByWithRelationInput | trackguitbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trackguitbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackguitbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackguitbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trackguitbs
    **/
    _count?: true | TrackguitbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrackguitbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrackguitbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackguitbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackguitbMaxAggregateInputType
  }

  export type GetTrackguitbAggregateType<T extends TrackguitbAggregateArgs> = {
        [P in keyof T & keyof AggregateTrackguitb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrackguitb[P]>
      : GetScalarType<T[P], AggregateTrackguitb[P]>
  }




  export type trackguitbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trackguitbWhereInput
    orderBy?: trackguitbOrderByWithAggregationInput | trackguitbOrderByWithAggregationInput[]
    by: TrackguitbScalarFieldEnum[] | TrackguitbScalarFieldEnum
    having?: trackguitbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackguitbCountAggregateInputType | true
    _avg?: TrackguitbAvgAggregateInputType
    _sum?: TrackguitbSumAggregateInputType
    _min?: TrackguitbMinAggregateInputType
    _max?: TrackguitbMaxAggregateInputType
  }

  export type TrackguitbGroupByOutputType = {
    ID: number
    RecordDate: Date
    FromTime: Date
    ToTime: Date
    DialogID: number
    PrePath: string | null
    ControlID: number
    Type: number
    Param: string | null
    ActionCount: number
    _count: TrackguitbCountAggregateOutputType | null
    _avg: TrackguitbAvgAggregateOutputType | null
    _sum: TrackguitbSumAggregateOutputType | null
    _min: TrackguitbMinAggregateOutputType | null
    _max: TrackguitbMaxAggregateOutputType | null
  }

  type GetTrackguitbGroupByPayload<T extends trackguitbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackguitbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackguitbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackguitbGroupByOutputType[P]>
            : GetScalarType<T[P], TrackguitbGroupByOutputType[P]>
        }
      >
    >


  export type trackguitbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    RecordDate?: boolean
    FromTime?: boolean
    ToTime?: boolean
    DialogID?: boolean
    PrePath?: boolean
    ControlID?: boolean
    Type?: boolean
    Param?: boolean
    ActionCount?: boolean
  }, ExtArgs["result"]["trackguitb"]>


  export type trackguitbSelectScalar = {
    ID?: boolean
    RecordDate?: boolean
    FromTime?: boolean
    ToTime?: boolean
    DialogID?: boolean
    PrePath?: boolean
    ControlID?: boolean
    Type?: boolean
    Param?: boolean
    ActionCount?: boolean
  }


  export type $trackguitbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trackguitb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      RecordDate: Date
      FromTime: Date
      ToTime: Date
      DialogID: number
      PrePath: string | null
      ControlID: number
      Type: number
      Param: string | null
      ActionCount: number
    }, ExtArgs["result"]["trackguitb"]>
    composites: {}
  }

  type trackguitbGetPayload<S extends boolean | null | undefined | trackguitbDefaultArgs> = $Result.GetResult<Prisma.$trackguitbPayload, S>

  type trackguitbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<trackguitbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrackguitbCountAggregateInputType | true
    }

  export interface trackguitbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trackguitb'], meta: { name: 'trackguitb' } }
    /**
     * Find zero or one Trackguitb that matches the filter.
     * @param {trackguitbFindUniqueArgs} args - Arguments to find a Trackguitb
     * @example
     * // Get one Trackguitb
     * const trackguitb = await prisma.trackguitb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trackguitbFindUniqueArgs>(args: SelectSubset<T, trackguitbFindUniqueArgs<ExtArgs>>): Prisma__trackguitbClient<$Result.GetResult<Prisma.$trackguitbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Trackguitb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {trackguitbFindUniqueOrThrowArgs} args - Arguments to find a Trackguitb
     * @example
     * // Get one Trackguitb
     * const trackguitb = await prisma.trackguitb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trackguitbFindUniqueOrThrowArgs>(args: SelectSubset<T, trackguitbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trackguitbClient<$Result.GetResult<Prisma.$trackguitbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Trackguitb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackguitbFindFirstArgs} args - Arguments to find a Trackguitb
     * @example
     * // Get one Trackguitb
     * const trackguitb = await prisma.trackguitb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trackguitbFindFirstArgs>(args?: SelectSubset<T, trackguitbFindFirstArgs<ExtArgs>>): Prisma__trackguitbClient<$Result.GetResult<Prisma.$trackguitbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Trackguitb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackguitbFindFirstOrThrowArgs} args - Arguments to find a Trackguitb
     * @example
     * // Get one Trackguitb
     * const trackguitb = await prisma.trackguitb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trackguitbFindFirstOrThrowArgs>(args?: SelectSubset<T, trackguitbFindFirstOrThrowArgs<ExtArgs>>): Prisma__trackguitbClient<$Result.GetResult<Prisma.$trackguitbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trackguitbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackguitbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trackguitbs
     * const trackguitbs = await prisma.trackguitb.findMany()
     * 
     * // Get first 10 Trackguitbs
     * const trackguitbs = await prisma.trackguitb.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const trackguitbWithIDOnly = await prisma.trackguitb.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends trackguitbFindManyArgs>(args?: SelectSubset<T, trackguitbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trackguitbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Trackguitb.
     * @param {trackguitbCreateArgs} args - Arguments to create a Trackguitb.
     * @example
     * // Create one Trackguitb
     * const Trackguitb = await prisma.trackguitb.create({
     *   data: {
     *     // ... data to create a Trackguitb
     *   }
     * })
     * 
     */
    create<T extends trackguitbCreateArgs>(args: SelectSubset<T, trackguitbCreateArgs<ExtArgs>>): Prisma__trackguitbClient<$Result.GetResult<Prisma.$trackguitbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trackguitbs.
     * @param {trackguitbCreateManyArgs} args - Arguments to create many Trackguitbs.
     * @example
     * // Create many Trackguitbs
     * const trackguitb = await prisma.trackguitb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trackguitbCreateManyArgs>(args?: SelectSubset<T, trackguitbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Trackguitb.
     * @param {trackguitbDeleteArgs} args - Arguments to delete one Trackguitb.
     * @example
     * // Delete one Trackguitb
     * const Trackguitb = await prisma.trackguitb.delete({
     *   where: {
     *     // ... filter to delete one Trackguitb
     *   }
     * })
     * 
     */
    delete<T extends trackguitbDeleteArgs>(args: SelectSubset<T, trackguitbDeleteArgs<ExtArgs>>): Prisma__trackguitbClient<$Result.GetResult<Prisma.$trackguitbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Trackguitb.
     * @param {trackguitbUpdateArgs} args - Arguments to update one Trackguitb.
     * @example
     * // Update one Trackguitb
     * const trackguitb = await prisma.trackguitb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trackguitbUpdateArgs>(args: SelectSubset<T, trackguitbUpdateArgs<ExtArgs>>): Prisma__trackguitbClient<$Result.GetResult<Prisma.$trackguitbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trackguitbs.
     * @param {trackguitbDeleteManyArgs} args - Arguments to filter Trackguitbs to delete.
     * @example
     * // Delete a few Trackguitbs
     * const { count } = await prisma.trackguitb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trackguitbDeleteManyArgs>(args?: SelectSubset<T, trackguitbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trackguitbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackguitbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trackguitbs
     * const trackguitb = await prisma.trackguitb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trackguitbUpdateManyArgs>(args: SelectSubset<T, trackguitbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Trackguitb.
     * @param {trackguitbUpsertArgs} args - Arguments to update or create a Trackguitb.
     * @example
     * // Update or create a Trackguitb
     * const trackguitb = await prisma.trackguitb.upsert({
     *   create: {
     *     // ... data to create a Trackguitb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trackguitb we want to update
     *   }
     * })
     */
    upsert<T extends trackguitbUpsertArgs>(args: SelectSubset<T, trackguitbUpsertArgs<ExtArgs>>): Prisma__trackguitbClient<$Result.GetResult<Prisma.$trackguitbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trackguitbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackguitbCountArgs} args - Arguments to filter Trackguitbs to count.
     * @example
     * // Count the number of Trackguitbs
     * const count = await prisma.trackguitb.count({
     *   where: {
     *     // ... the filter for the Trackguitbs we want to count
     *   }
     * })
    **/
    count<T extends trackguitbCountArgs>(
      args?: Subset<T, trackguitbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackguitbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trackguitb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackguitbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackguitbAggregateArgs>(args: Subset<T, TrackguitbAggregateArgs>): Prisma.PrismaPromise<GetTrackguitbAggregateType<T>>

    /**
     * Group by Trackguitb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trackguitbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trackguitbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trackguitbGroupByArgs['orderBy'] }
        : { orderBy?: trackguitbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trackguitbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackguitbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trackguitb model
   */
  readonly fields: trackguitbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trackguitb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trackguitbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trackguitb model
   */ 
  interface trackguitbFieldRefs {
    readonly ID: FieldRef<"trackguitb", 'Int'>
    readonly RecordDate: FieldRef<"trackguitb", 'DateTime'>
    readonly FromTime: FieldRef<"trackguitb", 'DateTime'>
    readonly ToTime: FieldRef<"trackguitb", 'DateTime'>
    readonly DialogID: FieldRef<"trackguitb", 'Int'>
    readonly PrePath: FieldRef<"trackguitb", 'String'>
    readonly ControlID: FieldRef<"trackguitb", 'Int'>
    readonly Type: FieldRef<"trackguitb", 'Int'>
    readonly Param: FieldRef<"trackguitb", 'String'>
    readonly ActionCount: FieldRef<"trackguitb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * trackguitb findUnique
   */
  export type trackguitbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
    /**
     * Filter, which trackguitb to fetch.
     */
    where: trackguitbWhereUniqueInput
  }

  /**
   * trackguitb findUniqueOrThrow
   */
  export type trackguitbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
    /**
     * Filter, which trackguitb to fetch.
     */
    where: trackguitbWhereUniqueInput
  }

  /**
   * trackguitb findFirst
   */
  export type trackguitbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
    /**
     * Filter, which trackguitb to fetch.
     */
    where?: trackguitbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackguitbs to fetch.
     */
    orderBy?: trackguitbOrderByWithRelationInput | trackguitbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trackguitbs.
     */
    cursor?: trackguitbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackguitbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackguitbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trackguitbs.
     */
    distinct?: TrackguitbScalarFieldEnum | TrackguitbScalarFieldEnum[]
  }

  /**
   * trackguitb findFirstOrThrow
   */
  export type trackguitbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
    /**
     * Filter, which trackguitb to fetch.
     */
    where?: trackguitbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackguitbs to fetch.
     */
    orderBy?: trackguitbOrderByWithRelationInput | trackguitbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trackguitbs.
     */
    cursor?: trackguitbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackguitbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackguitbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trackguitbs.
     */
    distinct?: TrackguitbScalarFieldEnum | TrackguitbScalarFieldEnum[]
  }

  /**
   * trackguitb findMany
   */
  export type trackguitbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
    /**
     * Filter, which trackguitbs to fetch.
     */
    where?: trackguitbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trackguitbs to fetch.
     */
    orderBy?: trackguitbOrderByWithRelationInput | trackguitbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trackguitbs.
     */
    cursor?: trackguitbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trackguitbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trackguitbs.
     */
    skip?: number
    distinct?: TrackguitbScalarFieldEnum | TrackguitbScalarFieldEnum[]
  }

  /**
   * trackguitb create
   */
  export type trackguitbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
    /**
     * The data needed to create a trackguitb.
     */
    data: XOR<trackguitbCreateInput, trackguitbUncheckedCreateInput>
  }

  /**
   * trackguitb createMany
   */
  export type trackguitbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trackguitbs.
     */
    data: trackguitbCreateManyInput | trackguitbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trackguitb update
   */
  export type trackguitbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
    /**
     * The data needed to update a trackguitb.
     */
    data: XOR<trackguitbUpdateInput, trackguitbUncheckedUpdateInput>
    /**
     * Choose, which trackguitb to update.
     */
    where: trackguitbWhereUniqueInput
  }

  /**
   * trackguitb updateMany
   */
  export type trackguitbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trackguitbs.
     */
    data: XOR<trackguitbUpdateManyMutationInput, trackguitbUncheckedUpdateManyInput>
    /**
     * Filter which trackguitbs to update
     */
    where?: trackguitbWhereInput
  }

  /**
   * trackguitb upsert
   */
  export type trackguitbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
    /**
     * The filter to search for the trackguitb to update in case it exists.
     */
    where: trackguitbWhereUniqueInput
    /**
     * In case the trackguitb found by the `where` argument doesn't exist, create a new trackguitb with this data.
     */
    create: XOR<trackguitbCreateInput, trackguitbUncheckedCreateInput>
    /**
     * In case the trackguitb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trackguitbUpdateInput, trackguitbUncheckedUpdateInput>
  }

  /**
   * trackguitb delete
   */
  export type trackguitbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
    /**
     * Filter which trackguitb to delete.
     */
    where: trackguitbWhereUniqueInput
  }

  /**
   * trackguitb deleteMany
   */
  export type trackguitbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trackguitbs to delete
     */
    where?: trackguitbWhereInput
  }

  /**
   * trackguitb without action
   */
  export type trackguitbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trackguitb
     */
    select?: trackguitbSelect<ExtArgs> | null
  }


  /**
   * Model transferdetailtb
   */

  export type AggregateTransferdetailtb = {
    _count: TransferdetailtbCountAggregateOutputType | null
    _avg: TransferdetailtbAvgAggregateOutputType | null
    _sum: TransferdetailtbSumAggregateOutputType | null
    _min: TransferdetailtbMinAggregateOutputType | null
    _max: TransferdetailtbMaxAggregateOutputType | null
  }

  export type TransferdetailtbAvgAggregateOutputType = {
    TransferDetailId: number | null
    VoucherId: number | null
    FromUserId: number | null
    ToUserId: number | null
  }

  export type TransferdetailtbSumAggregateOutputType = {
    TransferDetailId: number | null
    VoucherId: number | null
    FromUserId: number | null
    ToUserId: number | null
  }

  export type TransferdetailtbMinAggregateOutputType = {
    TransferDetailId: number | null
    VoucherId: number | null
    FromUserId: number | null
    ToUserId: number | null
    TransferDate: Date | null
    TransferTime: Date | null
  }

  export type TransferdetailtbMaxAggregateOutputType = {
    TransferDetailId: number | null
    VoucherId: number | null
    FromUserId: number | null
    ToUserId: number | null
    TransferDate: Date | null
    TransferTime: Date | null
  }

  export type TransferdetailtbCountAggregateOutputType = {
    TransferDetailId: number
    VoucherId: number
    FromUserId: number
    ToUserId: number
    TransferDate: number
    TransferTime: number
    _all: number
  }


  export type TransferdetailtbAvgAggregateInputType = {
    TransferDetailId?: true
    VoucherId?: true
    FromUserId?: true
    ToUserId?: true
  }

  export type TransferdetailtbSumAggregateInputType = {
    TransferDetailId?: true
    VoucherId?: true
    FromUserId?: true
    ToUserId?: true
  }

  export type TransferdetailtbMinAggregateInputType = {
    TransferDetailId?: true
    VoucherId?: true
    FromUserId?: true
    ToUserId?: true
    TransferDate?: true
    TransferTime?: true
  }

  export type TransferdetailtbMaxAggregateInputType = {
    TransferDetailId?: true
    VoucherId?: true
    FromUserId?: true
    ToUserId?: true
    TransferDate?: true
    TransferTime?: true
  }

  export type TransferdetailtbCountAggregateInputType = {
    TransferDetailId?: true
    VoucherId?: true
    FromUserId?: true
    ToUserId?: true
    TransferDate?: true
    TransferTime?: true
    _all?: true
  }

  export type TransferdetailtbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transferdetailtb to aggregate.
     */
    where?: transferdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transferdetailtbs to fetch.
     */
    orderBy?: transferdetailtbOrderByWithRelationInput | transferdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transferdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transferdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transferdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transferdetailtbs
    **/
    _count?: true | TransferdetailtbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransferdetailtbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransferdetailtbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransferdetailtbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransferdetailtbMaxAggregateInputType
  }

  export type GetTransferdetailtbAggregateType<T extends TransferdetailtbAggregateArgs> = {
        [P in keyof T & keyof AggregateTransferdetailtb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransferdetailtb[P]>
      : GetScalarType<T[P], AggregateTransferdetailtb[P]>
  }




  export type transferdetailtbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transferdetailtbWhereInput
    orderBy?: transferdetailtbOrderByWithAggregationInput | transferdetailtbOrderByWithAggregationInput[]
    by: TransferdetailtbScalarFieldEnum[] | TransferdetailtbScalarFieldEnum
    having?: transferdetailtbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransferdetailtbCountAggregateInputType | true
    _avg?: TransferdetailtbAvgAggregateInputType
    _sum?: TransferdetailtbSumAggregateInputType
    _min?: TransferdetailtbMinAggregateInputType
    _max?: TransferdetailtbMaxAggregateInputType
  }

  export type TransferdetailtbGroupByOutputType = {
    TransferDetailId: number
    VoucherId: number
    FromUserId: number
    ToUserId: number
    TransferDate: Date
    TransferTime: Date
    _count: TransferdetailtbCountAggregateOutputType | null
    _avg: TransferdetailtbAvgAggregateOutputType | null
    _sum: TransferdetailtbSumAggregateOutputType | null
    _min: TransferdetailtbMinAggregateOutputType | null
    _max: TransferdetailtbMaxAggregateOutputType | null
  }

  type GetTransferdetailtbGroupByPayload<T extends transferdetailtbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransferdetailtbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransferdetailtbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransferdetailtbGroupByOutputType[P]>
            : GetScalarType<T[P], TransferdetailtbGroupByOutputType[P]>
        }
      >
    >


  export type transferdetailtbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TransferDetailId?: boolean
    VoucherId?: boolean
    FromUserId?: boolean
    ToUserId?: boolean
    TransferDate?: boolean
    TransferTime?: boolean
  }, ExtArgs["result"]["transferdetailtb"]>


  export type transferdetailtbSelectScalar = {
    TransferDetailId?: boolean
    VoucherId?: boolean
    FromUserId?: boolean
    ToUserId?: boolean
    TransferDate?: boolean
    TransferTime?: boolean
  }


  export type $transferdetailtbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transferdetailtb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      TransferDetailId: number
      VoucherId: number
      FromUserId: number
      ToUserId: number
      TransferDate: Date
      TransferTime: Date
    }, ExtArgs["result"]["transferdetailtb"]>
    composites: {}
  }

  type transferdetailtbGetPayload<S extends boolean | null | undefined | transferdetailtbDefaultArgs> = $Result.GetResult<Prisma.$transferdetailtbPayload, S>

  type transferdetailtbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<transferdetailtbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransferdetailtbCountAggregateInputType | true
    }

  export interface transferdetailtbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transferdetailtb'], meta: { name: 'transferdetailtb' } }
    /**
     * Find zero or one Transferdetailtb that matches the filter.
     * @param {transferdetailtbFindUniqueArgs} args - Arguments to find a Transferdetailtb
     * @example
     * // Get one Transferdetailtb
     * const transferdetailtb = await prisma.transferdetailtb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transferdetailtbFindUniqueArgs>(args: SelectSubset<T, transferdetailtbFindUniqueArgs<ExtArgs>>): Prisma__transferdetailtbClient<$Result.GetResult<Prisma.$transferdetailtbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transferdetailtb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {transferdetailtbFindUniqueOrThrowArgs} args - Arguments to find a Transferdetailtb
     * @example
     * // Get one Transferdetailtb
     * const transferdetailtb = await prisma.transferdetailtb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transferdetailtbFindUniqueOrThrowArgs>(args: SelectSubset<T, transferdetailtbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transferdetailtbClient<$Result.GetResult<Prisma.$transferdetailtbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transferdetailtb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transferdetailtbFindFirstArgs} args - Arguments to find a Transferdetailtb
     * @example
     * // Get one Transferdetailtb
     * const transferdetailtb = await prisma.transferdetailtb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transferdetailtbFindFirstArgs>(args?: SelectSubset<T, transferdetailtbFindFirstArgs<ExtArgs>>): Prisma__transferdetailtbClient<$Result.GetResult<Prisma.$transferdetailtbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transferdetailtb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transferdetailtbFindFirstOrThrowArgs} args - Arguments to find a Transferdetailtb
     * @example
     * // Get one Transferdetailtb
     * const transferdetailtb = await prisma.transferdetailtb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transferdetailtbFindFirstOrThrowArgs>(args?: SelectSubset<T, transferdetailtbFindFirstOrThrowArgs<ExtArgs>>): Prisma__transferdetailtbClient<$Result.GetResult<Prisma.$transferdetailtbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transferdetailtbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transferdetailtbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transferdetailtbs
     * const transferdetailtbs = await prisma.transferdetailtb.findMany()
     * 
     * // Get first 10 Transferdetailtbs
     * const transferdetailtbs = await prisma.transferdetailtb.findMany({ take: 10 })
     * 
     * // Only select the `TransferDetailId`
     * const transferdetailtbWithTransferDetailIdOnly = await prisma.transferdetailtb.findMany({ select: { TransferDetailId: true } })
     * 
     */
    findMany<T extends transferdetailtbFindManyArgs>(args?: SelectSubset<T, transferdetailtbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transferdetailtbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transferdetailtb.
     * @param {transferdetailtbCreateArgs} args - Arguments to create a Transferdetailtb.
     * @example
     * // Create one Transferdetailtb
     * const Transferdetailtb = await prisma.transferdetailtb.create({
     *   data: {
     *     // ... data to create a Transferdetailtb
     *   }
     * })
     * 
     */
    create<T extends transferdetailtbCreateArgs>(args: SelectSubset<T, transferdetailtbCreateArgs<ExtArgs>>): Prisma__transferdetailtbClient<$Result.GetResult<Prisma.$transferdetailtbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transferdetailtbs.
     * @param {transferdetailtbCreateManyArgs} args - Arguments to create many Transferdetailtbs.
     * @example
     * // Create many Transferdetailtbs
     * const transferdetailtb = await prisma.transferdetailtb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transferdetailtbCreateManyArgs>(args?: SelectSubset<T, transferdetailtbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transferdetailtb.
     * @param {transferdetailtbDeleteArgs} args - Arguments to delete one Transferdetailtb.
     * @example
     * // Delete one Transferdetailtb
     * const Transferdetailtb = await prisma.transferdetailtb.delete({
     *   where: {
     *     // ... filter to delete one Transferdetailtb
     *   }
     * })
     * 
     */
    delete<T extends transferdetailtbDeleteArgs>(args: SelectSubset<T, transferdetailtbDeleteArgs<ExtArgs>>): Prisma__transferdetailtbClient<$Result.GetResult<Prisma.$transferdetailtbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transferdetailtb.
     * @param {transferdetailtbUpdateArgs} args - Arguments to update one Transferdetailtb.
     * @example
     * // Update one Transferdetailtb
     * const transferdetailtb = await prisma.transferdetailtb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transferdetailtbUpdateArgs>(args: SelectSubset<T, transferdetailtbUpdateArgs<ExtArgs>>): Prisma__transferdetailtbClient<$Result.GetResult<Prisma.$transferdetailtbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transferdetailtbs.
     * @param {transferdetailtbDeleteManyArgs} args - Arguments to filter Transferdetailtbs to delete.
     * @example
     * // Delete a few Transferdetailtbs
     * const { count } = await prisma.transferdetailtb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transferdetailtbDeleteManyArgs>(args?: SelectSubset<T, transferdetailtbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transferdetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transferdetailtbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transferdetailtbs
     * const transferdetailtb = await prisma.transferdetailtb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transferdetailtbUpdateManyArgs>(args: SelectSubset<T, transferdetailtbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transferdetailtb.
     * @param {transferdetailtbUpsertArgs} args - Arguments to update or create a Transferdetailtb.
     * @example
     * // Update or create a Transferdetailtb
     * const transferdetailtb = await prisma.transferdetailtb.upsert({
     *   create: {
     *     // ... data to create a Transferdetailtb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transferdetailtb we want to update
     *   }
     * })
     */
    upsert<T extends transferdetailtbUpsertArgs>(args: SelectSubset<T, transferdetailtbUpsertArgs<ExtArgs>>): Prisma__transferdetailtbClient<$Result.GetResult<Prisma.$transferdetailtbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transferdetailtbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transferdetailtbCountArgs} args - Arguments to filter Transferdetailtbs to count.
     * @example
     * // Count the number of Transferdetailtbs
     * const count = await prisma.transferdetailtb.count({
     *   where: {
     *     // ... the filter for the Transferdetailtbs we want to count
     *   }
     * })
    **/
    count<T extends transferdetailtbCountArgs>(
      args?: Subset<T, transferdetailtbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransferdetailtbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transferdetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransferdetailtbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransferdetailtbAggregateArgs>(args: Subset<T, TransferdetailtbAggregateArgs>): Prisma.PrismaPromise<GetTransferdetailtbAggregateType<T>>

    /**
     * Group by Transferdetailtb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transferdetailtbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transferdetailtbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transferdetailtbGroupByArgs['orderBy'] }
        : { orderBy?: transferdetailtbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transferdetailtbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransferdetailtbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transferdetailtb model
   */
  readonly fields: transferdetailtbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transferdetailtb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transferdetailtbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transferdetailtb model
   */ 
  interface transferdetailtbFieldRefs {
    readonly TransferDetailId: FieldRef<"transferdetailtb", 'Int'>
    readonly VoucherId: FieldRef<"transferdetailtb", 'Int'>
    readonly FromUserId: FieldRef<"transferdetailtb", 'Int'>
    readonly ToUserId: FieldRef<"transferdetailtb", 'Int'>
    readonly TransferDate: FieldRef<"transferdetailtb", 'DateTime'>
    readonly TransferTime: FieldRef<"transferdetailtb", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transferdetailtb findUnique
   */
  export type transferdetailtbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which transferdetailtb to fetch.
     */
    where: transferdetailtbWhereUniqueInput
  }

  /**
   * transferdetailtb findUniqueOrThrow
   */
  export type transferdetailtbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which transferdetailtb to fetch.
     */
    where: transferdetailtbWhereUniqueInput
  }

  /**
   * transferdetailtb findFirst
   */
  export type transferdetailtbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which transferdetailtb to fetch.
     */
    where?: transferdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transferdetailtbs to fetch.
     */
    orderBy?: transferdetailtbOrderByWithRelationInput | transferdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transferdetailtbs.
     */
    cursor?: transferdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transferdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transferdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transferdetailtbs.
     */
    distinct?: TransferdetailtbScalarFieldEnum | TransferdetailtbScalarFieldEnum[]
  }

  /**
   * transferdetailtb findFirstOrThrow
   */
  export type transferdetailtbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which transferdetailtb to fetch.
     */
    where?: transferdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transferdetailtbs to fetch.
     */
    orderBy?: transferdetailtbOrderByWithRelationInput | transferdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transferdetailtbs.
     */
    cursor?: transferdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transferdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transferdetailtbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transferdetailtbs.
     */
    distinct?: TransferdetailtbScalarFieldEnum | TransferdetailtbScalarFieldEnum[]
  }

  /**
   * transferdetailtb findMany
   */
  export type transferdetailtbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
    /**
     * Filter, which transferdetailtbs to fetch.
     */
    where?: transferdetailtbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transferdetailtbs to fetch.
     */
    orderBy?: transferdetailtbOrderByWithRelationInput | transferdetailtbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transferdetailtbs.
     */
    cursor?: transferdetailtbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transferdetailtbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transferdetailtbs.
     */
    skip?: number
    distinct?: TransferdetailtbScalarFieldEnum | TransferdetailtbScalarFieldEnum[]
  }

  /**
   * transferdetailtb create
   */
  export type transferdetailtbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
    /**
     * The data needed to create a transferdetailtb.
     */
    data: XOR<transferdetailtbCreateInput, transferdetailtbUncheckedCreateInput>
  }

  /**
   * transferdetailtb createMany
   */
  export type transferdetailtbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transferdetailtbs.
     */
    data: transferdetailtbCreateManyInput | transferdetailtbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transferdetailtb update
   */
  export type transferdetailtbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
    /**
     * The data needed to update a transferdetailtb.
     */
    data: XOR<transferdetailtbUpdateInput, transferdetailtbUncheckedUpdateInput>
    /**
     * Choose, which transferdetailtb to update.
     */
    where: transferdetailtbWhereUniqueInput
  }

  /**
   * transferdetailtb updateMany
   */
  export type transferdetailtbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transferdetailtbs.
     */
    data: XOR<transferdetailtbUpdateManyMutationInput, transferdetailtbUncheckedUpdateManyInput>
    /**
     * Filter which transferdetailtbs to update
     */
    where?: transferdetailtbWhereInput
  }

  /**
   * transferdetailtb upsert
   */
  export type transferdetailtbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
    /**
     * The filter to search for the transferdetailtb to update in case it exists.
     */
    where: transferdetailtbWhereUniqueInput
    /**
     * In case the transferdetailtb found by the `where` argument doesn't exist, create a new transferdetailtb with this data.
     */
    create: XOR<transferdetailtbCreateInput, transferdetailtbUncheckedCreateInput>
    /**
     * In case the transferdetailtb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transferdetailtbUpdateInput, transferdetailtbUncheckedUpdateInput>
  }

  /**
   * transferdetailtb delete
   */
  export type transferdetailtbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
    /**
     * Filter which transferdetailtb to delete.
     */
    where: transferdetailtbWhereUniqueInput
  }

  /**
   * transferdetailtb deleteMany
   */
  export type transferdetailtbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transferdetailtbs to delete
     */
    where?: transferdetailtbWhereInput
  }

  /**
   * transferdetailtb without action
   */
  export type transferdetailtbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transferdetailtb
     */
    select?: transferdetailtbSelect<ExtArgs> | null
  }


  /**
   * Model usagetimetb
   */

  export type AggregateUsagetimetb = {
    _count: UsagetimetbCountAggregateOutputType | null
    _avg: UsagetimetbAvgAggregateOutputType | null
    _sum: UsagetimetbSumAggregateOutputType | null
    _min: UsagetimetbMinAggregateOutputType | null
    _max: UsagetimetbMaxAggregateOutputType | null
  }

  export type UsagetimetbAvgAggregateOutputType = {
    UsageTimeId: number | null
    FromAge: number | null
    ToAge: number | null
    UserType: number | null
  }

  export type UsagetimetbSumAggregateOutputType = {
    UsageTimeId: number | null
    FromAge: number | null
    ToAge: number | null
    UserType: number | null
  }

  export type UsagetimetbMinAggregateOutputType = {
    UsageTimeId: number | null
    UsageTimeName: string | null
    FromAge: number | null
    ToAge: number | null
    UserType: number | null
  }

  export type UsagetimetbMaxAggregateOutputType = {
    UsageTimeId: number | null
    UsageTimeName: string | null
    FromAge: number | null
    ToAge: number | null
    UserType: number | null
  }

  export type UsagetimetbCountAggregateOutputType = {
    UsageTimeId: number
    UsageTimeName: number
    FromAge: number
    ToAge: number
    UserType: number
    _all: number
  }


  export type UsagetimetbAvgAggregateInputType = {
    UsageTimeId?: true
    FromAge?: true
    ToAge?: true
    UserType?: true
  }

  export type UsagetimetbSumAggregateInputType = {
    UsageTimeId?: true
    FromAge?: true
    ToAge?: true
    UserType?: true
  }

  export type UsagetimetbMinAggregateInputType = {
    UsageTimeId?: true
    UsageTimeName?: true
    FromAge?: true
    ToAge?: true
    UserType?: true
  }

  export type UsagetimetbMaxAggregateInputType = {
    UsageTimeId?: true
    UsageTimeName?: true
    FromAge?: true
    ToAge?: true
    UserType?: true
  }

  export type UsagetimetbCountAggregateInputType = {
    UsageTimeId?: true
    UsageTimeName?: true
    FromAge?: true
    ToAge?: true
    UserType?: true
    _all?: true
  }

  export type UsagetimetbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usagetimetb to aggregate.
     */
    where?: usagetimetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usagetimetbs to fetch.
     */
    orderBy?: usagetimetbOrderByWithRelationInput | usagetimetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usagetimetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usagetimetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usagetimetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usagetimetbs
    **/
    _count?: true | UsagetimetbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsagetimetbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsagetimetbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsagetimetbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsagetimetbMaxAggregateInputType
  }

  export type GetUsagetimetbAggregateType<T extends UsagetimetbAggregateArgs> = {
        [P in keyof T & keyof AggregateUsagetimetb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsagetimetb[P]>
      : GetScalarType<T[P], AggregateUsagetimetb[P]>
  }




  export type usagetimetbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usagetimetbWhereInput
    orderBy?: usagetimetbOrderByWithAggregationInput | usagetimetbOrderByWithAggregationInput[]
    by: UsagetimetbScalarFieldEnum[] | UsagetimetbScalarFieldEnum
    having?: usagetimetbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsagetimetbCountAggregateInputType | true
    _avg?: UsagetimetbAvgAggregateInputType
    _sum?: UsagetimetbSumAggregateInputType
    _min?: UsagetimetbMinAggregateInputType
    _max?: UsagetimetbMaxAggregateInputType
  }

  export type UsagetimetbGroupByOutputType = {
    UsageTimeId: number
    UsageTimeName: string | null
    FromAge: number | null
    ToAge: number | null
    UserType: number
    _count: UsagetimetbCountAggregateOutputType | null
    _avg: UsagetimetbAvgAggregateOutputType | null
    _sum: UsagetimetbSumAggregateOutputType | null
    _min: UsagetimetbMinAggregateOutputType | null
    _max: UsagetimetbMaxAggregateOutputType | null
  }

  type GetUsagetimetbGroupByPayload<T extends usagetimetbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsagetimetbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsagetimetbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsagetimetbGroupByOutputType[P]>
            : GetScalarType<T[P], UsagetimetbGroupByOutputType[P]>
        }
      >
    >


  export type usagetimetbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UsageTimeId?: boolean
    UsageTimeName?: boolean
    FromAge?: boolean
    ToAge?: boolean
    UserType?: boolean
  }, ExtArgs["result"]["usagetimetb"]>


  export type usagetimetbSelectScalar = {
    UsageTimeId?: boolean
    UsageTimeName?: boolean
    FromAge?: boolean
    ToAge?: boolean
    UserType?: boolean
  }


  export type $usagetimetbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usagetimetb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      UsageTimeId: number
      UsageTimeName: string | null
      FromAge: number | null
      ToAge: number | null
      UserType: number
    }, ExtArgs["result"]["usagetimetb"]>
    composites: {}
  }

  type usagetimetbGetPayload<S extends boolean | null | undefined | usagetimetbDefaultArgs> = $Result.GetResult<Prisma.$usagetimetbPayload, S>

  type usagetimetbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usagetimetbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsagetimetbCountAggregateInputType | true
    }

  export interface usagetimetbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usagetimetb'], meta: { name: 'usagetimetb' } }
    /**
     * Find zero or one Usagetimetb that matches the filter.
     * @param {usagetimetbFindUniqueArgs} args - Arguments to find a Usagetimetb
     * @example
     * // Get one Usagetimetb
     * const usagetimetb = await prisma.usagetimetb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usagetimetbFindUniqueArgs>(args: SelectSubset<T, usagetimetbFindUniqueArgs<ExtArgs>>): Prisma__usagetimetbClient<$Result.GetResult<Prisma.$usagetimetbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usagetimetb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usagetimetbFindUniqueOrThrowArgs} args - Arguments to find a Usagetimetb
     * @example
     * // Get one Usagetimetb
     * const usagetimetb = await prisma.usagetimetb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usagetimetbFindUniqueOrThrowArgs>(args: SelectSubset<T, usagetimetbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usagetimetbClient<$Result.GetResult<Prisma.$usagetimetbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usagetimetb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usagetimetbFindFirstArgs} args - Arguments to find a Usagetimetb
     * @example
     * // Get one Usagetimetb
     * const usagetimetb = await prisma.usagetimetb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usagetimetbFindFirstArgs>(args?: SelectSubset<T, usagetimetbFindFirstArgs<ExtArgs>>): Prisma__usagetimetbClient<$Result.GetResult<Prisma.$usagetimetbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usagetimetb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usagetimetbFindFirstOrThrowArgs} args - Arguments to find a Usagetimetb
     * @example
     * // Get one Usagetimetb
     * const usagetimetb = await prisma.usagetimetb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usagetimetbFindFirstOrThrowArgs>(args?: SelectSubset<T, usagetimetbFindFirstOrThrowArgs<ExtArgs>>): Prisma__usagetimetbClient<$Result.GetResult<Prisma.$usagetimetbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usagetimetbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usagetimetbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usagetimetbs
     * const usagetimetbs = await prisma.usagetimetb.findMany()
     * 
     * // Get first 10 Usagetimetbs
     * const usagetimetbs = await prisma.usagetimetb.findMany({ take: 10 })
     * 
     * // Only select the `UsageTimeId`
     * const usagetimetbWithUsageTimeIdOnly = await prisma.usagetimetb.findMany({ select: { UsageTimeId: true } })
     * 
     */
    findMany<T extends usagetimetbFindManyArgs>(args?: SelectSubset<T, usagetimetbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usagetimetbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usagetimetb.
     * @param {usagetimetbCreateArgs} args - Arguments to create a Usagetimetb.
     * @example
     * // Create one Usagetimetb
     * const Usagetimetb = await prisma.usagetimetb.create({
     *   data: {
     *     // ... data to create a Usagetimetb
     *   }
     * })
     * 
     */
    create<T extends usagetimetbCreateArgs>(args: SelectSubset<T, usagetimetbCreateArgs<ExtArgs>>): Prisma__usagetimetbClient<$Result.GetResult<Prisma.$usagetimetbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usagetimetbs.
     * @param {usagetimetbCreateManyArgs} args - Arguments to create many Usagetimetbs.
     * @example
     * // Create many Usagetimetbs
     * const usagetimetb = await prisma.usagetimetb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usagetimetbCreateManyArgs>(args?: SelectSubset<T, usagetimetbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usagetimetb.
     * @param {usagetimetbDeleteArgs} args - Arguments to delete one Usagetimetb.
     * @example
     * // Delete one Usagetimetb
     * const Usagetimetb = await prisma.usagetimetb.delete({
     *   where: {
     *     // ... filter to delete one Usagetimetb
     *   }
     * })
     * 
     */
    delete<T extends usagetimetbDeleteArgs>(args: SelectSubset<T, usagetimetbDeleteArgs<ExtArgs>>): Prisma__usagetimetbClient<$Result.GetResult<Prisma.$usagetimetbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usagetimetb.
     * @param {usagetimetbUpdateArgs} args - Arguments to update one Usagetimetb.
     * @example
     * // Update one Usagetimetb
     * const usagetimetb = await prisma.usagetimetb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usagetimetbUpdateArgs>(args: SelectSubset<T, usagetimetbUpdateArgs<ExtArgs>>): Prisma__usagetimetbClient<$Result.GetResult<Prisma.$usagetimetbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usagetimetbs.
     * @param {usagetimetbDeleteManyArgs} args - Arguments to filter Usagetimetbs to delete.
     * @example
     * // Delete a few Usagetimetbs
     * const { count } = await prisma.usagetimetb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usagetimetbDeleteManyArgs>(args?: SelectSubset<T, usagetimetbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usagetimetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usagetimetbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usagetimetbs
     * const usagetimetb = await prisma.usagetimetb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usagetimetbUpdateManyArgs>(args: SelectSubset<T, usagetimetbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usagetimetb.
     * @param {usagetimetbUpsertArgs} args - Arguments to update or create a Usagetimetb.
     * @example
     * // Update or create a Usagetimetb
     * const usagetimetb = await prisma.usagetimetb.upsert({
     *   create: {
     *     // ... data to create a Usagetimetb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usagetimetb we want to update
     *   }
     * })
     */
    upsert<T extends usagetimetbUpsertArgs>(args: SelectSubset<T, usagetimetbUpsertArgs<ExtArgs>>): Prisma__usagetimetbClient<$Result.GetResult<Prisma.$usagetimetbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usagetimetbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usagetimetbCountArgs} args - Arguments to filter Usagetimetbs to count.
     * @example
     * // Count the number of Usagetimetbs
     * const count = await prisma.usagetimetb.count({
     *   where: {
     *     // ... the filter for the Usagetimetbs we want to count
     *   }
     * })
    **/
    count<T extends usagetimetbCountArgs>(
      args?: Subset<T, usagetimetbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsagetimetbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usagetimetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsagetimetbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsagetimetbAggregateArgs>(args: Subset<T, UsagetimetbAggregateArgs>): Prisma.PrismaPromise<GetUsagetimetbAggregateType<T>>

    /**
     * Group by Usagetimetb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usagetimetbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usagetimetbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usagetimetbGroupByArgs['orderBy'] }
        : { orderBy?: usagetimetbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usagetimetbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsagetimetbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usagetimetb model
   */
  readonly fields: usagetimetbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usagetimetb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usagetimetbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usagetimetb model
   */ 
  interface usagetimetbFieldRefs {
    readonly UsageTimeId: FieldRef<"usagetimetb", 'Int'>
    readonly UsageTimeName: FieldRef<"usagetimetb", 'String'>
    readonly FromAge: FieldRef<"usagetimetb", 'Int'>
    readonly ToAge: FieldRef<"usagetimetb", 'Int'>
    readonly UserType: FieldRef<"usagetimetb", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * usagetimetb findUnique
   */
  export type usagetimetbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
    /**
     * Filter, which usagetimetb to fetch.
     */
    where: usagetimetbWhereUniqueInput
  }

  /**
   * usagetimetb findUniqueOrThrow
   */
  export type usagetimetbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
    /**
     * Filter, which usagetimetb to fetch.
     */
    where: usagetimetbWhereUniqueInput
  }

  /**
   * usagetimetb findFirst
   */
  export type usagetimetbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
    /**
     * Filter, which usagetimetb to fetch.
     */
    where?: usagetimetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usagetimetbs to fetch.
     */
    orderBy?: usagetimetbOrderByWithRelationInput | usagetimetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usagetimetbs.
     */
    cursor?: usagetimetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usagetimetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usagetimetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usagetimetbs.
     */
    distinct?: UsagetimetbScalarFieldEnum | UsagetimetbScalarFieldEnum[]
  }

  /**
   * usagetimetb findFirstOrThrow
   */
  export type usagetimetbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
    /**
     * Filter, which usagetimetb to fetch.
     */
    where?: usagetimetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usagetimetbs to fetch.
     */
    orderBy?: usagetimetbOrderByWithRelationInput | usagetimetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usagetimetbs.
     */
    cursor?: usagetimetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usagetimetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usagetimetbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usagetimetbs.
     */
    distinct?: UsagetimetbScalarFieldEnum | UsagetimetbScalarFieldEnum[]
  }

  /**
   * usagetimetb findMany
   */
  export type usagetimetbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
    /**
     * Filter, which usagetimetbs to fetch.
     */
    where?: usagetimetbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usagetimetbs to fetch.
     */
    orderBy?: usagetimetbOrderByWithRelationInput | usagetimetbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usagetimetbs.
     */
    cursor?: usagetimetbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usagetimetbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usagetimetbs.
     */
    skip?: number
    distinct?: UsagetimetbScalarFieldEnum | UsagetimetbScalarFieldEnum[]
  }

  /**
   * usagetimetb create
   */
  export type usagetimetbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
    /**
     * The data needed to create a usagetimetb.
     */
    data?: XOR<usagetimetbCreateInput, usagetimetbUncheckedCreateInput>
  }

  /**
   * usagetimetb createMany
   */
  export type usagetimetbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usagetimetbs.
     */
    data: usagetimetbCreateManyInput | usagetimetbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usagetimetb update
   */
  export type usagetimetbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
    /**
     * The data needed to update a usagetimetb.
     */
    data: XOR<usagetimetbUpdateInput, usagetimetbUncheckedUpdateInput>
    /**
     * Choose, which usagetimetb to update.
     */
    where: usagetimetbWhereUniqueInput
  }

  /**
   * usagetimetb updateMany
   */
  export type usagetimetbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usagetimetbs.
     */
    data: XOR<usagetimetbUpdateManyMutationInput, usagetimetbUncheckedUpdateManyInput>
    /**
     * Filter which usagetimetbs to update
     */
    where?: usagetimetbWhereInput
  }

  /**
   * usagetimetb upsert
   */
  export type usagetimetbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
    /**
     * The filter to search for the usagetimetb to update in case it exists.
     */
    where: usagetimetbWhereUniqueInput
    /**
     * In case the usagetimetb found by the `where` argument doesn't exist, create a new usagetimetb with this data.
     */
    create: XOR<usagetimetbCreateInput, usagetimetbUncheckedCreateInput>
    /**
     * In case the usagetimetb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usagetimetbUpdateInput, usagetimetbUncheckedUpdateInput>
  }

  /**
   * usagetimetb delete
   */
  export type usagetimetbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
    /**
     * Filter which usagetimetb to delete.
     */
    where: usagetimetbWhereUniqueInput
  }

  /**
   * usagetimetb deleteMany
   */
  export type usagetimetbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usagetimetbs to delete
     */
    where?: usagetimetbWhereInput
  }

  /**
   * usagetimetb without action
   */
  export type usagetimetbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usagetimetb
     */
    select?: usagetimetbSelect<ExtArgs> | null
  }


  /**
   * Model usertb
   */

  export type AggregateUsertb = {
    _count: UsertbCountAggregateOutputType | null
    _avg: UsertbAvgAggregateOutputType | null
    _sum: UsertbSumAggregateOutputType | null
    _min: UsertbMinAggregateOutputType | null
    _max: UsertbMaxAggregateOutputType | null
  }

  export type UsertbAvgAggregateOutputType = {
    UserId: number | null
    Debit: Decimal | null
    CreditLimit: Decimal | null
    UserType: number | null
    TimePaid: number | null
    TimeUsed: number | null
    MoneyPaid: number | null
    MoneyUsed: number | null
    RemainTime: number | null
    FreeTime: number | null
    TimeTransfer: number | null
    RemainMoney: number | null
    FreeMoney: number | null
    MoneyTransfer: number | null
    UsageTimeId: number | null
    PromotionTime: number | null
    PromotionMoney: number | null
    MachineGroupId: number | null
    changepcdetailId: number | null
    MoneyUsedMin: number | null
    CType: number | null
    Status: number | null
    PriceAppRentID: number | null
    EIType: number | null
  }

  export type UsertbSumAggregateOutputType = {
    UserId: number | null
    Debit: Decimal | null
    CreditLimit: Decimal | null
    UserType: number | null
    TimePaid: number | null
    TimeUsed: number | null
    MoneyPaid: number | null
    MoneyUsed: number | null
    RemainTime: number | null
    FreeTime: number | null
    TimeTransfer: number | null
    RemainMoney: number | null
    FreeMoney: number | null
    MoneyTransfer: number | null
    UsageTimeId: number | null
    PromotionTime: number | null
    PromotionMoney: number | null
    MachineGroupId: number | null
    changepcdetailId: number | null
    MoneyUsedMin: number | null
    CType: number | null
    Status: number | null
    PriceAppRentID: number | null
    EIType: number | null
  }

  export type UsertbMinAggregateOutputType = {
    UserId: number | null
    FirstName: string | null
    LastName: string | null
    MiddleName: string | null
    UserName: string | null
    Password: string | null
    ID: string | null
    Address: string | null
    Phone: string | null
    Email: string | null
    City: string | null
    State: string | null
    Zipcode: string | null
    Debit: Decimal | null
    CreditLimit: Decimal | null
    Active: boolean | null
    RecordDate: Date | null
    ExpiryDate: Date | null
    UserType: number | null
    Memo: string | null
    Birthdate: Date | null
    SSN1: string | null
    SSN2: string | null
    SSN3: string | null
    TimePaid: number | null
    TimeUsed: number | null
    MoneyPaid: number | null
    MoneyUsed: number | null
    RemainTime: number | null
    FreeTime: number | null
    TimeTransfer: number | null
    RemainMoney: number | null
    FreeMoney: number | null
    MoneyTransfer: number | null
    UsageTimeId: number | null
    PromotionTime: number | null
    PromotionMoney: number | null
    MachineGroupId: number | null
    MAC: string | null
    changepcdetailId: number | null
    MoneyUsedMin: number | null
    CType: number | null
    Status: number | null
    LastLoginDate: Date | null
    PriceAppRentID: number | null
    EIType: number | null
    pc_rptInfo: string | null
  }

  export type UsertbMaxAggregateOutputType = {
    UserId: number | null
    FirstName: string | null
    LastName: string | null
    MiddleName: string | null
    UserName: string | null
    Password: string | null
    ID: string | null
    Address: string | null
    Phone: string | null
    Email: string | null
    City: string | null
    State: string | null
    Zipcode: string | null
    Debit: Decimal | null
    CreditLimit: Decimal | null
    Active: boolean | null
    RecordDate: Date | null
    ExpiryDate: Date | null
    UserType: number | null
    Memo: string | null
    Birthdate: Date | null
    SSN1: string | null
    SSN2: string | null
    SSN3: string | null
    TimePaid: number | null
    TimeUsed: number | null
    MoneyPaid: number | null
    MoneyUsed: number | null
    RemainTime: number | null
    FreeTime: number | null
    TimeTransfer: number | null
    RemainMoney: number | null
    FreeMoney: number | null
    MoneyTransfer: number | null
    UsageTimeId: number | null
    PromotionTime: number | null
    PromotionMoney: number | null
    MachineGroupId: number | null
    MAC: string | null
    changepcdetailId: number | null
    MoneyUsedMin: number | null
    CType: number | null
    Status: number | null
    LastLoginDate: Date | null
    PriceAppRentID: number | null
    EIType: number | null
    pc_rptInfo: string | null
  }

  export type UsertbCountAggregateOutputType = {
    UserId: number
    FirstName: number
    LastName: number
    MiddleName: number
    UserName: number
    Password: number
    ID: number
    Address: number
    Phone: number
    Email: number
    City: number
    State: number
    Zipcode: number
    Debit: number
    CreditLimit: number
    Active: number
    RecordDate: number
    ExpiryDate: number
    UserType: number
    Memo: number
    Birthdate: number
    SSN1: number
    SSN2: number
    SSN3: number
    TimePaid: number
    TimeUsed: number
    MoneyPaid: number
    MoneyUsed: number
    RemainTime: number
    FreeTime: number
    TimeTransfer: number
    RemainMoney: number
    FreeMoney: number
    MoneyTransfer: number
    UsageTimeId: number
    PromotionTime: number
    PromotionMoney: number
    MachineGroupId: number
    MAC: number
    changepcdetailId: number
    MoneyUsedMin: number
    CType: number
    Status: number
    LastLoginDate: number
    PriceAppRentID: number
    EIType: number
    pc_rptInfo: number
    _all: number
  }


  export type UsertbAvgAggregateInputType = {
    UserId?: true
    Debit?: true
    CreditLimit?: true
    UserType?: true
    TimePaid?: true
    TimeUsed?: true
    MoneyPaid?: true
    MoneyUsed?: true
    RemainTime?: true
    FreeTime?: true
    TimeTransfer?: true
    RemainMoney?: true
    FreeMoney?: true
    MoneyTransfer?: true
    UsageTimeId?: true
    PromotionTime?: true
    PromotionMoney?: true
    MachineGroupId?: true
    changepcdetailId?: true
    MoneyUsedMin?: true
    CType?: true
    Status?: true
    PriceAppRentID?: true
    EIType?: true
  }

  export type UsertbSumAggregateInputType = {
    UserId?: true
    Debit?: true
    CreditLimit?: true
    UserType?: true
    TimePaid?: true
    TimeUsed?: true
    MoneyPaid?: true
    MoneyUsed?: true
    RemainTime?: true
    FreeTime?: true
    TimeTransfer?: true
    RemainMoney?: true
    FreeMoney?: true
    MoneyTransfer?: true
    UsageTimeId?: true
    PromotionTime?: true
    PromotionMoney?: true
    MachineGroupId?: true
    changepcdetailId?: true
    MoneyUsedMin?: true
    CType?: true
    Status?: true
    PriceAppRentID?: true
    EIType?: true
  }

  export type UsertbMinAggregateInputType = {
    UserId?: true
    FirstName?: true
    LastName?: true
    MiddleName?: true
    UserName?: true
    Password?: true
    ID?: true
    Address?: true
    Phone?: true
    Email?: true
    City?: true
    State?: true
    Zipcode?: true
    Debit?: true
    CreditLimit?: true
    Active?: true
    RecordDate?: true
    ExpiryDate?: true
    UserType?: true
    Memo?: true
    Birthdate?: true
    SSN1?: true
    SSN2?: true
    SSN3?: true
    TimePaid?: true
    TimeUsed?: true
    MoneyPaid?: true
    MoneyUsed?: true
    RemainTime?: true
    FreeTime?: true
    TimeTransfer?: true
    RemainMoney?: true
    FreeMoney?: true
    MoneyTransfer?: true
    UsageTimeId?: true
    PromotionTime?: true
    PromotionMoney?: true
    MachineGroupId?: true
    MAC?: true
    changepcdetailId?: true
    MoneyUsedMin?: true
    CType?: true
    Status?: true
    LastLoginDate?: true
    PriceAppRentID?: true
    EIType?: true
    pc_rptInfo?: true
  }

  export type UsertbMaxAggregateInputType = {
    UserId?: true
    FirstName?: true
    LastName?: true
    MiddleName?: true
    UserName?: true
    Password?: true
    ID?: true
    Address?: true
    Phone?: true
    Email?: true
    City?: true
    State?: true
    Zipcode?: true
    Debit?: true
    CreditLimit?: true
    Active?: true
    RecordDate?: true
    ExpiryDate?: true
    UserType?: true
    Memo?: true
    Birthdate?: true
    SSN1?: true
    SSN2?: true
    SSN3?: true
    TimePaid?: true
    TimeUsed?: true
    MoneyPaid?: true
    MoneyUsed?: true
    RemainTime?: true
    FreeTime?: true
    TimeTransfer?: true
    RemainMoney?: true
    FreeMoney?: true
    MoneyTransfer?: true
    UsageTimeId?: true
    PromotionTime?: true
    PromotionMoney?: true
    MachineGroupId?: true
    MAC?: true
    changepcdetailId?: true
    MoneyUsedMin?: true
    CType?: true
    Status?: true
    LastLoginDate?: true
    PriceAppRentID?: true
    EIType?: true
    pc_rptInfo?: true
  }

  export type UsertbCountAggregateInputType = {
    UserId?: true
    FirstName?: true
    LastName?: true
    MiddleName?: true
    UserName?: true
    Password?: true
    ID?: true
    Address?: true
    Phone?: true
    Email?: true
    City?: true
    State?: true
    Zipcode?: true
    Debit?: true
    CreditLimit?: true
    Active?: true
    RecordDate?: true
    ExpiryDate?: true
    UserType?: true
    Memo?: true
    Birthdate?: true
    SSN1?: true
    SSN2?: true
    SSN3?: true
    TimePaid?: true
    TimeUsed?: true
    MoneyPaid?: true
    MoneyUsed?: true
    RemainTime?: true
    FreeTime?: true
    TimeTransfer?: true
    RemainMoney?: true
    FreeMoney?: true
    MoneyTransfer?: true
    UsageTimeId?: true
    PromotionTime?: true
    PromotionMoney?: true
    MachineGroupId?: true
    MAC?: true
    changepcdetailId?: true
    MoneyUsedMin?: true
    CType?: true
    Status?: true
    LastLoginDate?: true
    PriceAppRentID?: true
    EIType?: true
    pc_rptInfo?: true
    _all?: true
  }

  export type UsertbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usertb to aggregate.
     */
    where?: usertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usertbs to fetch.
     */
    orderBy?: usertbOrderByWithRelationInput | usertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usertbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usertbs
    **/
    _count?: true | UsertbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsertbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsertbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsertbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsertbMaxAggregateInputType
  }

  export type GetUsertbAggregateType<T extends UsertbAggregateArgs> = {
        [P in keyof T & keyof AggregateUsertb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsertb[P]>
      : GetScalarType<T[P], AggregateUsertb[P]>
  }




  export type usertbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usertbWhereInput
    orderBy?: usertbOrderByWithAggregationInput | usertbOrderByWithAggregationInput[]
    by: UsertbScalarFieldEnum[] | UsertbScalarFieldEnum
    having?: usertbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsertbCountAggregateInputType | true
    _avg?: UsertbAvgAggregateInputType
    _sum?: UsertbSumAggregateInputType
    _min?: UsertbMinAggregateInputType
    _max?: UsertbMaxAggregateInputType
  }

  export type UsertbGroupByOutputType = {
    UserId: number
    FirstName: string | null
    LastName: string | null
    MiddleName: string | null
    UserName: string
    Password: string
    ID: string
    Address: string
    Phone: string
    Email: string
    City: string
    State: string
    Zipcode: string
    Debit: Decimal
    CreditLimit: Decimal
    Active: boolean
    RecordDate: Date
    ExpiryDate: Date | null
    UserType: number
    Memo: string
    Birthdate: Date | null
    SSN1: string
    SSN2: string
    SSN3: string
    TimePaid: number
    TimeUsed: number
    MoneyPaid: number
    MoneyUsed: number
    RemainTime: number
    FreeTime: number
    TimeTransfer: number
    RemainMoney: number
    FreeMoney: number
    MoneyTransfer: number
    UsageTimeId: number
    PromotionTime: number
    PromotionMoney: number
    MachineGroupId: number
    MAC: string
    changepcdetailId: number
    MoneyUsedMin: number
    CType: number | null
    Status: number | null
    LastLoginDate: Date
    PriceAppRentID: number
    EIType: number | null
    pc_rptInfo: string | null
    _count: UsertbCountAggregateOutputType | null
    _avg: UsertbAvgAggregateOutputType | null
    _sum: UsertbSumAggregateOutputType | null
    _min: UsertbMinAggregateOutputType | null
    _max: UsertbMaxAggregateOutputType | null
  }

  type GetUsertbGroupByPayload<T extends usertbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsertbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsertbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsertbGroupByOutputType[P]>
            : GetScalarType<T[P], UsertbGroupByOutputType[P]>
        }
      >
    >


  export type usertbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserId?: boolean
    FirstName?: boolean
    LastName?: boolean
    MiddleName?: boolean
    UserName?: boolean
    Password?: boolean
    ID?: boolean
    Address?: boolean
    Phone?: boolean
    Email?: boolean
    City?: boolean
    State?: boolean
    Zipcode?: boolean
    Debit?: boolean
    CreditLimit?: boolean
    Active?: boolean
    RecordDate?: boolean
    ExpiryDate?: boolean
    UserType?: boolean
    Memo?: boolean
    Birthdate?: boolean
    SSN1?: boolean
    SSN2?: boolean
    SSN3?: boolean
    TimePaid?: boolean
    TimeUsed?: boolean
    MoneyPaid?: boolean
    MoneyUsed?: boolean
    RemainTime?: boolean
    FreeTime?: boolean
    TimeTransfer?: boolean
    RemainMoney?: boolean
    FreeMoney?: boolean
    MoneyTransfer?: boolean
    UsageTimeId?: boolean
    PromotionTime?: boolean
    PromotionMoney?: boolean
    MachineGroupId?: boolean
    MAC?: boolean
    changepcdetailId?: boolean
    MoneyUsedMin?: boolean
    CType?: boolean
    Status?: boolean
    LastLoginDate?: boolean
    PriceAppRentID?: boolean
    EIType?: boolean
    pc_rptInfo?: boolean
  }, ExtArgs["result"]["usertb"]>


  export type usertbSelectScalar = {
    UserId?: boolean
    FirstName?: boolean
    LastName?: boolean
    MiddleName?: boolean
    UserName?: boolean
    Password?: boolean
    ID?: boolean
    Address?: boolean
    Phone?: boolean
    Email?: boolean
    City?: boolean
    State?: boolean
    Zipcode?: boolean
    Debit?: boolean
    CreditLimit?: boolean
    Active?: boolean
    RecordDate?: boolean
    ExpiryDate?: boolean
    UserType?: boolean
    Memo?: boolean
    Birthdate?: boolean
    SSN1?: boolean
    SSN2?: boolean
    SSN3?: boolean
    TimePaid?: boolean
    TimeUsed?: boolean
    MoneyPaid?: boolean
    MoneyUsed?: boolean
    RemainTime?: boolean
    FreeTime?: boolean
    TimeTransfer?: boolean
    RemainMoney?: boolean
    FreeMoney?: boolean
    MoneyTransfer?: boolean
    UsageTimeId?: boolean
    PromotionTime?: boolean
    PromotionMoney?: boolean
    MachineGroupId?: boolean
    MAC?: boolean
    changepcdetailId?: boolean
    MoneyUsedMin?: boolean
    CType?: boolean
    Status?: boolean
    LastLoginDate?: boolean
    PriceAppRentID?: boolean
    EIType?: boolean
    pc_rptInfo?: boolean
  }


  export type $usertbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usertb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      UserId: number
      FirstName: string | null
      LastName: string | null
      MiddleName: string | null
      UserName: string
      Password: string
      ID: string
      Address: string
      Phone: string
      Email: string
      City: string
      State: string
      Zipcode: string
      Debit: Prisma.Decimal
      CreditLimit: Prisma.Decimal
      Active: boolean
      RecordDate: Date
      ExpiryDate: Date | null
      UserType: number
      Memo: string
      Birthdate: Date | null
      SSN1: string
      SSN2: string
      SSN3: string
      TimePaid: number
      TimeUsed: number
      MoneyPaid: number
      MoneyUsed: number
      RemainTime: number
      FreeTime: number
      TimeTransfer: number
      RemainMoney: number
      FreeMoney: number
      MoneyTransfer: number
      UsageTimeId: number
      PromotionTime: number
      PromotionMoney: number
      MachineGroupId: number
      MAC: string
      changepcdetailId: number
      MoneyUsedMin: number
      CType: number | null
      Status: number | null
      LastLoginDate: Date
      PriceAppRentID: number
      EIType: number | null
      pc_rptInfo: string | null
    }, ExtArgs["result"]["usertb"]>
    composites: {}
  }

  type usertbGetPayload<S extends boolean | null | undefined | usertbDefaultArgs> = $Result.GetResult<Prisma.$usertbPayload, S>

  type usertbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usertbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsertbCountAggregateInputType | true
    }

  export interface usertbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usertb'], meta: { name: 'usertb' } }
    /**
     * Find zero or one Usertb that matches the filter.
     * @param {usertbFindUniqueArgs} args - Arguments to find a Usertb
     * @example
     * // Get one Usertb
     * const usertb = await prisma.usertb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usertbFindUniqueArgs>(args: SelectSubset<T, usertbFindUniqueArgs<ExtArgs>>): Prisma__usertbClient<$Result.GetResult<Prisma.$usertbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usertb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usertbFindUniqueOrThrowArgs} args - Arguments to find a Usertb
     * @example
     * // Get one Usertb
     * const usertb = await prisma.usertb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usertbFindUniqueOrThrowArgs>(args: SelectSubset<T, usertbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usertbClient<$Result.GetResult<Prisma.$usertbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usertb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertbFindFirstArgs} args - Arguments to find a Usertb
     * @example
     * // Get one Usertb
     * const usertb = await prisma.usertb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usertbFindFirstArgs>(args?: SelectSubset<T, usertbFindFirstArgs<ExtArgs>>): Prisma__usertbClient<$Result.GetResult<Prisma.$usertbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usertb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertbFindFirstOrThrowArgs} args - Arguments to find a Usertb
     * @example
     * // Get one Usertb
     * const usertb = await prisma.usertb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usertbFindFirstOrThrowArgs>(args?: SelectSubset<T, usertbFindFirstOrThrowArgs<ExtArgs>>): Prisma__usertbClient<$Result.GetResult<Prisma.$usertbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usertbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usertbs
     * const usertbs = await prisma.usertb.findMany()
     * 
     * // Get first 10 Usertbs
     * const usertbs = await prisma.usertb.findMany({ take: 10 })
     * 
     * // Only select the `UserId`
     * const usertbWithUserIdOnly = await prisma.usertb.findMany({ select: { UserId: true } })
     * 
     */
    findMany<T extends usertbFindManyArgs>(args?: SelectSubset<T, usertbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usertbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usertb.
     * @param {usertbCreateArgs} args - Arguments to create a Usertb.
     * @example
     * // Create one Usertb
     * const Usertb = await prisma.usertb.create({
     *   data: {
     *     // ... data to create a Usertb
     *   }
     * })
     * 
     */
    create<T extends usertbCreateArgs>(args: SelectSubset<T, usertbCreateArgs<ExtArgs>>): Prisma__usertbClient<$Result.GetResult<Prisma.$usertbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usertbs.
     * @param {usertbCreateManyArgs} args - Arguments to create many Usertbs.
     * @example
     * // Create many Usertbs
     * const usertb = await prisma.usertb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usertbCreateManyArgs>(args?: SelectSubset<T, usertbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usertb.
     * @param {usertbDeleteArgs} args - Arguments to delete one Usertb.
     * @example
     * // Delete one Usertb
     * const Usertb = await prisma.usertb.delete({
     *   where: {
     *     // ... filter to delete one Usertb
     *   }
     * })
     * 
     */
    delete<T extends usertbDeleteArgs>(args: SelectSubset<T, usertbDeleteArgs<ExtArgs>>): Prisma__usertbClient<$Result.GetResult<Prisma.$usertbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usertb.
     * @param {usertbUpdateArgs} args - Arguments to update one Usertb.
     * @example
     * // Update one Usertb
     * const usertb = await prisma.usertb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usertbUpdateArgs>(args: SelectSubset<T, usertbUpdateArgs<ExtArgs>>): Prisma__usertbClient<$Result.GetResult<Prisma.$usertbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usertbs.
     * @param {usertbDeleteManyArgs} args - Arguments to filter Usertbs to delete.
     * @example
     * // Delete a few Usertbs
     * const { count } = await prisma.usertb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usertbDeleteManyArgs>(args?: SelectSubset<T, usertbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usertbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usertbs
     * const usertb = await prisma.usertb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usertbUpdateManyArgs>(args: SelectSubset<T, usertbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usertb.
     * @param {usertbUpsertArgs} args - Arguments to update or create a Usertb.
     * @example
     * // Update or create a Usertb
     * const usertb = await prisma.usertb.upsert({
     *   create: {
     *     // ... data to create a Usertb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usertb we want to update
     *   }
     * })
     */
    upsert<T extends usertbUpsertArgs>(args: SelectSubset<T, usertbUpsertArgs<ExtArgs>>): Prisma__usertbClient<$Result.GetResult<Prisma.$usertbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usertbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertbCountArgs} args - Arguments to filter Usertbs to count.
     * @example
     * // Count the number of Usertbs
     * const count = await prisma.usertb.count({
     *   where: {
     *     // ... the filter for the Usertbs we want to count
     *   }
     * })
    **/
    count<T extends usertbCountArgs>(
      args?: Subset<T, usertbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsertbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usertb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsertbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsertbAggregateArgs>(args: Subset<T, UsertbAggregateArgs>): Prisma.PrismaPromise<GetUsertbAggregateType<T>>

    /**
     * Group by Usertb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usertbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usertbGroupByArgs['orderBy'] }
        : { orderBy?: usertbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usertbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsertbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usertb model
   */
  readonly fields: usertbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usertb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usertbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usertb model
   */ 
  interface usertbFieldRefs {
    readonly UserId: FieldRef<"usertb", 'Int'>
    readonly FirstName: FieldRef<"usertb", 'String'>
    readonly LastName: FieldRef<"usertb", 'String'>
    readonly MiddleName: FieldRef<"usertb", 'String'>
    readonly UserName: FieldRef<"usertb", 'String'>
    readonly Password: FieldRef<"usertb", 'String'>
    readonly ID: FieldRef<"usertb", 'String'>
    readonly Address: FieldRef<"usertb", 'String'>
    readonly Phone: FieldRef<"usertb", 'String'>
    readonly Email: FieldRef<"usertb", 'String'>
    readonly City: FieldRef<"usertb", 'String'>
    readonly State: FieldRef<"usertb", 'String'>
    readonly Zipcode: FieldRef<"usertb", 'String'>
    readonly Debit: FieldRef<"usertb", 'Decimal'>
    readonly CreditLimit: FieldRef<"usertb", 'Decimal'>
    readonly Active: FieldRef<"usertb", 'Boolean'>
    readonly RecordDate: FieldRef<"usertb", 'DateTime'>
    readonly ExpiryDate: FieldRef<"usertb", 'DateTime'>
    readonly UserType: FieldRef<"usertb", 'Int'>
    readonly Memo: FieldRef<"usertb", 'String'>
    readonly Birthdate: FieldRef<"usertb", 'DateTime'>
    readonly SSN1: FieldRef<"usertb", 'String'>
    readonly SSN2: FieldRef<"usertb", 'String'>
    readonly SSN3: FieldRef<"usertb", 'String'>
    readonly TimePaid: FieldRef<"usertb", 'Int'>
    readonly TimeUsed: FieldRef<"usertb", 'Int'>
    readonly MoneyPaid: FieldRef<"usertb", 'Int'>
    readonly MoneyUsed: FieldRef<"usertb", 'Int'>
    readonly RemainTime: FieldRef<"usertb", 'Int'>
    readonly FreeTime: FieldRef<"usertb", 'Int'>
    readonly TimeTransfer: FieldRef<"usertb", 'Int'>
    readonly RemainMoney: FieldRef<"usertb", 'Int'>
    readonly FreeMoney: FieldRef<"usertb", 'Int'>
    readonly MoneyTransfer: FieldRef<"usertb", 'Int'>
    readonly UsageTimeId: FieldRef<"usertb", 'Int'>
    readonly PromotionTime: FieldRef<"usertb", 'Int'>
    readonly PromotionMoney: FieldRef<"usertb", 'Int'>
    readonly MachineGroupId: FieldRef<"usertb", 'Int'>
    readonly MAC: FieldRef<"usertb", 'String'>
    readonly changepcdetailId: FieldRef<"usertb", 'Int'>
    readonly MoneyUsedMin: FieldRef<"usertb", 'Int'>
    readonly CType: FieldRef<"usertb", 'Int'>
    readonly Status: FieldRef<"usertb", 'Int'>
    readonly LastLoginDate: FieldRef<"usertb", 'DateTime'>
    readonly PriceAppRentID: FieldRef<"usertb", 'Int'>
    readonly EIType: FieldRef<"usertb", 'Int'>
    readonly pc_rptInfo: FieldRef<"usertb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * usertb findUnique
   */
  export type usertbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
    /**
     * Filter, which usertb to fetch.
     */
    where: usertbWhereUniqueInput
  }

  /**
   * usertb findUniqueOrThrow
   */
  export type usertbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
    /**
     * Filter, which usertb to fetch.
     */
    where: usertbWhereUniqueInput
  }

  /**
   * usertb findFirst
   */
  export type usertbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
    /**
     * Filter, which usertb to fetch.
     */
    where?: usertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usertbs to fetch.
     */
    orderBy?: usertbOrderByWithRelationInput | usertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usertbs.
     */
    cursor?: usertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usertbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usertbs.
     */
    distinct?: UsertbScalarFieldEnum | UsertbScalarFieldEnum[]
  }

  /**
   * usertb findFirstOrThrow
   */
  export type usertbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
    /**
     * Filter, which usertb to fetch.
     */
    where?: usertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usertbs to fetch.
     */
    orderBy?: usertbOrderByWithRelationInput | usertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usertbs.
     */
    cursor?: usertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usertbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usertbs.
     */
    distinct?: UsertbScalarFieldEnum | UsertbScalarFieldEnum[]
  }

  /**
   * usertb findMany
   */
  export type usertbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
    /**
     * Filter, which usertbs to fetch.
     */
    where?: usertbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usertbs to fetch.
     */
    orderBy?: usertbOrderByWithRelationInput | usertbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usertbs.
     */
    cursor?: usertbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usertbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usertbs.
     */
    skip?: number
    distinct?: UsertbScalarFieldEnum | UsertbScalarFieldEnum[]
  }

  /**
   * usertb create
   */
  export type usertbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
    /**
     * The data needed to create a usertb.
     */
    data: XOR<usertbCreateInput, usertbUncheckedCreateInput>
  }

  /**
   * usertb createMany
   */
  export type usertbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usertbs.
     */
    data: usertbCreateManyInput | usertbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usertb update
   */
  export type usertbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
    /**
     * The data needed to update a usertb.
     */
    data: XOR<usertbUpdateInput, usertbUncheckedUpdateInput>
    /**
     * Choose, which usertb to update.
     */
    where: usertbWhereUniqueInput
  }

  /**
   * usertb updateMany
   */
  export type usertbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usertbs.
     */
    data: XOR<usertbUpdateManyMutationInput, usertbUncheckedUpdateManyInput>
    /**
     * Filter which usertbs to update
     */
    where?: usertbWhereInput
  }

  /**
   * usertb upsert
   */
  export type usertbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
    /**
     * The filter to search for the usertb to update in case it exists.
     */
    where: usertbWhereUniqueInput
    /**
     * In case the usertb found by the `where` argument doesn't exist, create a new usertb with this data.
     */
    create: XOR<usertbCreateInput, usertbUncheckedCreateInput>
    /**
     * In case the usertb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usertbUpdateInput, usertbUncheckedUpdateInput>
  }

  /**
   * usertb delete
   */
  export type usertbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
    /**
     * Filter which usertb to delete.
     */
    where: usertbWhereUniqueInput
  }

  /**
   * usertb deleteMany
   */
  export type usertbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usertbs to delete
     */
    where?: usertbWhereInput
  }

  /**
   * usertb without action
   */
  export type usertbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertb
     */
    select?: usertbSelect<ExtArgs> | null
  }


  /**
   * Model versiontb
   */

  export type AggregateVersiontb = {
    _count: VersiontbCountAggregateOutputType | null
    _avg: VersiontbAvgAggregateOutputType | null
    _sum: VersiontbSumAggregateOutputType | null
    _min: VersiontbMinAggregateOutputType | null
    _max: VersiontbMaxAggregateOutputType | null
  }

  export type VersiontbAvgAggregateOutputType = {
    Type: number | null
    DPStatus: number | null
    DPType: number | null
  }

  export type VersiontbSumAggregateOutputType = {
    Type: number | null
    DPStatus: number | null
    DPType: number | null
  }

  export type VersiontbMinAggregateOutputType = {
    ComputerName: string | null
    Version: string | null
    Type: number | null
    ReleaseDate: Date | null
    LastUpdate: Date | null
    DPStatus: number | null
    DPType: number | null
    DPVersion: string | null
  }

  export type VersiontbMaxAggregateOutputType = {
    ComputerName: string | null
    Version: string | null
    Type: number | null
    ReleaseDate: Date | null
    LastUpdate: Date | null
    DPStatus: number | null
    DPType: number | null
    DPVersion: string | null
  }

  export type VersiontbCountAggregateOutputType = {
    ComputerName: number
    Version: number
    Type: number
    ReleaseDate: number
    LastUpdate: number
    DPStatus: number
    DPType: number
    DPVersion: number
    _all: number
  }


  export type VersiontbAvgAggregateInputType = {
    Type?: true
    DPStatus?: true
    DPType?: true
  }

  export type VersiontbSumAggregateInputType = {
    Type?: true
    DPStatus?: true
    DPType?: true
  }

  export type VersiontbMinAggregateInputType = {
    ComputerName?: true
    Version?: true
    Type?: true
    ReleaseDate?: true
    LastUpdate?: true
    DPStatus?: true
    DPType?: true
    DPVersion?: true
  }

  export type VersiontbMaxAggregateInputType = {
    ComputerName?: true
    Version?: true
    Type?: true
    ReleaseDate?: true
    LastUpdate?: true
    DPStatus?: true
    DPType?: true
    DPVersion?: true
  }

  export type VersiontbCountAggregateInputType = {
    ComputerName?: true
    Version?: true
    Type?: true
    ReleaseDate?: true
    LastUpdate?: true
    DPStatus?: true
    DPType?: true
    DPVersion?: true
    _all?: true
  }

  export type VersiontbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which versiontb to aggregate.
     */
    where?: versiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of versiontbs to fetch.
     */
    orderBy?: versiontbOrderByWithRelationInput | versiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: versiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` versiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` versiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned versiontbs
    **/
    _count?: true | VersiontbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VersiontbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VersiontbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersiontbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersiontbMaxAggregateInputType
  }

  export type GetVersiontbAggregateType<T extends VersiontbAggregateArgs> = {
        [P in keyof T & keyof AggregateVersiontb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersiontb[P]>
      : GetScalarType<T[P], AggregateVersiontb[P]>
  }




  export type versiontbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: versiontbWhereInput
    orderBy?: versiontbOrderByWithAggregationInput | versiontbOrderByWithAggregationInput[]
    by: VersiontbScalarFieldEnum[] | VersiontbScalarFieldEnum
    having?: versiontbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersiontbCountAggregateInputType | true
    _avg?: VersiontbAvgAggregateInputType
    _sum?: VersiontbSumAggregateInputType
    _min?: VersiontbMinAggregateInputType
    _max?: VersiontbMaxAggregateInputType
  }

  export type VersiontbGroupByOutputType = {
    ComputerName: string
    Version: string
    Type: number
    ReleaseDate: Date
    LastUpdate: Date
    DPStatus: number | null
    DPType: number | null
    DPVersion: string
    _count: VersiontbCountAggregateOutputType | null
    _avg: VersiontbAvgAggregateOutputType | null
    _sum: VersiontbSumAggregateOutputType | null
    _min: VersiontbMinAggregateOutputType | null
    _max: VersiontbMaxAggregateOutputType | null
  }

  type GetVersiontbGroupByPayload<T extends versiontbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VersiontbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersiontbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersiontbGroupByOutputType[P]>
            : GetScalarType<T[P], VersiontbGroupByOutputType[P]>
        }
      >
    >


  export type versiontbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ComputerName?: boolean
    Version?: boolean
    Type?: boolean
    ReleaseDate?: boolean
    LastUpdate?: boolean
    DPStatus?: boolean
    DPType?: boolean
    DPVersion?: boolean
  }, ExtArgs["result"]["versiontb"]>


  export type versiontbSelectScalar = {
    ComputerName?: boolean
    Version?: boolean
    Type?: boolean
    ReleaseDate?: boolean
    LastUpdate?: boolean
    DPStatus?: boolean
    DPType?: boolean
    DPVersion?: boolean
  }


  export type $versiontbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "versiontb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ComputerName: string
      Version: string
      Type: number
      ReleaseDate: Date
      LastUpdate: Date
      DPStatus: number | null
      DPType: number | null
      DPVersion: string
    }, ExtArgs["result"]["versiontb"]>
    composites: {}
  }

  type versiontbGetPayload<S extends boolean | null | undefined | versiontbDefaultArgs> = $Result.GetResult<Prisma.$versiontbPayload, S>

  type versiontbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<versiontbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VersiontbCountAggregateInputType | true
    }

  export interface versiontbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['versiontb'], meta: { name: 'versiontb' } }
    /**
     * Find zero or one Versiontb that matches the filter.
     * @param {versiontbFindUniqueArgs} args - Arguments to find a Versiontb
     * @example
     * // Get one Versiontb
     * const versiontb = await prisma.versiontb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends versiontbFindUniqueArgs>(args: SelectSubset<T, versiontbFindUniqueArgs<ExtArgs>>): Prisma__versiontbClient<$Result.GetResult<Prisma.$versiontbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Versiontb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {versiontbFindUniqueOrThrowArgs} args - Arguments to find a Versiontb
     * @example
     * // Get one Versiontb
     * const versiontb = await prisma.versiontb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends versiontbFindUniqueOrThrowArgs>(args: SelectSubset<T, versiontbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__versiontbClient<$Result.GetResult<Prisma.$versiontbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Versiontb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versiontbFindFirstArgs} args - Arguments to find a Versiontb
     * @example
     * // Get one Versiontb
     * const versiontb = await prisma.versiontb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends versiontbFindFirstArgs>(args?: SelectSubset<T, versiontbFindFirstArgs<ExtArgs>>): Prisma__versiontbClient<$Result.GetResult<Prisma.$versiontbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Versiontb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versiontbFindFirstOrThrowArgs} args - Arguments to find a Versiontb
     * @example
     * // Get one Versiontb
     * const versiontb = await prisma.versiontb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends versiontbFindFirstOrThrowArgs>(args?: SelectSubset<T, versiontbFindFirstOrThrowArgs<ExtArgs>>): Prisma__versiontbClient<$Result.GetResult<Prisma.$versiontbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Versiontbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versiontbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Versiontbs
     * const versiontbs = await prisma.versiontb.findMany()
     * 
     * // Get first 10 Versiontbs
     * const versiontbs = await prisma.versiontb.findMany({ take: 10 })
     * 
     * // Only select the `ComputerName`
     * const versiontbWithComputerNameOnly = await prisma.versiontb.findMany({ select: { ComputerName: true } })
     * 
     */
    findMany<T extends versiontbFindManyArgs>(args?: SelectSubset<T, versiontbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$versiontbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Versiontb.
     * @param {versiontbCreateArgs} args - Arguments to create a Versiontb.
     * @example
     * // Create one Versiontb
     * const Versiontb = await prisma.versiontb.create({
     *   data: {
     *     // ... data to create a Versiontb
     *   }
     * })
     * 
     */
    create<T extends versiontbCreateArgs>(args: SelectSubset<T, versiontbCreateArgs<ExtArgs>>): Prisma__versiontbClient<$Result.GetResult<Prisma.$versiontbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Versiontbs.
     * @param {versiontbCreateManyArgs} args - Arguments to create many Versiontbs.
     * @example
     * // Create many Versiontbs
     * const versiontb = await prisma.versiontb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends versiontbCreateManyArgs>(args?: SelectSubset<T, versiontbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Versiontb.
     * @param {versiontbDeleteArgs} args - Arguments to delete one Versiontb.
     * @example
     * // Delete one Versiontb
     * const Versiontb = await prisma.versiontb.delete({
     *   where: {
     *     // ... filter to delete one Versiontb
     *   }
     * })
     * 
     */
    delete<T extends versiontbDeleteArgs>(args: SelectSubset<T, versiontbDeleteArgs<ExtArgs>>): Prisma__versiontbClient<$Result.GetResult<Prisma.$versiontbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Versiontb.
     * @param {versiontbUpdateArgs} args - Arguments to update one Versiontb.
     * @example
     * // Update one Versiontb
     * const versiontb = await prisma.versiontb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends versiontbUpdateArgs>(args: SelectSubset<T, versiontbUpdateArgs<ExtArgs>>): Prisma__versiontbClient<$Result.GetResult<Prisma.$versiontbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Versiontbs.
     * @param {versiontbDeleteManyArgs} args - Arguments to filter Versiontbs to delete.
     * @example
     * // Delete a few Versiontbs
     * const { count } = await prisma.versiontb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends versiontbDeleteManyArgs>(args?: SelectSubset<T, versiontbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versiontbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versiontbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Versiontbs
     * const versiontb = await prisma.versiontb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends versiontbUpdateManyArgs>(args: SelectSubset<T, versiontbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Versiontb.
     * @param {versiontbUpsertArgs} args - Arguments to update or create a Versiontb.
     * @example
     * // Update or create a Versiontb
     * const versiontb = await prisma.versiontb.upsert({
     *   create: {
     *     // ... data to create a Versiontb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Versiontb we want to update
     *   }
     * })
     */
    upsert<T extends versiontbUpsertArgs>(args: SelectSubset<T, versiontbUpsertArgs<ExtArgs>>): Prisma__versiontbClient<$Result.GetResult<Prisma.$versiontbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Versiontbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versiontbCountArgs} args - Arguments to filter Versiontbs to count.
     * @example
     * // Count the number of Versiontbs
     * const count = await prisma.versiontb.count({
     *   where: {
     *     // ... the filter for the Versiontbs we want to count
     *   }
     * })
    **/
    count<T extends versiontbCountArgs>(
      args?: Subset<T, versiontbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersiontbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Versiontb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersiontbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersiontbAggregateArgs>(args: Subset<T, VersiontbAggregateArgs>): Prisma.PrismaPromise<GetVersiontbAggregateType<T>>

    /**
     * Group by Versiontb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {versiontbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends versiontbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: versiontbGroupByArgs['orderBy'] }
        : { orderBy?: versiontbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, versiontbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersiontbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the versiontb model
   */
  readonly fields: versiontbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for versiontb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__versiontbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the versiontb model
   */ 
  interface versiontbFieldRefs {
    readonly ComputerName: FieldRef<"versiontb", 'String'>
    readonly Version: FieldRef<"versiontb", 'String'>
    readonly Type: FieldRef<"versiontb", 'Int'>
    readonly ReleaseDate: FieldRef<"versiontb", 'DateTime'>
    readonly LastUpdate: FieldRef<"versiontb", 'DateTime'>
    readonly DPStatus: FieldRef<"versiontb", 'Int'>
    readonly DPType: FieldRef<"versiontb", 'Int'>
    readonly DPVersion: FieldRef<"versiontb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * versiontb findUnique
   */
  export type versiontbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
    /**
     * Filter, which versiontb to fetch.
     */
    where: versiontbWhereUniqueInput
  }

  /**
   * versiontb findUniqueOrThrow
   */
  export type versiontbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
    /**
     * Filter, which versiontb to fetch.
     */
    where: versiontbWhereUniqueInput
  }

  /**
   * versiontb findFirst
   */
  export type versiontbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
    /**
     * Filter, which versiontb to fetch.
     */
    where?: versiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of versiontbs to fetch.
     */
    orderBy?: versiontbOrderByWithRelationInput | versiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for versiontbs.
     */
    cursor?: versiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` versiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` versiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of versiontbs.
     */
    distinct?: VersiontbScalarFieldEnum | VersiontbScalarFieldEnum[]
  }

  /**
   * versiontb findFirstOrThrow
   */
  export type versiontbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
    /**
     * Filter, which versiontb to fetch.
     */
    where?: versiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of versiontbs to fetch.
     */
    orderBy?: versiontbOrderByWithRelationInput | versiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for versiontbs.
     */
    cursor?: versiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` versiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` versiontbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of versiontbs.
     */
    distinct?: VersiontbScalarFieldEnum | VersiontbScalarFieldEnum[]
  }

  /**
   * versiontb findMany
   */
  export type versiontbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
    /**
     * Filter, which versiontbs to fetch.
     */
    where?: versiontbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of versiontbs to fetch.
     */
    orderBy?: versiontbOrderByWithRelationInput | versiontbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing versiontbs.
     */
    cursor?: versiontbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` versiontbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` versiontbs.
     */
    skip?: number
    distinct?: VersiontbScalarFieldEnum | VersiontbScalarFieldEnum[]
  }

  /**
   * versiontb create
   */
  export type versiontbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
    /**
     * The data needed to create a versiontb.
     */
    data: XOR<versiontbCreateInput, versiontbUncheckedCreateInput>
  }

  /**
   * versiontb createMany
   */
  export type versiontbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many versiontbs.
     */
    data: versiontbCreateManyInput | versiontbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * versiontb update
   */
  export type versiontbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
    /**
     * The data needed to update a versiontb.
     */
    data: XOR<versiontbUpdateInput, versiontbUncheckedUpdateInput>
    /**
     * Choose, which versiontb to update.
     */
    where: versiontbWhereUniqueInput
  }

  /**
   * versiontb updateMany
   */
  export type versiontbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update versiontbs.
     */
    data: XOR<versiontbUpdateManyMutationInput, versiontbUncheckedUpdateManyInput>
    /**
     * Filter which versiontbs to update
     */
    where?: versiontbWhereInput
  }

  /**
   * versiontb upsert
   */
  export type versiontbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
    /**
     * The filter to search for the versiontb to update in case it exists.
     */
    where: versiontbWhereUniqueInput
    /**
     * In case the versiontb found by the `where` argument doesn't exist, create a new versiontb with this data.
     */
    create: XOR<versiontbCreateInput, versiontbUncheckedCreateInput>
    /**
     * In case the versiontb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<versiontbUpdateInput, versiontbUncheckedUpdateInput>
  }

  /**
   * versiontb delete
   */
  export type versiontbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
    /**
     * Filter which versiontb to delete.
     */
    where: versiontbWhereUniqueInput
  }

  /**
   * versiontb deleteMany
   */
  export type versiontbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which versiontbs to delete
     */
    where?: versiontbWhereInput
  }

  /**
   * versiontb without action
   */
  export type versiontbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the versiontb
     */
    select?: versiontbSelect<ExtArgs> | null
  }


  /**
   * Model wallettb
   */

  export type AggregateWallettb = {
    _count: WallettbCountAggregateOutputType | null
    _avg: WallettbAvgAggregateOutputType | null
    _sum: WallettbSumAggregateOutputType | null
    _min: WallettbMinAggregateOutputType | null
    _max: WallettbMaxAggregateOutputType | null
  }

  export type WallettbAvgAggregateOutputType = {
    id: number | null
    main: number | null
    sub: number | null
    sub1: number | null
    sub2: number | null
    userid: number | null
    status: number | null
    ts: number | null
    wsec: number | null
  }

  export type WallettbSumAggregateOutputType = {
    id: bigint | null
    main: bigint | null
    sub: bigint | null
    sub1: bigint | null
    sub2: bigint | null
    userid: bigint | null
    status: number | null
    ts: bigint | null
    wsec: bigint | null
  }

  export type WallettbMinAggregateOutputType = {
    id: bigint | null
    main: bigint | null
    sub: bigint | null
    sub1: bigint | null
    sub2: bigint | null
    userid: bigint | null
    status: number | null
    ts: bigint | null
    wsec: bigint | null
    ssec: string | null
  }

  export type WallettbMaxAggregateOutputType = {
    id: bigint | null
    main: bigint | null
    sub: bigint | null
    sub1: bigint | null
    sub2: bigint | null
    userid: bigint | null
    status: number | null
    ts: bigint | null
    wsec: bigint | null
    ssec: string | null
  }

  export type WallettbCountAggregateOutputType = {
    id: number
    main: number
    sub: number
    sub1: number
    sub2: number
    userid: number
    status: number
    ts: number
    wsec: number
    ssec: number
    _all: number
  }


  export type WallettbAvgAggregateInputType = {
    id?: true
    main?: true
    sub?: true
    sub1?: true
    sub2?: true
    userid?: true
    status?: true
    ts?: true
    wsec?: true
  }

  export type WallettbSumAggregateInputType = {
    id?: true
    main?: true
    sub?: true
    sub1?: true
    sub2?: true
    userid?: true
    status?: true
    ts?: true
    wsec?: true
  }

  export type WallettbMinAggregateInputType = {
    id?: true
    main?: true
    sub?: true
    sub1?: true
    sub2?: true
    userid?: true
    status?: true
    ts?: true
    wsec?: true
    ssec?: true
  }

  export type WallettbMaxAggregateInputType = {
    id?: true
    main?: true
    sub?: true
    sub1?: true
    sub2?: true
    userid?: true
    status?: true
    ts?: true
    wsec?: true
    ssec?: true
  }

  export type WallettbCountAggregateInputType = {
    id?: true
    main?: true
    sub?: true
    sub1?: true
    sub2?: true
    userid?: true
    status?: true
    ts?: true
    wsec?: true
    ssec?: true
    _all?: true
  }

  export type WallettbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallettb to aggregate.
     */
    where?: wallettbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallettbs to fetch.
     */
    orderBy?: wallettbOrderByWithRelationInput | wallettbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: wallettbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallettbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallettbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallettbs
    **/
    _count?: true | WallettbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WallettbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WallettbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WallettbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WallettbMaxAggregateInputType
  }

  export type GetWallettbAggregateType<T extends WallettbAggregateArgs> = {
        [P in keyof T & keyof AggregateWallettb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallettb[P]>
      : GetScalarType<T[P], AggregateWallettb[P]>
  }




  export type wallettbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: wallettbWhereInput
    orderBy?: wallettbOrderByWithAggregationInput | wallettbOrderByWithAggregationInput[]
    by: WallettbScalarFieldEnum[] | WallettbScalarFieldEnum
    having?: wallettbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WallettbCountAggregateInputType | true
    _avg?: WallettbAvgAggregateInputType
    _sum?: WallettbSumAggregateInputType
    _min?: WallettbMinAggregateInputType
    _max?: WallettbMaxAggregateInputType
  }

  export type WallettbGroupByOutputType = {
    id: bigint
    main: bigint | null
    sub: bigint | null
    sub1: bigint | null
    sub2: bigint | null
    userid: bigint | null
    status: number | null
    ts: bigint | null
    wsec: bigint | null
    ssec: string | null
    _count: WallettbCountAggregateOutputType | null
    _avg: WallettbAvgAggregateOutputType | null
    _sum: WallettbSumAggregateOutputType | null
    _min: WallettbMinAggregateOutputType | null
    _max: WallettbMaxAggregateOutputType | null
  }

  type GetWallettbGroupByPayload<T extends wallettbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WallettbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WallettbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WallettbGroupByOutputType[P]>
            : GetScalarType<T[P], WallettbGroupByOutputType[P]>
        }
      >
    >


  export type wallettbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    main?: boolean
    sub?: boolean
    sub1?: boolean
    sub2?: boolean
    userid?: boolean
    status?: boolean
    ts?: boolean
    wsec?: boolean
    ssec?: boolean
  }, ExtArgs["result"]["wallettb"]>


  export type wallettbSelectScalar = {
    id?: boolean
    main?: boolean
    sub?: boolean
    sub1?: boolean
    sub2?: boolean
    userid?: boolean
    status?: boolean
    ts?: boolean
    wsec?: boolean
    ssec?: boolean
  }


  export type $wallettbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallettb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      main: bigint | null
      sub: bigint | null
      sub1: bigint | null
      sub2: bigint | null
      userid: bigint | null
      status: number | null
      ts: bigint | null
      wsec: bigint | null
      ssec: string | null
    }, ExtArgs["result"]["wallettb"]>
    composites: {}
  }

  type wallettbGetPayload<S extends boolean | null | undefined | wallettbDefaultArgs> = $Result.GetResult<Prisma.$wallettbPayload, S>

  type wallettbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<wallettbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WallettbCountAggregateInputType | true
    }

  export interface wallettbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallettb'], meta: { name: 'wallettb' } }
    /**
     * Find zero or one Wallettb that matches the filter.
     * @param {wallettbFindUniqueArgs} args - Arguments to find a Wallettb
     * @example
     * // Get one Wallettb
     * const wallettb = await prisma.wallettb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends wallettbFindUniqueArgs>(args: SelectSubset<T, wallettbFindUniqueArgs<ExtArgs>>): Prisma__wallettbClient<$Result.GetResult<Prisma.$wallettbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallettb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {wallettbFindUniqueOrThrowArgs} args - Arguments to find a Wallettb
     * @example
     * // Get one Wallettb
     * const wallettb = await prisma.wallettb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends wallettbFindUniqueOrThrowArgs>(args: SelectSubset<T, wallettbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__wallettbClient<$Result.GetResult<Prisma.$wallettbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallettb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallettbFindFirstArgs} args - Arguments to find a Wallettb
     * @example
     * // Get one Wallettb
     * const wallettb = await prisma.wallettb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends wallettbFindFirstArgs>(args?: SelectSubset<T, wallettbFindFirstArgs<ExtArgs>>): Prisma__wallettbClient<$Result.GetResult<Prisma.$wallettbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallettb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallettbFindFirstOrThrowArgs} args - Arguments to find a Wallettb
     * @example
     * // Get one Wallettb
     * const wallettb = await prisma.wallettb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends wallettbFindFirstOrThrowArgs>(args?: SelectSubset<T, wallettbFindFirstOrThrowArgs<ExtArgs>>): Prisma__wallettbClient<$Result.GetResult<Prisma.$wallettbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallettbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallettbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallettbs
     * const wallettbs = await prisma.wallettb.findMany()
     * 
     * // Get first 10 Wallettbs
     * const wallettbs = await prisma.wallettb.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wallettbWithIdOnly = await prisma.wallettb.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends wallettbFindManyArgs>(args?: SelectSubset<T, wallettbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$wallettbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallettb.
     * @param {wallettbCreateArgs} args - Arguments to create a Wallettb.
     * @example
     * // Create one Wallettb
     * const Wallettb = await prisma.wallettb.create({
     *   data: {
     *     // ... data to create a Wallettb
     *   }
     * })
     * 
     */
    create<T extends wallettbCreateArgs>(args: SelectSubset<T, wallettbCreateArgs<ExtArgs>>): Prisma__wallettbClient<$Result.GetResult<Prisma.$wallettbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallettbs.
     * @param {wallettbCreateManyArgs} args - Arguments to create many Wallettbs.
     * @example
     * // Create many Wallettbs
     * const wallettb = await prisma.wallettb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends wallettbCreateManyArgs>(args?: SelectSubset<T, wallettbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallettb.
     * @param {wallettbDeleteArgs} args - Arguments to delete one Wallettb.
     * @example
     * // Delete one Wallettb
     * const Wallettb = await prisma.wallettb.delete({
     *   where: {
     *     // ... filter to delete one Wallettb
     *   }
     * })
     * 
     */
    delete<T extends wallettbDeleteArgs>(args: SelectSubset<T, wallettbDeleteArgs<ExtArgs>>): Prisma__wallettbClient<$Result.GetResult<Prisma.$wallettbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallettb.
     * @param {wallettbUpdateArgs} args - Arguments to update one Wallettb.
     * @example
     * // Update one Wallettb
     * const wallettb = await prisma.wallettb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends wallettbUpdateArgs>(args: SelectSubset<T, wallettbUpdateArgs<ExtArgs>>): Prisma__wallettbClient<$Result.GetResult<Prisma.$wallettbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallettbs.
     * @param {wallettbDeleteManyArgs} args - Arguments to filter Wallettbs to delete.
     * @example
     * // Delete a few Wallettbs
     * const { count } = await prisma.wallettb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends wallettbDeleteManyArgs>(args?: SelectSubset<T, wallettbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallettbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallettbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallettbs
     * const wallettb = await prisma.wallettb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends wallettbUpdateManyArgs>(args: SelectSubset<T, wallettbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallettb.
     * @param {wallettbUpsertArgs} args - Arguments to update or create a Wallettb.
     * @example
     * // Update or create a Wallettb
     * const wallettb = await prisma.wallettb.upsert({
     *   create: {
     *     // ... data to create a Wallettb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallettb we want to update
     *   }
     * })
     */
    upsert<T extends wallettbUpsertArgs>(args: SelectSubset<T, wallettbUpsertArgs<ExtArgs>>): Prisma__wallettbClient<$Result.GetResult<Prisma.$wallettbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallettbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallettbCountArgs} args - Arguments to filter Wallettbs to count.
     * @example
     * // Count the number of Wallettbs
     * const count = await prisma.wallettb.count({
     *   where: {
     *     // ... the filter for the Wallettbs we want to count
     *   }
     * })
    **/
    count<T extends wallettbCountArgs>(
      args?: Subset<T, wallettbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WallettbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallettb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WallettbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WallettbAggregateArgs>(args: Subset<T, WallettbAggregateArgs>): Prisma.PrismaPromise<GetWallettbAggregateType<T>>

    /**
     * Group by Wallettb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {wallettbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends wallettbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: wallettbGroupByArgs['orderBy'] }
        : { orderBy?: wallettbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, wallettbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWallettbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallettb model
   */
  readonly fields: wallettbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallettb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__wallettbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallettb model
   */ 
  interface wallettbFieldRefs {
    readonly id: FieldRef<"wallettb", 'BigInt'>
    readonly main: FieldRef<"wallettb", 'BigInt'>
    readonly sub: FieldRef<"wallettb", 'BigInt'>
    readonly sub1: FieldRef<"wallettb", 'BigInt'>
    readonly sub2: FieldRef<"wallettb", 'BigInt'>
    readonly userid: FieldRef<"wallettb", 'BigInt'>
    readonly status: FieldRef<"wallettb", 'Int'>
    readonly ts: FieldRef<"wallettb", 'BigInt'>
    readonly wsec: FieldRef<"wallettb", 'BigInt'>
    readonly ssec: FieldRef<"wallettb", 'String'>
  }
    

  // Custom InputTypes
  /**
   * wallettb findUnique
   */
  export type wallettbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
    /**
     * Filter, which wallettb to fetch.
     */
    where: wallettbWhereUniqueInput
  }

  /**
   * wallettb findUniqueOrThrow
   */
  export type wallettbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
    /**
     * Filter, which wallettb to fetch.
     */
    where: wallettbWhereUniqueInput
  }

  /**
   * wallettb findFirst
   */
  export type wallettbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
    /**
     * Filter, which wallettb to fetch.
     */
    where?: wallettbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallettbs to fetch.
     */
    orderBy?: wallettbOrderByWithRelationInput | wallettbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallettbs.
     */
    cursor?: wallettbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallettbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallettbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallettbs.
     */
    distinct?: WallettbScalarFieldEnum | WallettbScalarFieldEnum[]
  }

  /**
   * wallettb findFirstOrThrow
   */
  export type wallettbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
    /**
     * Filter, which wallettb to fetch.
     */
    where?: wallettbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallettbs to fetch.
     */
    orderBy?: wallettbOrderByWithRelationInput | wallettbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallettbs.
     */
    cursor?: wallettbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallettbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallettbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallettbs.
     */
    distinct?: WallettbScalarFieldEnum | WallettbScalarFieldEnum[]
  }

  /**
   * wallettb findMany
   */
  export type wallettbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
    /**
     * Filter, which wallettbs to fetch.
     */
    where?: wallettbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallettbs to fetch.
     */
    orderBy?: wallettbOrderByWithRelationInput | wallettbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallettbs.
     */
    cursor?: wallettbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallettbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallettbs.
     */
    skip?: number
    distinct?: WallettbScalarFieldEnum | WallettbScalarFieldEnum[]
  }

  /**
   * wallettb create
   */
  export type wallettbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
    /**
     * The data needed to create a wallettb.
     */
    data?: XOR<wallettbCreateInput, wallettbUncheckedCreateInput>
  }

  /**
   * wallettb createMany
   */
  export type wallettbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallettbs.
     */
    data: wallettbCreateManyInput | wallettbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallettb update
   */
  export type wallettbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
    /**
     * The data needed to update a wallettb.
     */
    data: XOR<wallettbUpdateInput, wallettbUncheckedUpdateInput>
    /**
     * Choose, which wallettb to update.
     */
    where: wallettbWhereUniqueInput
  }

  /**
   * wallettb updateMany
   */
  export type wallettbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallettbs.
     */
    data: XOR<wallettbUpdateManyMutationInput, wallettbUncheckedUpdateManyInput>
    /**
     * Filter which wallettbs to update
     */
    where?: wallettbWhereInput
  }

  /**
   * wallettb upsert
   */
  export type wallettbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
    /**
     * The filter to search for the wallettb to update in case it exists.
     */
    where: wallettbWhereUniqueInput
    /**
     * In case the wallettb found by the `where` argument doesn't exist, create a new wallettb with this data.
     */
    create: XOR<wallettbCreateInput, wallettbUncheckedCreateInput>
    /**
     * In case the wallettb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<wallettbUpdateInput, wallettbUncheckedUpdateInput>
  }

  /**
   * wallettb delete
   */
  export type wallettbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
    /**
     * Filter which wallettb to delete.
     */
    where: wallettbWhereUniqueInput
  }

  /**
   * wallettb deleteMany
   */
  export type wallettbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallettbs to delete
     */
    where?: wallettbWhereInput
  }

  /**
   * wallettb without action
   */
  export type wallettbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallettb
     */
    select?: wallettbSelect<ExtArgs> | null
  }


  /**
   * Model webhistorytb
   */

  export type AggregateWebhistorytb = {
    _count: WebhistorytbCountAggregateOutputType | null
    _avg: WebhistorytbAvgAggregateOutputType | null
    _sum: WebhistorytbSumAggregateOutputType | null
    _min: WebhistorytbMinAggregateOutputType | null
    _max: WebhistorytbMaxAggregateOutputType | null
  }

  export type WebhistorytbAvgAggregateOutputType = {
    URLId: number | null
    UserId: number | null
    Active: number | null
    Session: number | null
    AnonymousId: number | null
  }

  export type WebhistorytbSumAggregateOutputType = {
    URLId: number | null
    UserId: number | null
    Active: number | null
    Session: number | null
    AnonymousId: number | null
  }

  export type WebhistorytbMinAggregateOutputType = {
    URLId: number | null
    URL: string | null
    RecordDate: Date | null
    UserId: number | null
    Machine: string | null
    Active: number | null
    Session: number | null
    AnonymousId: number | null
    BrowserType: boolean | null
  }

  export type WebhistorytbMaxAggregateOutputType = {
    URLId: number | null
    URL: string | null
    RecordDate: Date | null
    UserId: number | null
    Machine: string | null
    Active: number | null
    Session: number | null
    AnonymousId: number | null
    BrowserType: boolean | null
  }

  export type WebhistorytbCountAggregateOutputType = {
    URLId: number
    URL: number
    RecordDate: number
    UserId: number
    Machine: number
    Active: number
    Session: number
    AnonymousId: number
    BrowserType: number
    _all: number
  }


  export type WebhistorytbAvgAggregateInputType = {
    URLId?: true
    UserId?: true
    Active?: true
    Session?: true
    AnonymousId?: true
  }

  export type WebhistorytbSumAggregateInputType = {
    URLId?: true
    UserId?: true
    Active?: true
    Session?: true
    AnonymousId?: true
  }

  export type WebhistorytbMinAggregateInputType = {
    URLId?: true
    URL?: true
    RecordDate?: true
    UserId?: true
    Machine?: true
    Active?: true
    Session?: true
    AnonymousId?: true
    BrowserType?: true
  }

  export type WebhistorytbMaxAggregateInputType = {
    URLId?: true
    URL?: true
    RecordDate?: true
    UserId?: true
    Machine?: true
    Active?: true
    Session?: true
    AnonymousId?: true
    BrowserType?: true
  }

  export type WebhistorytbCountAggregateInputType = {
    URLId?: true
    URL?: true
    RecordDate?: true
    UserId?: true
    Machine?: true
    Active?: true
    Session?: true
    AnonymousId?: true
    BrowserType?: true
    _all?: true
  }

  export type WebhistorytbAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webhistorytb to aggregate.
     */
    where?: webhistorytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhistorytbs to fetch.
     */
    orderBy?: webhistorytbOrderByWithRelationInput | webhistorytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webhistorytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhistorytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhistorytbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webhistorytbs
    **/
    _count?: true | WebhistorytbCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhistorytbAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhistorytbSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhistorytbMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhistorytbMaxAggregateInputType
  }

  export type GetWebhistorytbAggregateType<T extends WebhistorytbAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhistorytb]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhistorytb[P]>
      : GetScalarType<T[P], AggregateWebhistorytb[P]>
  }




  export type webhistorytbGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webhistorytbWhereInput
    orderBy?: webhistorytbOrderByWithAggregationInput | webhistorytbOrderByWithAggregationInput[]
    by: WebhistorytbScalarFieldEnum[] | WebhistorytbScalarFieldEnum
    having?: webhistorytbScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhistorytbCountAggregateInputType | true
    _avg?: WebhistorytbAvgAggregateInputType
    _sum?: WebhistorytbSumAggregateInputType
    _min?: WebhistorytbMinAggregateInputType
    _max?: WebhistorytbMaxAggregateInputType
  }

  export type WebhistorytbGroupByOutputType = {
    URLId: number
    URL: string
    RecordDate: Date
    UserId: number
    Machine: string
    Active: number
    Session: number
    AnonymousId: number
    BrowserType: boolean
    _count: WebhistorytbCountAggregateOutputType | null
    _avg: WebhistorytbAvgAggregateOutputType | null
    _sum: WebhistorytbSumAggregateOutputType | null
    _min: WebhistorytbMinAggregateOutputType | null
    _max: WebhistorytbMaxAggregateOutputType | null
  }

  type GetWebhistorytbGroupByPayload<T extends webhistorytbGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhistorytbGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhistorytbGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhistorytbGroupByOutputType[P]>
            : GetScalarType<T[P], WebhistorytbGroupByOutputType[P]>
        }
      >
    >


  export type webhistorytbSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    URLId?: boolean
    URL?: boolean
    RecordDate?: boolean
    UserId?: boolean
    Machine?: boolean
    Active?: boolean
    Session?: boolean
    AnonymousId?: boolean
    BrowserType?: boolean
  }, ExtArgs["result"]["webhistorytb"]>


  export type webhistorytbSelectScalar = {
    URLId?: boolean
    URL?: boolean
    RecordDate?: boolean
    UserId?: boolean
    Machine?: boolean
    Active?: boolean
    Session?: boolean
    AnonymousId?: boolean
    BrowserType?: boolean
  }


  export type $webhistorytbPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "webhistorytb"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      URLId: number
      URL: string
      RecordDate: Date
      UserId: number
      Machine: string
      Active: number
      Session: number
      AnonymousId: number
      BrowserType: boolean
    }, ExtArgs["result"]["webhistorytb"]>
    composites: {}
  }

  type webhistorytbGetPayload<S extends boolean | null | undefined | webhistorytbDefaultArgs> = $Result.GetResult<Prisma.$webhistorytbPayload, S>

  type webhistorytbCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<webhistorytbFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhistorytbCountAggregateInputType | true
    }

  export interface webhistorytbDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['webhistorytb'], meta: { name: 'webhistorytb' } }
    /**
     * Find zero or one Webhistorytb that matches the filter.
     * @param {webhistorytbFindUniqueArgs} args - Arguments to find a Webhistorytb
     * @example
     * // Get one Webhistorytb
     * const webhistorytb = await prisma.webhistorytb.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends webhistorytbFindUniqueArgs>(args: SelectSubset<T, webhistorytbFindUniqueArgs<ExtArgs>>): Prisma__webhistorytbClient<$Result.GetResult<Prisma.$webhistorytbPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webhistorytb that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {webhistorytbFindUniqueOrThrowArgs} args - Arguments to find a Webhistorytb
     * @example
     * // Get one Webhistorytb
     * const webhistorytb = await prisma.webhistorytb.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends webhistorytbFindUniqueOrThrowArgs>(args: SelectSubset<T, webhistorytbFindUniqueOrThrowArgs<ExtArgs>>): Prisma__webhistorytbClient<$Result.GetResult<Prisma.$webhistorytbPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webhistorytb that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhistorytbFindFirstArgs} args - Arguments to find a Webhistorytb
     * @example
     * // Get one Webhistorytb
     * const webhistorytb = await prisma.webhistorytb.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends webhistorytbFindFirstArgs>(args?: SelectSubset<T, webhistorytbFindFirstArgs<ExtArgs>>): Prisma__webhistorytbClient<$Result.GetResult<Prisma.$webhistorytbPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webhistorytb that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhistorytbFindFirstOrThrowArgs} args - Arguments to find a Webhistorytb
     * @example
     * // Get one Webhistorytb
     * const webhistorytb = await prisma.webhistorytb.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends webhistorytbFindFirstOrThrowArgs>(args?: SelectSubset<T, webhistorytbFindFirstOrThrowArgs<ExtArgs>>): Prisma__webhistorytbClient<$Result.GetResult<Prisma.$webhistorytbPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webhistorytbs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhistorytbFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhistorytbs
     * const webhistorytbs = await prisma.webhistorytb.findMany()
     * 
     * // Get first 10 Webhistorytbs
     * const webhistorytbs = await prisma.webhistorytb.findMany({ take: 10 })
     * 
     * // Only select the `URLId`
     * const webhistorytbWithURLIdOnly = await prisma.webhistorytb.findMany({ select: { URLId: true } })
     * 
     */
    findMany<T extends webhistorytbFindManyArgs>(args?: SelectSubset<T, webhistorytbFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webhistorytbPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webhistorytb.
     * @param {webhistorytbCreateArgs} args - Arguments to create a Webhistorytb.
     * @example
     * // Create one Webhistorytb
     * const Webhistorytb = await prisma.webhistorytb.create({
     *   data: {
     *     // ... data to create a Webhistorytb
     *   }
     * })
     * 
     */
    create<T extends webhistorytbCreateArgs>(args: SelectSubset<T, webhistorytbCreateArgs<ExtArgs>>): Prisma__webhistorytbClient<$Result.GetResult<Prisma.$webhistorytbPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webhistorytbs.
     * @param {webhistorytbCreateManyArgs} args - Arguments to create many Webhistorytbs.
     * @example
     * // Create many Webhistorytbs
     * const webhistorytb = await prisma.webhistorytb.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends webhistorytbCreateManyArgs>(args?: SelectSubset<T, webhistorytbCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Webhistorytb.
     * @param {webhistorytbDeleteArgs} args - Arguments to delete one Webhistorytb.
     * @example
     * // Delete one Webhistorytb
     * const Webhistorytb = await prisma.webhistorytb.delete({
     *   where: {
     *     // ... filter to delete one Webhistorytb
     *   }
     * })
     * 
     */
    delete<T extends webhistorytbDeleteArgs>(args: SelectSubset<T, webhistorytbDeleteArgs<ExtArgs>>): Prisma__webhistorytbClient<$Result.GetResult<Prisma.$webhistorytbPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webhistorytb.
     * @param {webhistorytbUpdateArgs} args - Arguments to update one Webhistorytb.
     * @example
     * // Update one Webhistorytb
     * const webhistorytb = await prisma.webhistorytb.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends webhistorytbUpdateArgs>(args: SelectSubset<T, webhistorytbUpdateArgs<ExtArgs>>): Prisma__webhistorytbClient<$Result.GetResult<Prisma.$webhistorytbPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webhistorytbs.
     * @param {webhistorytbDeleteManyArgs} args - Arguments to filter Webhistorytbs to delete.
     * @example
     * // Delete a few Webhistorytbs
     * const { count } = await prisma.webhistorytb.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends webhistorytbDeleteManyArgs>(args?: SelectSubset<T, webhistorytbDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhistorytbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhistorytbUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhistorytbs
     * const webhistorytb = await prisma.webhistorytb.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends webhistorytbUpdateManyArgs>(args: SelectSubset<T, webhistorytbUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhistorytb.
     * @param {webhistorytbUpsertArgs} args - Arguments to update or create a Webhistorytb.
     * @example
     * // Update or create a Webhistorytb
     * const webhistorytb = await prisma.webhistorytb.upsert({
     *   create: {
     *     // ... data to create a Webhistorytb
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhistorytb we want to update
     *   }
     * })
     */
    upsert<T extends webhistorytbUpsertArgs>(args: SelectSubset<T, webhistorytbUpsertArgs<ExtArgs>>): Prisma__webhistorytbClient<$Result.GetResult<Prisma.$webhistorytbPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webhistorytbs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhistorytbCountArgs} args - Arguments to filter Webhistorytbs to count.
     * @example
     * // Count the number of Webhistorytbs
     * const count = await prisma.webhistorytb.count({
     *   where: {
     *     // ... the filter for the Webhistorytbs we want to count
     *   }
     * })
    **/
    count<T extends webhistorytbCountArgs>(
      args?: Subset<T, webhistorytbCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhistorytbCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhistorytb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhistorytbAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhistorytbAggregateArgs>(args: Subset<T, WebhistorytbAggregateArgs>): Prisma.PrismaPromise<GetWebhistorytbAggregateType<T>>

    /**
     * Group by Webhistorytb.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhistorytbGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends webhistorytbGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: webhistorytbGroupByArgs['orderBy'] }
        : { orderBy?: webhistorytbGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, webhistorytbGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhistorytbGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the webhistorytb model
   */
  readonly fields: webhistorytbFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for webhistorytb.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__webhistorytbClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the webhistorytb model
   */ 
  interface webhistorytbFieldRefs {
    readonly URLId: FieldRef<"webhistorytb", 'Int'>
    readonly URL: FieldRef<"webhistorytb", 'String'>
    readonly RecordDate: FieldRef<"webhistorytb", 'DateTime'>
    readonly UserId: FieldRef<"webhistorytb", 'Int'>
    readonly Machine: FieldRef<"webhistorytb", 'String'>
    readonly Active: FieldRef<"webhistorytb", 'Int'>
    readonly Session: FieldRef<"webhistorytb", 'Int'>
    readonly AnonymousId: FieldRef<"webhistorytb", 'Int'>
    readonly BrowserType: FieldRef<"webhistorytb", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * webhistorytb findUnique
   */
  export type webhistorytbFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
    /**
     * Filter, which webhistorytb to fetch.
     */
    where: webhistorytbWhereUniqueInput
  }

  /**
   * webhistorytb findUniqueOrThrow
   */
  export type webhistorytbFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
    /**
     * Filter, which webhistorytb to fetch.
     */
    where: webhistorytbWhereUniqueInput
  }

  /**
   * webhistorytb findFirst
   */
  export type webhistorytbFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
    /**
     * Filter, which webhistorytb to fetch.
     */
    where?: webhistorytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhistorytbs to fetch.
     */
    orderBy?: webhistorytbOrderByWithRelationInput | webhistorytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhistorytbs.
     */
    cursor?: webhistorytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhistorytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhistorytbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhistorytbs.
     */
    distinct?: WebhistorytbScalarFieldEnum | WebhistorytbScalarFieldEnum[]
  }

  /**
   * webhistorytb findFirstOrThrow
   */
  export type webhistorytbFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
    /**
     * Filter, which webhistorytb to fetch.
     */
    where?: webhistorytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhistorytbs to fetch.
     */
    orderBy?: webhistorytbOrderByWithRelationInput | webhistorytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhistorytbs.
     */
    cursor?: webhistorytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhistorytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhistorytbs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhistorytbs.
     */
    distinct?: WebhistorytbScalarFieldEnum | WebhistorytbScalarFieldEnum[]
  }

  /**
   * webhistorytb findMany
   */
  export type webhistorytbFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
    /**
     * Filter, which webhistorytbs to fetch.
     */
    where?: webhistorytbWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhistorytbs to fetch.
     */
    orderBy?: webhistorytbOrderByWithRelationInput | webhistorytbOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webhistorytbs.
     */
    cursor?: webhistorytbWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhistorytbs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhistorytbs.
     */
    skip?: number
    distinct?: WebhistorytbScalarFieldEnum | WebhistorytbScalarFieldEnum[]
  }

  /**
   * webhistorytb create
   */
  export type webhistorytbCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
    /**
     * The data needed to create a webhistorytb.
     */
    data: XOR<webhistorytbCreateInput, webhistorytbUncheckedCreateInput>
  }

  /**
   * webhistorytb createMany
   */
  export type webhistorytbCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many webhistorytbs.
     */
    data: webhistorytbCreateManyInput | webhistorytbCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * webhistorytb update
   */
  export type webhistorytbUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
    /**
     * The data needed to update a webhistorytb.
     */
    data: XOR<webhistorytbUpdateInput, webhistorytbUncheckedUpdateInput>
    /**
     * Choose, which webhistorytb to update.
     */
    where: webhistorytbWhereUniqueInput
  }

  /**
   * webhistorytb updateMany
   */
  export type webhistorytbUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update webhistorytbs.
     */
    data: XOR<webhistorytbUpdateManyMutationInput, webhistorytbUncheckedUpdateManyInput>
    /**
     * Filter which webhistorytbs to update
     */
    where?: webhistorytbWhereInput
  }

  /**
   * webhistorytb upsert
   */
  export type webhistorytbUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
    /**
     * The filter to search for the webhistorytb to update in case it exists.
     */
    where: webhistorytbWhereUniqueInput
    /**
     * In case the webhistorytb found by the `where` argument doesn't exist, create a new webhistorytb with this data.
     */
    create: XOR<webhistorytbCreateInput, webhistorytbUncheckedCreateInput>
    /**
     * In case the webhistorytb was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webhistorytbUpdateInput, webhistorytbUncheckedUpdateInput>
  }

  /**
   * webhistorytb delete
   */
  export type webhistorytbDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
    /**
     * Filter which webhistorytb to delete.
     */
    where: webhistorytbWhereUniqueInput
  }

  /**
   * webhistorytb deleteMany
   */
  export type webhistorytbDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webhistorytbs to delete
     */
    where?: webhistorytbWhereInput
  }

  /**
   * webhistorytb without action
   */
  export type webhistorytbDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhistorytb
     */
    select?: webhistorytbSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountingentrytbScalarFieldEnum: {
    ID: 'ID',
    CreateDate: 'CreateDate',
    CreateTime: 'CreateTime',
    StaffID: 'StaffID',
    FromDate: 'FromDate',
    FromTime: 'FromTime',
    NumBalance: 'NumBalance',
    ImportQuantity: 'ImportQuantity',
    ImportTotalAmount: 'ImportTotalAmount',
    SaleQuantity: 'SaleQuantity',
    SaleTotalAmount: 'SaleTotalAmount',
    NumInventoryExpected: 'NumInventoryExpected',
    NumInventoryReal: 'NumInventoryReal',
    NumAdjust: 'NumAdjust',
    Note: 'Note',
    ServiceID: 'ServiceID'
  };

  export type AccountingentrytbScalarFieldEnum = (typeof AccountingentrytbScalarFieldEnum)[keyof typeof AccountingentrytbScalarFieldEnum]


  export const AnonymoustbScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    IDCard: 'IDCard',
    Address: 'Address',
    MachineID: 'MachineID',
    Session: 'Session',
    RecordDate: 'RecordDate'
  };

  export type AnonymoustbScalarFieldEnum = (typeof AnonymoustbScalarFieldEnum)[keyof typeof AnonymoustbScalarFieldEnum]


  export const ApplicationrenttbScalarFieldEnum: {
    ApplicationRentID: 'ApplicationRentID',
    Name: 'Name',
    Hash: 'Hash',
    AddBy: 'AddBy',
    Status: 'Status'
  };

  export type ApplicationrenttbScalarFieldEnum = (typeof ApplicationrenttbScalarFieldEnum)[keyof typeof ApplicationrenttbScalarFieldEnum]


  export const ApplicationtbScalarFieldEnum: {
    ApplicationId: 'ApplicationId',
    ApplicationName: 'ApplicationName',
    Description: 'Description',
    RestrictType: 'RestrictType',
    Hash: 'Hash',
    AppType: 'AppType',
    AddedBy: 'AddedBy'
  };

  export type ApplicationtbScalarFieldEnum = (typeof ApplicationtbScalarFieldEnum)[keyof typeof ApplicationtbScalarFieldEnum]


  export const BlacklisttbScalarFieldEnum: {
    URLId: 'URLId',
    URL: 'URL',
    Title: 'Title',
    Description: 'Description',
    RecordDate: 'RecordDate',
    Active: 'Active',
    AddedBy: 'AddedBy'
  };

  export type BlacklisttbScalarFieldEnum = (typeof BlacklisttbScalarFieldEnum)[keyof typeof BlacklisttbScalarFieldEnum]


  export const ChangepcdetailtbScalarFieldEnum: {
    ChangePCDetailId: 'ChangePCDetailId',
    VoucherId: 'VoucherId',
    FromMachineId: 'FromMachineId',
    ToMachineId: 'ToMachineId',
    TimeUsed: 'TimeUsed',
    MoneyUsed: 'MoneyUsed',
    SessionId: 'SessionId',
    ChangePCDate: 'ChangePCDate',
    ChangePCTime: 'ChangePCTime',
    BeginDateTime: 'BeginDateTime',
    LogNote: 'LogNote',
    MachineName: 'MachineName',
    LogType: 'LogType'
  };

  export type ChangepcdetailtbScalarFieldEnum = (typeof ChangepcdetailtbScalarFieldEnum)[keyof typeof ChangepcdetailtbScalarFieldEnum]


  export const ClientatbScalarFieldEnum: {
    ID: 'ID',
    PubID: 'PubID',
    AID: 'AID',
    DateA: 'DateA',
    STime: 'STime',
    ETime: 'ETime',
    FName: 'FName',
    FLink: 'FLink',
    Area: 'Area',
    Panel: 'Panel',
    Row: 'Row',
    Col: 'Col',
    Method: 'Method',
    CountS: 'CountS',
    CountC: 'CountC',
    RecordDate: 'RecordDate'
  };

  export type ClientatbScalarFieldEnum = (typeof ClientatbScalarFieldEnum)[keyof typeof ClientatbScalarFieldEnum]


  export const ClientsystbScalarFieldEnum: {
    ID: 'ID',
    UserId: 'UserId',
    MAC: 'MAC',
    CPU: 'CPU',
    RAM: 'RAM',
    HD: 'HD',
    OS: 'OS',
    CardName: 'CardName',
    ChipType: 'ChipType',
    VGAMem: 'VGAMem',
    NIC: 'NIC',
    FreeSpace: 'FreeSpace',
    CPName: 'CPName',
    Active: 'Active',
    NTFS: 'NTFS',
    FAT: 'FAT',
    Mainboard: 'Mainboard',
    IP: 'IP',
    LAN: 'LAN',
    RamFree: 'RamFree',
    PageFile: 'PageFile',
    TempCPU: 'TempCPU',
    LoadCPU: 'LoadCPU',
    TempGPU: 'TempGPU',
    LoadGPU: 'LoadGPU',
    LastUpdate: 'LastUpdate',
    PCName: 'PCName',
    NetInfo: 'NetInfo'
  };

  export type ClientsystbScalarFieldEnum = (typeof ClientsystbScalarFieldEnum)[keyof typeof ClientsystbScalarFieldEnum]


  export const CombodetailtbScalarFieldEnum: {
    ComboDetailID: 'ComboDetailID',
    UserID: 'UserID',
    ComboID: 'ComboID',
    VoucherID: 'VoucherID',
    Accept: 'Accept',
    CreateDate: 'CreateDate',
    CreateTime: 'CreateTime',
    FromDate: 'FromDate',
    FromTime: 'FromTime',
    ToDate: 'ToDate',
    ToTime: 'ToTime',
    Zone: 'Zone',
    LoginTime: 'LoginTime',
    Ownerid: 'Ownerid'
  };

  export type CombodetailtbScalarFieldEnum = (typeof CombodetailtbScalarFieldEnum)[keyof typeof CombodetailtbScalarFieldEnum]


  export const CombodonatetbScalarFieldEnum: {
    ComboDonateID: 'ComboDonateID',
    ComboID: 'ComboID',
    ServiceID: 'ServiceID',
    Quantity: 'Quantity'
  };

  export type CombodonatetbScalarFieldEnum = (typeof CombodonatetbScalarFieldEnum)[keyof typeof CombodonatetbScalarFieldEnum]


  export const CombotbScalarFieldEnum: {
    ComboID: 'ComboID',
    Name: 'Name',
    Price: 'Price',
    CreateDate: 'CreateDate',
    CreateTime: 'CreateTime',
    Type: 'Type',
    PreAlias: 'PreAlias',
    IsStatus: 'IsStatus',
    OrderPosition: 'OrderPosition',
    NumOfDay: 'NumOfDay'
  };

  export type CombotbScalarFieldEnum = (typeof CombotbScalarFieldEnum)[keyof typeof CombotbScalarFieldEnum]


  export const CombousagetbScalarFieldEnum: {
    ComboUsageID: 'ComboUsageID',
    ComboID: 'ComboID',
    MachineGroupID: 'MachineGroupID',
    FromTime: 'FromTime',
    ToTime: 'ToTime'
  };

  export type CombousagetbScalarFieldEnum = (typeof CombousagetbScalarFieldEnum)[keyof typeof CombousagetbScalarFieldEnum]


  export const ConvertunittbScalarFieldEnum: {
    ID: 'ID',
    ServiceID: 'ServiceID',
    UnitRootID: 'UnitRootID',
    ConvertUnitID: 'ConvertUnitID',
    Quantity: 'Quantity'
  };

  export type ConvertunittbScalarFieldEnum = (typeof ConvertunittbScalarFieldEnum)[keyof typeof ConvertunittbScalarFieldEnum]


  export const DptbScalarFieldEnum: {
    ComputerName: 'ComputerName',
    Status: 'Status',
    Type: 'Type',
    Version: 'Version',
    LastUpdate: 'LastUpdate',
    FNetVersion: 'FNetVersion',
    FNetReleaseDate: 'FNetReleaseDate',
    DPB: 'DPB'
  };

  export type DptbScalarFieldEnum = (typeof DptbScalarFieldEnum)[keyof typeof DptbScalarFieldEnum]


  export const FreetimedetailtbScalarFieldEnum: {
    FreeTimeDetailId: 'FreeTimeDetailId',
    UserId: 'UserId',
    FreeTime: 'FreeTime',
    FreeMoney: 'FreeMoney',
    Type: 'Type',
    RecordDate: 'RecordDate',
    VoucherId: 'VoucherId'
  };

  export type FreetimedetailtbScalarFieldEnum = (typeof FreetimedetailtbScalarFieldEnum)[keyof typeof FreetimedetailtbScalarFieldEnum]


  export const FunctiontbScalarFieldEnum: {
    FunctionCode: 'FunctionCode',
    FunctionName: 'FunctionName',
    ParentFunction: 'ParentFunction',
    LevelFunction: 'LevelFunction',
    OrderOfLevel: 'OrderOfLevel',
    Active: 'Active'
  };

  export type FunctiontbScalarFieldEnum = (typeof FunctiontbScalarFieldEnum)[keyof typeof FunctiontbScalarFieldEnum]


  export const GamefoldertbScalarFieldEnum: {
    ID: 'ID',
    MachineID: 'MachineID',
    GameId: 'GameId',
    GamePath: 'GamePath'
  };

  export type GamefoldertbScalarFieldEnum = (typeof GamefoldertbScalarFieldEnum)[keyof typeof GamefoldertbScalarFieldEnum]


  export const GamelisttbScalarFieldEnum: {
    GameId: 'GameId',
    GameAlias: 'GameAlias',
    GameName: 'GameName',
    GameLauncher: 'GameLauncher',
    Active: 'Active',
    Protocol: 'Protocol',
    URL: 'URL',
    Checksum: 'Checksum',
    PublishDate: 'PublishDate',
    TorrentFile: 'TorrentFile',
    SetupFile: 'SetupFile',
    ShortcutPath: 'ShortcutPath',
    Type: 'Type',
    Size: 'Size',
    SetupType: 'SetupType',
    ConfigFile: 'ConfigFile',
    Checked: 'Checked'
  };

  export type GamelisttbScalarFieldEnum = (typeof GamelisttbScalarFieldEnum)[keyof typeof GamelisttbScalarFieldEnum]


  export const HptbScalarFieldEnum: {
    ID: 'ID',
    MachineName: 'MachineName',
    IEHP: 'IEHP',
    FFHP: 'FFHP',
    GCHP: 'GCHP',
    LastUpdateDate: 'LastUpdateDate'
  };

  export type HptbScalarFieldEnum = (typeof HptbScalarFieldEnum)[keyof typeof HptbScalarFieldEnum]


  export const IntoptiontbScalarFieldEnum: {
    OptionId: 'OptionId',
    OptionName: 'OptionName',
    Value: 'Value',
    Active: 'Active'
  };

  export type IntoptiontbScalarFieldEnum = (typeof IntoptiontbScalarFieldEnum)[keyof typeof IntoptiontbScalarFieldEnum]


  export const InventorytbScalarFieldEnum: {
    ID: 'ID',
    CreateDate: 'CreateDate',
    CreateTime: 'CreateTime',
    StaffID: 'StaffID',
    Note: 'Note',
    ServiceID: 'ServiceID',
    ImportQuantity: 'ImportQuantity',
    ImportPrice: 'ImportPrice',
    ImportTotalAmount: 'ImportTotalAmount'
  };

  export type InventorytbScalarFieldEnum = (typeof InventorytbScalarFieldEnum)[keyof typeof InventorytbScalarFieldEnum]


  export const LegalapptbScalarFieldEnum: {
    AppName: 'AppName'
  };

  export type LegalapptbScalarFieldEnum = (typeof LegalapptbScalarFieldEnum)[keyof typeof LegalapptbScalarFieldEnum]


  export const MachinegrouptbScalarFieldEnum: {
    MachineGroupId: 'MachineGroupId',
    MachineGroupName: 'MachineGroupName',
    PriceDefault: 'PriceDefault',
    Active: 'Active',
    Description: 'Description'
  };

  export type MachinegrouptbScalarFieldEnum = (typeof MachinegrouptbScalarFieldEnum)[keyof typeof MachinegrouptbScalarFieldEnum]


  export const PaymenttbScalarFieldEnum: {
    VoucherId: 'VoucherId',
    UserId: 'UserId',
    VoucherNo: 'VoucherNo',
    VoucherDate: 'VoucherDate',
    VoucherTime: 'VoucherTime',
    ServeDate: 'ServeDate',
    ServeTime: 'ServeTime',
    Amount: 'Amount',
    AutoAmount: 'AutoAmount',
    TimeTotal: 'TimeTotal',
    Active: 'Active',
    UserNote: 'UserNote',
    Note: 'Note',
    ServicePaid: 'ServicePaid',
    StaffId: 'StaffId',
    MachineName: 'MachineName',
    PaymentType: 'PaymentType',
    PaymentWaitId: 'PaymentWaitId',
    zOid: 'zOid',
    zTid: 'zTid',
    zSig: 'zSig'
  };

  export type PaymenttbScalarFieldEnum = (typeof PaymenttbScalarFieldEnum)[keyof typeof PaymenttbScalarFieldEnum]


  export const PaymentwaittbScalarFieldEnum: {
    PaymentWaitId: 'PaymentWaitId',
    MachineName: 'MachineName',
    TotalTimeUsed: 'TotalTimeUsed',
    TotalTimeFee: 'TotalTimeFee',
    BeginTime: 'BeginTime',
    EndTime: 'EndTime',
    TimeFee: 'TimeFee',
    TimeUsed: 'TimeUsed',
    RemainTime: 'RemainTime',
    TimePaid: 'TimePaid',
    FreeTime: 'FreeTime',
    ChangePCSessionId: 'ChangePCSessionId',
    AnonymId: 'AnonymId',
    PriceGroupId: 'PriceGroupId',
    MachineGroupId: 'MachineGroupId',
    Note: 'Note',
    PriceAppRentID: 'PriceAppRentID'
  };

  export type PaymentwaittbScalarFieldEnum = (typeof PaymentwaittbScalarFieldEnum)[keyof typeof PaymentwaittbScalarFieldEnum]


  export const PriceapprenttbScalarFieldEnum: {
    PriceAppRentID: 'PriceAppRentID',
    PriceID: 'PriceID',
    MachineGroupID: 'MachineGroupID',
    Name: 'Name',
    Price: 'Price',
    Status: 'Status'
  };

  export type PriceapprenttbScalarFieldEnum = (typeof PriceapprenttbScalarFieldEnum)[keyof typeof PriceapprenttbScalarFieldEnum]


  export const PriceapprentusetbScalarFieldEnum: {
    PriceAppRentUseID: 'PriceAppRentUseID',
    PriceAppRentID: 'PriceAppRentID',
    ApplicationRentID: 'ApplicationRentID'
  };

  export type PriceapprentusetbScalarFieldEnum = (typeof PriceapprentusetbScalarFieldEnum)[keyof typeof PriceapprentusetbScalarFieldEnum]


  export const PricedetailtbScalarFieldEnum: {
    PriceDetailId: 'PriceDetailId',
    PriceId: 'PriceId',
    MachineGroupId: 'MachineGroupId',
    Price: 'Price',
    Promotion: 'Promotion',
    PromotionTerm: 'PromotionTerm',
    FreeMoney: 'FreeMoney',
    FreeTime: 'FreeTime',
    BeginTime: 'BeginTime',
    EndTime: 'EndTime',
    Term: 'Term',
    PromotionOrder: 'PromotionOrder',
    BeginDate: 'BeginDate',
    EndDate: 'EndDate',
    DayOfWeekMask: 'DayOfWeekMask',
    PromotionType: 'PromotionType'
  };

  export type PricedetailtbScalarFieldEnum = (typeof PricedetailtbScalarFieldEnum)[keyof typeof PricedetailtbScalarFieldEnum]


  export const PricelisttbScalarFieldEnum: {
    PriceId: 'PriceId',
    PriceType: 'PriceType',
    Price: 'Price',
    Type: 'Type',
    Active: 'Active'
  };

  export type PricelisttbScalarFieldEnum = (typeof PricelisttbScalarFieldEnum)[keyof typeof PricelisttbScalarFieldEnum]


  export const PricemachinetbScalarFieldEnum: {
    PriceMachineId: 'PriceMachineId',
    PriceId: 'PriceId',
    MachineGroupId: 'MachineGroupId',
    Price: 'Price'
  };

  export type PricemachinetbScalarFieldEnum = (typeof PricemachinetbScalarFieldEnum)[keyof typeof PricemachinetbScalarFieldEnum]


  export const PrintertbScalarFieldEnum: {
    ID: 'ID',
    PrinterName: 'PrinterName',
    Type: 'Type',
    Active: 'Active'
  };

  export type PrintertbScalarFieldEnum = (typeof PrintertbScalarFieldEnum)[keyof typeof PrintertbScalarFieldEnum]


  export const PrintservicetbScalarFieldEnum: {
    ID: 'ID',
    PrinterID: 'PrinterID',
    ServiceID: 'ServiceID'
  };

  export type PrintservicetbScalarFieldEnum = (typeof PrintservicetbScalarFieldEnum)[keyof typeof PrintservicetbScalarFieldEnum]


  export const ProcesstbScalarFieldEnum: {
    ID: 'ID',
    MachineName: 'MachineName',
    ProcessName: 'ProcessName',
    FileLocation: 'FileLocation',
    FileDescription: 'FileDescription',
    Type: 'Type',
    PreviousDate: 'PreviousDate',
    CurrentDate: 'CurrentDate'
  };

  export type ProcesstbScalarFieldEnum = (typeof ProcesstbScalarFieldEnum)[keyof typeof ProcesstbScalarFieldEnum]


  export const RechargecarddetailtbScalarFieldEnum: {
    CardDetailId: 'CardDetailId',
    VoucherId: 'VoucherId',
    StaffId: 'StaffId',
    CardValue: 'CardValue',
    CardDate: 'CardDate',
    CardTime: 'CardTime',
    CardQuantity: 'CardQuantity',
    CardAmount: 'CardAmount',
    UserId: 'UserId',
    Accept: 'Accept'
  };

  export type RechargecarddetailtbScalarFieldEnum = (typeof RechargecarddetailtbScalarFieldEnum)[keyof typeof RechargecarddetailtbScalarFieldEnum]


  export const RechargecardtbScalarFieldEnum: {
    CardId: 'CardId',
    cardcode: 'cardcode',
    CardValue: 'CardValue',
    ExpiryDate: 'ExpiryDate',
    CreateDate: 'CreateDate',
    CreateTime: 'CreateTime',
    ModifyDate: 'ModifyDate',
    ModifyTime: 'ModifyTime',
    Status: 'Status',
    UserId: 'UserId',
    Note: 'Note'
  };

  export type RechargecardtbScalarFieldEnum = (typeof RechargecardtbScalarFieldEnum)[keyof typeof RechargecardtbScalarFieldEnum]


  export const ReportdailyScalarFieldEnum: {
    ymd: 'ymd',
    prefix: 'prefix',
    mode: 'mode',
    f1: 'f1',
    f2: 'f2',
    f3: 'f3',
    f4: 'f4',
    f5: 'f5',
    f6: 'f6',
    f7: 'f7',
    f8: 'f8',
    f9: 'f9',
    f10: 'f10',
    f11: 'f11',
    f12: 'f12',
    f13: 'f13',
    f14: 'f14',
    f15: 'f15',
    f16: 'f16',
    f17: 'f17',
    f18: 'f18',
    f19: 'f19',
    f20: 'f20',
    ext: 'ext',
    hash: 'hash',
    create_date: 'create_date',
    update_date: 'update_date'
  };

  export type ReportdailyScalarFieldEnum = (typeof ReportdailyScalarFieldEnum)[keyof typeof ReportdailyScalarFieldEnum]


  export const ReportmonthlyScalarFieldEnum: {
    ymd: 'ymd',
    prefix: 'prefix',
    mode: 'mode',
    f1: 'f1',
    f2: 'f2',
    f3: 'f3',
    f4: 'f4',
    f5: 'f5',
    f6: 'f6',
    f7: 'f7',
    f8: 'f8',
    f9: 'f9',
    f10: 'f10',
    f11: 'f11',
    f12: 'f12',
    f13: 'f13',
    f14: 'f14',
    f15: 'f15',
    f16: 'f16',
    f17: 'f17',
    f18: 'f18',
    f19: 'f19',
    f20: 'f20',
    ext: 'ext',
    hash: 'hash',
    create_date: 'create_date',
    update_date: 'update_date'
  };

  export type ReportmonthlyScalarFieldEnum = (typeof ReportmonthlyScalarFieldEnum)[keyof typeof ReportmonthlyScalarFieldEnum]


  export const RighttbScalarFieldEnum: {
    RightId: 'RightId',
    UserId: 'UserId',
    FunctionCode: 'FunctionCode'
  };

  export type RighttbScalarFieldEnum = (typeof RighttbScalarFieldEnum)[keyof typeof RighttbScalarFieldEnum]


  export const ServerlogtbScalarFieldEnum: {
    ServerLogId: 'ServerLogId',
    Status: 'Status',
    RecordDate: 'RecordDate',
    RecordTime: 'RecordTime',
    Period: 'Period',
    Note: 'Note'
  };

  export type ServerlogtbScalarFieldEnum = (typeof ServerlogtbScalarFieldEnum)[keyof typeof ServerlogtbScalarFieldEnum]


  export const ServicedetailtbScalarFieldEnum: {
    ServiceDetailId: 'ServiceDetailId',
    UserId: 'UserId',
    ServiceId: 'ServiceId',
    ServiceDate: 'ServiceDate',
    ServiceTime: 'ServiceTime',
    ServiceQuantity: 'ServiceQuantity',
    ServiceAmount: 'ServiceAmount',
    ServicePaid: 'ServicePaid',
    Accept: 'Accept',
    VoucherId: 'VoucherId',
    StaffId: 'StaffId',
    PaymentWaitId: 'PaymentWaitId',
    iCafeHash: 'iCafeHash',
    iCafeUsr: 'iCafeUsr'
  };

  export type ServicedetailtbScalarFieldEnum = (typeof ServicedetailtbScalarFieldEnum)[keyof typeof ServicedetailtbScalarFieldEnum]


  export const ServicegiftsbagScalarFieldEnum: {
    recId: 'recId',
    recUuid: 'recUuid',
    userId: 'userId',
    userName: 'userName',
    createDate: 'createDate',
    expDate: 'expDate',
    sourceType: 'sourceType',
    serviceId: 'serviceId',
    serviceName: 'serviceName',
    servicePrice: 'servicePrice',
    serviceImg: 'serviceImg',
    status: 'status',
    requestDate: 'requestDate',
    acceptDate: 'acceptDate',
    sign: 'sign',
    staffId: 'staffId',
    staffName: 'staffName',
    transId: 'transId',
    serialId: 'serialId',
    ymd: 'ymd',
    totalDay: 'totalDay',
    groupId: 'groupId'
  };

  export type ServicegiftsbagScalarFieldEnum = (typeof ServicegiftsbagScalarFieldEnum)[keyof typeof ServicegiftsbagScalarFieldEnum]


  export const ServicegrouptbScalarFieldEnum: {
    ID: 'ID',
    ServiceGroupName: 'ServiceGroupName',
    IsOrder: 'IsOrder',
    Active: 'Active',
    TypeID: 'TypeID'
  };

  export type ServicegrouptbScalarFieldEnum = (typeof ServicegrouptbScalarFieldEnum)[keyof typeof ServicegrouptbScalarFieldEnum]


  export const ServiceinfologtbScalarFieldEnum: {
    logId: 'logId',
    serviceId: 'serviceId',
    prefix: 'prefix',
    info: 'info',
    status: 'status',
    createDate: 'createDate',
    mode: 'mode',
    hash: 'hash'
  };

  export type ServiceinfologtbScalarFieldEnum = (typeof ServiceinfologtbScalarFieldEnum)[keyof typeof ServiceinfologtbScalarFieldEnum]


  export const ServiceinfotbScalarFieldEnum: {
    serviceId: 'serviceId',
    prefix: 'prefix',
    info: 'info',
    status: 'status',
    createDate: 'createDate',
    mode: 'mode',
    hash: 'hash'
  };

  export type ServiceinfotbScalarFieldEnum = (typeof ServiceinfotbScalarFieldEnum)[keyof typeof ServiceinfotbScalarFieldEnum]


  export const ServicetbScalarFieldEnum: {
    ServiceId: 'ServiceId',
    ServiceName: 'ServiceName',
    ServicePrice: 'ServicePrice',
    Unit: 'Unit',
    Active: 'Active',
    InventoryManagement: 'InventoryManagement',
    Inventory: 'Inventory',
    WarningInventory: 'WarningInventory',
    ServiceGroupID: 'ServiceGroupID',
    NumInventoryExpected: 'NumInventoryExpected',
    UnitID: 'UnitID',
    SuggestID: 'SuggestID',
    ServiceImg: 'ServiceImg',
    ServiceDate: 'ServiceDate'
  };

  export type ServicetbScalarFieldEnum = (typeof ServicetbScalarFieldEnum)[keyof typeof ServicetbScalarFieldEnum]


  export const ServiceunittbScalarFieldEnum: {
    ID: 'ID',
    Unit: 'Unit',
    IsActive: 'IsActive'
  };

  export type ServiceunittbScalarFieldEnum = (typeof ServiceunittbScalarFieldEnum)[keyof typeof ServiceunittbScalarFieldEnum]


  export const ServicevisitScalarFieldEnum: {
    uid: 'uid',
    vstotal: 'vstotal',
    vsdetail: 'vsdetail',
    ym: 'ym',
    last_update: 'last_update',
    sign: 'sign',
    ssid: 'ssid',
    reset: 'reset'
  };

  export type ServicevisitScalarFieldEnum = (typeof ServicevisitScalarFieldEnum)[keyof typeof ServicevisitScalarFieldEnum]


  export const SettingtbScalarFieldEnum: {
    SettingId: 'SettingId',
    Value: 'Value',
    Data: 'Data',
    Active: 'Active'
  };

  export type SettingtbScalarFieldEnum = (typeof SettingtbScalarFieldEnum)[keyof typeof SettingtbScalarFieldEnum]


  export const SoftwaretbScalarFieldEnum: {
    ID: 'ID',
    UserId: 'UserId',
    Name: 'Name',
    Version: 'Version',
    MAC: 'MAC',
    Active: 'Active'
  };

  export type SoftwaretbScalarFieldEnum = (typeof SoftwaretbScalarFieldEnum)[keyof typeof SoftwaretbScalarFieldEnum]


  export const SpecappdetailtbScalarFieldEnum: {
    ID: 'ID',
    MachineName: 'MachineName',
    AppName: 'AppName',
    Shortcut: 'Shortcut',
    InstallName: 'InstallName',
    InstallVersion: 'InstallVersion',
    InstallLocation: 'InstallLocation',
    LastUpdateDate: 'LastUpdateDate',
    Sent: 'Sent',
    AppRun: 'AppRun',
    SubRun: 'SubRun',
    SubRun2: 'SubRun2'
  };

  export type SpecappdetailtbScalarFieldEnum = (typeof SpecappdetailtbScalarFieldEnum)[keyof typeof SpecappdetailtbScalarFieldEnum]


  export const StandardservicetbScalarFieldEnum: {
    StandardServiceId: 'StandardServiceId',
    StandardServiceName: 'StandardServiceName',
    StandardServiceGroupID: 'StandardServiceGroupID',
    Active: 'Active'
  };

  export type StandardservicetbScalarFieldEnum = (typeof StandardservicetbScalarFieldEnum)[keyof typeof StandardservicetbScalarFieldEnum]


  export const StocktakingtbScalarFieldEnum: {
    ID: 'ID',
    CreateDate: 'CreateDate',
    CreateTime: 'CreateTime',
    StaffID: 'StaffID',
    NumInventoryExpected: 'NumInventoryExpected',
    NumInventoryReal: 'NumInventoryReal',
    NumAdjust: 'NumAdjust',
    NumPreAdjust: 'NumPreAdjust',
    Note: 'Note',
    ServiceID: 'ServiceID'
  };

  export type StocktakingtbScalarFieldEnum = (typeof StocktakingtbScalarFieldEnum)[keyof typeof StocktakingtbScalarFieldEnum]


  export const SupportsScalarFieldEnum: {
    supportId: 'supportId',
    supportTitle: 'supportTitle',
    supportImage: 'supportImage',
    suportCode: 'suportCode',
    supportHash: 'supportHash',
    status: 'status',
    order: 'order',
    supportCat: 'supportCat',
    totalClick: 'totalClick',
    ssId: 'ssId',
    createDate: 'createDate',
    modifyDate: 'modifyDate'
  };

  export type SupportsScalarFieldEnum = (typeof SupportsScalarFieldEnum)[keyof typeof SupportsScalarFieldEnum]


  export const SystemfunctiontbScalarFieldEnum: {
    ResourceID: 'ResourceID',
    Status: 'Status'
  };

  export type SystemfunctiontbScalarFieldEnum = (typeof SystemfunctiontbScalarFieldEnum)[keyof typeof SystemfunctiontbScalarFieldEnum]


  export const SystemlogtbScalarFieldEnum: {
    SystemLogId: 'SystemLogId',
    UserId: 'UserId',
    MachineName: 'MachineName',
    IPAddress: 'IPAddress',
    EnterDate: 'EnterDate',
    EnterTime: 'EnterTime',
    EndDate: 'EndDate',
    EndTime: 'EndTime',
    Status: 'Status',
    Note: 'Note',
    TimeUsed: 'TimeUsed',
    MoneyUsed: 'MoneyUsed',
    PriceAppRentID: 'PriceAppRentID',
    AppRentMoneyUsed: 'AppRentMoneyUsed'
  };

  export type SystemlogtbScalarFieldEnum = (typeof SystemlogtbScalarFieldEnum)[keyof typeof SystemlogtbScalarFieldEnum]


  export const TrackappdetailtbScalarFieldEnum: {
    TrackAppDetailId: 'TrackAppDetailId',
    AppName: 'AppName',
    UserName: 'UserName',
    TrackingDate: 'TrackingDate',
    TrackingTime: 'TrackingTime',
    TimeTotal: 'TimeTotal',
    AppSession: 'AppSession',
    Sent: 'Sent',
    Machine: 'Machine',
    SessionId: 'SessionId',
    ETT: 'ETT'
  };

  export type TrackappdetailtbScalarFieldEnum = (typeof TrackappdetailtbScalarFieldEnum)[keyof typeof TrackappdetailtbScalarFieldEnum]


  export const TrackapptbScalarFieldEnum: {
    AppName: 'AppName',
    TrackingType: 'TrackingType'
  };

  export type TrackapptbScalarFieldEnum = (typeof TrackapptbScalarFieldEnum)[keyof typeof TrackapptbScalarFieldEnum]


  export const TrackguitbScalarFieldEnum: {
    ID: 'ID',
    RecordDate: 'RecordDate',
    FromTime: 'FromTime',
    ToTime: 'ToTime',
    DialogID: 'DialogID',
    PrePath: 'PrePath',
    ControlID: 'ControlID',
    Type: 'Type',
    Param: 'Param',
    ActionCount: 'ActionCount'
  };

  export type TrackguitbScalarFieldEnum = (typeof TrackguitbScalarFieldEnum)[keyof typeof TrackguitbScalarFieldEnum]


  export const TransferdetailtbScalarFieldEnum: {
    TransferDetailId: 'TransferDetailId',
    VoucherId: 'VoucherId',
    FromUserId: 'FromUserId',
    ToUserId: 'ToUserId',
    TransferDate: 'TransferDate',
    TransferTime: 'TransferTime'
  };

  export type TransferdetailtbScalarFieldEnum = (typeof TransferdetailtbScalarFieldEnum)[keyof typeof TransferdetailtbScalarFieldEnum]


  export const UsagetimetbScalarFieldEnum: {
    UsageTimeId: 'UsageTimeId',
    UsageTimeName: 'UsageTimeName',
    FromAge: 'FromAge',
    ToAge: 'ToAge',
    UserType: 'UserType'
  };

  export type UsagetimetbScalarFieldEnum = (typeof UsagetimetbScalarFieldEnum)[keyof typeof UsagetimetbScalarFieldEnum]


  export const UsertbScalarFieldEnum: {
    UserId: 'UserId',
    FirstName: 'FirstName',
    LastName: 'LastName',
    MiddleName: 'MiddleName',
    UserName: 'UserName',
    Password: 'Password',
    ID: 'ID',
    Address: 'Address',
    Phone: 'Phone',
    Email: 'Email',
    City: 'City',
    State: 'State',
    Zipcode: 'Zipcode',
    Debit: 'Debit',
    CreditLimit: 'CreditLimit',
    Active: 'Active',
    RecordDate: 'RecordDate',
    ExpiryDate: 'ExpiryDate',
    UserType: 'UserType',
    Memo: 'Memo',
    Birthdate: 'Birthdate',
    SSN1: 'SSN1',
    SSN2: 'SSN2',
    SSN3: 'SSN3',
    TimePaid: 'TimePaid',
    TimeUsed: 'TimeUsed',
    MoneyPaid: 'MoneyPaid',
    MoneyUsed: 'MoneyUsed',
    RemainTime: 'RemainTime',
    FreeTime: 'FreeTime',
    TimeTransfer: 'TimeTransfer',
    RemainMoney: 'RemainMoney',
    FreeMoney: 'FreeMoney',
    MoneyTransfer: 'MoneyTransfer',
    UsageTimeId: 'UsageTimeId',
    PromotionTime: 'PromotionTime',
    PromotionMoney: 'PromotionMoney',
    MachineGroupId: 'MachineGroupId',
    MAC: 'MAC',
    changepcdetailId: 'changepcdetailId',
    MoneyUsedMin: 'MoneyUsedMin',
    CType: 'CType',
    Status: 'Status',
    LastLoginDate: 'LastLoginDate',
    PriceAppRentID: 'PriceAppRentID',
    EIType: 'EIType',
    pc_rptInfo: 'pc_rptInfo'
  };

  export type UsertbScalarFieldEnum = (typeof UsertbScalarFieldEnum)[keyof typeof UsertbScalarFieldEnum]


  export const VersiontbScalarFieldEnum: {
    ComputerName: 'ComputerName',
    Version: 'Version',
    Type: 'Type',
    ReleaseDate: 'ReleaseDate',
    LastUpdate: 'LastUpdate',
    DPStatus: 'DPStatus',
    DPType: 'DPType',
    DPVersion: 'DPVersion'
  };

  export type VersiontbScalarFieldEnum = (typeof VersiontbScalarFieldEnum)[keyof typeof VersiontbScalarFieldEnum]


  export const WallettbScalarFieldEnum: {
    id: 'id',
    main: 'main',
    sub: 'sub',
    sub1: 'sub1',
    sub2: 'sub2',
    userid: 'userid',
    status: 'status',
    ts: 'ts',
    wsec: 'wsec',
    ssec: 'ssec'
  };

  export type WallettbScalarFieldEnum = (typeof WallettbScalarFieldEnum)[keyof typeof WallettbScalarFieldEnum]


  export const WebhistorytbScalarFieldEnum: {
    URLId: 'URLId',
    URL: 'URL',
    RecordDate: 'RecordDate',
    UserId: 'UserId',
    Machine: 'Machine',
    Active: 'Active',
    Session: 'Session',
    AnonymousId: 'AnonymousId',
    BrowserType: 'BrowserType'
  };

  export type WebhistorytbScalarFieldEnum = (typeof WebhistorytbScalarFieldEnum)[keyof typeof WebhistorytbScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type accountingentrytbWhereInput = {
    AND?: accountingentrytbWhereInput | accountingentrytbWhereInput[]
    OR?: accountingentrytbWhereInput[]
    NOT?: accountingentrytbWhereInput | accountingentrytbWhereInput[]
    ID?: IntFilter<"accountingentrytb"> | number
    CreateDate?: DateTimeFilter<"accountingentrytb"> | Date | string
    CreateTime?: DateTimeFilter<"accountingentrytb"> | Date | string
    StaffID?: IntFilter<"accountingentrytb"> | number
    FromDate?: DateTimeFilter<"accountingentrytb"> | Date | string
    FromTime?: DateTimeFilter<"accountingentrytb"> | Date | string
    NumBalance?: IntFilter<"accountingentrytb"> | number
    ImportQuantity?: IntFilter<"accountingentrytb"> | number
    ImportTotalAmount?: DecimalFilter<"accountingentrytb"> | Decimal | DecimalJsLike | number | string
    SaleQuantity?: IntFilter<"accountingentrytb"> | number
    SaleTotalAmount?: DecimalFilter<"accountingentrytb"> | Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: IntFilter<"accountingentrytb"> | number
    NumInventoryReal?: IntFilter<"accountingentrytb"> | number
    NumAdjust?: IntFilter<"accountingentrytb"> | number
    Note?: StringNullableFilter<"accountingentrytb"> | string | null
    ServiceID?: IntFilter<"accountingentrytb"> | number
  }

  export type accountingentrytbOrderByWithRelationInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    NumBalance?: SortOrder
    ImportQuantity?: SortOrder
    ImportTotalAmount?: SortOrder
    SaleQuantity?: SortOrder
    SaleTotalAmount?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    Note?: SortOrderInput | SortOrder
    ServiceID?: SortOrder
  }

  export type accountingentrytbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: accountingentrytbWhereInput | accountingentrytbWhereInput[]
    OR?: accountingentrytbWhereInput[]
    NOT?: accountingentrytbWhereInput | accountingentrytbWhereInput[]
    CreateDate?: DateTimeFilter<"accountingentrytb"> | Date | string
    CreateTime?: DateTimeFilter<"accountingentrytb"> | Date | string
    StaffID?: IntFilter<"accountingentrytb"> | number
    FromDate?: DateTimeFilter<"accountingentrytb"> | Date | string
    FromTime?: DateTimeFilter<"accountingentrytb"> | Date | string
    NumBalance?: IntFilter<"accountingentrytb"> | number
    ImportQuantity?: IntFilter<"accountingentrytb"> | number
    ImportTotalAmount?: DecimalFilter<"accountingentrytb"> | Decimal | DecimalJsLike | number | string
    SaleQuantity?: IntFilter<"accountingentrytb"> | number
    SaleTotalAmount?: DecimalFilter<"accountingentrytb"> | Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: IntFilter<"accountingentrytb"> | number
    NumInventoryReal?: IntFilter<"accountingentrytb"> | number
    NumAdjust?: IntFilter<"accountingentrytb"> | number
    Note?: StringNullableFilter<"accountingentrytb"> | string | null
    ServiceID?: IntFilter<"accountingentrytb"> | number
  }, "ID">

  export type accountingentrytbOrderByWithAggregationInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    NumBalance?: SortOrder
    ImportQuantity?: SortOrder
    ImportTotalAmount?: SortOrder
    SaleQuantity?: SortOrder
    SaleTotalAmount?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    Note?: SortOrderInput | SortOrder
    ServiceID?: SortOrder
    _count?: accountingentrytbCountOrderByAggregateInput
    _avg?: accountingentrytbAvgOrderByAggregateInput
    _max?: accountingentrytbMaxOrderByAggregateInput
    _min?: accountingentrytbMinOrderByAggregateInput
    _sum?: accountingentrytbSumOrderByAggregateInput
  }

  export type accountingentrytbScalarWhereWithAggregatesInput = {
    AND?: accountingentrytbScalarWhereWithAggregatesInput | accountingentrytbScalarWhereWithAggregatesInput[]
    OR?: accountingentrytbScalarWhereWithAggregatesInput[]
    NOT?: accountingentrytbScalarWhereWithAggregatesInput | accountingentrytbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"accountingentrytb"> | number
    CreateDate?: DateTimeWithAggregatesFilter<"accountingentrytb"> | Date | string
    CreateTime?: DateTimeWithAggregatesFilter<"accountingentrytb"> | Date | string
    StaffID?: IntWithAggregatesFilter<"accountingentrytb"> | number
    FromDate?: DateTimeWithAggregatesFilter<"accountingentrytb"> | Date | string
    FromTime?: DateTimeWithAggregatesFilter<"accountingentrytb"> | Date | string
    NumBalance?: IntWithAggregatesFilter<"accountingentrytb"> | number
    ImportQuantity?: IntWithAggregatesFilter<"accountingentrytb"> | number
    ImportTotalAmount?: DecimalWithAggregatesFilter<"accountingentrytb"> | Decimal | DecimalJsLike | number | string
    SaleQuantity?: IntWithAggregatesFilter<"accountingentrytb"> | number
    SaleTotalAmount?: DecimalWithAggregatesFilter<"accountingentrytb"> | Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: IntWithAggregatesFilter<"accountingentrytb"> | number
    NumInventoryReal?: IntWithAggregatesFilter<"accountingentrytb"> | number
    NumAdjust?: IntWithAggregatesFilter<"accountingentrytb"> | number
    Note?: StringNullableWithAggregatesFilter<"accountingentrytb"> | string | null
    ServiceID?: IntWithAggregatesFilter<"accountingentrytb"> | number
  }

  export type anonymoustbWhereInput = {
    AND?: anonymoustbWhereInput | anonymoustbWhereInput[]
    OR?: anonymoustbWhereInput[]
    NOT?: anonymoustbWhereInput | anonymoustbWhereInput[]
    ID?: IntFilter<"anonymoustb"> | number
    Name?: StringNullableFilter<"anonymoustb"> | string | null
    IDCard?: StringNullableFilter<"anonymoustb"> | string | null
    Address?: StringNullableFilter<"anonymoustb"> | string | null
    MachineID?: IntNullableFilter<"anonymoustb"> | number | null
    Session?: IntFilter<"anonymoustb"> | number
    RecordDate?: DateTimeFilter<"anonymoustb"> | Date | string
  }

  export type anonymoustbOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrderInput | SortOrder
    IDCard?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    MachineID?: SortOrderInput | SortOrder
    Session?: SortOrder
    RecordDate?: SortOrder
  }

  export type anonymoustbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: anonymoustbWhereInput | anonymoustbWhereInput[]
    OR?: anonymoustbWhereInput[]
    NOT?: anonymoustbWhereInput | anonymoustbWhereInput[]
    Name?: StringNullableFilter<"anonymoustb"> | string | null
    IDCard?: StringNullableFilter<"anonymoustb"> | string | null
    Address?: StringNullableFilter<"anonymoustb"> | string | null
    MachineID?: IntNullableFilter<"anonymoustb"> | number | null
    Session?: IntFilter<"anonymoustb"> | number
    RecordDate?: DateTimeFilter<"anonymoustb"> | Date | string
  }, "ID">

  export type anonymoustbOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrderInput | SortOrder
    IDCard?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    MachineID?: SortOrderInput | SortOrder
    Session?: SortOrder
    RecordDate?: SortOrder
    _count?: anonymoustbCountOrderByAggregateInput
    _avg?: anonymoustbAvgOrderByAggregateInput
    _max?: anonymoustbMaxOrderByAggregateInput
    _min?: anonymoustbMinOrderByAggregateInput
    _sum?: anonymoustbSumOrderByAggregateInput
  }

  export type anonymoustbScalarWhereWithAggregatesInput = {
    AND?: anonymoustbScalarWhereWithAggregatesInput | anonymoustbScalarWhereWithAggregatesInput[]
    OR?: anonymoustbScalarWhereWithAggregatesInput[]
    NOT?: anonymoustbScalarWhereWithAggregatesInput | anonymoustbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"anonymoustb"> | number
    Name?: StringNullableWithAggregatesFilter<"anonymoustb"> | string | null
    IDCard?: StringNullableWithAggregatesFilter<"anonymoustb"> | string | null
    Address?: StringNullableWithAggregatesFilter<"anonymoustb"> | string | null
    MachineID?: IntNullableWithAggregatesFilter<"anonymoustb"> | number | null
    Session?: IntWithAggregatesFilter<"anonymoustb"> | number
    RecordDate?: DateTimeWithAggregatesFilter<"anonymoustb"> | Date | string
  }

  export type applicationrenttbWhereInput = {
    AND?: applicationrenttbWhereInput | applicationrenttbWhereInput[]
    OR?: applicationrenttbWhereInput[]
    NOT?: applicationrenttbWhereInput | applicationrenttbWhereInput[]
    ApplicationRentID?: IntFilter<"applicationrenttb"> | number
    Name?: StringFilter<"applicationrenttb"> | string
    Hash?: StringFilter<"applicationrenttb"> | string
    AddBy?: IntFilter<"applicationrenttb"> | number
    Status?: IntFilter<"applicationrenttb"> | number
  }

  export type applicationrenttbOrderByWithRelationInput = {
    ApplicationRentID?: SortOrder
    Name?: SortOrder
    Hash?: SortOrder
    AddBy?: SortOrder
    Status?: SortOrder
  }

  export type applicationrenttbWhereUniqueInput = Prisma.AtLeast<{
    ApplicationRentID?: number
    AND?: applicationrenttbWhereInput | applicationrenttbWhereInput[]
    OR?: applicationrenttbWhereInput[]
    NOT?: applicationrenttbWhereInput | applicationrenttbWhereInput[]
    Name?: StringFilter<"applicationrenttb"> | string
    Hash?: StringFilter<"applicationrenttb"> | string
    AddBy?: IntFilter<"applicationrenttb"> | number
    Status?: IntFilter<"applicationrenttb"> | number
  }, "ApplicationRentID">

  export type applicationrenttbOrderByWithAggregationInput = {
    ApplicationRentID?: SortOrder
    Name?: SortOrder
    Hash?: SortOrder
    AddBy?: SortOrder
    Status?: SortOrder
    _count?: applicationrenttbCountOrderByAggregateInput
    _avg?: applicationrenttbAvgOrderByAggregateInput
    _max?: applicationrenttbMaxOrderByAggregateInput
    _min?: applicationrenttbMinOrderByAggregateInput
    _sum?: applicationrenttbSumOrderByAggregateInput
  }

  export type applicationrenttbScalarWhereWithAggregatesInput = {
    AND?: applicationrenttbScalarWhereWithAggregatesInput | applicationrenttbScalarWhereWithAggregatesInput[]
    OR?: applicationrenttbScalarWhereWithAggregatesInput[]
    NOT?: applicationrenttbScalarWhereWithAggregatesInput | applicationrenttbScalarWhereWithAggregatesInput[]
    ApplicationRentID?: IntWithAggregatesFilter<"applicationrenttb"> | number
    Name?: StringWithAggregatesFilter<"applicationrenttb"> | string
    Hash?: StringWithAggregatesFilter<"applicationrenttb"> | string
    AddBy?: IntWithAggregatesFilter<"applicationrenttb"> | number
    Status?: IntWithAggregatesFilter<"applicationrenttb"> | number
  }

  export type applicationtbWhereInput = {
    AND?: applicationtbWhereInput | applicationtbWhereInput[]
    OR?: applicationtbWhereInput[]
    NOT?: applicationtbWhereInput | applicationtbWhereInput[]
    ApplicationId?: IntFilter<"applicationtb"> | number
    ApplicationName?: StringFilter<"applicationtb"> | string
    Description?: StringNullableFilter<"applicationtb"> | string | null
    RestrictType?: IntFilter<"applicationtb"> | number
    Hash?: StringNullableFilter<"applicationtb"> | string | null
    AppType?: IntFilter<"applicationtb"> | number
    AddedBy?: IntFilter<"applicationtb"> | number
  }

  export type applicationtbOrderByWithRelationInput = {
    ApplicationId?: SortOrder
    ApplicationName?: SortOrder
    Description?: SortOrderInput | SortOrder
    RestrictType?: SortOrder
    Hash?: SortOrderInput | SortOrder
    AppType?: SortOrder
    AddedBy?: SortOrder
  }

  export type applicationtbWhereUniqueInput = Prisma.AtLeast<{
    ApplicationId?: number
    ApplicationName?: string
    AND?: applicationtbWhereInput | applicationtbWhereInput[]
    OR?: applicationtbWhereInput[]
    NOT?: applicationtbWhereInput | applicationtbWhereInput[]
    Description?: StringNullableFilter<"applicationtb"> | string | null
    RestrictType?: IntFilter<"applicationtb"> | number
    Hash?: StringNullableFilter<"applicationtb"> | string | null
    AppType?: IntFilter<"applicationtb"> | number
    AddedBy?: IntFilter<"applicationtb"> | number
  }, "ApplicationId" | "ApplicationName">

  export type applicationtbOrderByWithAggregationInput = {
    ApplicationId?: SortOrder
    ApplicationName?: SortOrder
    Description?: SortOrderInput | SortOrder
    RestrictType?: SortOrder
    Hash?: SortOrderInput | SortOrder
    AppType?: SortOrder
    AddedBy?: SortOrder
    _count?: applicationtbCountOrderByAggregateInput
    _avg?: applicationtbAvgOrderByAggregateInput
    _max?: applicationtbMaxOrderByAggregateInput
    _min?: applicationtbMinOrderByAggregateInput
    _sum?: applicationtbSumOrderByAggregateInput
  }

  export type applicationtbScalarWhereWithAggregatesInput = {
    AND?: applicationtbScalarWhereWithAggregatesInput | applicationtbScalarWhereWithAggregatesInput[]
    OR?: applicationtbScalarWhereWithAggregatesInput[]
    NOT?: applicationtbScalarWhereWithAggregatesInput | applicationtbScalarWhereWithAggregatesInput[]
    ApplicationId?: IntWithAggregatesFilter<"applicationtb"> | number
    ApplicationName?: StringWithAggregatesFilter<"applicationtb"> | string
    Description?: StringNullableWithAggregatesFilter<"applicationtb"> | string | null
    RestrictType?: IntWithAggregatesFilter<"applicationtb"> | number
    Hash?: StringNullableWithAggregatesFilter<"applicationtb"> | string | null
    AppType?: IntWithAggregatesFilter<"applicationtb"> | number
    AddedBy?: IntWithAggregatesFilter<"applicationtb"> | number
  }

  export type blacklisttbWhereInput = {
    AND?: blacklisttbWhereInput | blacklisttbWhereInput[]
    OR?: blacklisttbWhereInput[]
    NOT?: blacklisttbWhereInput | blacklisttbWhereInput[]
    URLId?: IntFilter<"blacklisttb"> | number
    URL?: StringFilter<"blacklisttb"> | string
    Title?: StringNullableFilter<"blacklisttb"> | string | null
    Description?: StringNullableFilter<"blacklisttb"> | string | null
    RecordDate?: DateTimeFilter<"blacklisttb"> | Date | string
    Active?: IntFilter<"blacklisttb"> | number
    AddedBy?: IntFilter<"blacklisttb"> | number
  }

  export type blacklisttbOrderByWithRelationInput = {
    URLId?: SortOrder
    URL?: SortOrder
    Title?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    RecordDate?: SortOrder
    Active?: SortOrder
    AddedBy?: SortOrder
  }

  export type blacklisttbWhereUniqueInput = Prisma.AtLeast<{
    URLId?: number
    AND?: blacklisttbWhereInput | blacklisttbWhereInput[]
    OR?: blacklisttbWhereInput[]
    NOT?: blacklisttbWhereInput | blacklisttbWhereInput[]
    URL?: StringFilter<"blacklisttb"> | string
    Title?: StringNullableFilter<"blacklisttb"> | string | null
    Description?: StringNullableFilter<"blacklisttb"> | string | null
    RecordDate?: DateTimeFilter<"blacklisttb"> | Date | string
    Active?: IntFilter<"blacklisttb"> | number
    AddedBy?: IntFilter<"blacklisttb"> | number
  }, "URLId">

  export type blacklisttbOrderByWithAggregationInput = {
    URLId?: SortOrder
    URL?: SortOrder
    Title?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    RecordDate?: SortOrder
    Active?: SortOrder
    AddedBy?: SortOrder
    _count?: blacklisttbCountOrderByAggregateInput
    _avg?: blacklisttbAvgOrderByAggregateInput
    _max?: blacklisttbMaxOrderByAggregateInput
    _min?: blacklisttbMinOrderByAggregateInput
    _sum?: blacklisttbSumOrderByAggregateInput
  }

  export type blacklisttbScalarWhereWithAggregatesInput = {
    AND?: blacklisttbScalarWhereWithAggregatesInput | blacklisttbScalarWhereWithAggregatesInput[]
    OR?: blacklisttbScalarWhereWithAggregatesInput[]
    NOT?: blacklisttbScalarWhereWithAggregatesInput | blacklisttbScalarWhereWithAggregatesInput[]
    URLId?: IntWithAggregatesFilter<"blacklisttb"> | number
    URL?: StringWithAggregatesFilter<"blacklisttb"> | string
    Title?: StringNullableWithAggregatesFilter<"blacklisttb"> | string | null
    Description?: StringNullableWithAggregatesFilter<"blacklisttb"> | string | null
    RecordDate?: DateTimeWithAggregatesFilter<"blacklisttb"> | Date | string
    Active?: IntWithAggregatesFilter<"blacklisttb"> | number
    AddedBy?: IntWithAggregatesFilter<"blacklisttb"> | number
  }

  export type changepcdetailtbWhereInput = {
    AND?: changepcdetailtbWhereInput | changepcdetailtbWhereInput[]
    OR?: changepcdetailtbWhereInput[]
    NOT?: changepcdetailtbWhereInput | changepcdetailtbWhereInput[]
    ChangePCDetailId?: IntFilter<"changepcdetailtb"> | number
    VoucherId?: IntFilter<"changepcdetailtb"> | number
    FromMachineId?: IntFilter<"changepcdetailtb"> | number
    ToMachineId?: IntFilter<"changepcdetailtb"> | number
    TimeUsed?: IntFilter<"changepcdetailtb"> | number
    MoneyUsed?: IntFilter<"changepcdetailtb"> | number
    SessionId?: IntFilter<"changepcdetailtb"> | number
    ChangePCDate?: DateTimeFilter<"changepcdetailtb"> | Date | string
    ChangePCTime?: DateTimeFilter<"changepcdetailtb"> | Date | string
    BeginDateTime?: DateTimeFilter<"changepcdetailtb"> | Date | string
    LogNote?: StringFilter<"changepcdetailtb"> | string
    MachineName?: StringFilter<"changepcdetailtb"> | string
    LogType?: IntFilter<"changepcdetailtb"> | number
  }

  export type changepcdetailtbOrderByWithRelationInput = {
    ChangePCDetailId?: SortOrder
    VoucherId?: SortOrder
    FromMachineId?: SortOrder
    ToMachineId?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    SessionId?: SortOrder
    ChangePCDate?: SortOrder
    ChangePCTime?: SortOrder
    BeginDateTime?: SortOrder
    LogNote?: SortOrder
    MachineName?: SortOrder
    LogType?: SortOrder
  }

  export type changepcdetailtbWhereUniqueInput = Prisma.AtLeast<{
    ChangePCDetailId?: number
    AND?: changepcdetailtbWhereInput | changepcdetailtbWhereInput[]
    OR?: changepcdetailtbWhereInput[]
    NOT?: changepcdetailtbWhereInput | changepcdetailtbWhereInput[]
    VoucherId?: IntFilter<"changepcdetailtb"> | number
    FromMachineId?: IntFilter<"changepcdetailtb"> | number
    ToMachineId?: IntFilter<"changepcdetailtb"> | number
    TimeUsed?: IntFilter<"changepcdetailtb"> | number
    MoneyUsed?: IntFilter<"changepcdetailtb"> | number
    SessionId?: IntFilter<"changepcdetailtb"> | number
    ChangePCDate?: DateTimeFilter<"changepcdetailtb"> | Date | string
    ChangePCTime?: DateTimeFilter<"changepcdetailtb"> | Date | string
    BeginDateTime?: DateTimeFilter<"changepcdetailtb"> | Date | string
    LogNote?: StringFilter<"changepcdetailtb"> | string
    MachineName?: StringFilter<"changepcdetailtb"> | string
    LogType?: IntFilter<"changepcdetailtb"> | number
  }, "ChangePCDetailId">

  export type changepcdetailtbOrderByWithAggregationInput = {
    ChangePCDetailId?: SortOrder
    VoucherId?: SortOrder
    FromMachineId?: SortOrder
    ToMachineId?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    SessionId?: SortOrder
    ChangePCDate?: SortOrder
    ChangePCTime?: SortOrder
    BeginDateTime?: SortOrder
    LogNote?: SortOrder
    MachineName?: SortOrder
    LogType?: SortOrder
    _count?: changepcdetailtbCountOrderByAggregateInput
    _avg?: changepcdetailtbAvgOrderByAggregateInput
    _max?: changepcdetailtbMaxOrderByAggregateInput
    _min?: changepcdetailtbMinOrderByAggregateInput
    _sum?: changepcdetailtbSumOrderByAggregateInput
  }

  export type changepcdetailtbScalarWhereWithAggregatesInput = {
    AND?: changepcdetailtbScalarWhereWithAggregatesInput | changepcdetailtbScalarWhereWithAggregatesInput[]
    OR?: changepcdetailtbScalarWhereWithAggregatesInput[]
    NOT?: changepcdetailtbScalarWhereWithAggregatesInput | changepcdetailtbScalarWhereWithAggregatesInput[]
    ChangePCDetailId?: IntWithAggregatesFilter<"changepcdetailtb"> | number
    VoucherId?: IntWithAggregatesFilter<"changepcdetailtb"> | number
    FromMachineId?: IntWithAggregatesFilter<"changepcdetailtb"> | number
    ToMachineId?: IntWithAggregatesFilter<"changepcdetailtb"> | number
    TimeUsed?: IntWithAggregatesFilter<"changepcdetailtb"> | number
    MoneyUsed?: IntWithAggregatesFilter<"changepcdetailtb"> | number
    SessionId?: IntWithAggregatesFilter<"changepcdetailtb"> | number
    ChangePCDate?: DateTimeWithAggregatesFilter<"changepcdetailtb"> | Date | string
    ChangePCTime?: DateTimeWithAggregatesFilter<"changepcdetailtb"> | Date | string
    BeginDateTime?: DateTimeWithAggregatesFilter<"changepcdetailtb"> | Date | string
    LogNote?: StringWithAggregatesFilter<"changepcdetailtb"> | string
    MachineName?: StringWithAggregatesFilter<"changepcdetailtb"> | string
    LogType?: IntWithAggregatesFilter<"changepcdetailtb"> | number
  }

  export type clientatbWhereInput = {
    AND?: clientatbWhereInput | clientatbWhereInput[]
    OR?: clientatbWhereInput[]
    NOT?: clientatbWhereInput | clientatbWhereInput[]
    ID?: IntFilter<"clientatb"> | number
    PubID?: IntFilter<"clientatb"> | number
    AID?: IntFilter<"clientatb"> | number
    DateA?: StringFilter<"clientatb"> | string
    STime?: IntFilter<"clientatb"> | number
    ETime?: IntFilter<"clientatb"> | number
    FName?: StringFilter<"clientatb"> | string
    FLink?: StringFilter<"clientatb"> | string
    Area?: StringFilter<"clientatb"> | string
    Panel?: IntFilter<"clientatb"> | number
    Row?: IntFilter<"clientatb"> | number
    Col?: IntFilter<"clientatb"> | number
    Method?: StringFilter<"clientatb"> | string
    CountS?: IntFilter<"clientatb"> | number
    CountC?: IntFilter<"clientatb"> | number
    RecordDate?: StringFilter<"clientatb"> | string
  }

  export type clientatbOrderByWithRelationInput = {
    ID?: SortOrder
    PubID?: SortOrder
    AID?: SortOrder
    DateA?: SortOrder
    STime?: SortOrder
    ETime?: SortOrder
    FName?: SortOrder
    FLink?: SortOrder
    Area?: SortOrder
    Panel?: SortOrder
    Row?: SortOrder
    Col?: SortOrder
    Method?: SortOrder
    CountS?: SortOrder
    CountC?: SortOrder
    RecordDate?: SortOrder
  }

  export type clientatbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: clientatbWhereInput | clientatbWhereInput[]
    OR?: clientatbWhereInput[]
    NOT?: clientatbWhereInput | clientatbWhereInput[]
    PubID?: IntFilter<"clientatb"> | number
    AID?: IntFilter<"clientatb"> | number
    DateA?: StringFilter<"clientatb"> | string
    STime?: IntFilter<"clientatb"> | number
    ETime?: IntFilter<"clientatb"> | number
    FName?: StringFilter<"clientatb"> | string
    FLink?: StringFilter<"clientatb"> | string
    Area?: StringFilter<"clientatb"> | string
    Panel?: IntFilter<"clientatb"> | number
    Row?: IntFilter<"clientatb"> | number
    Col?: IntFilter<"clientatb"> | number
    Method?: StringFilter<"clientatb"> | string
    CountS?: IntFilter<"clientatb"> | number
    CountC?: IntFilter<"clientatb"> | number
    RecordDate?: StringFilter<"clientatb"> | string
  }, "ID">

  export type clientatbOrderByWithAggregationInput = {
    ID?: SortOrder
    PubID?: SortOrder
    AID?: SortOrder
    DateA?: SortOrder
    STime?: SortOrder
    ETime?: SortOrder
    FName?: SortOrder
    FLink?: SortOrder
    Area?: SortOrder
    Panel?: SortOrder
    Row?: SortOrder
    Col?: SortOrder
    Method?: SortOrder
    CountS?: SortOrder
    CountC?: SortOrder
    RecordDate?: SortOrder
    _count?: clientatbCountOrderByAggregateInput
    _avg?: clientatbAvgOrderByAggregateInput
    _max?: clientatbMaxOrderByAggregateInput
    _min?: clientatbMinOrderByAggregateInput
    _sum?: clientatbSumOrderByAggregateInput
  }

  export type clientatbScalarWhereWithAggregatesInput = {
    AND?: clientatbScalarWhereWithAggregatesInput | clientatbScalarWhereWithAggregatesInput[]
    OR?: clientatbScalarWhereWithAggregatesInput[]
    NOT?: clientatbScalarWhereWithAggregatesInput | clientatbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"clientatb"> | number
    PubID?: IntWithAggregatesFilter<"clientatb"> | number
    AID?: IntWithAggregatesFilter<"clientatb"> | number
    DateA?: StringWithAggregatesFilter<"clientatb"> | string
    STime?: IntWithAggregatesFilter<"clientatb"> | number
    ETime?: IntWithAggregatesFilter<"clientatb"> | number
    FName?: StringWithAggregatesFilter<"clientatb"> | string
    FLink?: StringWithAggregatesFilter<"clientatb"> | string
    Area?: StringWithAggregatesFilter<"clientatb"> | string
    Panel?: IntWithAggregatesFilter<"clientatb"> | number
    Row?: IntWithAggregatesFilter<"clientatb"> | number
    Col?: IntWithAggregatesFilter<"clientatb"> | number
    Method?: StringWithAggregatesFilter<"clientatb"> | string
    CountS?: IntWithAggregatesFilter<"clientatb"> | number
    CountC?: IntWithAggregatesFilter<"clientatb"> | number
    RecordDate?: StringWithAggregatesFilter<"clientatb"> | string
  }

  export type clientsystbWhereInput = {
    AND?: clientsystbWhereInput | clientsystbWhereInput[]
    OR?: clientsystbWhereInput[]
    NOT?: clientsystbWhereInput | clientsystbWhereInput[]
    ID?: IntFilter<"clientsystb"> | number
    UserId?: IntFilter<"clientsystb"> | number
    MAC?: StringFilter<"clientsystb"> | string
    CPU?: StringFilter<"clientsystb"> | string
    RAM?: StringFilter<"clientsystb"> | string
    HD?: StringFilter<"clientsystb"> | string
    OS?: StringFilter<"clientsystb"> | string
    CardName?: StringFilter<"clientsystb"> | string
    ChipType?: StringFilter<"clientsystb"> | string
    VGAMem?: StringFilter<"clientsystb"> | string
    NIC?: StringFilter<"clientsystb"> | string
    FreeSpace?: StringFilter<"clientsystb"> | string
    CPName?: StringFilter<"clientsystb"> | string
    Active?: IntFilter<"clientsystb"> | number
    NTFS?: StringFilter<"clientsystb"> | string
    FAT?: StringFilter<"clientsystb"> | string
    Mainboard?: StringFilter<"clientsystb"> | string
    IP?: StringFilter<"clientsystb"> | string
    LAN?: StringFilter<"clientsystb"> | string
    RamFree?: StringFilter<"clientsystb"> | string
    PageFile?: StringFilter<"clientsystb"> | string
    TempCPU?: StringFilter<"clientsystb"> | string
    LoadCPU?: StringFilter<"clientsystb"> | string
    TempGPU?: StringFilter<"clientsystb"> | string
    LoadGPU?: StringFilter<"clientsystb"> | string
    LastUpdate?: DateTimeFilter<"clientsystb"> | Date | string
    PCName?: StringNullableFilter<"clientsystb"> | string | null
    NetInfo?: StringNullableFilter<"clientsystb"> | string | null
  }

  export type clientsystbOrderByWithRelationInput = {
    ID?: SortOrder
    UserId?: SortOrder
    MAC?: SortOrder
    CPU?: SortOrder
    RAM?: SortOrder
    HD?: SortOrder
    OS?: SortOrder
    CardName?: SortOrder
    ChipType?: SortOrder
    VGAMem?: SortOrder
    NIC?: SortOrder
    FreeSpace?: SortOrder
    CPName?: SortOrder
    Active?: SortOrder
    NTFS?: SortOrder
    FAT?: SortOrder
    Mainboard?: SortOrder
    IP?: SortOrder
    LAN?: SortOrder
    RamFree?: SortOrder
    PageFile?: SortOrder
    TempCPU?: SortOrder
    LoadCPU?: SortOrder
    TempGPU?: SortOrder
    LoadGPU?: SortOrder
    LastUpdate?: SortOrder
    PCName?: SortOrderInput | SortOrder
    NetInfo?: SortOrderInput | SortOrder
  }

  export type clientsystbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    PCName?: string
    AND?: clientsystbWhereInput | clientsystbWhereInput[]
    OR?: clientsystbWhereInput[]
    NOT?: clientsystbWhereInput | clientsystbWhereInput[]
    UserId?: IntFilter<"clientsystb"> | number
    MAC?: StringFilter<"clientsystb"> | string
    CPU?: StringFilter<"clientsystb"> | string
    RAM?: StringFilter<"clientsystb"> | string
    HD?: StringFilter<"clientsystb"> | string
    OS?: StringFilter<"clientsystb"> | string
    CardName?: StringFilter<"clientsystb"> | string
    ChipType?: StringFilter<"clientsystb"> | string
    VGAMem?: StringFilter<"clientsystb"> | string
    NIC?: StringFilter<"clientsystb"> | string
    FreeSpace?: StringFilter<"clientsystb"> | string
    CPName?: StringFilter<"clientsystb"> | string
    Active?: IntFilter<"clientsystb"> | number
    NTFS?: StringFilter<"clientsystb"> | string
    FAT?: StringFilter<"clientsystb"> | string
    Mainboard?: StringFilter<"clientsystb"> | string
    IP?: StringFilter<"clientsystb"> | string
    LAN?: StringFilter<"clientsystb"> | string
    RamFree?: StringFilter<"clientsystb"> | string
    PageFile?: StringFilter<"clientsystb"> | string
    TempCPU?: StringFilter<"clientsystb"> | string
    LoadCPU?: StringFilter<"clientsystb"> | string
    TempGPU?: StringFilter<"clientsystb"> | string
    LoadGPU?: StringFilter<"clientsystb"> | string
    LastUpdate?: DateTimeFilter<"clientsystb"> | Date | string
    NetInfo?: StringNullableFilter<"clientsystb"> | string | null
  }, "ID" | "PCName">

  export type clientsystbOrderByWithAggregationInput = {
    ID?: SortOrder
    UserId?: SortOrder
    MAC?: SortOrder
    CPU?: SortOrder
    RAM?: SortOrder
    HD?: SortOrder
    OS?: SortOrder
    CardName?: SortOrder
    ChipType?: SortOrder
    VGAMem?: SortOrder
    NIC?: SortOrder
    FreeSpace?: SortOrder
    CPName?: SortOrder
    Active?: SortOrder
    NTFS?: SortOrder
    FAT?: SortOrder
    Mainboard?: SortOrder
    IP?: SortOrder
    LAN?: SortOrder
    RamFree?: SortOrder
    PageFile?: SortOrder
    TempCPU?: SortOrder
    LoadCPU?: SortOrder
    TempGPU?: SortOrder
    LoadGPU?: SortOrder
    LastUpdate?: SortOrder
    PCName?: SortOrderInput | SortOrder
    NetInfo?: SortOrderInput | SortOrder
    _count?: clientsystbCountOrderByAggregateInput
    _avg?: clientsystbAvgOrderByAggregateInput
    _max?: clientsystbMaxOrderByAggregateInput
    _min?: clientsystbMinOrderByAggregateInput
    _sum?: clientsystbSumOrderByAggregateInput
  }

  export type clientsystbScalarWhereWithAggregatesInput = {
    AND?: clientsystbScalarWhereWithAggregatesInput | clientsystbScalarWhereWithAggregatesInput[]
    OR?: clientsystbScalarWhereWithAggregatesInput[]
    NOT?: clientsystbScalarWhereWithAggregatesInput | clientsystbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"clientsystb"> | number
    UserId?: IntWithAggregatesFilter<"clientsystb"> | number
    MAC?: StringWithAggregatesFilter<"clientsystb"> | string
    CPU?: StringWithAggregatesFilter<"clientsystb"> | string
    RAM?: StringWithAggregatesFilter<"clientsystb"> | string
    HD?: StringWithAggregatesFilter<"clientsystb"> | string
    OS?: StringWithAggregatesFilter<"clientsystb"> | string
    CardName?: StringWithAggregatesFilter<"clientsystb"> | string
    ChipType?: StringWithAggregatesFilter<"clientsystb"> | string
    VGAMem?: StringWithAggregatesFilter<"clientsystb"> | string
    NIC?: StringWithAggregatesFilter<"clientsystb"> | string
    FreeSpace?: StringWithAggregatesFilter<"clientsystb"> | string
    CPName?: StringWithAggregatesFilter<"clientsystb"> | string
    Active?: IntWithAggregatesFilter<"clientsystb"> | number
    NTFS?: StringWithAggregatesFilter<"clientsystb"> | string
    FAT?: StringWithAggregatesFilter<"clientsystb"> | string
    Mainboard?: StringWithAggregatesFilter<"clientsystb"> | string
    IP?: StringWithAggregatesFilter<"clientsystb"> | string
    LAN?: StringWithAggregatesFilter<"clientsystb"> | string
    RamFree?: StringWithAggregatesFilter<"clientsystb"> | string
    PageFile?: StringWithAggregatesFilter<"clientsystb"> | string
    TempCPU?: StringWithAggregatesFilter<"clientsystb"> | string
    LoadCPU?: StringWithAggregatesFilter<"clientsystb"> | string
    TempGPU?: StringWithAggregatesFilter<"clientsystb"> | string
    LoadGPU?: StringWithAggregatesFilter<"clientsystb"> | string
    LastUpdate?: DateTimeWithAggregatesFilter<"clientsystb"> | Date | string
    PCName?: StringNullableWithAggregatesFilter<"clientsystb"> | string | null
    NetInfo?: StringNullableWithAggregatesFilter<"clientsystb"> | string | null
  }

  export type combodetailtbWhereInput = {
    AND?: combodetailtbWhereInput | combodetailtbWhereInput[]
    OR?: combodetailtbWhereInput[]
    NOT?: combodetailtbWhereInput | combodetailtbWhereInput[]
    ComboDetailID?: IntFilter<"combodetailtb"> | number
    UserID?: IntFilter<"combodetailtb"> | number
    ComboID?: IntFilter<"combodetailtb"> | number
    VoucherID?: IntFilter<"combodetailtb"> | number
    Accept?: IntFilter<"combodetailtb"> | number
    CreateDate?: DateTimeFilter<"combodetailtb"> | Date | string
    CreateTime?: DateTimeFilter<"combodetailtb"> | Date | string
    FromDate?: DateTimeFilter<"combodetailtb"> | Date | string
    FromTime?: DateTimeFilter<"combodetailtb"> | Date | string
    ToDate?: DateTimeFilter<"combodetailtb"> | Date | string
    ToTime?: DateTimeFilter<"combodetailtb"> | Date | string
    Zone?: StringNullableFilter<"combodetailtb"> | string | null
    LoginTime?: DateTimeFilter<"combodetailtb"> | Date | string
    Ownerid?: BigIntNullableFilter<"combodetailtb"> | bigint | number | null
  }

  export type combodetailtbOrderByWithRelationInput = {
    ComboDetailID?: SortOrder
    UserID?: SortOrder
    ComboID?: SortOrder
    VoucherID?: SortOrder
    Accept?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    ToDate?: SortOrder
    ToTime?: SortOrder
    Zone?: SortOrderInput | SortOrder
    LoginTime?: SortOrder
    Ownerid?: SortOrderInput | SortOrder
  }

  export type combodetailtbWhereUniqueInput = Prisma.AtLeast<{
    ComboDetailID?: number
    AND?: combodetailtbWhereInput | combodetailtbWhereInput[]
    OR?: combodetailtbWhereInput[]
    NOT?: combodetailtbWhereInput | combodetailtbWhereInput[]
    UserID?: IntFilter<"combodetailtb"> | number
    ComboID?: IntFilter<"combodetailtb"> | number
    VoucherID?: IntFilter<"combodetailtb"> | number
    Accept?: IntFilter<"combodetailtb"> | number
    CreateDate?: DateTimeFilter<"combodetailtb"> | Date | string
    CreateTime?: DateTimeFilter<"combodetailtb"> | Date | string
    FromDate?: DateTimeFilter<"combodetailtb"> | Date | string
    FromTime?: DateTimeFilter<"combodetailtb"> | Date | string
    ToDate?: DateTimeFilter<"combodetailtb"> | Date | string
    ToTime?: DateTimeFilter<"combodetailtb"> | Date | string
    Zone?: StringNullableFilter<"combodetailtb"> | string | null
    LoginTime?: DateTimeFilter<"combodetailtb"> | Date | string
    Ownerid?: BigIntNullableFilter<"combodetailtb"> | bigint | number | null
  }, "ComboDetailID">

  export type combodetailtbOrderByWithAggregationInput = {
    ComboDetailID?: SortOrder
    UserID?: SortOrder
    ComboID?: SortOrder
    VoucherID?: SortOrder
    Accept?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    ToDate?: SortOrder
    ToTime?: SortOrder
    Zone?: SortOrderInput | SortOrder
    LoginTime?: SortOrder
    Ownerid?: SortOrderInput | SortOrder
    _count?: combodetailtbCountOrderByAggregateInput
    _avg?: combodetailtbAvgOrderByAggregateInput
    _max?: combodetailtbMaxOrderByAggregateInput
    _min?: combodetailtbMinOrderByAggregateInput
    _sum?: combodetailtbSumOrderByAggregateInput
  }

  export type combodetailtbScalarWhereWithAggregatesInput = {
    AND?: combodetailtbScalarWhereWithAggregatesInput | combodetailtbScalarWhereWithAggregatesInput[]
    OR?: combodetailtbScalarWhereWithAggregatesInput[]
    NOT?: combodetailtbScalarWhereWithAggregatesInput | combodetailtbScalarWhereWithAggregatesInput[]
    ComboDetailID?: IntWithAggregatesFilter<"combodetailtb"> | number
    UserID?: IntWithAggregatesFilter<"combodetailtb"> | number
    ComboID?: IntWithAggregatesFilter<"combodetailtb"> | number
    VoucherID?: IntWithAggregatesFilter<"combodetailtb"> | number
    Accept?: IntWithAggregatesFilter<"combodetailtb"> | number
    CreateDate?: DateTimeWithAggregatesFilter<"combodetailtb"> | Date | string
    CreateTime?: DateTimeWithAggregatesFilter<"combodetailtb"> | Date | string
    FromDate?: DateTimeWithAggregatesFilter<"combodetailtb"> | Date | string
    FromTime?: DateTimeWithAggregatesFilter<"combodetailtb"> | Date | string
    ToDate?: DateTimeWithAggregatesFilter<"combodetailtb"> | Date | string
    ToTime?: DateTimeWithAggregatesFilter<"combodetailtb"> | Date | string
    Zone?: StringNullableWithAggregatesFilter<"combodetailtb"> | string | null
    LoginTime?: DateTimeWithAggregatesFilter<"combodetailtb"> | Date | string
    Ownerid?: BigIntNullableWithAggregatesFilter<"combodetailtb"> | bigint | number | null
  }

  export type combodonatetbWhereInput = {
    AND?: combodonatetbWhereInput | combodonatetbWhereInput[]
    OR?: combodonatetbWhereInput[]
    NOT?: combodonatetbWhereInput | combodonatetbWhereInput[]
    ComboDonateID?: IntFilter<"combodonatetb"> | number
    ComboID?: IntFilter<"combodonatetb"> | number
    ServiceID?: IntFilter<"combodonatetb"> | number
    Quantity?: IntFilter<"combodonatetb"> | number
  }

  export type combodonatetbOrderByWithRelationInput = {
    ComboDonateID?: SortOrder
    ComboID?: SortOrder
    ServiceID?: SortOrder
    Quantity?: SortOrder
  }

  export type combodonatetbWhereUniqueInput = Prisma.AtLeast<{
    ComboDonateID?: number
    AND?: combodonatetbWhereInput | combodonatetbWhereInput[]
    OR?: combodonatetbWhereInput[]
    NOT?: combodonatetbWhereInput | combodonatetbWhereInput[]
    ComboID?: IntFilter<"combodonatetb"> | number
    ServiceID?: IntFilter<"combodonatetb"> | number
    Quantity?: IntFilter<"combodonatetb"> | number
  }, "ComboDonateID">

  export type combodonatetbOrderByWithAggregationInput = {
    ComboDonateID?: SortOrder
    ComboID?: SortOrder
    ServiceID?: SortOrder
    Quantity?: SortOrder
    _count?: combodonatetbCountOrderByAggregateInput
    _avg?: combodonatetbAvgOrderByAggregateInput
    _max?: combodonatetbMaxOrderByAggregateInput
    _min?: combodonatetbMinOrderByAggregateInput
    _sum?: combodonatetbSumOrderByAggregateInput
  }

  export type combodonatetbScalarWhereWithAggregatesInput = {
    AND?: combodonatetbScalarWhereWithAggregatesInput | combodonatetbScalarWhereWithAggregatesInput[]
    OR?: combodonatetbScalarWhereWithAggregatesInput[]
    NOT?: combodonatetbScalarWhereWithAggregatesInput | combodonatetbScalarWhereWithAggregatesInput[]
    ComboDonateID?: IntWithAggregatesFilter<"combodonatetb"> | number
    ComboID?: IntWithAggregatesFilter<"combodonatetb"> | number
    ServiceID?: IntWithAggregatesFilter<"combodonatetb"> | number
    Quantity?: IntWithAggregatesFilter<"combodonatetb"> | number
  }

  export type combotbWhereInput = {
    AND?: combotbWhereInput | combotbWhereInput[]
    OR?: combotbWhereInput[]
    NOT?: combotbWhereInput | combotbWhereInput[]
    ComboID?: IntFilter<"combotb"> | number
    Name?: StringFilter<"combotb"> | string
    Price?: DecimalFilter<"combotb"> | Decimal | DecimalJsLike | number | string
    CreateDate?: DateTimeFilter<"combotb"> | Date | string
    CreateTime?: DateTimeFilter<"combotb"> | Date | string
    Type?: IntFilter<"combotb"> | number
    PreAlias?: StringFilter<"combotb"> | string
    IsStatus?: IntFilter<"combotb"> | number
    OrderPosition?: IntFilter<"combotb"> | number
    NumOfDay?: IntFilter<"combotb"> | number
  }

  export type combotbOrderByWithRelationInput = {
    ComboID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    Type?: SortOrder
    PreAlias?: SortOrder
    IsStatus?: SortOrder
    OrderPosition?: SortOrder
    NumOfDay?: SortOrder
  }

  export type combotbWhereUniqueInput = Prisma.AtLeast<{
    ComboID?: number
    AND?: combotbWhereInput | combotbWhereInput[]
    OR?: combotbWhereInput[]
    NOT?: combotbWhereInput | combotbWhereInput[]
    Name?: StringFilter<"combotb"> | string
    Price?: DecimalFilter<"combotb"> | Decimal | DecimalJsLike | number | string
    CreateDate?: DateTimeFilter<"combotb"> | Date | string
    CreateTime?: DateTimeFilter<"combotb"> | Date | string
    Type?: IntFilter<"combotb"> | number
    PreAlias?: StringFilter<"combotb"> | string
    IsStatus?: IntFilter<"combotb"> | number
    OrderPosition?: IntFilter<"combotb"> | number
    NumOfDay?: IntFilter<"combotb"> | number
  }, "ComboID">

  export type combotbOrderByWithAggregationInput = {
    ComboID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    Type?: SortOrder
    PreAlias?: SortOrder
    IsStatus?: SortOrder
    OrderPosition?: SortOrder
    NumOfDay?: SortOrder
    _count?: combotbCountOrderByAggregateInput
    _avg?: combotbAvgOrderByAggregateInput
    _max?: combotbMaxOrderByAggregateInput
    _min?: combotbMinOrderByAggregateInput
    _sum?: combotbSumOrderByAggregateInput
  }

  export type combotbScalarWhereWithAggregatesInput = {
    AND?: combotbScalarWhereWithAggregatesInput | combotbScalarWhereWithAggregatesInput[]
    OR?: combotbScalarWhereWithAggregatesInput[]
    NOT?: combotbScalarWhereWithAggregatesInput | combotbScalarWhereWithAggregatesInput[]
    ComboID?: IntWithAggregatesFilter<"combotb"> | number
    Name?: StringWithAggregatesFilter<"combotb"> | string
    Price?: DecimalWithAggregatesFilter<"combotb"> | Decimal | DecimalJsLike | number | string
    CreateDate?: DateTimeWithAggregatesFilter<"combotb"> | Date | string
    CreateTime?: DateTimeWithAggregatesFilter<"combotb"> | Date | string
    Type?: IntWithAggregatesFilter<"combotb"> | number
    PreAlias?: StringWithAggregatesFilter<"combotb"> | string
    IsStatus?: IntWithAggregatesFilter<"combotb"> | number
    OrderPosition?: IntWithAggregatesFilter<"combotb"> | number
    NumOfDay?: IntWithAggregatesFilter<"combotb"> | number
  }

  export type combousagetbWhereInput = {
    AND?: combousagetbWhereInput | combousagetbWhereInput[]
    OR?: combousagetbWhereInput[]
    NOT?: combousagetbWhereInput | combousagetbWhereInput[]
    ComboUsageID?: IntFilter<"combousagetb"> | number
    ComboID?: IntFilter<"combousagetb"> | number
    MachineGroupID?: IntFilter<"combousagetb"> | number
    FromTime?: IntFilter<"combousagetb"> | number
    ToTime?: IntFilter<"combousagetb"> | number
  }

  export type combousagetbOrderByWithRelationInput = {
    ComboUsageID?: SortOrder
    ComboID?: SortOrder
    MachineGroupID?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
  }

  export type combousagetbWhereUniqueInput = Prisma.AtLeast<{
    ComboUsageID?: number
    AND?: combousagetbWhereInput | combousagetbWhereInput[]
    OR?: combousagetbWhereInput[]
    NOT?: combousagetbWhereInput | combousagetbWhereInput[]
    ComboID?: IntFilter<"combousagetb"> | number
    MachineGroupID?: IntFilter<"combousagetb"> | number
    FromTime?: IntFilter<"combousagetb"> | number
    ToTime?: IntFilter<"combousagetb"> | number
  }, "ComboUsageID">

  export type combousagetbOrderByWithAggregationInput = {
    ComboUsageID?: SortOrder
    ComboID?: SortOrder
    MachineGroupID?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
    _count?: combousagetbCountOrderByAggregateInput
    _avg?: combousagetbAvgOrderByAggregateInput
    _max?: combousagetbMaxOrderByAggregateInput
    _min?: combousagetbMinOrderByAggregateInput
    _sum?: combousagetbSumOrderByAggregateInput
  }

  export type combousagetbScalarWhereWithAggregatesInput = {
    AND?: combousagetbScalarWhereWithAggregatesInput | combousagetbScalarWhereWithAggregatesInput[]
    OR?: combousagetbScalarWhereWithAggregatesInput[]
    NOT?: combousagetbScalarWhereWithAggregatesInput | combousagetbScalarWhereWithAggregatesInput[]
    ComboUsageID?: IntWithAggregatesFilter<"combousagetb"> | number
    ComboID?: IntWithAggregatesFilter<"combousagetb"> | number
    MachineGroupID?: IntWithAggregatesFilter<"combousagetb"> | number
    FromTime?: IntWithAggregatesFilter<"combousagetb"> | number
    ToTime?: IntWithAggregatesFilter<"combousagetb"> | number
  }

  export type convertunittbWhereInput = {
    AND?: convertunittbWhereInput | convertunittbWhereInput[]
    OR?: convertunittbWhereInput[]
    NOT?: convertunittbWhereInput | convertunittbWhereInput[]
    ID?: IntFilter<"convertunittb"> | number
    ServiceID?: IntFilter<"convertunittb"> | number
    UnitRootID?: IntFilter<"convertunittb"> | number
    ConvertUnitID?: IntFilter<"convertunittb"> | number
    Quantity?: IntFilter<"convertunittb"> | number
  }

  export type convertunittbOrderByWithRelationInput = {
    ID?: SortOrder
    ServiceID?: SortOrder
    UnitRootID?: SortOrder
    ConvertUnitID?: SortOrder
    Quantity?: SortOrder
  }

  export type convertunittbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: convertunittbWhereInput | convertunittbWhereInput[]
    OR?: convertunittbWhereInput[]
    NOT?: convertunittbWhereInput | convertunittbWhereInput[]
    ServiceID?: IntFilter<"convertunittb"> | number
    UnitRootID?: IntFilter<"convertunittb"> | number
    ConvertUnitID?: IntFilter<"convertunittb"> | number
    Quantity?: IntFilter<"convertunittb"> | number
  }, "ID">

  export type convertunittbOrderByWithAggregationInput = {
    ID?: SortOrder
    ServiceID?: SortOrder
    UnitRootID?: SortOrder
    ConvertUnitID?: SortOrder
    Quantity?: SortOrder
    _count?: convertunittbCountOrderByAggregateInput
    _avg?: convertunittbAvgOrderByAggregateInput
    _max?: convertunittbMaxOrderByAggregateInput
    _min?: convertunittbMinOrderByAggregateInput
    _sum?: convertunittbSumOrderByAggregateInput
  }

  export type convertunittbScalarWhereWithAggregatesInput = {
    AND?: convertunittbScalarWhereWithAggregatesInput | convertunittbScalarWhereWithAggregatesInput[]
    OR?: convertunittbScalarWhereWithAggregatesInput[]
    NOT?: convertunittbScalarWhereWithAggregatesInput | convertunittbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"convertunittb"> | number
    ServiceID?: IntWithAggregatesFilter<"convertunittb"> | number
    UnitRootID?: IntWithAggregatesFilter<"convertunittb"> | number
    ConvertUnitID?: IntWithAggregatesFilter<"convertunittb"> | number
    Quantity?: IntWithAggregatesFilter<"convertunittb"> | number
  }

  export type dptbWhereInput = {
    AND?: dptbWhereInput | dptbWhereInput[]
    OR?: dptbWhereInput[]
    NOT?: dptbWhereInput | dptbWhereInput[]
    ComputerName?: StringFilter<"dptb"> | string
    Status?: IntFilter<"dptb"> | number
    Type?: IntFilter<"dptb"> | number
    Version?: StringFilter<"dptb"> | string
    LastUpdate?: DateTimeFilter<"dptb"> | Date | string
    FNetVersion?: StringFilter<"dptb"> | string
    FNetReleaseDate?: DateTimeFilter<"dptb"> | Date | string
    DPB?: StringFilter<"dptb"> | string
  }

  export type dptbOrderByWithRelationInput = {
    ComputerName?: SortOrder
    Status?: SortOrder
    Type?: SortOrder
    Version?: SortOrder
    LastUpdate?: SortOrder
    FNetVersion?: SortOrder
    FNetReleaseDate?: SortOrder
    DPB?: SortOrder
  }

  export type dptbWhereUniqueInput = Prisma.AtLeast<{
    ComputerName?: string
    AND?: dptbWhereInput | dptbWhereInput[]
    OR?: dptbWhereInput[]
    NOT?: dptbWhereInput | dptbWhereInput[]
    Status?: IntFilter<"dptb"> | number
    Type?: IntFilter<"dptb"> | number
    Version?: StringFilter<"dptb"> | string
    LastUpdate?: DateTimeFilter<"dptb"> | Date | string
    FNetVersion?: StringFilter<"dptb"> | string
    FNetReleaseDate?: DateTimeFilter<"dptb"> | Date | string
    DPB?: StringFilter<"dptb"> | string
  }, "ComputerName">

  export type dptbOrderByWithAggregationInput = {
    ComputerName?: SortOrder
    Status?: SortOrder
    Type?: SortOrder
    Version?: SortOrder
    LastUpdate?: SortOrder
    FNetVersion?: SortOrder
    FNetReleaseDate?: SortOrder
    DPB?: SortOrder
    _count?: dptbCountOrderByAggregateInput
    _avg?: dptbAvgOrderByAggregateInput
    _max?: dptbMaxOrderByAggregateInput
    _min?: dptbMinOrderByAggregateInput
    _sum?: dptbSumOrderByAggregateInput
  }

  export type dptbScalarWhereWithAggregatesInput = {
    AND?: dptbScalarWhereWithAggregatesInput | dptbScalarWhereWithAggregatesInput[]
    OR?: dptbScalarWhereWithAggregatesInput[]
    NOT?: dptbScalarWhereWithAggregatesInput | dptbScalarWhereWithAggregatesInput[]
    ComputerName?: StringWithAggregatesFilter<"dptb"> | string
    Status?: IntWithAggregatesFilter<"dptb"> | number
    Type?: IntWithAggregatesFilter<"dptb"> | number
    Version?: StringWithAggregatesFilter<"dptb"> | string
    LastUpdate?: DateTimeWithAggregatesFilter<"dptb"> | Date | string
    FNetVersion?: StringWithAggregatesFilter<"dptb"> | string
    FNetReleaseDate?: DateTimeWithAggregatesFilter<"dptb"> | Date | string
    DPB?: StringWithAggregatesFilter<"dptb"> | string
  }

  export type freetimedetailtbWhereInput = {
    AND?: freetimedetailtbWhereInput | freetimedetailtbWhereInput[]
    OR?: freetimedetailtbWhereInput[]
    NOT?: freetimedetailtbWhereInput | freetimedetailtbWhereInput[]
    FreeTimeDetailId?: IntFilter<"freetimedetailtb"> | number
    UserId?: IntFilter<"freetimedetailtb"> | number
    FreeTime?: IntFilter<"freetimedetailtb"> | number
    FreeMoney?: IntFilter<"freetimedetailtb"> | number
    Type?: IntFilter<"freetimedetailtb"> | number
    RecordDate?: DateTimeFilter<"freetimedetailtb"> | Date | string
    VoucherId?: IntFilter<"freetimedetailtb"> | number
  }

  export type freetimedetailtbOrderByWithRelationInput = {
    FreeTimeDetailId?: SortOrder
    UserId?: SortOrder
    FreeTime?: SortOrder
    FreeMoney?: SortOrder
    Type?: SortOrder
    RecordDate?: SortOrder
    VoucherId?: SortOrder
  }

  export type freetimedetailtbWhereUniqueInput = Prisma.AtLeast<{
    FreeTimeDetailId?: number
    AND?: freetimedetailtbWhereInput | freetimedetailtbWhereInput[]
    OR?: freetimedetailtbWhereInput[]
    NOT?: freetimedetailtbWhereInput | freetimedetailtbWhereInput[]
    UserId?: IntFilter<"freetimedetailtb"> | number
    FreeTime?: IntFilter<"freetimedetailtb"> | number
    FreeMoney?: IntFilter<"freetimedetailtb"> | number
    Type?: IntFilter<"freetimedetailtb"> | number
    RecordDate?: DateTimeFilter<"freetimedetailtb"> | Date | string
    VoucherId?: IntFilter<"freetimedetailtb"> | number
  }, "FreeTimeDetailId">

  export type freetimedetailtbOrderByWithAggregationInput = {
    FreeTimeDetailId?: SortOrder
    UserId?: SortOrder
    FreeTime?: SortOrder
    FreeMoney?: SortOrder
    Type?: SortOrder
    RecordDate?: SortOrder
    VoucherId?: SortOrder
    _count?: freetimedetailtbCountOrderByAggregateInput
    _avg?: freetimedetailtbAvgOrderByAggregateInput
    _max?: freetimedetailtbMaxOrderByAggregateInput
    _min?: freetimedetailtbMinOrderByAggregateInput
    _sum?: freetimedetailtbSumOrderByAggregateInput
  }

  export type freetimedetailtbScalarWhereWithAggregatesInput = {
    AND?: freetimedetailtbScalarWhereWithAggregatesInput | freetimedetailtbScalarWhereWithAggregatesInput[]
    OR?: freetimedetailtbScalarWhereWithAggregatesInput[]
    NOT?: freetimedetailtbScalarWhereWithAggregatesInput | freetimedetailtbScalarWhereWithAggregatesInput[]
    FreeTimeDetailId?: IntWithAggregatesFilter<"freetimedetailtb"> | number
    UserId?: IntWithAggregatesFilter<"freetimedetailtb"> | number
    FreeTime?: IntWithAggregatesFilter<"freetimedetailtb"> | number
    FreeMoney?: IntWithAggregatesFilter<"freetimedetailtb"> | number
    Type?: IntWithAggregatesFilter<"freetimedetailtb"> | number
    RecordDate?: DateTimeWithAggregatesFilter<"freetimedetailtb"> | Date | string
    VoucherId?: IntWithAggregatesFilter<"freetimedetailtb"> | number
  }

  export type functiontbWhereInput = {
    AND?: functiontbWhereInput | functiontbWhereInput[]
    OR?: functiontbWhereInput[]
    NOT?: functiontbWhereInput | functiontbWhereInput[]
    FunctionCode?: StringFilter<"functiontb"> | string
    FunctionName?: StringFilter<"functiontb"> | string
    ParentFunction?: StringFilter<"functiontb"> | string
    LevelFunction?: IntFilter<"functiontb"> | number
    OrderOfLevel?: IntFilter<"functiontb"> | number
    Active?: IntFilter<"functiontb"> | number
  }

  export type functiontbOrderByWithRelationInput = {
    FunctionCode?: SortOrder
    FunctionName?: SortOrder
    ParentFunction?: SortOrder
    LevelFunction?: SortOrder
    OrderOfLevel?: SortOrder
    Active?: SortOrder
  }

  export type functiontbWhereUniqueInput = Prisma.AtLeast<{
    FunctionCode?: string
    AND?: functiontbWhereInput | functiontbWhereInput[]
    OR?: functiontbWhereInput[]
    NOT?: functiontbWhereInput | functiontbWhereInput[]
    FunctionName?: StringFilter<"functiontb"> | string
    ParentFunction?: StringFilter<"functiontb"> | string
    LevelFunction?: IntFilter<"functiontb"> | number
    OrderOfLevel?: IntFilter<"functiontb"> | number
    Active?: IntFilter<"functiontb"> | number
  }, "FunctionCode">

  export type functiontbOrderByWithAggregationInput = {
    FunctionCode?: SortOrder
    FunctionName?: SortOrder
    ParentFunction?: SortOrder
    LevelFunction?: SortOrder
    OrderOfLevel?: SortOrder
    Active?: SortOrder
    _count?: functiontbCountOrderByAggregateInput
    _avg?: functiontbAvgOrderByAggregateInput
    _max?: functiontbMaxOrderByAggregateInput
    _min?: functiontbMinOrderByAggregateInput
    _sum?: functiontbSumOrderByAggregateInput
  }

  export type functiontbScalarWhereWithAggregatesInput = {
    AND?: functiontbScalarWhereWithAggregatesInput | functiontbScalarWhereWithAggregatesInput[]
    OR?: functiontbScalarWhereWithAggregatesInput[]
    NOT?: functiontbScalarWhereWithAggregatesInput | functiontbScalarWhereWithAggregatesInput[]
    FunctionCode?: StringWithAggregatesFilter<"functiontb"> | string
    FunctionName?: StringWithAggregatesFilter<"functiontb"> | string
    ParentFunction?: StringWithAggregatesFilter<"functiontb"> | string
    LevelFunction?: IntWithAggregatesFilter<"functiontb"> | number
    OrderOfLevel?: IntWithAggregatesFilter<"functiontb"> | number
    Active?: IntWithAggregatesFilter<"functiontb"> | number
  }

  export type gamefoldertbWhereInput = {
    AND?: gamefoldertbWhereInput | gamefoldertbWhereInput[]
    OR?: gamefoldertbWhereInput[]
    NOT?: gamefoldertbWhereInput | gamefoldertbWhereInput[]
    ID?: IntFilter<"gamefoldertb"> | number
    MachineID?: IntFilter<"gamefoldertb"> | number
    GameId?: IntFilter<"gamefoldertb"> | number
    GamePath?: StringFilter<"gamefoldertb"> | string
  }

  export type gamefoldertbOrderByWithRelationInput = {
    ID?: SortOrder
    MachineID?: SortOrder
    GameId?: SortOrder
    GamePath?: SortOrder
  }

  export type gamefoldertbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: gamefoldertbWhereInput | gamefoldertbWhereInput[]
    OR?: gamefoldertbWhereInput[]
    NOT?: gamefoldertbWhereInput | gamefoldertbWhereInput[]
    MachineID?: IntFilter<"gamefoldertb"> | number
    GameId?: IntFilter<"gamefoldertb"> | number
    GamePath?: StringFilter<"gamefoldertb"> | string
  }, "ID">

  export type gamefoldertbOrderByWithAggregationInput = {
    ID?: SortOrder
    MachineID?: SortOrder
    GameId?: SortOrder
    GamePath?: SortOrder
    _count?: gamefoldertbCountOrderByAggregateInput
    _avg?: gamefoldertbAvgOrderByAggregateInput
    _max?: gamefoldertbMaxOrderByAggregateInput
    _min?: gamefoldertbMinOrderByAggregateInput
    _sum?: gamefoldertbSumOrderByAggregateInput
  }

  export type gamefoldertbScalarWhereWithAggregatesInput = {
    AND?: gamefoldertbScalarWhereWithAggregatesInput | gamefoldertbScalarWhereWithAggregatesInput[]
    OR?: gamefoldertbScalarWhereWithAggregatesInput[]
    NOT?: gamefoldertbScalarWhereWithAggregatesInput | gamefoldertbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"gamefoldertb"> | number
    MachineID?: IntWithAggregatesFilter<"gamefoldertb"> | number
    GameId?: IntWithAggregatesFilter<"gamefoldertb"> | number
    GamePath?: StringWithAggregatesFilter<"gamefoldertb"> | string
  }

  export type gamelisttbWhereInput = {
    AND?: gamelisttbWhereInput | gamelisttbWhereInput[]
    OR?: gamelisttbWhereInput[]
    NOT?: gamelisttbWhereInput | gamelisttbWhereInput[]
    GameId?: IntFilter<"gamelisttb"> | number
    GameAlias?: StringFilter<"gamelisttb"> | string
    GameName?: StringFilter<"gamelisttb"> | string
    GameLauncher?: StringFilter<"gamelisttb"> | string
    Active?: IntFilter<"gamelisttb"> | number
    Protocol?: StringFilter<"gamelisttb"> | string
    URL?: StringFilter<"gamelisttb"> | string
    Checksum?: StringFilter<"gamelisttb"> | string
    PublishDate?: DateTimeFilter<"gamelisttb"> | Date | string
    TorrentFile?: StringFilter<"gamelisttb"> | string
    SetupFile?: StringFilter<"gamelisttb"> | string
    ShortcutPath?: StringFilter<"gamelisttb"> | string
    Type?: IntFilter<"gamelisttb"> | number
    Size?: StringFilter<"gamelisttb"> | string
    SetupType?: IntFilter<"gamelisttb"> | number
    ConfigFile?: StringFilter<"gamelisttb"> | string
    Checked?: IntFilter<"gamelisttb"> | number
  }

  export type gamelisttbOrderByWithRelationInput = {
    GameId?: SortOrder
    GameAlias?: SortOrder
    GameName?: SortOrder
    GameLauncher?: SortOrder
    Active?: SortOrder
    Protocol?: SortOrder
    URL?: SortOrder
    Checksum?: SortOrder
    PublishDate?: SortOrder
    TorrentFile?: SortOrder
    SetupFile?: SortOrder
    ShortcutPath?: SortOrder
    Type?: SortOrder
    Size?: SortOrder
    SetupType?: SortOrder
    ConfigFile?: SortOrder
    Checked?: SortOrder
  }

  export type gamelisttbWhereUniqueInput = Prisma.AtLeast<{
    GameId?: number
    AND?: gamelisttbWhereInput | gamelisttbWhereInput[]
    OR?: gamelisttbWhereInput[]
    NOT?: gamelisttbWhereInput | gamelisttbWhereInput[]
    GameAlias?: StringFilter<"gamelisttb"> | string
    GameName?: StringFilter<"gamelisttb"> | string
    GameLauncher?: StringFilter<"gamelisttb"> | string
    Active?: IntFilter<"gamelisttb"> | number
    Protocol?: StringFilter<"gamelisttb"> | string
    URL?: StringFilter<"gamelisttb"> | string
    Checksum?: StringFilter<"gamelisttb"> | string
    PublishDate?: DateTimeFilter<"gamelisttb"> | Date | string
    TorrentFile?: StringFilter<"gamelisttb"> | string
    SetupFile?: StringFilter<"gamelisttb"> | string
    ShortcutPath?: StringFilter<"gamelisttb"> | string
    Type?: IntFilter<"gamelisttb"> | number
    Size?: StringFilter<"gamelisttb"> | string
    SetupType?: IntFilter<"gamelisttb"> | number
    ConfigFile?: StringFilter<"gamelisttb"> | string
    Checked?: IntFilter<"gamelisttb"> | number
  }, "GameId">

  export type gamelisttbOrderByWithAggregationInput = {
    GameId?: SortOrder
    GameAlias?: SortOrder
    GameName?: SortOrder
    GameLauncher?: SortOrder
    Active?: SortOrder
    Protocol?: SortOrder
    URL?: SortOrder
    Checksum?: SortOrder
    PublishDate?: SortOrder
    TorrentFile?: SortOrder
    SetupFile?: SortOrder
    ShortcutPath?: SortOrder
    Type?: SortOrder
    Size?: SortOrder
    SetupType?: SortOrder
    ConfigFile?: SortOrder
    Checked?: SortOrder
    _count?: gamelisttbCountOrderByAggregateInput
    _avg?: gamelisttbAvgOrderByAggregateInput
    _max?: gamelisttbMaxOrderByAggregateInput
    _min?: gamelisttbMinOrderByAggregateInput
    _sum?: gamelisttbSumOrderByAggregateInput
  }

  export type gamelisttbScalarWhereWithAggregatesInput = {
    AND?: gamelisttbScalarWhereWithAggregatesInput | gamelisttbScalarWhereWithAggregatesInput[]
    OR?: gamelisttbScalarWhereWithAggregatesInput[]
    NOT?: gamelisttbScalarWhereWithAggregatesInput | gamelisttbScalarWhereWithAggregatesInput[]
    GameId?: IntWithAggregatesFilter<"gamelisttb"> | number
    GameAlias?: StringWithAggregatesFilter<"gamelisttb"> | string
    GameName?: StringWithAggregatesFilter<"gamelisttb"> | string
    GameLauncher?: StringWithAggregatesFilter<"gamelisttb"> | string
    Active?: IntWithAggregatesFilter<"gamelisttb"> | number
    Protocol?: StringWithAggregatesFilter<"gamelisttb"> | string
    URL?: StringWithAggregatesFilter<"gamelisttb"> | string
    Checksum?: StringWithAggregatesFilter<"gamelisttb"> | string
    PublishDate?: DateTimeWithAggregatesFilter<"gamelisttb"> | Date | string
    TorrentFile?: StringWithAggregatesFilter<"gamelisttb"> | string
    SetupFile?: StringWithAggregatesFilter<"gamelisttb"> | string
    ShortcutPath?: StringWithAggregatesFilter<"gamelisttb"> | string
    Type?: IntWithAggregatesFilter<"gamelisttb"> | number
    Size?: StringWithAggregatesFilter<"gamelisttb"> | string
    SetupType?: IntWithAggregatesFilter<"gamelisttb"> | number
    ConfigFile?: StringWithAggregatesFilter<"gamelisttb"> | string
    Checked?: IntWithAggregatesFilter<"gamelisttb"> | number
  }

  export type hptbWhereInput = {
    AND?: hptbWhereInput | hptbWhereInput[]
    OR?: hptbWhereInput[]
    NOT?: hptbWhereInput | hptbWhereInput[]
    ID?: IntFilter<"hptb"> | number
    MachineName?: StringFilter<"hptb"> | string
    IEHP?: StringFilter<"hptb"> | string
    FFHP?: StringFilter<"hptb"> | string
    GCHP?: StringFilter<"hptb"> | string
    LastUpdateDate?: DateTimeFilter<"hptb"> | Date | string
  }

  export type hptbOrderByWithRelationInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    IEHP?: SortOrder
    FFHP?: SortOrder
    GCHP?: SortOrder
    LastUpdateDate?: SortOrder
  }

  export type hptbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: hptbWhereInput | hptbWhereInput[]
    OR?: hptbWhereInput[]
    NOT?: hptbWhereInput | hptbWhereInput[]
    MachineName?: StringFilter<"hptb"> | string
    IEHP?: StringFilter<"hptb"> | string
    FFHP?: StringFilter<"hptb"> | string
    GCHP?: StringFilter<"hptb"> | string
    LastUpdateDate?: DateTimeFilter<"hptb"> | Date | string
  }, "ID">

  export type hptbOrderByWithAggregationInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    IEHP?: SortOrder
    FFHP?: SortOrder
    GCHP?: SortOrder
    LastUpdateDate?: SortOrder
    _count?: hptbCountOrderByAggregateInput
    _avg?: hptbAvgOrderByAggregateInput
    _max?: hptbMaxOrderByAggregateInput
    _min?: hptbMinOrderByAggregateInput
    _sum?: hptbSumOrderByAggregateInput
  }

  export type hptbScalarWhereWithAggregatesInput = {
    AND?: hptbScalarWhereWithAggregatesInput | hptbScalarWhereWithAggregatesInput[]
    OR?: hptbScalarWhereWithAggregatesInput[]
    NOT?: hptbScalarWhereWithAggregatesInput | hptbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"hptb"> | number
    MachineName?: StringWithAggregatesFilter<"hptb"> | string
    IEHP?: StringWithAggregatesFilter<"hptb"> | string
    FFHP?: StringWithAggregatesFilter<"hptb"> | string
    GCHP?: StringWithAggregatesFilter<"hptb"> | string
    LastUpdateDate?: DateTimeWithAggregatesFilter<"hptb"> | Date | string
  }

  export type intoptiontbWhereInput = {
    AND?: intoptiontbWhereInput | intoptiontbWhereInput[]
    OR?: intoptiontbWhereInput[]
    NOT?: intoptiontbWhereInput | intoptiontbWhereInput[]
    OptionId?: IntFilter<"intoptiontb"> | number
    OptionName?: StringFilter<"intoptiontb"> | string
    Value?: StringFilter<"intoptiontb"> | string
    Active?: BoolFilter<"intoptiontb"> | boolean
  }

  export type intoptiontbOrderByWithRelationInput = {
    OptionId?: SortOrder
    OptionName?: SortOrder
    Value?: SortOrder
    Active?: SortOrder
  }

  export type intoptiontbWhereUniqueInput = Prisma.AtLeast<{
    OptionId?: number
    AND?: intoptiontbWhereInput | intoptiontbWhereInput[]
    OR?: intoptiontbWhereInput[]
    NOT?: intoptiontbWhereInput | intoptiontbWhereInput[]
    OptionName?: StringFilter<"intoptiontb"> | string
    Value?: StringFilter<"intoptiontb"> | string
    Active?: BoolFilter<"intoptiontb"> | boolean
  }, "OptionId">

  export type intoptiontbOrderByWithAggregationInput = {
    OptionId?: SortOrder
    OptionName?: SortOrder
    Value?: SortOrder
    Active?: SortOrder
    _count?: intoptiontbCountOrderByAggregateInput
    _avg?: intoptiontbAvgOrderByAggregateInput
    _max?: intoptiontbMaxOrderByAggregateInput
    _min?: intoptiontbMinOrderByAggregateInput
    _sum?: intoptiontbSumOrderByAggregateInput
  }

  export type intoptiontbScalarWhereWithAggregatesInput = {
    AND?: intoptiontbScalarWhereWithAggregatesInput | intoptiontbScalarWhereWithAggregatesInput[]
    OR?: intoptiontbScalarWhereWithAggregatesInput[]
    NOT?: intoptiontbScalarWhereWithAggregatesInput | intoptiontbScalarWhereWithAggregatesInput[]
    OptionId?: IntWithAggregatesFilter<"intoptiontb"> | number
    OptionName?: StringWithAggregatesFilter<"intoptiontb"> | string
    Value?: StringWithAggregatesFilter<"intoptiontb"> | string
    Active?: BoolWithAggregatesFilter<"intoptiontb"> | boolean
  }

  export type inventorytbWhereInput = {
    AND?: inventorytbWhereInput | inventorytbWhereInput[]
    OR?: inventorytbWhereInput[]
    NOT?: inventorytbWhereInput | inventorytbWhereInput[]
    ID?: IntFilter<"inventorytb"> | number
    CreateDate?: DateTimeFilter<"inventorytb"> | Date | string
    CreateTime?: DateTimeFilter<"inventorytb"> | Date | string
    StaffID?: IntFilter<"inventorytb"> | number
    Note?: StringNullableFilter<"inventorytb"> | string | null
    ServiceID?: IntFilter<"inventorytb"> | number
    ImportQuantity?: IntFilter<"inventorytb"> | number
    ImportPrice?: DecimalFilter<"inventorytb"> | Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: DecimalFilter<"inventorytb"> | Decimal | DecimalJsLike | number | string
  }

  export type inventorytbOrderByWithRelationInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    Note?: SortOrderInput | SortOrder
    ServiceID?: SortOrder
    ImportQuantity?: SortOrder
    ImportPrice?: SortOrder
    ImportTotalAmount?: SortOrder
  }

  export type inventorytbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: inventorytbWhereInput | inventorytbWhereInput[]
    OR?: inventorytbWhereInput[]
    NOT?: inventorytbWhereInput | inventorytbWhereInput[]
    CreateDate?: DateTimeFilter<"inventorytb"> | Date | string
    CreateTime?: DateTimeFilter<"inventorytb"> | Date | string
    StaffID?: IntFilter<"inventorytb"> | number
    Note?: StringNullableFilter<"inventorytb"> | string | null
    ServiceID?: IntFilter<"inventorytb"> | number
    ImportQuantity?: IntFilter<"inventorytb"> | number
    ImportPrice?: DecimalFilter<"inventorytb"> | Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: DecimalFilter<"inventorytb"> | Decimal | DecimalJsLike | number | string
  }, "ID">

  export type inventorytbOrderByWithAggregationInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    Note?: SortOrderInput | SortOrder
    ServiceID?: SortOrder
    ImportQuantity?: SortOrder
    ImportPrice?: SortOrder
    ImportTotalAmount?: SortOrder
    _count?: inventorytbCountOrderByAggregateInput
    _avg?: inventorytbAvgOrderByAggregateInput
    _max?: inventorytbMaxOrderByAggregateInput
    _min?: inventorytbMinOrderByAggregateInput
    _sum?: inventorytbSumOrderByAggregateInput
  }

  export type inventorytbScalarWhereWithAggregatesInput = {
    AND?: inventorytbScalarWhereWithAggregatesInput | inventorytbScalarWhereWithAggregatesInput[]
    OR?: inventorytbScalarWhereWithAggregatesInput[]
    NOT?: inventorytbScalarWhereWithAggregatesInput | inventorytbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"inventorytb"> | number
    CreateDate?: DateTimeWithAggregatesFilter<"inventorytb"> | Date | string
    CreateTime?: DateTimeWithAggregatesFilter<"inventorytb"> | Date | string
    StaffID?: IntWithAggregatesFilter<"inventorytb"> | number
    Note?: StringNullableWithAggregatesFilter<"inventorytb"> | string | null
    ServiceID?: IntWithAggregatesFilter<"inventorytb"> | number
    ImportQuantity?: IntWithAggregatesFilter<"inventorytb"> | number
    ImportPrice?: DecimalWithAggregatesFilter<"inventorytb"> | Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: DecimalWithAggregatesFilter<"inventorytb"> | Decimal | DecimalJsLike | number | string
  }

  export type legalapptbWhereInput = {
    AND?: legalapptbWhereInput | legalapptbWhereInput[]
    OR?: legalapptbWhereInput[]
    NOT?: legalapptbWhereInput | legalapptbWhereInput[]
    AppName?: StringFilter<"legalapptb"> | string
  }

  export type legalapptbOrderByWithRelationInput = {
    AppName?: SortOrder
  }

  export type legalapptbWhereUniqueInput = Prisma.AtLeast<{
    AppName?: string
    AND?: legalapptbWhereInput | legalapptbWhereInput[]
    OR?: legalapptbWhereInput[]
    NOT?: legalapptbWhereInput | legalapptbWhereInput[]
  }, "AppName">

  export type legalapptbOrderByWithAggregationInput = {
    AppName?: SortOrder
    _count?: legalapptbCountOrderByAggregateInput
    _max?: legalapptbMaxOrderByAggregateInput
    _min?: legalapptbMinOrderByAggregateInput
  }

  export type legalapptbScalarWhereWithAggregatesInput = {
    AND?: legalapptbScalarWhereWithAggregatesInput | legalapptbScalarWhereWithAggregatesInput[]
    OR?: legalapptbScalarWhereWithAggregatesInput[]
    NOT?: legalapptbScalarWhereWithAggregatesInput | legalapptbScalarWhereWithAggregatesInput[]
    AppName?: StringWithAggregatesFilter<"legalapptb"> | string
  }

  export type machinegrouptbWhereInput = {
    AND?: machinegrouptbWhereInput | machinegrouptbWhereInput[]
    OR?: machinegrouptbWhereInput[]
    NOT?: machinegrouptbWhereInput | machinegrouptbWhereInput[]
    MachineGroupId?: IntFilter<"machinegrouptb"> | number
    MachineGroupName?: StringFilter<"machinegrouptb"> | string
    PriceDefault?: IntNullableFilter<"machinegrouptb"> | number | null
    Active?: IntNullableFilter<"machinegrouptb"> | number | null
    Description?: StringNullableFilter<"machinegrouptb"> | string | null
  }

  export type machinegrouptbOrderByWithRelationInput = {
    MachineGroupId?: SortOrder
    MachineGroupName?: SortOrder
    PriceDefault?: SortOrderInput | SortOrder
    Active?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
  }

  export type machinegrouptbWhereUniqueInput = Prisma.AtLeast<{
    MachineGroupId?: number
    AND?: machinegrouptbWhereInput | machinegrouptbWhereInput[]
    OR?: machinegrouptbWhereInput[]
    NOT?: machinegrouptbWhereInput | machinegrouptbWhereInput[]
    MachineGroupName?: StringFilter<"machinegrouptb"> | string
    PriceDefault?: IntNullableFilter<"machinegrouptb"> | number | null
    Active?: IntNullableFilter<"machinegrouptb"> | number | null
    Description?: StringNullableFilter<"machinegrouptb"> | string | null
  }, "MachineGroupId">

  export type machinegrouptbOrderByWithAggregationInput = {
    MachineGroupId?: SortOrder
    MachineGroupName?: SortOrder
    PriceDefault?: SortOrderInput | SortOrder
    Active?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    _count?: machinegrouptbCountOrderByAggregateInput
    _avg?: machinegrouptbAvgOrderByAggregateInput
    _max?: machinegrouptbMaxOrderByAggregateInput
    _min?: machinegrouptbMinOrderByAggregateInput
    _sum?: machinegrouptbSumOrderByAggregateInput
  }

  export type machinegrouptbScalarWhereWithAggregatesInput = {
    AND?: machinegrouptbScalarWhereWithAggregatesInput | machinegrouptbScalarWhereWithAggregatesInput[]
    OR?: machinegrouptbScalarWhereWithAggregatesInput[]
    NOT?: machinegrouptbScalarWhereWithAggregatesInput | machinegrouptbScalarWhereWithAggregatesInput[]
    MachineGroupId?: IntWithAggregatesFilter<"machinegrouptb"> | number
    MachineGroupName?: StringWithAggregatesFilter<"machinegrouptb"> | string
    PriceDefault?: IntNullableWithAggregatesFilter<"machinegrouptb"> | number | null
    Active?: IntNullableWithAggregatesFilter<"machinegrouptb"> | number | null
    Description?: StringNullableWithAggregatesFilter<"machinegrouptb"> | string | null
  }

  export type paymenttbWhereInput = {
    AND?: paymenttbWhereInput | paymenttbWhereInput[]
    OR?: paymenttbWhereInput[]
    NOT?: paymenttbWhereInput | paymenttbWhereInput[]
    VoucherId?: IntFilter<"paymenttb"> | number
    UserId?: IntFilter<"paymenttb"> | number
    VoucherNo?: StringNullableFilter<"paymenttb"> | string | null
    VoucherDate?: DateTimeFilter<"paymenttb"> | Date | string
    VoucherTime?: DateTimeFilter<"paymenttb"> | Date | string
    ServeDate?: DateTimeFilter<"paymenttb"> | Date | string
    ServeTime?: DateTimeFilter<"paymenttb"> | Date | string
    Amount?: DecimalFilter<"paymenttb"> | Decimal | DecimalJsLike | number | string
    AutoAmount?: DecimalFilter<"paymenttb"> | Decimal | DecimalJsLike | number | string
    TimeTotal?: IntFilter<"paymenttb"> | number
    Active?: BoolFilter<"paymenttb"> | boolean
    UserNote?: StringFilter<"paymenttb"> | string
    Note?: StringFilter<"paymenttb"> | string
    ServicePaid?: BoolFilter<"paymenttb"> | boolean
    StaffId?: IntFilter<"paymenttb"> | number
    MachineName?: StringNullableFilter<"paymenttb"> | string | null
    PaymentType?: IntNullableFilter<"paymenttb"> | number | null
    PaymentWaitId?: IntFilter<"paymenttb"> | number
    zOid?: StringNullableFilter<"paymenttb"> | string | null
    zTid?: StringNullableFilter<"paymenttb"> | string | null
    zSig?: StringNullableFilter<"paymenttb"> | string | null
  }

  export type paymenttbOrderByWithRelationInput = {
    VoucherId?: SortOrder
    UserId?: SortOrder
    VoucherNo?: SortOrderInput | SortOrder
    VoucherDate?: SortOrder
    VoucherTime?: SortOrder
    ServeDate?: SortOrder
    ServeTime?: SortOrder
    Amount?: SortOrder
    AutoAmount?: SortOrder
    TimeTotal?: SortOrder
    Active?: SortOrder
    UserNote?: SortOrder
    Note?: SortOrder
    ServicePaid?: SortOrder
    StaffId?: SortOrder
    MachineName?: SortOrderInput | SortOrder
    PaymentType?: SortOrderInput | SortOrder
    PaymentWaitId?: SortOrder
    zOid?: SortOrderInput | SortOrder
    zTid?: SortOrderInput | SortOrder
    zSig?: SortOrderInput | SortOrder
  }

  export type paymenttbWhereUniqueInput = Prisma.AtLeast<{
    VoucherId?: number
    zOid?: string
    zTid?: string
    AND?: paymenttbWhereInput | paymenttbWhereInput[]
    OR?: paymenttbWhereInput[]
    NOT?: paymenttbWhereInput | paymenttbWhereInput[]
    UserId?: IntFilter<"paymenttb"> | number
    VoucherNo?: StringNullableFilter<"paymenttb"> | string | null
    VoucherDate?: DateTimeFilter<"paymenttb"> | Date | string
    VoucherTime?: DateTimeFilter<"paymenttb"> | Date | string
    ServeDate?: DateTimeFilter<"paymenttb"> | Date | string
    ServeTime?: DateTimeFilter<"paymenttb"> | Date | string
    Amount?: DecimalFilter<"paymenttb"> | Decimal | DecimalJsLike | number | string
    AutoAmount?: DecimalFilter<"paymenttb"> | Decimal | DecimalJsLike | number | string
    TimeTotal?: IntFilter<"paymenttb"> | number
    Active?: BoolFilter<"paymenttb"> | boolean
    UserNote?: StringFilter<"paymenttb"> | string
    Note?: StringFilter<"paymenttb"> | string
    ServicePaid?: BoolFilter<"paymenttb"> | boolean
    StaffId?: IntFilter<"paymenttb"> | number
    MachineName?: StringNullableFilter<"paymenttb"> | string | null
    PaymentType?: IntNullableFilter<"paymenttb"> | number | null
    PaymentWaitId?: IntFilter<"paymenttb"> | number
    zSig?: StringNullableFilter<"paymenttb"> | string | null
  }, "VoucherId" | "zOid" | "zTid">

  export type paymenttbOrderByWithAggregationInput = {
    VoucherId?: SortOrder
    UserId?: SortOrder
    VoucherNo?: SortOrderInput | SortOrder
    VoucherDate?: SortOrder
    VoucherTime?: SortOrder
    ServeDate?: SortOrder
    ServeTime?: SortOrder
    Amount?: SortOrder
    AutoAmount?: SortOrder
    TimeTotal?: SortOrder
    Active?: SortOrder
    UserNote?: SortOrder
    Note?: SortOrder
    ServicePaid?: SortOrder
    StaffId?: SortOrder
    MachineName?: SortOrderInput | SortOrder
    PaymentType?: SortOrderInput | SortOrder
    PaymentWaitId?: SortOrder
    zOid?: SortOrderInput | SortOrder
    zTid?: SortOrderInput | SortOrder
    zSig?: SortOrderInput | SortOrder
    _count?: paymenttbCountOrderByAggregateInput
    _avg?: paymenttbAvgOrderByAggregateInput
    _max?: paymenttbMaxOrderByAggregateInput
    _min?: paymenttbMinOrderByAggregateInput
    _sum?: paymenttbSumOrderByAggregateInput
  }

  export type paymenttbScalarWhereWithAggregatesInput = {
    AND?: paymenttbScalarWhereWithAggregatesInput | paymenttbScalarWhereWithAggregatesInput[]
    OR?: paymenttbScalarWhereWithAggregatesInput[]
    NOT?: paymenttbScalarWhereWithAggregatesInput | paymenttbScalarWhereWithAggregatesInput[]
    VoucherId?: IntWithAggregatesFilter<"paymenttb"> | number
    UserId?: IntWithAggregatesFilter<"paymenttb"> | number
    VoucherNo?: StringNullableWithAggregatesFilter<"paymenttb"> | string | null
    VoucherDate?: DateTimeWithAggregatesFilter<"paymenttb"> | Date | string
    VoucherTime?: DateTimeWithAggregatesFilter<"paymenttb"> | Date | string
    ServeDate?: DateTimeWithAggregatesFilter<"paymenttb"> | Date | string
    ServeTime?: DateTimeWithAggregatesFilter<"paymenttb"> | Date | string
    Amount?: DecimalWithAggregatesFilter<"paymenttb"> | Decimal | DecimalJsLike | number | string
    AutoAmount?: DecimalWithAggregatesFilter<"paymenttb"> | Decimal | DecimalJsLike | number | string
    TimeTotal?: IntWithAggregatesFilter<"paymenttb"> | number
    Active?: BoolWithAggregatesFilter<"paymenttb"> | boolean
    UserNote?: StringWithAggregatesFilter<"paymenttb"> | string
    Note?: StringWithAggregatesFilter<"paymenttb"> | string
    ServicePaid?: BoolWithAggregatesFilter<"paymenttb"> | boolean
    StaffId?: IntWithAggregatesFilter<"paymenttb"> | number
    MachineName?: StringNullableWithAggregatesFilter<"paymenttb"> | string | null
    PaymentType?: IntNullableWithAggregatesFilter<"paymenttb"> | number | null
    PaymentWaitId?: IntWithAggregatesFilter<"paymenttb"> | number
    zOid?: StringNullableWithAggregatesFilter<"paymenttb"> | string | null
    zTid?: StringNullableWithAggregatesFilter<"paymenttb"> | string | null
    zSig?: StringNullableWithAggregatesFilter<"paymenttb"> | string | null
  }

  export type paymentwaittbWhereInput = {
    AND?: paymentwaittbWhereInput | paymentwaittbWhereInput[]
    OR?: paymentwaittbWhereInput[]
    NOT?: paymentwaittbWhereInput | paymentwaittbWhereInput[]
    PaymentWaitId?: IntFilter<"paymentwaittb"> | number
    MachineName?: StringFilter<"paymentwaittb"> | string
    TotalTimeUsed?: IntFilter<"paymentwaittb"> | number
    TotalTimeFee?: IntFilter<"paymentwaittb"> | number
    BeginTime?: DateTimeFilter<"paymentwaittb"> | Date | string
    EndTime?: DateTimeFilter<"paymentwaittb"> | Date | string
    TimeFee?: DecimalFilter<"paymentwaittb"> | Decimal | DecimalJsLike | number | string
    TimeUsed?: IntFilter<"paymentwaittb"> | number
    RemainTime?: IntFilter<"paymentwaittb"> | number
    TimePaid?: IntFilter<"paymentwaittb"> | number
    FreeTime?: IntFilter<"paymentwaittb"> | number
    ChangePCSessionId?: IntFilter<"paymentwaittb"> | number
    AnonymId?: IntFilter<"paymentwaittb"> | number
    PriceGroupId?: IntFilter<"paymentwaittb"> | number
    MachineGroupId?: IntFilter<"paymentwaittb"> | number
    Note?: StringFilter<"paymentwaittb"> | string
    PriceAppRentID?: IntFilter<"paymentwaittb"> | number
  }

  export type paymentwaittbOrderByWithRelationInput = {
    PaymentWaitId?: SortOrder
    MachineName?: SortOrder
    TotalTimeUsed?: SortOrder
    TotalTimeFee?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    TimeFee?: SortOrder
    TimeUsed?: SortOrder
    RemainTime?: SortOrder
    TimePaid?: SortOrder
    FreeTime?: SortOrder
    ChangePCSessionId?: SortOrder
    AnonymId?: SortOrder
    PriceGroupId?: SortOrder
    MachineGroupId?: SortOrder
    Note?: SortOrder
    PriceAppRentID?: SortOrder
  }

  export type paymentwaittbWhereUniqueInput = Prisma.AtLeast<{
    PaymentWaitId?: number
    AND?: paymentwaittbWhereInput | paymentwaittbWhereInput[]
    OR?: paymentwaittbWhereInput[]
    NOT?: paymentwaittbWhereInput | paymentwaittbWhereInput[]
    MachineName?: StringFilter<"paymentwaittb"> | string
    TotalTimeUsed?: IntFilter<"paymentwaittb"> | number
    TotalTimeFee?: IntFilter<"paymentwaittb"> | number
    BeginTime?: DateTimeFilter<"paymentwaittb"> | Date | string
    EndTime?: DateTimeFilter<"paymentwaittb"> | Date | string
    TimeFee?: DecimalFilter<"paymentwaittb"> | Decimal | DecimalJsLike | number | string
    TimeUsed?: IntFilter<"paymentwaittb"> | number
    RemainTime?: IntFilter<"paymentwaittb"> | number
    TimePaid?: IntFilter<"paymentwaittb"> | number
    FreeTime?: IntFilter<"paymentwaittb"> | number
    ChangePCSessionId?: IntFilter<"paymentwaittb"> | number
    AnonymId?: IntFilter<"paymentwaittb"> | number
    PriceGroupId?: IntFilter<"paymentwaittb"> | number
    MachineGroupId?: IntFilter<"paymentwaittb"> | number
    Note?: StringFilter<"paymentwaittb"> | string
    PriceAppRentID?: IntFilter<"paymentwaittb"> | number
  }, "PaymentWaitId">

  export type paymentwaittbOrderByWithAggregationInput = {
    PaymentWaitId?: SortOrder
    MachineName?: SortOrder
    TotalTimeUsed?: SortOrder
    TotalTimeFee?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    TimeFee?: SortOrder
    TimeUsed?: SortOrder
    RemainTime?: SortOrder
    TimePaid?: SortOrder
    FreeTime?: SortOrder
    ChangePCSessionId?: SortOrder
    AnonymId?: SortOrder
    PriceGroupId?: SortOrder
    MachineGroupId?: SortOrder
    Note?: SortOrder
    PriceAppRentID?: SortOrder
    _count?: paymentwaittbCountOrderByAggregateInput
    _avg?: paymentwaittbAvgOrderByAggregateInput
    _max?: paymentwaittbMaxOrderByAggregateInput
    _min?: paymentwaittbMinOrderByAggregateInput
    _sum?: paymentwaittbSumOrderByAggregateInput
  }

  export type paymentwaittbScalarWhereWithAggregatesInput = {
    AND?: paymentwaittbScalarWhereWithAggregatesInput | paymentwaittbScalarWhereWithAggregatesInput[]
    OR?: paymentwaittbScalarWhereWithAggregatesInput[]
    NOT?: paymentwaittbScalarWhereWithAggregatesInput | paymentwaittbScalarWhereWithAggregatesInput[]
    PaymentWaitId?: IntWithAggregatesFilter<"paymentwaittb"> | number
    MachineName?: StringWithAggregatesFilter<"paymentwaittb"> | string
    TotalTimeUsed?: IntWithAggregatesFilter<"paymentwaittb"> | number
    TotalTimeFee?: IntWithAggregatesFilter<"paymentwaittb"> | number
    BeginTime?: DateTimeWithAggregatesFilter<"paymentwaittb"> | Date | string
    EndTime?: DateTimeWithAggregatesFilter<"paymentwaittb"> | Date | string
    TimeFee?: DecimalWithAggregatesFilter<"paymentwaittb"> | Decimal | DecimalJsLike | number | string
    TimeUsed?: IntWithAggregatesFilter<"paymentwaittb"> | number
    RemainTime?: IntWithAggregatesFilter<"paymentwaittb"> | number
    TimePaid?: IntWithAggregatesFilter<"paymentwaittb"> | number
    FreeTime?: IntWithAggregatesFilter<"paymentwaittb"> | number
    ChangePCSessionId?: IntWithAggregatesFilter<"paymentwaittb"> | number
    AnonymId?: IntWithAggregatesFilter<"paymentwaittb"> | number
    PriceGroupId?: IntWithAggregatesFilter<"paymentwaittb"> | number
    MachineGroupId?: IntWithAggregatesFilter<"paymentwaittb"> | number
    Note?: StringWithAggregatesFilter<"paymentwaittb"> | string
    PriceAppRentID?: IntWithAggregatesFilter<"paymentwaittb"> | number
  }

  export type priceapprenttbWhereInput = {
    AND?: priceapprenttbWhereInput | priceapprenttbWhereInput[]
    OR?: priceapprenttbWhereInput[]
    NOT?: priceapprenttbWhereInput | priceapprenttbWhereInput[]
    PriceAppRentID?: IntFilter<"priceapprenttb"> | number
    PriceID?: IntFilter<"priceapprenttb"> | number
    MachineGroupID?: IntFilter<"priceapprenttb"> | number
    Name?: StringFilter<"priceapprenttb"> | string
    Price?: DecimalFilter<"priceapprenttb"> | Decimal | DecimalJsLike | number | string
    Status?: IntFilter<"priceapprenttb"> | number
  }

  export type priceapprenttbOrderByWithRelationInput = {
    PriceAppRentID?: SortOrder
    PriceID?: SortOrder
    MachineGroupID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    Status?: SortOrder
  }

  export type priceapprenttbWhereUniqueInput = Prisma.AtLeast<{
    PriceAppRentID?: number
    AND?: priceapprenttbWhereInput | priceapprenttbWhereInput[]
    OR?: priceapprenttbWhereInput[]
    NOT?: priceapprenttbWhereInput | priceapprenttbWhereInput[]
    PriceID?: IntFilter<"priceapprenttb"> | number
    MachineGroupID?: IntFilter<"priceapprenttb"> | number
    Name?: StringFilter<"priceapprenttb"> | string
    Price?: DecimalFilter<"priceapprenttb"> | Decimal | DecimalJsLike | number | string
    Status?: IntFilter<"priceapprenttb"> | number
  }, "PriceAppRentID">

  export type priceapprenttbOrderByWithAggregationInput = {
    PriceAppRentID?: SortOrder
    PriceID?: SortOrder
    MachineGroupID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    Status?: SortOrder
    _count?: priceapprenttbCountOrderByAggregateInput
    _avg?: priceapprenttbAvgOrderByAggregateInput
    _max?: priceapprenttbMaxOrderByAggregateInput
    _min?: priceapprenttbMinOrderByAggregateInput
    _sum?: priceapprenttbSumOrderByAggregateInput
  }

  export type priceapprenttbScalarWhereWithAggregatesInput = {
    AND?: priceapprenttbScalarWhereWithAggregatesInput | priceapprenttbScalarWhereWithAggregatesInput[]
    OR?: priceapprenttbScalarWhereWithAggregatesInput[]
    NOT?: priceapprenttbScalarWhereWithAggregatesInput | priceapprenttbScalarWhereWithAggregatesInput[]
    PriceAppRentID?: IntWithAggregatesFilter<"priceapprenttb"> | number
    PriceID?: IntWithAggregatesFilter<"priceapprenttb"> | number
    MachineGroupID?: IntWithAggregatesFilter<"priceapprenttb"> | number
    Name?: StringWithAggregatesFilter<"priceapprenttb"> | string
    Price?: DecimalWithAggregatesFilter<"priceapprenttb"> | Decimal | DecimalJsLike | number | string
    Status?: IntWithAggregatesFilter<"priceapprenttb"> | number
  }

  export type priceapprentusetbWhereInput = {
    AND?: priceapprentusetbWhereInput | priceapprentusetbWhereInput[]
    OR?: priceapprentusetbWhereInput[]
    NOT?: priceapprentusetbWhereInput | priceapprentusetbWhereInput[]
    PriceAppRentUseID?: IntFilter<"priceapprentusetb"> | number
    PriceAppRentID?: IntFilter<"priceapprentusetb"> | number
    ApplicationRentID?: IntFilter<"priceapprentusetb"> | number
  }

  export type priceapprentusetbOrderByWithRelationInput = {
    PriceAppRentUseID?: SortOrder
    PriceAppRentID?: SortOrder
    ApplicationRentID?: SortOrder
  }

  export type priceapprentusetbWhereUniqueInput = Prisma.AtLeast<{
    PriceAppRentUseID?: number
    AND?: priceapprentusetbWhereInput | priceapprentusetbWhereInput[]
    OR?: priceapprentusetbWhereInput[]
    NOT?: priceapprentusetbWhereInput | priceapprentusetbWhereInput[]
    PriceAppRentID?: IntFilter<"priceapprentusetb"> | number
    ApplicationRentID?: IntFilter<"priceapprentusetb"> | number
  }, "PriceAppRentUseID">

  export type priceapprentusetbOrderByWithAggregationInput = {
    PriceAppRentUseID?: SortOrder
    PriceAppRentID?: SortOrder
    ApplicationRentID?: SortOrder
    _count?: priceapprentusetbCountOrderByAggregateInput
    _avg?: priceapprentusetbAvgOrderByAggregateInput
    _max?: priceapprentusetbMaxOrderByAggregateInput
    _min?: priceapprentusetbMinOrderByAggregateInput
    _sum?: priceapprentusetbSumOrderByAggregateInput
  }

  export type priceapprentusetbScalarWhereWithAggregatesInput = {
    AND?: priceapprentusetbScalarWhereWithAggregatesInput | priceapprentusetbScalarWhereWithAggregatesInput[]
    OR?: priceapprentusetbScalarWhereWithAggregatesInput[]
    NOT?: priceapprentusetbScalarWhereWithAggregatesInput | priceapprentusetbScalarWhereWithAggregatesInput[]
    PriceAppRentUseID?: IntWithAggregatesFilter<"priceapprentusetb"> | number
    PriceAppRentID?: IntWithAggregatesFilter<"priceapprentusetb"> | number
    ApplicationRentID?: IntWithAggregatesFilter<"priceapprentusetb"> | number
  }

  export type pricedetailtbWhereInput = {
    AND?: pricedetailtbWhereInput | pricedetailtbWhereInput[]
    OR?: pricedetailtbWhereInput[]
    NOT?: pricedetailtbWhereInput | pricedetailtbWhereInput[]
    PriceDetailId?: IntFilter<"pricedetailtb"> | number
    PriceId?: IntFilter<"pricedetailtb"> | number
    MachineGroupId?: IntNullableFilter<"pricedetailtb"> | number | null
    Price?: DecimalNullableFilter<"pricedetailtb"> | Decimal | DecimalJsLike | number | string | null
    Promotion?: IntNullableFilter<"pricedetailtb"> | number | null
    PromotionTerm?: IntNullableFilter<"pricedetailtb"> | number | null
    FreeMoney?: IntNullableFilter<"pricedetailtb"> | number | null
    FreeTime?: IntNullableFilter<"pricedetailtb"> | number | null
    BeginTime?: IntNullableFilter<"pricedetailtb"> | number | null
    EndTime?: IntNullableFilter<"pricedetailtb"> | number | null
    Term?: IntNullableFilter<"pricedetailtb"> | number | null
    PromotionOrder?: IntNullableFilter<"pricedetailtb"> | number | null
    BeginDate?: DateTimeNullableFilter<"pricedetailtb"> | Date | string | null
    EndDate?: DateTimeNullableFilter<"pricedetailtb"> | Date | string | null
    DayOfWeekMask?: IntFilter<"pricedetailtb"> | number
    PromotionType?: IntFilter<"pricedetailtb"> | number
  }

  export type pricedetailtbOrderByWithRelationInput = {
    PriceDetailId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrderInput | SortOrder
    Price?: SortOrderInput | SortOrder
    Promotion?: SortOrderInput | SortOrder
    PromotionTerm?: SortOrderInput | SortOrder
    FreeMoney?: SortOrderInput | SortOrder
    FreeTime?: SortOrderInput | SortOrder
    BeginTime?: SortOrderInput | SortOrder
    EndTime?: SortOrderInput | SortOrder
    Term?: SortOrderInput | SortOrder
    PromotionOrder?: SortOrderInput | SortOrder
    BeginDate?: SortOrderInput | SortOrder
    EndDate?: SortOrderInput | SortOrder
    DayOfWeekMask?: SortOrder
    PromotionType?: SortOrder
  }

  export type pricedetailtbWhereUniqueInput = Prisma.AtLeast<{
    PriceDetailId?: number
    AND?: pricedetailtbWhereInput | pricedetailtbWhereInput[]
    OR?: pricedetailtbWhereInput[]
    NOT?: pricedetailtbWhereInput | pricedetailtbWhereInput[]
    PriceId?: IntFilter<"pricedetailtb"> | number
    MachineGroupId?: IntNullableFilter<"pricedetailtb"> | number | null
    Price?: DecimalNullableFilter<"pricedetailtb"> | Decimal | DecimalJsLike | number | string | null
    Promotion?: IntNullableFilter<"pricedetailtb"> | number | null
    PromotionTerm?: IntNullableFilter<"pricedetailtb"> | number | null
    FreeMoney?: IntNullableFilter<"pricedetailtb"> | number | null
    FreeTime?: IntNullableFilter<"pricedetailtb"> | number | null
    BeginTime?: IntNullableFilter<"pricedetailtb"> | number | null
    EndTime?: IntNullableFilter<"pricedetailtb"> | number | null
    Term?: IntNullableFilter<"pricedetailtb"> | number | null
    PromotionOrder?: IntNullableFilter<"pricedetailtb"> | number | null
    BeginDate?: DateTimeNullableFilter<"pricedetailtb"> | Date | string | null
    EndDate?: DateTimeNullableFilter<"pricedetailtb"> | Date | string | null
    DayOfWeekMask?: IntFilter<"pricedetailtb"> | number
    PromotionType?: IntFilter<"pricedetailtb"> | number
  }, "PriceDetailId">

  export type pricedetailtbOrderByWithAggregationInput = {
    PriceDetailId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrderInput | SortOrder
    Price?: SortOrderInput | SortOrder
    Promotion?: SortOrderInput | SortOrder
    PromotionTerm?: SortOrderInput | SortOrder
    FreeMoney?: SortOrderInput | SortOrder
    FreeTime?: SortOrderInput | SortOrder
    BeginTime?: SortOrderInput | SortOrder
    EndTime?: SortOrderInput | SortOrder
    Term?: SortOrderInput | SortOrder
    PromotionOrder?: SortOrderInput | SortOrder
    BeginDate?: SortOrderInput | SortOrder
    EndDate?: SortOrderInput | SortOrder
    DayOfWeekMask?: SortOrder
    PromotionType?: SortOrder
    _count?: pricedetailtbCountOrderByAggregateInput
    _avg?: pricedetailtbAvgOrderByAggregateInput
    _max?: pricedetailtbMaxOrderByAggregateInput
    _min?: pricedetailtbMinOrderByAggregateInput
    _sum?: pricedetailtbSumOrderByAggregateInput
  }

  export type pricedetailtbScalarWhereWithAggregatesInput = {
    AND?: pricedetailtbScalarWhereWithAggregatesInput | pricedetailtbScalarWhereWithAggregatesInput[]
    OR?: pricedetailtbScalarWhereWithAggregatesInput[]
    NOT?: pricedetailtbScalarWhereWithAggregatesInput | pricedetailtbScalarWhereWithAggregatesInput[]
    PriceDetailId?: IntWithAggregatesFilter<"pricedetailtb"> | number
    PriceId?: IntWithAggregatesFilter<"pricedetailtb"> | number
    MachineGroupId?: IntNullableWithAggregatesFilter<"pricedetailtb"> | number | null
    Price?: DecimalNullableWithAggregatesFilter<"pricedetailtb"> | Decimal | DecimalJsLike | number | string | null
    Promotion?: IntNullableWithAggregatesFilter<"pricedetailtb"> | number | null
    PromotionTerm?: IntNullableWithAggregatesFilter<"pricedetailtb"> | number | null
    FreeMoney?: IntNullableWithAggregatesFilter<"pricedetailtb"> | number | null
    FreeTime?: IntNullableWithAggregatesFilter<"pricedetailtb"> | number | null
    BeginTime?: IntNullableWithAggregatesFilter<"pricedetailtb"> | number | null
    EndTime?: IntNullableWithAggregatesFilter<"pricedetailtb"> | number | null
    Term?: IntNullableWithAggregatesFilter<"pricedetailtb"> | number | null
    PromotionOrder?: IntNullableWithAggregatesFilter<"pricedetailtb"> | number | null
    BeginDate?: DateTimeNullableWithAggregatesFilter<"pricedetailtb"> | Date | string | null
    EndDate?: DateTimeNullableWithAggregatesFilter<"pricedetailtb"> | Date | string | null
    DayOfWeekMask?: IntWithAggregatesFilter<"pricedetailtb"> | number
    PromotionType?: IntWithAggregatesFilter<"pricedetailtb"> | number
  }

  export type pricelisttbWhereInput = {
    AND?: pricelisttbWhereInput | pricelisttbWhereInput[]
    OR?: pricelisttbWhereInput[]
    NOT?: pricelisttbWhereInput | pricelisttbWhereInput[]
    PriceId?: IntFilter<"pricelisttb"> | number
    PriceType?: StringFilter<"pricelisttb"> | string
    Price?: DecimalFilter<"pricelisttb"> | Decimal | DecimalJsLike | number | string
    Type?: IntFilter<"pricelisttb"> | number
    Active?: IntNullableFilter<"pricelisttb"> | number | null
  }

  export type pricelisttbOrderByWithRelationInput = {
    PriceId?: SortOrder
    PriceType?: SortOrder
    Price?: SortOrder
    Type?: SortOrder
    Active?: SortOrderInput | SortOrder
  }

  export type pricelisttbWhereUniqueInput = Prisma.AtLeast<{
    PriceId?: number
    PriceType?: string
    AND?: pricelisttbWhereInput | pricelisttbWhereInput[]
    OR?: pricelisttbWhereInput[]
    NOT?: pricelisttbWhereInput | pricelisttbWhereInput[]
    Price?: DecimalFilter<"pricelisttb"> | Decimal | DecimalJsLike | number | string
    Type?: IntFilter<"pricelisttb"> | number
    Active?: IntNullableFilter<"pricelisttb"> | number | null
  }, "PriceId" | "PriceType">

  export type pricelisttbOrderByWithAggregationInput = {
    PriceId?: SortOrder
    PriceType?: SortOrder
    Price?: SortOrder
    Type?: SortOrder
    Active?: SortOrderInput | SortOrder
    _count?: pricelisttbCountOrderByAggregateInput
    _avg?: pricelisttbAvgOrderByAggregateInput
    _max?: pricelisttbMaxOrderByAggregateInput
    _min?: pricelisttbMinOrderByAggregateInput
    _sum?: pricelisttbSumOrderByAggregateInput
  }

  export type pricelisttbScalarWhereWithAggregatesInput = {
    AND?: pricelisttbScalarWhereWithAggregatesInput | pricelisttbScalarWhereWithAggregatesInput[]
    OR?: pricelisttbScalarWhereWithAggregatesInput[]
    NOT?: pricelisttbScalarWhereWithAggregatesInput | pricelisttbScalarWhereWithAggregatesInput[]
    PriceId?: IntWithAggregatesFilter<"pricelisttb"> | number
    PriceType?: StringWithAggregatesFilter<"pricelisttb"> | string
    Price?: DecimalWithAggregatesFilter<"pricelisttb"> | Decimal | DecimalJsLike | number | string
    Type?: IntWithAggregatesFilter<"pricelisttb"> | number
    Active?: IntNullableWithAggregatesFilter<"pricelisttb"> | number | null
  }

  export type pricemachinetbWhereInput = {
    AND?: pricemachinetbWhereInput | pricemachinetbWhereInput[]
    OR?: pricemachinetbWhereInput[]
    NOT?: pricemachinetbWhereInput | pricemachinetbWhereInput[]
    PriceMachineId?: IntFilter<"pricemachinetb"> | number
    PriceId?: IntFilter<"pricemachinetb"> | number
    MachineGroupId?: IntFilter<"pricemachinetb"> | number
    Price?: DecimalFilter<"pricemachinetb"> | Decimal | DecimalJsLike | number | string
  }

  export type pricemachinetbOrderByWithRelationInput = {
    PriceMachineId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
  }

  export type pricemachinetbWhereUniqueInput = Prisma.AtLeast<{
    PriceMachineId?: number
    AND?: pricemachinetbWhereInput | pricemachinetbWhereInput[]
    OR?: pricemachinetbWhereInput[]
    NOT?: pricemachinetbWhereInput | pricemachinetbWhereInput[]
    PriceId?: IntFilter<"pricemachinetb"> | number
    MachineGroupId?: IntFilter<"pricemachinetb"> | number
    Price?: DecimalFilter<"pricemachinetb"> | Decimal | DecimalJsLike | number | string
  }, "PriceMachineId">

  export type pricemachinetbOrderByWithAggregationInput = {
    PriceMachineId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
    _count?: pricemachinetbCountOrderByAggregateInput
    _avg?: pricemachinetbAvgOrderByAggregateInput
    _max?: pricemachinetbMaxOrderByAggregateInput
    _min?: pricemachinetbMinOrderByAggregateInput
    _sum?: pricemachinetbSumOrderByAggregateInput
  }

  export type pricemachinetbScalarWhereWithAggregatesInput = {
    AND?: pricemachinetbScalarWhereWithAggregatesInput | pricemachinetbScalarWhereWithAggregatesInput[]
    OR?: pricemachinetbScalarWhereWithAggregatesInput[]
    NOT?: pricemachinetbScalarWhereWithAggregatesInput | pricemachinetbScalarWhereWithAggregatesInput[]
    PriceMachineId?: IntWithAggregatesFilter<"pricemachinetb"> | number
    PriceId?: IntWithAggregatesFilter<"pricemachinetb"> | number
    MachineGroupId?: IntWithAggregatesFilter<"pricemachinetb"> | number
    Price?: DecimalWithAggregatesFilter<"pricemachinetb"> | Decimal | DecimalJsLike | number | string
  }

  export type printertbWhereInput = {
    AND?: printertbWhereInput | printertbWhereInput[]
    OR?: printertbWhereInput[]
    NOT?: printertbWhereInput | printertbWhereInput[]
    ID?: IntFilter<"printertb"> | number
    PrinterName?: StringFilter<"printertb"> | string
    Type?: IntFilter<"printertb"> | number
    Active?: IntFilter<"printertb"> | number
  }

  export type printertbOrderByWithRelationInput = {
    ID?: SortOrder
    PrinterName?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type printertbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: printertbWhereInput | printertbWhereInput[]
    OR?: printertbWhereInput[]
    NOT?: printertbWhereInput | printertbWhereInput[]
    PrinterName?: StringFilter<"printertb"> | string
    Type?: IntFilter<"printertb"> | number
    Active?: IntFilter<"printertb"> | number
  }, "ID">

  export type printertbOrderByWithAggregationInput = {
    ID?: SortOrder
    PrinterName?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
    _count?: printertbCountOrderByAggregateInput
    _avg?: printertbAvgOrderByAggregateInput
    _max?: printertbMaxOrderByAggregateInput
    _min?: printertbMinOrderByAggregateInput
    _sum?: printertbSumOrderByAggregateInput
  }

  export type printertbScalarWhereWithAggregatesInput = {
    AND?: printertbScalarWhereWithAggregatesInput | printertbScalarWhereWithAggregatesInput[]
    OR?: printertbScalarWhereWithAggregatesInput[]
    NOT?: printertbScalarWhereWithAggregatesInput | printertbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"printertb"> | number
    PrinterName?: StringWithAggregatesFilter<"printertb"> | string
    Type?: IntWithAggregatesFilter<"printertb"> | number
    Active?: IntWithAggregatesFilter<"printertb"> | number
  }

  export type printservicetbWhereInput = {
    AND?: printservicetbWhereInput | printservicetbWhereInput[]
    OR?: printservicetbWhereInput[]
    NOT?: printservicetbWhereInput | printservicetbWhereInput[]
    ID?: IntFilter<"printservicetb"> | number
    PrinterID?: IntFilter<"printservicetb"> | number
    ServiceID?: IntFilter<"printservicetb"> | number
  }

  export type printservicetbOrderByWithRelationInput = {
    ID?: SortOrder
    PrinterID?: SortOrder
    ServiceID?: SortOrder
  }

  export type printservicetbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: printservicetbWhereInput | printservicetbWhereInput[]
    OR?: printservicetbWhereInput[]
    NOT?: printservicetbWhereInput | printservicetbWhereInput[]
    PrinterID?: IntFilter<"printservicetb"> | number
    ServiceID?: IntFilter<"printservicetb"> | number
  }, "ID">

  export type printservicetbOrderByWithAggregationInput = {
    ID?: SortOrder
    PrinterID?: SortOrder
    ServiceID?: SortOrder
    _count?: printservicetbCountOrderByAggregateInput
    _avg?: printservicetbAvgOrderByAggregateInput
    _max?: printservicetbMaxOrderByAggregateInput
    _min?: printservicetbMinOrderByAggregateInput
    _sum?: printservicetbSumOrderByAggregateInput
  }

  export type printservicetbScalarWhereWithAggregatesInput = {
    AND?: printservicetbScalarWhereWithAggregatesInput | printservicetbScalarWhereWithAggregatesInput[]
    OR?: printservicetbScalarWhereWithAggregatesInput[]
    NOT?: printservicetbScalarWhereWithAggregatesInput | printservicetbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"printservicetb"> | number
    PrinterID?: IntWithAggregatesFilter<"printservicetb"> | number
    ServiceID?: IntWithAggregatesFilter<"printservicetb"> | number
  }

  export type processtbWhereInput = {
    AND?: processtbWhereInput | processtbWhereInput[]
    OR?: processtbWhereInput[]
    NOT?: processtbWhereInput | processtbWhereInput[]
    ID?: IntFilter<"processtb"> | number
    MachineName?: StringFilter<"processtb"> | string
    ProcessName?: StringFilter<"processtb"> | string
    FileLocation?: StringFilter<"processtb"> | string
    FileDescription?: StringFilter<"processtb"> | string
    Type?: IntFilter<"processtb"> | number
    PreviousDate?: DateTimeFilter<"processtb"> | Date | string
    CurrentDate?: DateTimeFilter<"processtb"> | Date | string
  }

  export type processtbOrderByWithRelationInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    ProcessName?: SortOrder
    FileLocation?: SortOrder
    FileDescription?: SortOrder
    Type?: SortOrder
    PreviousDate?: SortOrder
    CurrentDate?: SortOrder
  }

  export type processtbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: processtbWhereInput | processtbWhereInput[]
    OR?: processtbWhereInput[]
    NOT?: processtbWhereInput | processtbWhereInput[]
    MachineName?: StringFilter<"processtb"> | string
    ProcessName?: StringFilter<"processtb"> | string
    FileLocation?: StringFilter<"processtb"> | string
    FileDescription?: StringFilter<"processtb"> | string
    Type?: IntFilter<"processtb"> | number
    PreviousDate?: DateTimeFilter<"processtb"> | Date | string
    CurrentDate?: DateTimeFilter<"processtb"> | Date | string
  }, "ID">

  export type processtbOrderByWithAggregationInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    ProcessName?: SortOrder
    FileLocation?: SortOrder
    FileDescription?: SortOrder
    Type?: SortOrder
    PreviousDate?: SortOrder
    CurrentDate?: SortOrder
    _count?: processtbCountOrderByAggregateInput
    _avg?: processtbAvgOrderByAggregateInput
    _max?: processtbMaxOrderByAggregateInput
    _min?: processtbMinOrderByAggregateInput
    _sum?: processtbSumOrderByAggregateInput
  }

  export type processtbScalarWhereWithAggregatesInput = {
    AND?: processtbScalarWhereWithAggregatesInput | processtbScalarWhereWithAggregatesInput[]
    OR?: processtbScalarWhereWithAggregatesInput[]
    NOT?: processtbScalarWhereWithAggregatesInput | processtbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"processtb"> | number
    MachineName?: StringWithAggregatesFilter<"processtb"> | string
    ProcessName?: StringWithAggregatesFilter<"processtb"> | string
    FileLocation?: StringWithAggregatesFilter<"processtb"> | string
    FileDescription?: StringWithAggregatesFilter<"processtb"> | string
    Type?: IntWithAggregatesFilter<"processtb"> | number
    PreviousDate?: DateTimeWithAggregatesFilter<"processtb"> | Date | string
    CurrentDate?: DateTimeWithAggregatesFilter<"processtb"> | Date | string
  }

  export type rechargecarddetailtbWhereInput = {
    AND?: rechargecarddetailtbWhereInput | rechargecarddetailtbWhereInput[]
    OR?: rechargecarddetailtbWhereInput[]
    NOT?: rechargecarddetailtbWhereInput | rechargecarddetailtbWhereInput[]
    CardDetailId?: IntFilter<"rechargecarddetailtb"> | number
    VoucherId?: IntFilter<"rechargecarddetailtb"> | number
    StaffId?: IntFilter<"rechargecarddetailtb"> | number
    CardValue?: DecimalFilter<"rechargecarddetailtb"> | Decimal | DecimalJsLike | number | string
    CardDate?: DateTimeFilter<"rechargecarddetailtb"> | Date | string
    CardTime?: DateTimeFilter<"rechargecarddetailtb"> | Date | string
    CardQuantity?: IntFilter<"rechargecarddetailtb"> | number
    CardAmount?: DecimalFilter<"rechargecarddetailtb"> | Decimal | DecimalJsLike | number | string
    UserId?: IntNullableFilter<"rechargecarddetailtb"> | number | null
    Accept?: BoolNullableFilter<"rechargecarddetailtb"> | boolean | null
  }

  export type rechargecarddetailtbOrderByWithRelationInput = {
    CardDetailId?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    CardValue?: SortOrder
    CardDate?: SortOrder
    CardTime?: SortOrder
    CardQuantity?: SortOrder
    CardAmount?: SortOrder
    UserId?: SortOrderInput | SortOrder
    Accept?: SortOrderInput | SortOrder
  }

  export type rechargecarddetailtbWhereUniqueInput = Prisma.AtLeast<{
    CardDetailId?: number
    AND?: rechargecarddetailtbWhereInput | rechargecarddetailtbWhereInput[]
    OR?: rechargecarddetailtbWhereInput[]
    NOT?: rechargecarddetailtbWhereInput | rechargecarddetailtbWhereInput[]
    VoucherId?: IntFilter<"rechargecarddetailtb"> | number
    StaffId?: IntFilter<"rechargecarddetailtb"> | number
    CardValue?: DecimalFilter<"rechargecarddetailtb"> | Decimal | DecimalJsLike | number | string
    CardDate?: DateTimeFilter<"rechargecarddetailtb"> | Date | string
    CardTime?: DateTimeFilter<"rechargecarddetailtb"> | Date | string
    CardQuantity?: IntFilter<"rechargecarddetailtb"> | number
    CardAmount?: DecimalFilter<"rechargecarddetailtb"> | Decimal | DecimalJsLike | number | string
    UserId?: IntNullableFilter<"rechargecarddetailtb"> | number | null
    Accept?: BoolNullableFilter<"rechargecarddetailtb"> | boolean | null
  }, "CardDetailId">

  export type rechargecarddetailtbOrderByWithAggregationInput = {
    CardDetailId?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    CardValue?: SortOrder
    CardDate?: SortOrder
    CardTime?: SortOrder
    CardQuantity?: SortOrder
    CardAmount?: SortOrder
    UserId?: SortOrderInput | SortOrder
    Accept?: SortOrderInput | SortOrder
    _count?: rechargecarddetailtbCountOrderByAggregateInput
    _avg?: rechargecarddetailtbAvgOrderByAggregateInput
    _max?: rechargecarddetailtbMaxOrderByAggregateInput
    _min?: rechargecarddetailtbMinOrderByAggregateInput
    _sum?: rechargecarddetailtbSumOrderByAggregateInput
  }

  export type rechargecarddetailtbScalarWhereWithAggregatesInput = {
    AND?: rechargecarddetailtbScalarWhereWithAggregatesInput | rechargecarddetailtbScalarWhereWithAggregatesInput[]
    OR?: rechargecarddetailtbScalarWhereWithAggregatesInput[]
    NOT?: rechargecarddetailtbScalarWhereWithAggregatesInput | rechargecarddetailtbScalarWhereWithAggregatesInput[]
    CardDetailId?: IntWithAggregatesFilter<"rechargecarddetailtb"> | number
    VoucherId?: IntWithAggregatesFilter<"rechargecarddetailtb"> | number
    StaffId?: IntWithAggregatesFilter<"rechargecarddetailtb"> | number
    CardValue?: DecimalWithAggregatesFilter<"rechargecarddetailtb"> | Decimal | DecimalJsLike | number | string
    CardDate?: DateTimeWithAggregatesFilter<"rechargecarddetailtb"> | Date | string
    CardTime?: DateTimeWithAggregatesFilter<"rechargecarddetailtb"> | Date | string
    CardQuantity?: IntWithAggregatesFilter<"rechargecarddetailtb"> | number
    CardAmount?: DecimalWithAggregatesFilter<"rechargecarddetailtb"> | Decimal | DecimalJsLike | number | string
    UserId?: IntNullableWithAggregatesFilter<"rechargecarddetailtb"> | number | null
    Accept?: BoolNullableWithAggregatesFilter<"rechargecarddetailtb"> | boolean | null
  }

  export type rechargecardtbWhereInput = {
    AND?: rechargecardtbWhereInput | rechargecardtbWhereInput[]
    OR?: rechargecardtbWhereInput[]
    NOT?: rechargecardtbWhereInput | rechargecardtbWhereInput[]
    CardId?: IntFilter<"rechargecardtb"> | number
    cardcode?: StringNullableFilter<"rechargecardtb"> | string | null
    CardValue?: DecimalFilter<"rechargecardtb"> | Decimal | DecimalJsLike | number | string
    ExpiryDate?: DateTimeFilter<"rechargecardtb"> | Date | string
    CreateDate?: DateTimeFilter<"rechargecardtb"> | Date | string
    CreateTime?: DateTimeFilter<"rechargecardtb"> | Date | string
    ModifyDate?: DateTimeNullableFilter<"rechargecardtb"> | Date | string | null
    ModifyTime?: DateTimeNullableFilter<"rechargecardtb"> | Date | string | null
    Status?: BoolNullableFilter<"rechargecardtb"> | boolean | null
    UserId?: IntNullableFilter<"rechargecardtb"> | number | null
    Note?: StringNullableFilter<"rechargecardtb"> | string | null
  }

  export type rechargecardtbOrderByWithRelationInput = {
    CardId?: SortOrder
    cardcode?: SortOrderInput | SortOrder
    CardValue?: SortOrder
    ExpiryDate?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    ModifyDate?: SortOrderInput | SortOrder
    ModifyTime?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    Note?: SortOrderInput | SortOrder
  }

  export type rechargecardtbWhereUniqueInput = Prisma.AtLeast<{
    CardId?: number
    AND?: rechargecardtbWhereInput | rechargecardtbWhereInput[]
    OR?: rechargecardtbWhereInput[]
    NOT?: rechargecardtbWhereInput | rechargecardtbWhereInput[]
    cardcode?: StringNullableFilter<"rechargecardtb"> | string | null
    CardValue?: DecimalFilter<"rechargecardtb"> | Decimal | DecimalJsLike | number | string
    ExpiryDate?: DateTimeFilter<"rechargecardtb"> | Date | string
    CreateDate?: DateTimeFilter<"rechargecardtb"> | Date | string
    CreateTime?: DateTimeFilter<"rechargecardtb"> | Date | string
    ModifyDate?: DateTimeNullableFilter<"rechargecardtb"> | Date | string | null
    ModifyTime?: DateTimeNullableFilter<"rechargecardtb"> | Date | string | null
    Status?: BoolNullableFilter<"rechargecardtb"> | boolean | null
    UserId?: IntNullableFilter<"rechargecardtb"> | number | null
    Note?: StringNullableFilter<"rechargecardtb"> | string | null
  }, "CardId">

  export type rechargecardtbOrderByWithAggregationInput = {
    CardId?: SortOrder
    cardcode?: SortOrderInput | SortOrder
    CardValue?: SortOrder
    ExpiryDate?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    ModifyDate?: SortOrderInput | SortOrder
    ModifyTime?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    UserId?: SortOrderInput | SortOrder
    Note?: SortOrderInput | SortOrder
    _count?: rechargecardtbCountOrderByAggregateInput
    _avg?: rechargecardtbAvgOrderByAggregateInput
    _max?: rechargecardtbMaxOrderByAggregateInput
    _min?: rechargecardtbMinOrderByAggregateInput
    _sum?: rechargecardtbSumOrderByAggregateInput
  }

  export type rechargecardtbScalarWhereWithAggregatesInput = {
    AND?: rechargecardtbScalarWhereWithAggregatesInput | rechargecardtbScalarWhereWithAggregatesInput[]
    OR?: rechargecardtbScalarWhereWithAggregatesInput[]
    NOT?: rechargecardtbScalarWhereWithAggregatesInput | rechargecardtbScalarWhereWithAggregatesInput[]
    CardId?: IntWithAggregatesFilter<"rechargecardtb"> | number
    cardcode?: StringNullableWithAggregatesFilter<"rechargecardtb"> | string | null
    CardValue?: DecimalWithAggregatesFilter<"rechargecardtb"> | Decimal | DecimalJsLike | number | string
    ExpiryDate?: DateTimeWithAggregatesFilter<"rechargecardtb"> | Date | string
    CreateDate?: DateTimeWithAggregatesFilter<"rechargecardtb"> | Date | string
    CreateTime?: DateTimeWithAggregatesFilter<"rechargecardtb"> | Date | string
    ModifyDate?: DateTimeNullableWithAggregatesFilter<"rechargecardtb"> | Date | string | null
    ModifyTime?: DateTimeNullableWithAggregatesFilter<"rechargecardtb"> | Date | string | null
    Status?: BoolNullableWithAggregatesFilter<"rechargecardtb"> | boolean | null
    UserId?: IntNullableWithAggregatesFilter<"rechargecardtb"> | number | null
    Note?: StringNullableWithAggregatesFilter<"rechargecardtb"> | string | null
  }

  export type reportdailyWhereInput = {
    AND?: reportdailyWhereInput | reportdailyWhereInput[]
    OR?: reportdailyWhereInput[]
    NOT?: reportdailyWhereInput | reportdailyWhereInput[]
    ymd?: IntFilter<"reportdaily"> | number
    prefix?: StringFilter<"reportdaily"> | string
    mode?: IntFilter<"reportdaily"> | number
    f1?: IntNullableFilter<"reportdaily"> | number | null
    f2?: IntNullableFilter<"reportdaily"> | number | null
    f3?: IntNullableFilter<"reportdaily"> | number | null
    f4?: IntNullableFilter<"reportdaily"> | number | null
    f5?: IntNullableFilter<"reportdaily"> | number | null
    f6?: IntNullableFilter<"reportdaily"> | number | null
    f7?: IntNullableFilter<"reportdaily"> | number | null
    f8?: IntNullableFilter<"reportdaily"> | number | null
    f9?: IntNullableFilter<"reportdaily"> | number | null
    f10?: StringNullableFilter<"reportdaily"> | string | null
    f11?: StringNullableFilter<"reportdaily"> | string | null
    f12?: StringNullableFilter<"reportdaily"> | string | null
    f13?: StringNullableFilter<"reportdaily"> | string | null
    f14?: StringNullableFilter<"reportdaily"> | string | null
    f15?: FloatNullableFilter<"reportdaily"> | number | null
    f16?: FloatNullableFilter<"reportdaily"> | number | null
    f17?: FloatNullableFilter<"reportdaily"> | number | null
    f18?: FloatNullableFilter<"reportdaily"> | number | null
    f19?: FloatNullableFilter<"reportdaily"> | number | null
    f20?: FloatNullableFilter<"reportdaily"> | number | null
    ext?: StringNullableFilter<"reportdaily"> | string | null
    hash?: StringNullableFilter<"reportdaily"> | string | null
    create_date?: DateTimeNullableFilter<"reportdaily"> | Date | string | null
    update_date?: DateTimeNullableFilter<"reportdaily"> | Date | string | null
  }

  export type reportdailyOrderByWithRelationInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrderInput | SortOrder
    f2?: SortOrderInput | SortOrder
    f3?: SortOrderInput | SortOrder
    f4?: SortOrderInput | SortOrder
    f5?: SortOrderInput | SortOrder
    f6?: SortOrderInput | SortOrder
    f7?: SortOrderInput | SortOrder
    f8?: SortOrderInput | SortOrder
    f9?: SortOrderInput | SortOrder
    f10?: SortOrderInput | SortOrder
    f11?: SortOrderInput | SortOrder
    f12?: SortOrderInput | SortOrder
    f13?: SortOrderInput | SortOrder
    f14?: SortOrderInput | SortOrder
    f15?: SortOrderInput | SortOrder
    f16?: SortOrderInput | SortOrder
    f17?: SortOrderInput | SortOrder
    f18?: SortOrderInput | SortOrder
    f19?: SortOrderInput | SortOrder
    f20?: SortOrderInput | SortOrder
    ext?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    create_date?: SortOrderInput | SortOrder
    update_date?: SortOrderInput | SortOrder
  }

  export type reportdailyWhereUniqueInput = Prisma.AtLeast<{
    ymd_prefix_mode?: reportdailyYmdPrefixModeCompoundUniqueInput
    AND?: reportdailyWhereInput | reportdailyWhereInput[]
    OR?: reportdailyWhereInput[]
    NOT?: reportdailyWhereInput | reportdailyWhereInput[]
    ymd?: IntFilter<"reportdaily"> | number
    prefix?: StringFilter<"reportdaily"> | string
    mode?: IntFilter<"reportdaily"> | number
    f1?: IntNullableFilter<"reportdaily"> | number | null
    f2?: IntNullableFilter<"reportdaily"> | number | null
    f3?: IntNullableFilter<"reportdaily"> | number | null
    f4?: IntNullableFilter<"reportdaily"> | number | null
    f5?: IntNullableFilter<"reportdaily"> | number | null
    f6?: IntNullableFilter<"reportdaily"> | number | null
    f7?: IntNullableFilter<"reportdaily"> | number | null
    f8?: IntNullableFilter<"reportdaily"> | number | null
    f9?: IntNullableFilter<"reportdaily"> | number | null
    f10?: StringNullableFilter<"reportdaily"> | string | null
    f11?: StringNullableFilter<"reportdaily"> | string | null
    f12?: StringNullableFilter<"reportdaily"> | string | null
    f13?: StringNullableFilter<"reportdaily"> | string | null
    f14?: StringNullableFilter<"reportdaily"> | string | null
    f15?: FloatNullableFilter<"reportdaily"> | number | null
    f16?: FloatNullableFilter<"reportdaily"> | number | null
    f17?: FloatNullableFilter<"reportdaily"> | number | null
    f18?: FloatNullableFilter<"reportdaily"> | number | null
    f19?: FloatNullableFilter<"reportdaily"> | number | null
    f20?: FloatNullableFilter<"reportdaily"> | number | null
    ext?: StringNullableFilter<"reportdaily"> | string | null
    hash?: StringNullableFilter<"reportdaily"> | string | null
    create_date?: DateTimeNullableFilter<"reportdaily"> | Date | string | null
    update_date?: DateTimeNullableFilter<"reportdaily"> | Date | string | null
  }, "ymd_prefix_mode">

  export type reportdailyOrderByWithAggregationInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrderInput | SortOrder
    f2?: SortOrderInput | SortOrder
    f3?: SortOrderInput | SortOrder
    f4?: SortOrderInput | SortOrder
    f5?: SortOrderInput | SortOrder
    f6?: SortOrderInput | SortOrder
    f7?: SortOrderInput | SortOrder
    f8?: SortOrderInput | SortOrder
    f9?: SortOrderInput | SortOrder
    f10?: SortOrderInput | SortOrder
    f11?: SortOrderInput | SortOrder
    f12?: SortOrderInput | SortOrder
    f13?: SortOrderInput | SortOrder
    f14?: SortOrderInput | SortOrder
    f15?: SortOrderInput | SortOrder
    f16?: SortOrderInput | SortOrder
    f17?: SortOrderInput | SortOrder
    f18?: SortOrderInput | SortOrder
    f19?: SortOrderInput | SortOrder
    f20?: SortOrderInput | SortOrder
    ext?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    create_date?: SortOrderInput | SortOrder
    update_date?: SortOrderInput | SortOrder
    _count?: reportdailyCountOrderByAggregateInput
    _avg?: reportdailyAvgOrderByAggregateInput
    _max?: reportdailyMaxOrderByAggregateInput
    _min?: reportdailyMinOrderByAggregateInput
    _sum?: reportdailySumOrderByAggregateInput
  }

  export type reportdailyScalarWhereWithAggregatesInput = {
    AND?: reportdailyScalarWhereWithAggregatesInput | reportdailyScalarWhereWithAggregatesInput[]
    OR?: reportdailyScalarWhereWithAggregatesInput[]
    NOT?: reportdailyScalarWhereWithAggregatesInput | reportdailyScalarWhereWithAggregatesInput[]
    ymd?: IntWithAggregatesFilter<"reportdaily"> | number
    prefix?: StringWithAggregatesFilter<"reportdaily"> | string
    mode?: IntWithAggregatesFilter<"reportdaily"> | number
    f1?: IntNullableWithAggregatesFilter<"reportdaily"> | number | null
    f2?: IntNullableWithAggregatesFilter<"reportdaily"> | number | null
    f3?: IntNullableWithAggregatesFilter<"reportdaily"> | number | null
    f4?: IntNullableWithAggregatesFilter<"reportdaily"> | number | null
    f5?: IntNullableWithAggregatesFilter<"reportdaily"> | number | null
    f6?: IntNullableWithAggregatesFilter<"reportdaily"> | number | null
    f7?: IntNullableWithAggregatesFilter<"reportdaily"> | number | null
    f8?: IntNullableWithAggregatesFilter<"reportdaily"> | number | null
    f9?: IntNullableWithAggregatesFilter<"reportdaily"> | number | null
    f10?: StringNullableWithAggregatesFilter<"reportdaily"> | string | null
    f11?: StringNullableWithAggregatesFilter<"reportdaily"> | string | null
    f12?: StringNullableWithAggregatesFilter<"reportdaily"> | string | null
    f13?: StringNullableWithAggregatesFilter<"reportdaily"> | string | null
    f14?: StringNullableWithAggregatesFilter<"reportdaily"> | string | null
    f15?: FloatNullableWithAggregatesFilter<"reportdaily"> | number | null
    f16?: FloatNullableWithAggregatesFilter<"reportdaily"> | number | null
    f17?: FloatNullableWithAggregatesFilter<"reportdaily"> | number | null
    f18?: FloatNullableWithAggregatesFilter<"reportdaily"> | number | null
    f19?: FloatNullableWithAggregatesFilter<"reportdaily"> | number | null
    f20?: FloatNullableWithAggregatesFilter<"reportdaily"> | number | null
    ext?: StringNullableWithAggregatesFilter<"reportdaily"> | string | null
    hash?: StringNullableWithAggregatesFilter<"reportdaily"> | string | null
    create_date?: DateTimeNullableWithAggregatesFilter<"reportdaily"> | Date | string | null
    update_date?: DateTimeNullableWithAggregatesFilter<"reportdaily"> | Date | string | null
  }

  export type reportmonthlyWhereInput = {
    AND?: reportmonthlyWhereInput | reportmonthlyWhereInput[]
    OR?: reportmonthlyWhereInput[]
    NOT?: reportmonthlyWhereInput | reportmonthlyWhereInput[]
    ymd?: IntFilter<"reportmonthly"> | number
    prefix?: StringFilter<"reportmonthly"> | string
    mode?: IntFilter<"reportmonthly"> | number
    f1?: IntNullableFilter<"reportmonthly"> | number | null
    f2?: IntNullableFilter<"reportmonthly"> | number | null
    f3?: IntNullableFilter<"reportmonthly"> | number | null
    f4?: IntNullableFilter<"reportmonthly"> | number | null
    f5?: IntNullableFilter<"reportmonthly"> | number | null
    f6?: IntNullableFilter<"reportmonthly"> | number | null
    f7?: IntNullableFilter<"reportmonthly"> | number | null
    f8?: IntNullableFilter<"reportmonthly"> | number | null
    f9?: IntNullableFilter<"reportmonthly"> | number | null
    f10?: StringNullableFilter<"reportmonthly"> | string | null
    f11?: StringNullableFilter<"reportmonthly"> | string | null
    f12?: StringNullableFilter<"reportmonthly"> | string | null
    f13?: StringNullableFilter<"reportmonthly"> | string | null
    f14?: StringNullableFilter<"reportmonthly"> | string | null
    f15?: FloatNullableFilter<"reportmonthly"> | number | null
    f16?: FloatNullableFilter<"reportmonthly"> | number | null
    f17?: FloatNullableFilter<"reportmonthly"> | number | null
    f18?: FloatNullableFilter<"reportmonthly"> | number | null
    f19?: FloatNullableFilter<"reportmonthly"> | number | null
    f20?: FloatNullableFilter<"reportmonthly"> | number | null
    ext?: StringNullableFilter<"reportmonthly"> | string | null
    hash?: StringNullableFilter<"reportmonthly"> | string | null
    create_date?: DateTimeNullableFilter<"reportmonthly"> | Date | string | null
    update_date?: DateTimeNullableFilter<"reportmonthly"> | Date | string | null
  }

  export type reportmonthlyOrderByWithRelationInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrderInput | SortOrder
    f2?: SortOrderInput | SortOrder
    f3?: SortOrderInput | SortOrder
    f4?: SortOrderInput | SortOrder
    f5?: SortOrderInput | SortOrder
    f6?: SortOrderInput | SortOrder
    f7?: SortOrderInput | SortOrder
    f8?: SortOrderInput | SortOrder
    f9?: SortOrderInput | SortOrder
    f10?: SortOrderInput | SortOrder
    f11?: SortOrderInput | SortOrder
    f12?: SortOrderInput | SortOrder
    f13?: SortOrderInput | SortOrder
    f14?: SortOrderInput | SortOrder
    f15?: SortOrderInput | SortOrder
    f16?: SortOrderInput | SortOrder
    f17?: SortOrderInput | SortOrder
    f18?: SortOrderInput | SortOrder
    f19?: SortOrderInput | SortOrder
    f20?: SortOrderInput | SortOrder
    ext?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    create_date?: SortOrderInput | SortOrder
    update_date?: SortOrderInput | SortOrder
  }

  export type reportmonthlyWhereUniqueInput = Prisma.AtLeast<{
    ymd_prefix_mode?: reportmonthlyYmdPrefixModeCompoundUniqueInput
    AND?: reportmonthlyWhereInput | reportmonthlyWhereInput[]
    OR?: reportmonthlyWhereInput[]
    NOT?: reportmonthlyWhereInput | reportmonthlyWhereInput[]
    ymd?: IntFilter<"reportmonthly"> | number
    prefix?: StringFilter<"reportmonthly"> | string
    mode?: IntFilter<"reportmonthly"> | number
    f1?: IntNullableFilter<"reportmonthly"> | number | null
    f2?: IntNullableFilter<"reportmonthly"> | number | null
    f3?: IntNullableFilter<"reportmonthly"> | number | null
    f4?: IntNullableFilter<"reportmonthly"> | number | null
    f5?: IntNullableFilter<"reportmonthly"> | number | null
    f6?: IntNullableFilter<"reportmonthly"> | number | null
    f7?: IntNullableFilter<"reportmonthly"> | number | null
    f8?: IntNullableFilter<"reportmonthly"> | number | null
    f9?: IntNullableFilter<"reportmonthly"> | number | null
    f10?: StringNullableFilter<"reportmonthly"> | string | null
    f11?: StringNullableFilter<"reportmonthly"> | string | null
    f12?: StringNullableFilter<"reportmonthly"> | string | null
    f13?: StringNullableFilter<"reportmonthly"> | string | null
    f14?: StringNullableFilter<"reportmonthly"> | string | null
    f15?: FloatNullableFilter<"reportmonthly"> | number | null
    f16?: FloatNullableFilter<"reportmonthly"> | number | null
    f17?: FloatNullableFilter<"reportmonthly"> | number | null
    f18?: FloatNullableFilter<"reportmonthly"> | number | null
    f19?: FloatNullableFilter<"reportmonthly"> | number | null
    f20?: FloatNullableFilter<"reportmonthly"> | number | null
    ext?: StringNullableFilter<"reportmonthly"> | string | null
    hash?: StringNullableFilter<"reportmonthly"> | string | null
    create_date?: DateTimeNullableFilter<"reportmonthly"> | Date | string | null
    update_date?: DateTimeNullableFilter<"reportmonthly"> | Date | string | null
  }, "ymd_prefix_mode">

  export type reportmonthlyOrderByWithAggregationInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrderInput | SortOrder
    f2?: SortOrderInput | SortOrder
    f3?: SortOrderInput | SortOrder
    f4?: SortOrderInput | SortOrder
    f5?: SortOrderInput | SortOrder
    f6?: SortOrderInput | SortOrder
    f7?: SortOrderInput | SortOrder
    f8?: SortOrderInput | SortOrder
    f9?: SortOrderInput | SortOrder
    f10?: SortOrderInput | SortOrder
    f11?: SortOrderInput | SortOrder
    f12?: SortOrderInput | SortOrder
    f13?: SortOrderInput | SortOrder
    f14?: SortOrderInput | SortOrder
    f15?: SortOrderInput | SortOrder
    f16?: SortOrderInput | SortOrder
    f17?: SortOrderInput | SortOrder
    f18?: SortOrderInput | SortOrder
    f19?: SortOrderInput | SortOrder
    f20?: SortOrderInput | SortOrder
    ext?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    create_date?: SortOrderInput | SortOrder
    update_date?: SortOrderInput | SortOrder
    _count?: reportmonthlyCountOrderByAggregateInput
    _avg?: reportmonthlyAvgOrderByAggregateInput
    _max?: reportmonthlyMaxOrderByAggregateInput
    _min?: reportmonthlyMinOrderByAggregateInput
    _sum?: reportmonthlySumOrderByAggregateInput
  }

  export type reportmonthlyScalarWhereWithAggregatesInput = {
    AND?: reportmonthlyScalarWhereWithAggregatesInput | reportmonthlyScalarWhereWithAggregatesInput[]
    OR?: reportmonthlyScalarWhereWithAggregatesInput[]
    NOT?: reportmonthlyScalarWhereWithAggregatesInput | reportmonthlyScalarWhereWithAggregatesInput[]
    ymd?: IntWithAggregatesFilter<"reportmonthly"> | number
    prefix?: StringWithAggregatesFilter<"reportmonthly"> | string
    mode?: IntWithAggregatesFilter<"reportmonthly"> | number
    f1?: IntNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f2?: IntNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f3?: IntNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f4?: IntNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f5?: IntNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f6?: IntNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f7?: IntNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f8?: IntNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f9?: IntNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f10?: StringNullableWithAggregatesFilter<"reportmonthly"> | string | null
    f11?: StringNullableWithAggregatesFilter<"reportmonthly"> | string | null
    f12?: StringNullableWithAggregatesFilter<"reportmonthly"> | string | null
    f13?: StringNullableWithAggregatesFilter<"reportmonthly"> | string | null
    f14?: StringNullableWithAggregatesFilter<"reportmonthly"> | string | null
    f15?: FloatNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f16?: FloatNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f17?: FloatNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f18?: FloatNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f19?: FloatNullableWithAggregatesFilter<"reportmonthly"> | number | null
    f20?: FloatNullableWithAggregatesFilter<"reportmonthly"> | number | null
    ext?: StringNullableWithAggregatesFilter<"reportmonthly"> | string | null
    hash?: StringNullableWithAggregatesFilter<"reportmonthly"> | string | null
    create_date?: DateTimeNullableWithAggregatesFilter<"reportmonthly"> | Date | string | null
    update_date?: DateTimeNullableWithAggregatesFilter<"reportmonthly"> | Date | string | null
  }

  export type righttbWhereInput = {
    AND?: righttbWhereInput | righttbWhereInput[]
    OR?: righttbWhereInput[]
    NOT?: righttbWhereInput | righttbWhereInput[]
    RightId?: IntFilter<"righttb"> | number
    UserId?: IntFilter<"righttb"> | number
    FunctionCode?: StringFilter<"righttb"> | string
  }

  export type righttbOrderByWithRelationInput = {
    RightId?: SortOrder
    UserId?: SortOrder
    FunctionCode?: SortOrder
  }

  export type righttbWhereUniqueInput = Prisma.AtLeast<{
    RightId?: number
    UserId_FunctionCode?: righttbUserIdFunctionCodeCompoundUniqueInput
    AND?: righttbWhereInput | righttbWhereInput[]
    OR?: righttbWhereInput[]
    NOT?: righttbWhereInput | righttbWhereInput[]
    UserId?: IntFilter<"righttb"> | number
    FunctionCode?: StringFilter<"righttb"> | string
  }, "RightId" | "UserId_FunctionCode">

  export type righttbOrderByWithAggregationInput = {
    RightId?: SortOrder
    UserId?: SortOrder
    FunctionCode?: SortOrder
    _count?: righttbCountOrderByAggregateInput
    _avg?: righttbAvgOrderByAggregateInput
    _max?: righttbMaxOrderByAggregateInput
    _min?: righttbMinOrderByAggregateInput
    _sum?: righttbSumOrderByAggregateInput
  }

  export type righttbScalarWhereWithAggregatesInput = {
    AND?: righttbScalarWhereWithAggregatesInput | righttbScalarWhereWithAggregatesInput[]
    OR?: righttbScalarWhereWithAggregatesInput[]
    NOT?: righttbScalarWhereWithAggregatesInput | righttbScalarWhereWithAggregatesInput[]
    RightId?: IntWithAggregatesFilter<"righttb"> | number
    UserId?: IntWithAggregatesFilter<"righttb"> | number
    FunctionCode?: StringWithAggregatesFilter<"righttb"> | string
  }

  export type serverlogtbWhereInput = {
    AND?: serverlogtbWhereInput | serverlogtbWhereInput[]
    OR?: serverlogtbWhereInput[]
    NOT?: serverlogtbWhereInput | serverlogtbWhereInput[]
    ServerLogId?: IntFilter<"serverlogtb"> | number
    Status?: StringFilter<"serverlogtb"> | string
    RecordDate?: DateTimeFilter<"serverlogtb"> | Date | string
    RecordTime?: DateTimeFilter<"serverlogtb"> | Date | string
    Period?: IntFilter<"serverlogtb"> | number
    Note?: StringNullableFilter<"serverlogtb"> | string | null
  }

  export type serverlogtbOrderByWithRelationInput = {
    ServerLogId?: SortOrder
    Status?: SortOrder
    RecordDate?: SortOrder
    RecordTime?: SortOrder
    Period?: SortOrder
    Note?: SortOrderInput | SortOrder
  }

  export type serverlogtbWhereUniqueInput = Prisma.AtLeast<{
    ServerLogId?: number
    AND?: serverlogtbWhereInput | serverlogtbWhereInput[]
    OR?: serverlogtbWhereInput[]
    NOT?: serverlogtbWhereInput | serverlogtbWhereInput[]
    Status?: StringFilter<"serverlogtb"> | string
    RecordDate?: DateTimeFilter<"serverlogtb"> | Date | string
    RecordTime?: DateTimeFilter<"serverlogtb"> | Date | string
    Period?: IntFilter<"serverlogtb"> | number
    Note?: StringNullableFilter<"serverlogtb"> | string | null
  }, "ServerLogId">

  export type serverlogtbOrderByWithAggregationInput = {
    ServerLogId?: SortOrder
    Status?: SortOrder
    RecordDate?: SortOrder
    RecordTime?: SortOrder
    Period?: SortOrder
    Note?: SortOrderInput | SortOrder
    _count?: serverlogtbCountOrderByAggregateInput
    _avg?: serverlogtbAvgOrderByAggregateInput
    _max?: serverlogtbMaxOrderByAggregateInput
    _min?: serverlogtbMinOrderByAggregateInput
    _sum?: serverlogtbSumOrderByAggregateInput
  }

  export type serverlogtbScalarWhereWithAggregatesInput = {
    AND?: serverlogtbScalarWhereWithAggregatesInput | serverlogtbScalarWhereWithAggregatesInput[]
    OR?: serverlogtbScalarWhereWithAggregatesInput[]
    NOT?: serverlogtbScalarWhereWithAggregatesInput | serverlogtbScalarWhereWithAggregatesInput[]
    ServerLogId?: IntWithAggregatesFilter<"serverlogtb"> | number
    Status?: StringWithAggregatesFilter<"serverlogtb"> | string
    RecordDate?: DateTimeWithAggregatesFilter<"serverlogtb"> | Date | string
    RecordTime?: DateTimeWithAggregatesFilter<"serverlogtb"> | Date | string
    Period?: IntWithAggregatesFilter<"serverlogtb"> | number
    Note?: StringNullableWithAggregatesFilter<"serverlogtb"> | string | null
  }

  export type servicedetailtbWhereInput = {
    AND?: servicedetailtbWhereInput | servicedetailtbWhereInput[]
    OR?: servicedetailtbWhereInput[]
    NOT?: servicedetailtbWhereInput | servicedetailtbWhereInput[]
    ServiceDetailId?: IntFilter<"servicedetailtb"> | number
    UserId?: IntFilter<"servicedetailtb"> | number
    ServiceId?: IntFilter<"servicedetailtb"> | number
    ServiceDate?: DateTimeFilter<"servicedetailtb"> | Date | string
    ServiceTime?: DateTimeFilter<"servicedetailtb"> | Date | string
    ServiceQuantity?: IntFilter<"servicedetailtb"> | number
    ServiceAmount?: DecimalFilter<"servicedetailtb"> | Decimal | DecimalJsLike | number | string
    ServicePaid?: BoolFilter<"servicedetailtb"> | boolean
    Accept?: BoolFilter<"servicedetailtb"> | boolean
    VoucherId?: IntNullableFilter<"servicedetailtb"> | number | null
    StaffId?: IntFilter<"servicedetailtb"> | number
    PaymentWaitId?: IntFilter<"servicedetailtb"> | number
    iCafeHash?: StringNullableFilter<"servicedetailtb"> | string | null
    iCafeUsr?: StringNullableFilter<"servicedetailtb"> | string | null
  }

  export type servicedetailtbOrderByWithRelationInput = {
    ServiceDetailId?: SortOrder
    UserId?: SortOrder
    ServiceId?: SortOrder
    ServiceDate?: SortOrder
    ServiceTime?: SortOrder
    ServiceQuantity?: SortOrder
    ServiceAmount?: SortOrder
    ServicePaid?: SortOrder
    Accept?: SortOrder
    VoucherId?: SortOrderInput | SortOrder
    StaffId?: SortOrder
    PaymentWaitId?: SortOrder
    iCafeHash?: SortOrderInput | SortOrder
    iCafeUsr?: SortOrderInput | SortOrder
  }

  export type servicedetailtbWhereUniqueInput = Prisma.AtLeast<{
    ServiceDetailId?: number
    AND?: servicedetailtbWhereInput | servicedetailtbWhereInput[]
    OR?: servicedetailtbWhereInput[]
    NOT?: servicedetailtbWhereInput | servicedetailtbWhereInput[]
    UserId?: IntFilter<"servicedetailtb"> | number
    ServiceId?: IntFilter<"servicedetailtb"> | number
    ServiceDate?: DateTimeFilter<"servicedetailtb"> | Date | string
    ServiceTime?: DateTimeFilter<"servicedetailtb"> | Date | string
    ServiceQuantity?: IntFilter<"servicedetailtb"> | number
    ServiceAmount?: DecimalFilter<"servicedetailtb"> | Decimal | DecimalJsLike | number | string
    ServicePaid?: BoolFilter<"servicedetailtb"> | boolean
    Accept?: BoolFilter<"servicedetailtb"> | boolean
    VoucherId?: IntNullableFilter<"servicedetailtb"> | number | null
    StaffId?: IntFilter<"servicedetailtb"> | number
    PaymentWaitId?: IntFilter<"servicedetailtb"> | number
    iCafeHash?: StringNullableFilter<"servicedetailtb"> | string | null
    iCafeUsr?: StringNullableFilter<"servicedetailtb"> | string | null
  }, "ServiceDetailId">

  export type servicedetailtbOrderByWithAggregationInput = {
    ServiceDetailId?: SortOrder
    UserId?: SortOrder
    ServiceId?: SortOrder
    ServiceDate?: SortOrder
    ServiceTime?: SortOrder
    ServiceQuantity?: SortOrder
    ServiceAmount?: SortOrder
    ServicePaid?: SortOrder
    Accept?: SortOrder
    VoucherId?: SortOrderInput | SortOrder
    StaffId?: SortOrder
    PaymentWaitId?: SortOrder
    iCafeHash?: SortOrderInput | SortOrder
    iCafeUsr?: SortOrderInput | SortOrder
    _count?: servicedetailtbCountOrderByAggregateInput
    _avg?: servicedetailtbAvgOrderByAggregateInput
    _max?: servicedetailtbMaxOrderByAggregateInput
    _min?: servicedetailtbMinOrderByAggregateInput
    _sum?: servicedetailtbSumOrderByAggregateInput
  }

  export type servicedetailtbScalarWhereWithAggregatesInput = {
    AND?: servicedetailtbScalarWhereWithAggregatesInput | servicedetailtbScalarWhereWithAggregatesInput[]
    OR?: servicedetailtbScalarWhereWithAggregatesInput[]
    NOT?: servicedetailtbScalarWhereWithAggregatesInput | servicedetailtbScalarWhereWithAggregatesInput[]
    ServiceDetailId?: IntWithAggregatesFilter<"servicedetailtb"> | number
    UserId?: IntWithAggregatesFilter<"servicedetailtb"> | number
    ServiceId?: IntWithAggregatesFilter<"servicedetailtb"> | number
    ServiceDate?: DateTimeWithAggregatesFilter<"servicedetailtb"> | Date | string
    ServiceTime?: DateTimeWithAggregatesFilter<"servicedetailtb"> | Date | string
    ServiceQuantity?: IntWithAggregatesFilter<"servicedetailtb"> | number
    ServiceAmount?: DecimalWithAggregatesFilter<"servicedetailtb"> | Decimal | DecimalJsLike | number | string
    ServicePaid?: BoolWithAggregatesFilter<"servicedetailtb"> | boolean
    Accept?: BoolWithAggregatesFilter<"servicedetailtb"> | boolean
    VoucherId?: IntNullableWithAggregatesFilter<"servicedetailtb"> | number | null
    StaffId?: IntWithAggregatesFilter<"servicedetailtb"> | number
    PaymentWaitId?: IntWithAggregatesFilter<"servicedetailtb"> | number
    iCafeHash?: StringNullableWithAggregatesFilter<"servicedetailtb"> | string | null
    iCafeUsr?: StringNullableWithAggregatesFilter<"servicedetailtb"> | string | null
  }

  export type servicegiftsbagWhereInput = {
    AND?: servicegiftsbagWhereInput | servicegiftsbagWhereInput[]
    OR?: servicegiftsbagWhereInput[]
    NOT?: servicegiftsbagWhereInput | servicegiftsbagWhereInput[]
    recId?: BigIntFilter<"servicegiftsbag"> | bigint | number
    recUuid?: StringFilter<"servicegiftsbag"> | string
    userId?: StringNullableFilter<"servicegiftsbag"> | string | null
    userName?: StringNullableFilter<"servicegiftsbag"> | string | null
    createDate?: DateTimeNullableFilter<"servicegiftsbag"> | Date | string | null
    expDate?: DateTimeNullableFilter<"servicegiftsbag"> | Date | string | null
    sourceType?: IntNullableFilter<"servicegiftsbag"> | number | null
    serviceId?: IntNullableFilter<"servicegiftsbag"> | number | null
    serviceName?: StringNullableFilter<"servicegiftsbag"> | string | null
    servicePrice?: IntNullableFilter<"servicegiftsbag"> | number | null
    serviceImg?: StringNullableFilter<"servicegiftsbag"> | string | null
    status?: IntNullableFilter<"servicegiftsbag"> | number | null
    requestDate?: DateTimeNullableFilter<"servicegiftsbag"> | Date | string | null
    acceptDate?: DateTimeNullableFilter<"servicegiftsbag"> | Date | string | null
    sign?: StringNullableFilter<"servicegiftsbag"> | string | null
    staffId?: IntNullableFilter<"servicegiftsbag"> | number | null
    staffName?: StringNullableFilter<"servicegiftsbag"> | string | null
    transId?: StringNullableFilter<"servicegiftsbag"> | string | null
    serialId?: StringNullableFilter<"servicegiftsbag"> | string | null
    ymd?: IntNullableFilter<"servicegiftsbag"> | number | null
    totalDay?: IntNullableFilter<"servicegiftsbag"> | number | null
    groupId?: IntNullableFilter<"servicegiftsbag"> | number | null
  }

  export type servicegiftsbagOrderByWithRelationInput = {
    recId?: SortOrder
    recUuid?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    expDate?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    serviceName?: SortOrderInput | SortOrder
    servicePrice?: SortOrderInput | SortOrder
    serviceImg?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    requestDate?: SortOrderInput | SortOrder
    acceptDate?: SortOrderInput | SortOrder
    sign?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    staffName?: SortOrderInput | SortOrder
    transId?: SortOrderInput | SortOrder
    serialId?: SortOrderInput | SortOrder
    ymd?: SortOrderInput | SortOrder
    totalDay?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
  }

  export type servicegiftsbagWhereUniqueInput = Prisma.AtLeast<{
    recUuid?: string
    AND?: servicegiftsbagWhereInput | servicegiftsbagWhereInput[]
    OR?: servicegiftsbagWhereInput[]
    NOT?: servicegiftsbagWhereInput | servicegiftsbagWhereInput[]
    recId?: BigIntFilter<"servicegiftsbag"> | bigint | number
    userId?: StringNullableFilter<"servicegiftsbag"> | string | null
    userName?: StringNullableFilter<"servicegiftsbag"> | string | null
    createDate?: DateTimeNullableFilter<"servicegiftsbag"> | Date | string | null
    expDate?: DateTimeNullableFilter<"servicegiftsbag"> | Date | string | null
    sourceType?: IntNullableFilter<"servicegiftsbag"> | number | null
    serviceId?: IntNullableFilter<"servicegiftsbag"> | number | null
    serviceName?: StringNullableFilter<"servicegiftsbag"> | string | null
    servicePrice?: IntNullableFilter<"servicegiftsbag"> | number | null
    serviceImg?: StringNullableFilter<"servicegiftsbag"> | string | null
    status?: IntNullableFilter<"servicegiftsbag"> | number | null
    requestDate?: DateTimeNullableFilter<"servicegiftsbag"> | Date | string | null
    acceptDate?: DateTimeNullableFilter<"servicegiftsbag"> | Date | string | null
    sign?: StringNullableFilter<"servicegiftsbag"> | string | null
    staffId?: IntNullableFilter<"servicegiftsbag"> | number | null
    staffName?: StringNullableFilter<"servicegiftsbag"> | string | null
    transId?: StringNullableFilter<"servicegiftsbag"> | string | null
    serialId?: StringNullableFilter<"servicegiftsbag"> | string | null
    ymd?: IntNullableFilter<"servicegiftsbag"> | number | null
    totalDay?: IntNullableFilter<"servicegiftsbag"> | number | null
    groupId?: IntNullableFilter<"servicegiftsbag"> | number | null
  }, "recUuid">

  export type servicegiftsbagOrderByWithAggregationInput = {
    recId?: SortOrder
    recUuid?: SortOrder
    userId?: SortOrderInput | SortOrder
    userName?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    expDate?: SortOrderInput | SortOrder
    sourceType?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    serviceName?: SortOrderInput | SortOrder
    servicePrice?: SortOrderInput | SortOrder
    serviceImg?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    requestDate?: SortOrderInput | SortOrder
    acceptDate?: SortOrderInput | SortOrder
    sign?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    staffName?: SortOrderInput | SortOrder
    transId?: SortOrderInput | SortOrder
    serialId?: SortOrderInput | SortOrder
    ymd?: SortOrderInput | SortOrder
    totalDay?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    _count?: servicegiftsbagCountOrderByAggregateInput
    _avg?: servicegiftsbagAvgOrderByAggregateInput
    _max?: servicegiftsbagMaxOrderByAggregateInput
    _min?: servicegiftsbagMinOrderByAggregateInput
    _sum?: servicegiftsbagSumOrderByAggregateInput
  }

  export type servicegiftsbagScalarWhereWithAggregatesInput = {
    AND?: servicegiftsbagScalarWhereWithAggregatesInput | servicegiftsbagScalarWhereWithAggregatesInput[]
    OR?: servicegiftsbagScalarWhereWithAggregatesInput[]
    NOT?: servicegiftsbagScalarWhereWithAggregatesInput | servicegiftsbagScalarWhereWithAggregatesInput[]
    recId?: BigIntWithAggregatesFilter<"servicegiftsbag"> | bigint | number
    recUuid?: StringWithAggregatesFilter<"servicegiftsbag"> | string
    userId?: StringNullableWithAggregatesFilter<"servicegiftsbag"> | string | null
    userName?: StringNullableWithAggregatesFilter<"servicegiftsbag"> | string | null
    createDate?: DateTimeNullableWithAggregatesFilter<"servicegiftsbag"> | Date | string | null
    expDate?: DateTimeNullableWithAggregatesFilter<"servicegiftsbag"> | Date | string | null
    sourceType?: IntNullableWithAggregatesFilter<"servicegiftsbag"> | number | null
    serviceId?: IntNullableWithAggregatesFilter<"servicegiftsbag"> | number | null
    serviceName?: StringNullableWithAggregatesFilter<"servicegiftsbag"> | string | null
    servicePrice?: IntNullableWithAggregatesFilter<"servicegiftsbag"> | number | null
    serviceImg?: StringNullableWithAggregatesFilter<"servicegiftsbag"> | string | null
    status?: IntNullableWithAggregatesFilter<"servicegiftsbag"> | number | null
    requestDate?: DateTimeNullableWithAggregatesFilter<"servicegiftsbag"> | Date | string | null
    acceptDate?: DateTimeNullableWithAggregatesFilter<"servicegiftsbag"> | Date | string | null
    sign?: StringNullableWithAggregatesFilter<"servicegiftsbag"> | string | null
    staffId?: IntNullableWithAggregatesFilter<"servicegiftsbag"> | number | null
    staffName?: StringNullableWithAggregatesFilter<"servicegiftsbag"> | string | null
    transId?: StringNullableWithAggregatesFilter<"servicegiftsbag"> | string | null
    serialId?: StringNullableWithAggregatesFilter<"servicegiftsbag"> | string | null
    ymd?: IntNullableWithAggregatesFilter<"servicegiftsbag"> | number | null
    totalDay?: IntNullableWithAggregatesFilter<"servicegiftsbag"> | number | null
    groupId?: IntNullableWithAggregatesFilter<"servicegiftsbag"> | number | null
  }

  export type servicegrouptbWhereInput = {
    AND?: servicegrouptbWhereInput | servicegrouptbWhereInput[]
    OR?: servicegrouptbWhereInput[]
    NOT?: servicegrouptbWhereInput | servicegrouptbWhereInput[]
    ID?: IntFilter<"servicegrouptb"> | number
    ServiceGroupName?: StringFilter<"servicegrouptb"> | string
    IsOrder?: IntFilter<"servicegrouptb"> | number
    Active?: IntNullableFilter<"servicegrouptb"> | number | null
    TypeID?: IntFilter<"servicegrouptb"> | number
  }

  export type servicegrouptbOrderByWithRelationInput = {
    ID?: SortOrder
    ServiceGroupName?: SortOrder
    IsOrder?: SortOrder
    Active?: SortOrderInput | SortOrder
    TypeID?: SortOrder
  }

  export type servicegrouptbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    ServiceGroupName?: string
    AND?: servicegrouptbWhereInput | servicegrouptbWhereInput[]
    OR?: servicegrouptbWhereInput[]
    NOT?: servicegrouptbWhereInput | servicegrouptbWhereInput[]
    IsOrder?: IntFilter<"servicegrouptb"> | number
    Active?: IntNullableFilter<"servicegrouptb"> | number | null
    TypeID?: IntFilter<"servicegrouptb"> | number
  }, "ID" | "ServiceGroupName">

  export type servicegrouptbOrderByWithAggregationInput = {
    ID?: SortOrder
    ServiceGroupName?: SortOrder
    IsOrder?: SortOrder
    Active?: SortOrderInput | SortOrder
    TypeID?: SortOrder
    _count?: servicegrouptbCountOrderByAggregateInput
    _avg?: servicegrouptbAvgOrderByAggregateInput
    _max?: servicegrouptbMaxOrderByAggregateInput
    _min?: servicegrouptbMinOrderByAggregateInput
    _sum?: servicegrouptbSumOrderByAggregateInput
  }

  export type servicegrouptbScalarWhereWithAggregatesInput = {
    AND?: servicegrouptbScalarWhereWithAggregatesInput | servicegrouptbScalarWhereWithAggregatesInput[]
    OR?: servicegrouptbScalarWhereWithAggregatesInput[]
    NOT?: servicegrouptbScalarWhereWithAggregatesInput | servicegrouptbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"servicegrouptb"> | number
    ServiceGroupName?: StringWithAggregatesFilter<"servicegrouptb"> | string
    IsOrder?: IntWithAggregatesFilter<"servicegrouptb"> | number
    Active?: IntNullableWithAggregatesFilter<"servicegrouptb"> | number | null
    TypeID?: IntWithAggregatesFilter<"servicegrouptb"> | number
  }

  export type serviceinfologtbWhereInput = {
    AND?: serviceinfologtbWhereInput | serviceinfologtbWhereInput[]
    OR?: serviceinfologtbWhereInput[]
    NOT?: serviceinfologtbWhereInput | serviceinfologtbWhereInput[]
    logId?: IntFilter<"serviceinfologtb"> | number
    serviceId?: IntNullableFilter<"serviceinfologtb"> | number | null
    prefix?: StringFilter<"serviceinfologtb"> | string
    info?: StringNullableFilter<"serviceinfologtb"> | string | null
    status?: IntNullableFilter<"serviceinfologtb"> | number | null
    createDate?: DateTimeNullableFilter<"serviceinfologtb"> | Date | string | null
    mode?: IntNullableFilter<"serviceinfologtb"> | number | null
    hash?: StringNullableFilter<"serviceinfologtb"> | string | null
  }

  export type serviceinfologtbOrderByWithRelationInput = {
    logId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    prefix?: SortOrder
    info?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
  }

  export type serviceinfologtbWhereUniqueInput = Prisma.AtLeast<{
    prefix?: string
    AND?: serviceinfologtbWhereInput | serviceinfologtbWhereInput[]
    OR?: serviceinfologtbWhereInput[]
    NOT?: serviceinfologtbWhereInput | serviceinfologtbWhereInput[]
    logId?: IntFilter<"serviceinfologtb"> | number
    serviceId?: IntNullableFilter<"serviceinfologtb"> | number | null
    info?: StringNullableFilter<"serviceinfologtb"> | string | null
    status?: IntNullableFilter<"serviceinfologtb"> | number | null
    createDate?: DateTimeNullableFilter<"serviceinfologtb"> | Date | string | null
    mode?: IntNullableFilter<"serviceinfologtb"> | number | null
    hash?: StringNullableFilter<"serviceinfologtb"> | string | null
  }, "prefix">

  export type serviceinfologtbOrderByWithAggregationInput = {
    logId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    prefix?: SortOrder
    info?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    _count?: serviceinfologtbCountOrderByAggregateInput
    _avg?: serviceinfologtbAvgOrderByAggregateInput
    _max?: serviceinfologtbMaxOrderByAggregateInput
    _min?: serviceinfologtbMinOrderByAggregateInput
    _sum?: serviceinfologtbSumOrderByAggregateInput
  }

  export type serviceinfologtbScalarWhereWithAggregatesInput = {
    AND?: serviceinfologtbScalarWhereWithAggregatesInput | serviceinfologtbScalarWhereWithAggregatesInput[]
    OR?: serviceinfologtbScalarWhereWithAggregatesInput[]
    NOT?: serviceinfologtbScalarWhereWithAggregatesInput | serviceinfologtbScalarWhereWithAggregatesInput[]
    logId?: IntWithAggregatesFilter<"serviceinfologtb"> | number
    serviceId?: IntNullableWithAggregatesFilter<"serviceinfologtb"> | number | null
    prefix?: StringWithAggregatesFilter<"serviceinfologtb"> | string
    info?: StringNullableWithAggregatesFilter<"serviceinfologtb"> | string | null
    status?: IntNullableWithAggregatesFilter<"serviceinfologtb"> | number | null
    createDate?: DateTimeNullableWithAggregatesFilter<"serviceinfologtb"> | Date | string | null
    mode?: IntNullableWithAggregatesFilter<"serviceinfologtb"> | number | null
    hash?: StringNullableWithAggregatesFilter<"serviceinfologtb"> | string | null
  }

  export type serviceinfotbWhereInput = {
    AND?: serviceinfotbWhereInput | serviceinfotbWhereInput[]
    OR?: serviceinfotbWhereInput[]
    NOT?: serviceinfotbWhereInput | serviceinfotbWhereInput[]
    serviceId?: IntFilter<"serviceinfotb"> | number
    prefix?: StringFilter<"serviceinfotb"> | string
    info?: StringNullableFilter<"serviceinfotb"> | string | null
    status?: IntNullableFilter<"serviceinfotb"> | number | null
    createDate?: DateTimeNullableFilter<"serviceinfotb"> | Date | string | null
    mode?: IntNullableFilter<"serviceinfotb"> | number | null
    hash?: StringNullableFilter<"serviceinfotb"> | string | null
  }

  export type serviceinfotbOrderByWithRelationInput = {
    serviceId?: SortOrder
    prefix?: SortOrder
    info?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
  }

  export type serviceinfotbWhereUniqueInput = Prisma.AtLeast<{
    prefix?: string
    AND?: serviceinfotbWhereInput | serviceinfotbWhereInput[]
    OR?: serviceinfotbWhereInput[]
    NOT?: serviceinfotbWhereInput | serviceinfotbWhereInput[]
    serviceId?: IntFilter<"serviceinfotb"> | number
    info?: StringNullableFilter<"serviceinfotb"> | string | null
    status?: IntNullableFilter<"serviceinfotb"> | number | null
    createDate?: DateTimeNullableFilter<"serviceinfotb"> | Date | string | null
    mode?: IntNullableFilter<"serviceinfotb"> | number | null
    hash?: StringNullableFilter<"serviceinfotb"> | string | null
  }, "prefix">

  export type serviceinfotbOrderByWithAggregationInput = {
    serviceId?: SortOrder
    prefix?: SortOrder
    info?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    mode?: SortOrderInput | SortOrder
    hash?: SortOrderInput | SortOrder
    _count?: serviceinfotbCountOrderByAggregateInput
    _avg?: serviceinfotbAvgOrderByAggregateInput
    _max?: serviceinfotbMaxOrderByAggregateInput
    _min?: serviceinfotbMinOrderByAggregateInput
    _sum?: serviceinfotbSumOrderByAggregateInput
  }

  export type serviceinfotbScalarWhereWithAggregatesInput = {
    AND?: serviceinfotbScalarWhereWithAggregatesInput | serviceinfotbScalarWhereWithAggregatesInput[]
    OR?: serviceinfotbScalarWhereWithAggregatesInput[]
    NOT?: serviceinfotbScalarWhereWithAggregatesInput | serviceinfotbScalarWhereWithAggregatesInput[]
    serviceId?: IntWithAggregatesFilter<"serviceinfotb"> | number
    prefix?: StringWithAggregatesFilter<"serviceinfotb"> | string
    info?: StringNullableWithAggregatesFilter<"serviceinfotb"> | string | null
    status?: IntNullableWithAggregatesFilter<"serviceinfotb"> | number | null
    createDate?: DateTimeNullableWithAggregatesFilter<"serviceinfotb"> | Date | string | null
    mode?: IntNullableWithAggregatesFilter<"serviceinfotb"> | number | null
    hash?: StringNullableWithAggregatesFilter<"serviceinfotb"> | string | null
  }

  export type servicetbWhereInput = {
    AND?: servicetbWhereInput | servicetbWhereInput[]
    OR?: servicetbWhereInput[]
    NOT?: servicetbWhereInput | servicetbWhereInput[]
    ServiceId?: IntFilter<"servicetb"> | number
    ServiceName?: StringFilter<"servicetb"> | string
    ServicePrice?: DecimalFilter<"servicetb"> | Decimal | DecimalJsLike | number | string
    Unit?: StringFilter<"servicetb"> | string
    Active?: BoolFilter<"servicetb"> | boolean
    InventoryManagement?: BoolFilter<"servicetb"> | boolean
    Inventory?: IntFilter<"servicetb"> | number
    WarningInventory?: IntFilter<"servicetb"> | number
    ServiceGroupID?: IntFilter<"servicetb"> | number
    NumInventoryExpected?: IntFilter<"servicetb"> | number
    UnitID?: IntFilter<"servicetb"> | number
    SuggestID?: IntFilter<"servicetb"> | number
    ServiceImg?: StringNullableFilter<"servicetb"> | string | null
    ServiceDate?: DateTimeNullableFilter<"servicetb"> | Date | string | null
  }

  export type servicetbOrderByWithRelationInput = {
    ServiceId?: SortOrder
    ServiceName?: SortOrder
    ServicePrice?: SortOrder
    Unit?: SortOrder
    Active?: SortOrder
    InventoryManagement?: SortOrder
    Inventory?: SortOrder
    WarningInventory?: SortOrder
    ServiceGroupID?: SortOrder
    NumInventoryExpected?: SortOrder
    UnitID?: SortOrder
    SuggestID?: SortOrder
    ServiceImg?: SortOrderInput | SortOrder
    ServiceDate?: SortOrderInput | SortOrder
  }

  export type servicetbWhereUniqueInput = Prisma.AtLeast<{
    ServiceId?: number
    AND?: servicetbWhereInput | servicetbWhereInput[]
    OR?: servicetbWhereInput[]
    NOT?: servicetbWhereInput | servicetbWhereInput[]
    ServiceName?: StringFilter<"servicetb"> | string
    ServicePrice?: DecimalFilter<"servicetb"> | Decimal | DecimalJsLike | number | string
    Unit?: StringFilter<"servicetb"> | string
    Active?: BoolFilter<"servicetb"> | boolean
    InventoryManagement?: BoolFilter<"servicetb"> | boolean
    Inventory?: IntFilter<"servicetb"> | number
    WarningInventory?: IntFilter<"servicetb"> | number
    ServiceGroupID?: IntFilter<"servicetb"> | number
    NumInventoryExpected?: IntFilter<"servicetb"> | number
    UnitID?: IntFilter<"servicetb"> | number
    SuggestID?: IntFilter<"servicetb"> | number
    ServiceImg?: StringNullableFilter<"servicetb"> | string | null
    ServiceDate?: DateTimeNullableFilter<"servicetb"> | Date | string | null
  }, "ServiceId">

  export type servicetbOrderByWithAggregationInput = {
    ServiceId?: SortOrder
    ServiceName?: SortOrder
    ServicePrice?: SortOrder
    Unit?: SortOrder
    Active?: SortOrder
    InventoryManagement?: SortOrder
    Inventory?: SortOrder
    WarningInventory?: SortOrder
    ServiceGroupID?: SortOrder
    NumInventoryExpected?: SortOrder
    UnitID?: SortOrder
    SuggestID?: SortOrder
    ServiceImg?: SortOrderInput | SortOrder
    ServiceDate?: SortOrderInput | SortOrder
    _count?: servicetbCountOrderByAggregateInput
    _avg?: servicetbAvgOrderByAggregateInput
    _max?: servicetbMaxOrderByAggregateInput
    _min?: servicetbMinOrderByAggregateInput
    _sum?: servicetbSumOrderByAggregateInput
  }

  export type servicetbScalarWhereWithAggregatesInput = {
    AND?: servicetbScalarWhereWithAggregatesInput | servicetbScalarWhereWithAggregatesInput[]
    OR?: servicetbScalarWhereWithAggregatesInput[]
    NOT?: servicetbScalarWhereWithAggregatesInput | servicetbScalarWhereWithAggregatesInput[]
    ServiceId?: IntWithAggregatesFilter<"servicetb"> | number
    ServiceName?: StringWithAggregatesFilter<"servicetb"> | string
    ServicePrice?: DecimalWithAggregatesFilter<"servicetb"> | Decimal | DecimalJsLike | number | string
    Unit?: StringWithAggregatesFilter<"servicetb"> | string
    Active?: BoolWithAggregatesFilter<"servicetb"> | boolean
    InventoryManagement?: BoolWithAggregatesFilter<"servicetb"> | boolean
    Inventory?: IntWithAggregatesFilter<"servicetb"> | number
    WarningInventory?: IntWithAggregatesFilter<"servicetb"> | number
    ServiceGroupID?: IntWithAggregatesFilter<"servicetb"> | number
    NumInventoryExpected?: IntWithAggregatesFilter<"servicetb"> | number
    UnitID?: IntWithAggregatesFilter<"servicetb"> | number
    SuggestID?: IntWithAggregatesFilter<"servicetb"> | number
    ServiceImg?: StringNullableWithAggregatesFilter<"servicetb"> | string | null
    ServiceDate?: DateTimeNullableWithAggregatesFilter<"servicetb"> | Date | string | null
  }

  export type serviceunittbWhereInput = {
    AND?: serviceunittbWhereInput | serviceunittbWhereInput[]
    OR?: serviceunittbWhereInput[]
    NOT?: serviceunittbWhereInput | serviceunittbWhereInput[]
    ID?: IntFilter<"serviceunittb"> | number
    Unit?: StringFilter<"serviceunittb"> | string
    IsActive?: BoolFilter<"serviceunittb"> | boolean
  }

  export type serviceunittbOrderByWithRelationInput = {
    ID?: SortOrder
    Unit?: SortOrder
    IsActive?: SortOrder
  }

  export type serviceunittbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: serviceunittbWhereInput | serviceunittbWhereInput[]
    OR?: serviceunittbWhereInput[]
    NOT?: serviceunittbWhereInput | serviceunittbWhereInput[]
    Unit?: StringFilter<"serviceunittb"> | string
    IsActive?: BoolFilter<"serviceunittb"> | boolean
  }, "ID">

  export type serviceunittbOrderByWithAggregationInput = {
    ID?: SortOrder
    Unit?: SortOrder
    IsActive?: SortOrder
    _count?: serviceunittbCountOrderByAggregateInput
    _avg?: serviceunittbAvgOrderByAggregateInput
    _max?: serviceunittbMaxOrderByAggregateInput
    _min?: serviceunittbMinOrderByAggregateInput
    _sum?: serviceunittbSumOrderByAggregateInput
  }

  export type serviceunittbScalarWhereWithAggregatesInput = {
    AND?: serviceunittbScalarWhereWithAggregatesInput | serviceunittbScalarWhereWithAggregatesInput[]
    OR?: serviceunittbScalarWhereWithAggregatesInput[]
    NOT?: serviceunittbScalarWhereWithAggregatesInput | serviceunittbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"serviceunittb"> | number
    Unit?: StringWithAggregatesFilter<"serviceunittb"> | string
    IsActive?: BoolWithAggregatesFilter<"serviceunittb"> | boolean
  }

  export type servicevisitWhereInput = {
    AND?: servicevisitWhereInput | servicevisitWhereInput[]
    OR?: servicevisitWhereInput[]
    NOT?: servicevisitWhereInput | servicevisitWhereInput[]
    uid?: StringFilter<"servicevisit"> | string
    vstotal?: IntNullableFilter<"servicevisit"> | number | null
    vsdetail?: StringNullableFilter<"servicevisit"> | string | null
    ym?: IntFilter<"servicevisit"> | number
    last_update?: DateTimeNullableFilter<"servicevisit"> | Date | string | null
    sign?: StringNullableFilter<"servicevisit"> | string | null
    ssid?: StringNullableFilter<"servicevisit"> | string | null
    reset?: IntNullableFilter<"servicevisit"> | number | null
  }

  export type servicevisitOrderByWithRelationInput = {
    uid?: SortOrder
    vstotal?: SortOrderInput | SortOrder
    vsdetail?: SortOrderInput | SortOrder
    ym?: SortOrder
    last_update?: SortOrderInput | SortOrder
    sign?: SortOrderInput | SortOrder
    ssid?: SortOrderInput | SortOrder
    reset?: SortOrderInput | SortOrder
  }

  export type servicevisitWhereUniqueInput = Prisma.AtLeast<{
    uid_ym?: servicevisitUidYmCompoundUniqueInput
    AND?: servicevisitWhereInput | servicevisitWhereInput[]
    OR?: servicevisitWhereInput[]
    NOT?: servicevisitWhereInput | servicevisitWhereInput[]
    uid?: StringFilter<"servicevisit"> | string
    vstotal?: IntNullableFilter<"servicevisit"> | number | null
    vsdetail?: StringNullableFilter<"servicevisit"> | string | null
    ym?: IntFilter<"servicevisit"> | number
    last_update?: DateTimeNullableFilter<"servicevisit"> | Date | string | null
    sign?: StringNullableFilter<"servicevisit"> | string | null
    ssid?: StringNullableFilter<"servicevisit"> | string | null
    reset?: IntNullableFilter<"servicevisit"> | number | null
  }, "uid_ym">

  export type servicevisitOrderByWithAggregationInput = {
    uid?: SortOrder
    vstotal?: SortOrderInput | SortOrder
    vsdetail?: SortOrderInput | SortOrder
    ym?: SortOrder
    last_update?: SortOrderInput | SortOrder
    sign?: SortOrderInput | SortOrder
    ssid?: SortOrderInput | SortOrder
    reset?: SortOrderInput | SortOrder
    _count?: servicevisitCountOrderByAggregateInput
    _avg?: servicevisitAvgOrderByAggregateInput
    _max?: servicevisitMaxOrderByAggregateInput
    _min?: servicevisitMinOrderByAggregateInput
    _sum?: servicevisitSumOrderByAggregateInput
  }

  export type servicevisitScalarWhereWithAggregatesInput = {
    AND?: servicevisitScalarWhereWithAggregatesInput | servicevisitScalarWhereWithAggregatesInput[]
    OR?: servicevisitScalarWhereWithAggregatesInput[]
    NOT?: servicevisitScalarWhereWithAggregatesInput | servicevisitScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"servicevisit"> | string
    vstotal?: IntNullableWithAggregatesFilter<"servicevisit"> | number | null
    vsdetail?: StringNullableWithAggregatesFilter<"servicevisit"> | string | null
    ym?: IntWithAggregatesFilter<"servicevisit"> | number
    last_update?: DateTimeNullableWithAggregatesFilter<"servicevisit"> | Date | string | null
    sign?: StringNullableWithAggregatesFilter<"servicevisit"> | string | null
    ssid?: StringNullableWithAggregatesFilter<"servicevisit"> | string | null
    reset?: IntNullableWithAggregatesFilter<"servicevisit"> | number | null
  }

  export type settingtbWhereInput = {
    AND?: settingtbWhereInput | settingtbWhereInput[]
    OR?: settingtbWhereInput[]
    NOT?: settingtbWhereInput | settingtbWhereInput[]
    SettingId?: IntFilter<"settingtb"> | number
    Value?: IntFilter<"settingtb"> | number
    Data?: StringFilter<"settingtb"> | string
    Active?: BoolFilter<"settingtb"> | boolean
  }

  export type settingtbOrderByWithRelationInput = {
    SettingId?: SortOrder
    Value?: SortOrder
    Data?: SortOrder
    Active?: SortOrder
  }

  export type settingtbWhereUniqueInput = Prisma.AtLeast<{
    SettingId?: number
    AND?: settingtbWhereInput | settingtbWhereInput[]
    OR?: settingtbWhereInput[]
    NOT?: settingtbWhereInput | settingtbWhereInput[]
    Value?: IntFilter<"settingtb"> | number
    Data?: StringFilter<"settingtb"> | string
    Active?: BoolFilter<"settingtb"> | boolean
  }, "SettingId">

  export type settingtbOrderByWithAggregationInput = {
    SettingId?: SortOrder
    Value?: SortOrder
    Data?: SortOrder
    Active?: SortOrder
    _count?: settingtbCountOrderByAggregateInput
    _avg?: settingtbAvgOrderByAggregateInput
    _max?: settingtbMaxOrderByAggregateInput
    _min?: settingtbMinOrderByAggregateInput
    _sum?: settingtbSumOrderByAggregateInput
  }

  export type settingtbScalarWhereWithAggregatesInput = {
    AND?: settingtbScalarWhereWithAggregatesInput | settingtbScalarWhereWithAggregatesInput[]
    OR?: settingtbScalarWhereWithAggregatesInput[]
    NOT?: settingtbScalarWhereWithAggregatesInput | settingtbScalarWhereWithAggregatesInput[]
    SettingId?: IntWithAggregatesFilter<"settingtb"> | number
    Value?: IntWithAggregatesFilter<"settingtb"> | number
    Data?: StringWithAggregatesFilter<"settingtb"> | string
    Active?: BoolWithAggregatesFilter<"settingtb"> | boolean
  }

  export type softwaretbWhereInput = {
    AND?: softwaretbWhereInput | softwaretbWhereInput[]
    OR?: softwaretbWhereInput[]
    NOT?: softwaretbWhereInput | softwaretbWhereInput[]
    ID?: IntFilter<"softwaretb"> | number
    UserId?: IntFilter<"softwaretb"> | number
    Name?: StringFilter<"softwaretb"> | string
    Version?: StringFilter<"softwaretb"> | string
    MAC?: StringFilter<"softwaretb"> | string
    Active?: IntFilter<"softwaretb"> | number
  }

  export type softwaretbOrderByWithRelationInput = {
    ID?: SortOrder
    UserId?: SortOrder
    Name?: SortOrder
    Version?: SortOrder
    MAC?: SortOrder
    Active?: SortOrder
  }

  export type softwaretbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: softwaretbWhereInput | softwaretbWhereInput[]
    OR?: softwaretbWhereInput[]
    NOT?: softwaretbWhereInput | softwaretbWhereInput[]
    UserId?: IntFilter<"softwaretb"> | number
    Name?: StringFilter<"softwaretb"> | string
    Version?: StringFilter<"softwaretb"> | string
    MAC?: StringFilter<"softwaretb"> | string
    Active?: IntFilter<"softwaretb"> | number
  }, "ID">

  export type softwaretbOrderByWithAggregationInput = {
    ID?: SortOrder
    UserId?: SortOrder
    Name?: SortOrder
    Version?: SortOrder
    MAC?: SortOrder
    Active?: SortOrder
    _count?: softwaretbCountOrderByAggregateInput
    _avg?: softwaretbAvgOrderByAggregateInput
    _max?: softwaretbMaxOrderByAggregateInput
    _min?: softwaretbMinOrderByAggregateInput
    _sum?: softwaretbSumOrderByAggregateInput
  }

  export type softwaretbScalarWhereWithAggregatesInput = {
    AND?: softwaretbScalarWhereWithAggregatesInput | softwaretbScalarWhereWithAggregatesInput[]
    OR?: softwaretbScalarWhereWithAggregatesInput[]
    NOT?: softwaretbScalarWhereWithAggregatesInput | softwaretbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"softwaretb"> | number
    UserId?: IntWithAggregatesFilter<"softwaretb"> | number
    Name?: StringWithAggregatesFilter<"softwaretb"> | string
    Version?: StringWithAggregatesFilter<"softwaretb"> | string
    MAC?: StringWithAggregatesFilter<"softwaretb"> | string
    Active?: IntWithAggregatesFilter<"softwaretb"> | number
  }

  export type specappdetailtbWhereInput = {
    AND?: specappdetailtbWhereInput | specappdetailtbWhereInput[]
    OR?: specappdetailtbWhereInput[]
    NOT?: specappdetailtbWhereInput | specappdetailtbWhereInput[]
    ID?: IntFilter<"specappdetailtb"> | number
    MachineName?: StringFilter<"specappdetailtb"> | string
    AppName?: StringFilter<"specappdetailtb"> | string
    Shortcut?: StringFilter<"specappdetailtb"> | string
    InstallName?: StringFilter<"specappdetailtb"> | string
    InstallVersion?: StringFilter<"specappdetailtb"> | string
    InstallLocation?: StringFilter<"specappdetailtb"> | string
    LastUpdateDate?: DateTimeFilter<"specappdetailtb"> | Date | string
    Sent?: BoolFilter<"specappdetailtb"> | boolean
    AppRun?: BoolFilter<"specappdetailtb"> | boolean
    SubRun?: BoolFilter<"specappdetailtb"> | boolean
    SubRun2?: BoolFilter<"specappdetailtb"> | boolean
  }

  export type specappdetailtbOrderByWithRelationInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    AppName?: SortOrder
    Shortcut?: SortOrder
    InstallName?: SortOrder
    InstallVersion?: SortOrder
    InstallLocation?: SortOrder
    LastUpdateDate?: SortOrder
    Sent?: SortOrder
    AppRun?: SortOrder
    SubRun?: SortOrder
    SubRun2?: SortOrder
  }

  export type specappdetailtbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: specappdetailtbWhereInput | specappdetailtbWhereInput[]
    OR?: specappdetailtbWhereInput[]
    NOT?: specappdetailtbWhereInput | specappdetailtbWhereInput[]
    MachineName?: StringFilter<"specappdetailtb"> | string
    AppName?: StringFilter<"specappdetailtb"> | string
    Shortcut?: StringFilter<"specappdetailtb"> | string
    InstallName?: StringFilter<"specappdetailtb"> | string
    InstallVersion?: StringFilter<"specappdetailtb"> | string
    InstallLocation?: StringFilter<"specappdetailtb"> | string
    LastUpdateDate?: DateTimeFilter<"specappdetailtb"> | Date | string
    Sent?: BoolFilter<"specappdetailtb"> | boolean
    AppRun?: BoolFilter<"specappdetailtb"> | boolean
    SubRun?: BoolFilter<"specappdetailtb"> | boolean
    SubRun2?: BoolFilter<"specappdetailtb"> | boolean
  }, "ID">

  export type specappdetailtbOrderByWithAggregationInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    AppName?: SortOrder
    Shortcut?: SortOrder
    InstallName?: SortOrder
    InstallVersion?: SortOrder
    InstallLocation?: SortOrder
    LastUpdateDate?: SortOrder
    Sent?: SortOrder
    AppRun?: SortOrder
    SubRun?: SortOrder
    SubRun2?: SortOrder
    _count?: specappdetailtbCountOrderByAggregateInput
    _avg?: specappdetailtbAvgOrderByAggregateInput
    _max?: specappdetailtbMaxOrderByAggregateInput
    _min?: specappdetailtbMinOrderByAggregateInput
    _sum?: specappdetailtbSumOrderByAggregateInput
  }

  export type specappdetailtbScalarWhereWithAggregatesInput = {
    AND?: specappdetailtbScalarWhereWithAggregatesInput | specappdetailtbScalarWhereWithAggregatesInput[]
    OR?: specappdetailtbScalarWhereWithAggregatesInput[]
    NOT?: specappdetailtbScalarWhereWithAggregatesInput | specappdetailtbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"specappdetailtb"> | number
    MachineName?: StringWithAggregatesFilter<"specappdetailtb"> | string
    AppName?: StringWithAggregatesFilter<"specappdetailtb"> | string
    Shortcut?: StringWithAggregatesFilter<"specappdetailtb"> | string
    InstallName?: StringWithAggregatesFilter<"specappdetailtb"> | string
    InstallVersion?: StringWithAggregatesFilter<"specappdetailtb"> | string
    InstallLocation?: StringWithAggregatesFilter<"specappdetailtb"> | string
    LastUpdateDate?: DateTimeWithAggregatesFilter<"specappdetailtb"> | Date | string
    Sent?: BoolWithAggregatesFilter<"specappdetailtb"> | boolean
    AppRun?: BoolWithAggregatesFilter<"specappdetailtb"> | boolean
    SubRun?: BoolWithAggregatesFilter<"specappdetailtb"> | boolean
    SubRun2?: BoolWithAggregatesFilter<"specappdetailtb"> | boolean
  }

  export type standardservicetbWhereInput = {
    AND?: standardservicetbWhereInput | standardservicetbWhereInput[]
    OR?: standardservicetbWhereInput[]
    NOT?: standardservicetbWhereInput | standardservicetbWhereInput[]
    StandardServiceId?: IntFilter<"standardservicetb"> | number
    StandardServiceName?: StringFilter<"standardservicetb"> | string
    StandardServiceGroupID?: IntFilter<"standardservicetb"> | number
    Active?: IntFilter<"standardservicetb"> | number
  }

  export type standardservicetbOrderByWithRelationInput = {
    StandardServiceId?: SortOrder
    StandardServiceName?: SortOrder
    StandardServiceGroupID?: SortOrder
    Active?: SortOrder
  }

  export type standardservicetbWhereUniqueInput = Prisma.AtLeast<{
    StandardServiceId?: number
    AND?: standardservicetbWhereInput | standardservicetbWhereInput[]
    OR?: standardservicetbWhereInput[]
    NOT?: standardservicetbWhereInput | standardservicetbWhereInput[]
    StandardServiceName?: StringFilter<"standardservicetb"> | string
    StandardServiceGroupID?: IntFilter<"standardservicetb"> | number
    Active?: IntFilter<"standardservicetb"> | number
  }, "StandardServiceId">

  export type standardservicetbOrderByWithAggregationInput = {
    StandardServiceId?: SortOrder
    StandardServiceName?: SortOrder
    StandardServiceGroupID?: SortOrder
    Active?: SortOrder
    _count?: standardservicetbCountOrderByAggregateInput
    _avg?: standardservicetbAvgOrderByAggregateInput
    _max?: standardservicetbMaxOrderByAggregateInput
    _min?: standardservicetbMinOrderByAggregateInput
    _sum?: standardservicetbSumOrderByAggregateInput
  }

  export type standardservicetbScalarWhereWithAggregatesInput = {
    AND?: standardservicetbScalarWhereWithAggregatesInput | standardservicetbScalarWhereWithAggregatesInput[]
    OR?: standardservicetbScalarWhereWithAggregatesInput[]
    NOT?: standardservicetbScalarWhereWithAggregatesInput | standardservicetbScalarWhereWithAggregatesInput[]
    StandardServiceId?: IntWithAggregatesFilter<"standardservicetb"> | number
    StandardServiceName?: StringWithAggregatesFilter<"standardservicetb"> | string
    StandardServiceGroupID?: IntWithAggregatesFilter<"standardservicetb"> | number
    Active?: IntWithAggregatesFilter<"standardservicetb"> | number
  }

  export type stocktakingtbWhereInput = {
    AND?: stocktakingtbWhereInput | stocktakingtbWhereInput[]
    OR?: stocktakingtbWhereInput[]
    NOT?: stocktakingtbWhereInput | stocktakingtbWhereInput[]
    ID?: IntFilter<"stocktakingtb"> | number
    CreateDate?: DateTimeFilter<"stocktakingtb"> | Date | string
    CreateTime?: DateTimeFilter<"stocktakingtb"> | Date | string
    StaffID?: IntFilter<"stocktakingtb"> | number
    NumInventoryExpected?: IntFilter<"stocktakingtb"> | number
    NumInventoryReal?: IntFilter<"stocktakingtb"> | number
    NumAdjust?: IntFilter<"stocktakingtb"> | number
    NumPreAdjust?: IntFilter<"stocktakingtb"> | number
    Note?: StringNullableFilter<"stocktakingtb"> | string | null
    ServiceID?: IntFilter<"stocktakingtb"> | number
  }

  export type stocktakingtbOrderByWithRelationInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    NumPreAdjust?: SortOrder
    Note?: SortOrderInput | SortOrder
    ServiceID?: SortOrder
  }

  export type stocktakingtbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: stocktakingtbWhereInput | stocktakingtbWhereInput[]
    OR?: stocktakingtbWhereInput[]
    NOT?: stocktakingtbWhereInput | stocktakingtbWhereInput[]
    CreateDate?: DateTimeFilter<"stocktakingtb"> | Date | string
    CreateTime?: DateTimeFilter<"stocktakingtb"> | Date | string
    StaffID?: IntFilter<"stocktakingtb"> | number
    NumInventoryExpected?: IntFilter<"stocktakingtb"> | number
    NumInventoryReal?: IntFilter<"stocktakingtb"> | number
    NumAdjust?: IntFilter<"stocktakingtb"> | number
    NumPreAdjust?: IntFilter<"stocktakingtb"> | number
    Note?: StringNullableFilter<"stocktakingtb"> | string | null
    ServiceID?: IntFilter<"stocktakingtb"> | number
  }, "ID">

  export type stocktakingtbOrderByWithAggregationInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    NumPreAdjust?: SortOrder
    Note?: SortOrderInput | SortOrder
    ServiceID?: SortOrder
    _count?: stocktakingtbCountOrderByAggregateInput
    _avg?: stocktakingtbAvgOrderByAggregateInput
    _max?: stocktakingtbMaxOrderByAggregateInput
    _min?: stocktakingtbMinOrderByAggregateInput
    _sum?: stocktakingtbSumOrderByAggregateInput
  }

  export type stocktakingtbScalarWhereWithAggregatesInput = {
    AND?: stocktakingtbScalarWhereWithAggregatesInput | stocktakingtbScalarWhereWithAggregatesInput[]
    OR?: stocktakingtbScalarWhereWithAggregatesInput[]
    NOT?: stocktakingtbScalarWhereWithAggregatesInput | stocktakingtbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"stocktakingtb"> | number
    CreateDate?: DateTimeWithAggregatesFilter<"stocktakingtb"> | Date | string
    CreateTime?: DateTimeWithAggregatesFilter<"stocktakingtb"> | Date | string
    StaffID?: IntWithAggregatesFilter<"stocktakingtb"> | number
    NumInventoryExpected?: IntWithAggregatesFilter<"stocktakingtb"> | number
    NumInventoryReal?: IntWithAggregatesFilter<"stocktakingtb"> | number
    NumAdjust?: IntWithAggregatesFilter<"stocktakingtb"> | number
    NumPreAdjust?: IntWithAggregatesFilter<"stocktakingtb"> | number
    Note?: StringNullableWithAggregatesFilter<"stocktakingtb"> | string | null
    ServiceID?: IntWithAggregatesFilter<"stocktakingtb"> | number
  }

  export type supportsWhereInput = {
    AND?: supportsWhereInput | supportsWhereInput[]
    OR?: supportsWhereInput[]
    NOT?: supportsWhereInput | supportsWhereInput[]
    supportId?: IntFilter<"supports"> | number
    supportTitle?: StringFilter<"supports"> | string
    supportImage?: StringNullableFilter<"supports"> | string | null
    suportCode?: IntNullableFilter<"supports"> | number | null
    supportHash?: StringNullableFilter<"supports"> | string | null
    status?: IntNullableFilter<"supports"> | number | null
    order?: IntNullableFilter<"supports"> | number | null
    supportCat?: StringNullableFilter<"supports"> | string | null
    totalClick?: IntNullableFilter<"supports"> | number | null
    ssId?: StringNullableFilter<"supports"> | string | null
    createDate?: DateTimeNullableFilter<"supports"> | Date | string | null
    modifyDate?: DateTimeNullableFilter<"supports"> | Date | string | null
  }

  export type supportsOrderByWithRelationInput = {
    supportId?: SortOrder
    supportTitle?: SortOrder
    supportImage?: SortOrderInput | SortOrder
    suportCode?: SortOrderInput | SortOrder
    supportHash?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    supportCat?: SortOrderInput | SortOrder
    totalClick?: SortOrderInput | SortOrder
    ssId?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    modifyDate?: SortOrderInput | SortOrder
  }

  export type supportsWhereUniqueInput = Prisma.AtLeast<{
    supportTitle?: string
    AND?: supportsWhereInput | supportsWhereInput[]
    OR?: supportsWhereInput[]
    NOT?: supportsWhereInput | supportsWhereInput[]
    supportId?: IntFilter<"supports"> | number
    supportImage?: StringNullableFilter<"supports"> | string | null
    suportCode?: IntNullableFilter<"supports"> | number | null
    supportHash?: StringNullableFilter<"supports"> | string | null
    status?: IntNullableFilter<"supports"> | number | null
    order?: IntNullableFilter<"supports"> | number | null
    supportCat?: StringNullableFilter<"supports"> | string | null
    totalClick?: IntNullableFilter<"supports"> | number | null
    ssId?: StringNullableFilter<"supports"> | string | null
    createDate?: DateTimeNullableFilter<"supports"> | Date | string | null
    modifyDate?: DateTimeNullableFilter<"supports"> | Date | string | null
  }, "supportTitle">

  export type supportsOrderByWithAggregationInput = {
    supportId?: SortOrder
    supportTitle?: SortOrder
    supportImage?: SortOrderInput | SortOrder
    suportCode?: SortOrderInput | SortOrder
    supportHash?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    supportCat?: SortOrderInput | SortOrder
    totalClick?: SortOrderInput | SortOrder
    ssId?: SortOrderInput | SortOrder
    createDate?: SortOrderInput | SortOrder
    modifyDate?: SortOrderInput | SortOrder
    _count?: supportsCountOrderByAggregateInput
    _avg?: supportsAvgOrderByAggregateInput
    _max?: supportsMaxOrderByAggregateInput
    _min?: supportsMinOrderByAggregateInput
    _sum?: supportsSumOrderByAggregateInput
  }

  export type supportsScalarWhereWithAggregatesInput = {
    AND?: supportsScalarWhereWithAggregatesInput | supportsScalarWhereWithAggregatesInput[]
    OR?: supportsScalarWhereWithAggregatesInput[]
    NOT?: supportsScalarWhereWithAggregatesInput | supportsScalarWhereWithAggregatesInput[]
    supportId?: IntWithAggregatesFilter<"supports"> | number
    supportTitle?: StringWithAggregatesFilter<"supports"> | string
    supportImage?: StringNullableWithAggregatesFilter<"supports"> | string | null
    suportCode?: IntNullableWithAggregatesFilter<"supports"> | number | null
    supportHash?: StringNullableWithAggregatesFilter<"supports"> | string | null
    status?: IntNullableWithAggregatesFilter<"supports"> | number | null
    order?: IntNullableWithAggregatesFilter<"supports"> | number | null
    supportCat?: StringNullableWithAggregatesFilter<"supports"> | string | null
    totalClick?: IntNullableWithAggregatesFilter<"supports"> | number | null
    ssId?: StringNullableWithAggregatesFilter<"supports"> | string | null
    createDate?: DateTimeNullableWithAggregatesFilter<"supports"> | Date | string | null
    modifyDate?: DateTimeNullableWithAggregatesFilter<"supports"> | Date | string | null
  }

  export type systemfunctiontbWhereInput = {
    AND?: systemfunctiontbWhereInput | systemfunctiontbWhereInput[]
    OR?: systemfunctiontbWhereInput[]
    NOT?: systemfunctiontbWhereInput | systemfunctiontbWhereInput[]
    ResourceID?: IntFilter<"systemfunctiontb"> | number
    Status?: IntFilter<"systemfunctiontb"> | number
  }

  export type systemfunctiontbOrderByWithRelationInput = {
    ResourceID?: SortOrder
    Status?: SortOrder
  }

  export type systemfunctiontbWhereUniqueInput = Prisma.AtLeast<{
    ResourceID?: number
    AND?: systemfunctiontbWhereInput | systemfunctiontbWhereInput[]
    OR?: systemfunctiontbWhereInput[]
    NOT?: systemfunctiontbWhereInput | systemfunctiontbWhereInput[]
    Status?: IntFilter<"systemfunctiontb"> | number
  }, "ResourceID">

  export type systemfunctiontbOrderByWithAggregationInput = {
    ResourceID?: SortOrder
    Status?: SortOrder
    _count?: systemfunctiontbCountOrderByAggregateInput
    _avg?: systemfunctiontbAvgOrderByAggregateInput
    _max?: systemfunctiontbMaxOrderByAggregateInput
    _min?: systemfunctiontbMinOrderByAggregateInput
    _sum?: systemfunctiontbSumOrderByAggregateInput
  }

  export type systemfunctiontbScalarWhereWithAggregatesInput = {
    AND?: systemfunctiontbScalarWhereWithAggregatesInput | systemfunctiontbScalarWhereWithAggregatesInput[]
    OR?: systemfunctiontbScalarWhereWithAggregatesInput[]
    NOT?: systemfunctiontbScalarWhereWithAggregatesInput | systemfunctiontbScalarWhereWithAggregatesInput[]
    ResourceID?: IntWithAggregatesFilter<"systemfunctiontb"> | number
    Status?: IntWithAggregatesFilter<"systemfunctiontb"> | number
  }

  export type systemlogtbWhereInput = {
    AND?: systemlogtbWhereInput | systemlogtbWhereInput[]
    OR?: systemlogtbWhereInput[]
    NOT?: systemlogtbWhereInput | systemlogtbWhereInput[]
    SystemLogId?: IntFilter<"systemlogtb"> | number
    UserId?: IntNullableFilter<"systemlogtb"> | number | null
    MachineName?: StringFilter<"systemlogtb"> | string
    IPAddress?: StringFilter<"systemlogtb"> | string
    EnterDate?: DateTimeFilter<"systemlogtb"> | Date | string
    EnterTime?: DateTimeFilter<"systemlogtb"> | Date | string
    EndDate?: DateTimeNullableFilter<"systemlogtb"> | Date | string | null
    EndTime?: DateTimeNullableFilter<"systemlogtb"> | Date | string | null
    Status?: IntFilter<"systemlogtb"> | number
    Note?: StringFilter<"systemlogtb"> | string
    TimeUsed?: IntFilter<"systemlogtb"> | number
    MoneyUsed?: IntFilter<"systemlogtb"> | number
    PriceAppRentID?: IntFilter<"systemlogtb"> | number
    AppRentMoneyUsed?: IntFilter<"systemlogtb"> | number
  }

  export type systemlogtbOrderByWithRelationInput = {
    SystemLogId?: SortOrder
    UserId?: SortOrderInput | SortOrder
    MachineName?: SortOrder
    IPAddress?: SortOrder
    EnterDate?: SortOrder
    EnterTime?: SortOrder
    EndDate?: SortOrderInput | SortOrder
    EndTime?: SortOrderInput | SortOrder
    Status?: SortOrder
    Note?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    PriceAppRentID?: SortOrder
    AppRentMoneyUsed?: SortOrder
  }

  export type systemlogtbWhereUniqueInput = Prisma.AtLeast<{
    SystemLogId?: number
    AND?: systemlogtbWhereInput | systemlogtbWhereInput[]
    OR?: systemlogtbWhereInput[]
    NOT?: systemlogtbWhereInput | systemlogtbWhereInput[]
    UserId?: IntNullableFilter<"systemlogtb"> | number | null
    MachineName?: StringFilter<"systemlogtb"> | string
    IPAddress?: StringFilter<"systemlogtb"> | string
    EnterDate?: DateTimeFilter<"systemlogtb"> | Date | string
    EnterTime?: DateTimeFilter<"systemlogtb"> | Date | string
    EndDate?: DateTimeNullableFilter<"systemlogtb"> | Date | string | null
    EndTime?: DateTimeNullableFilter<"systemlogtb"> | Date | string | null
    Status?: IntFilter<"systemlogtb"> | number
    Note?: StringFilter<"systemlogtb"> | string
    TimeUsed?: IntFilter<"systemlogtb"> | number
    MoneyUsed?: IntFilter<"systemlogtb"> | number
    PriceAppRentID?: IntFilter<"systemlogtb"> | number
    AppRentMoneyUsed?: IntFilter<"systemlogtb"> | number
  }, "SystemLogId">

  export type systemlogtbOrderByWithAggregationInput = {
    SystemLogId?: SortOrder
    UserId?: SortOrderInput | SortOrder
    MachineName?: SortOrder
    IPAddress?: SortOrder
    EnterDate?: SortOrder
    EnterTime?: SortOrder
    EndDate?: SortOrderInput | SortOrder
    EndTime?: SortOrderInput | SortOrder
    Status?: SortOrder
    Note?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    PriceAppRentID?: SortOrder
    AppRentMoneyUsed?: SortOrder
    _count?: systemlogtbCountOrderByAggregateInput
    _avg?: systemlogtbAvgOrderByAggregateInput
    _max?: systemlogtbMaxOrderByAggregateInput
    _min?: systemlogtbMinOrderByAggregateInput
    _sum?: systemlogtbSumOrderByAggregateInput
  }

  export type systemlogtbScalarWhereWithAggregatesInput = {
    AND?: systemlogtbScalarWhereWithAggregatesInput | systemlogtbScalarWhereWithAggregatesInput[]
    OR?: systemlogtbScalarWhereWithAggregatesInput[]
    NOT?: systemlogtbScalarWhereWithAggregatesInput | systemlogtbScalarWhereWithAggregatesInput[]
    SystemLogId?: IntWithAggregatesFilter<"systemlogtb"> | number
    UserId?: IntNullableWithAggregatesFilter<"systemlogtb"> | number | null
    MachineName?: StringWithAggregatesFilter<"systemlogtb"> | string
    IPAddress?: StringWithAggregatesFilter<"systemlogtb"> | string
    EnterDate?: DateTimeWithAggregatesFilter<"systemlogtb"> | Date | string
    EnterTime?: DateTimeWithAggregatesFilter<"systemlogtb"> | Date | string
    EndDate?: DateTimeNullableWithAggregatesFilter<"systemlogtb"> | Date | string | null
    EndTime?: DateTimeNullableWithAggregatesFilter<"systemlogtb"> | Date | string | null
    Status?: IntWithAggregatesFilter<"systemlogtb"> | number
    Note?: StringWithAggregatesFilter<"systemlogtb"> | string
    TimeUsed?: IntWithAggregatesFilter<"systemlogtb"> | number
    MoneyUsed?: IntWithAggregatesFilter<"systemlogtb"> | number
    PriceAppRentID?: IntWithAggregatesFilter<"systemlogtb"> | number
    AppRentMoneyUsed?: IntWithAggregatesFilter<"systemlogtb"> | number
  }

  export type trackappdetailtbWhereInput = {
    AND?: trackappdetailtbWhereInput | trackappdetailtbWhereInput[]
    OR?: trackappdetailtbWhereInput[]
    NOT?: trackappdetailtbWhereInput | trackappdetailtbWhereInput[]
    TrackAppDetailId?: IntFilter<"trackappdetailtb"> | number
    AppName?: StringFilter<"trackappdetailtb"> | string
    UserName?: StringFilter<"trackappdetailtb"> | string
    TrackingDate?: DateTimeFilter<"trackappdetailtb"> | Date | string
    TrackingTime?: DateTimeFilter<"trackappdetailtb"> | Date | string
    TimeTotal?: IntFilter<"trackappdetailtb"> | number
    AppSession?: BoolFilter<"trackappdetailtb"> | boolean
    Sent?: BoolFilter<"trackappdetailtb"> | boolean
    Machine?: StringFilter<"trackappdetailtb"> | string
    SessionId?: IntFilter<"trackappdetailtb"> | number
    ETT?: StringFilter<"trackappdetailtb"> | string
  }

  export type trackappdetailtbOrderByWithRelationInput = {
    TrackAppDetailId?: SortOrder
    AppName?: SortOrder
    UserName?: SortOrder
    TrackingDate?: SortOrder
    TrackingTime?: SortOrder
    TimeTotal?: SortOrder
    AppSession?: SortOrder
    Sent?: SortOrder
    Machine?: SortOrder
    SessionId?: SortOrder
    ETT?: SortOrder
  }

  export type trackappdetailtbWhereUniqueInput = Prisma.AtLeast<{
    TrackAppDetailId?: number
    AND?: trackappdetailtbWhereInput | trackappdetailtbWhereInput[]
    OR?: trackappdetailtbWhereInput[]
    NOT?: trackappdetailtbWhereInput | trackappdetailtbWhereInput[]
    AppName?: StringFilter<"trackappdetailtb"> | string
    UserName?: StringFilter<"trackappdetailtb"> | string
    TrackingDate?: DateTimeFilter<"trackappdetailtb"> | Date | string
    TrackingTime?: DateTimeFilter<"trackappdetailtb"> | Date | string
    TimeTotal?: IntFilter<"trackappdetailtb"> | number
    AppSession?: BoolFilter<"trackappdetailtb"> | boolean
    Sent?: BoolFilter<"trackappdetailtb"> | boolean
    Machine?: StringFilter<"trackappdetailtb"> | string
    SessionId?: IntFilter<"trackappdetailtb"> | number
    ETT?: StringFilter<"trackappdetailtb"> | string
  }, "TrackAppDetailId">

  export type trackappdetailtbOrderByWithAggregationInput = {
    TrackAppDetailId?: SortOrder
    AppName?: SortOrder
    UserName?: SortOrder
    TrackingDate?: SortOrder
    TrackingTime?: SortOrder
    TimeTotal?: SortOrder
    AppSession?: SortOrder
    Sent?: SortOrder
    Machine?: SortOrder
    SessionId?: SortOrder
    ETT?: SortOrder
    _count?: trackappdetailtbCountOrderByAggregateInput
    _avg?: trackappdetailtbAvgOrderByAggregateInput
    _max?: trackappdetailtbMaxOrderByAggregateInput
    _min?: trackappdetailtbMinOrderByAggregateInput
    _sum?: trackappdetailtbSumOrderByAggregateInput
  }

  export type trackappdetailtbScalarWhereWithAggregatesInput = {
    AND?: trackappdetailtbScalarWhereWithAggregatesInput | trackappdetailtbScalarWhereWithAggregatesInput[]
    OR?: trackappdetailtbScalarWhereWithAggregatesInput[]
    NOT?: trackappdetailtbScalarWhereWithAggregatesInput | trackappdetailtbScalarWhereWithAggregatesInput[]
    TrackAppDetailId?: IntWithAggregatesFilter<"trackappdetailtb"> | number
    AppName?: StringWithAggregatesFilter<"trackappdetailtb"> | string
    UserName?: StringWithAggregatesFilter<"trackappdetailtb"> | string
    TrackingDate?: DateTimeWithAggregatesFilter<"trackappdetailtb"> | Date | string
    TrackingTime?: DateTimeWithAggregatesFilter<"trackappdetailtb"> | Date | string
    TimeTotal?: IntWithAggregatesFilter<"trackappdetailtb"> | number
    AppSession?: BoolWithAggregatesFilter<"trackappdetailtb"> | boolean
    Sent?: BoolWithAggregatesFilter<"trackappdetailtb"> | boolean
    Machine?: StringWithAggregatesFilter<"trackappdetailtb"> | string
    SessionId?: IntWithAggregatesFilter<"trackappdetailtb"> | number
    ETT?: StringWithAggregatesFilter<"trackappdetailtb"> | string
  }

  export type trackapptbWhereInput = {
    AND?: trackapptbWhereInput | trackapptbWhereInput[]
    OR?: trackapptbWhereInput[]
    NOT?: trackapptbWhereInput | trackapptbWhereInput[]
    AppName?: StringFilter<"trackapptb"> | string
    TrackingType?: IntFilter<"trackapptb"> | number
  }

  export type trackapptbOrderByWithRelationInput = {
    AppName?: SortOrder
    TrackingType?: SortOrder
  }

  export type trackapptbWhereUniqueInput = Prisma.AtLeast<{
    AppName?: string
    AND?: trackapptbWhereInput | trackapptbWhereInput[]
    OR?: trackapptbWhereInput[]
    NOT?: trackapptbWhereInput | trackapptbWhereInput[]
    TrackingType?: IntFilter<"trackapptb"> | number
  }, "AppName">

  export type trackapptbOrderByWithAggregationInput = {
    AppName?: SortOrder
    TrackingType?: SortOrder
    _count?: trackapptbCountOrderByAggregateInput
    _avg?: trackapptbAvgOrderByAggregateInput
    _max?: trackapptbMaxOrderByAggregateInput
    _min?: trackapptbMinOrderByAggregateInput
    _sum?: trackapptbSumOrderByAggregateInput
  }

  export type trackapptbScalarWhereWithAggregatesInput = {
    AND?: trackapptbScalarWhereWithAggregatesInput | trackapptbScalarWhereWithAggregatesInput[]
    OR?: trackapptbScalarWhereWithAggregatesInput[]
    NOT?: trackapptbScalarWhereWithAggregatesInput | trackapptbScalarWhereWithAggregatesInput[]
    AppName?: StringWithAggregatesFilter<"trackapptb"> | string
    TrackingType?: IntWithAggregatesFilter<"trackapptb"> | number
  }

  export type trackguitbWhereInput = {
    AND?: trackguitbWhereInput | trackguitbWhereInput[]
    OR?: trackguitbWhereInput[]
    NOT?: trackguitbWhereInput | trackguitbWhereInput[]
    ID?: IntFilter<"trackguitb"> | number
    RecordDate?: DateTimeFilter<"trackguitb"> | Date | string
    FromTime?: DateTimeFilter<"trackguitb"> | Date | string
    ToTime?: DateTimeFilter<"trackguitb"> | Date | string
    DialogID?: IntFilter<"trackguitb"> | number
    PrePath?: StringNullableFilter<"trackguitb"> | string | null
    ControlID?: IntFilter<"trackguitb"> | number
    Type?: IntFilter<"trackguitb"> | number
    Param?: StringNullableFilter<"trackguitb"> | string | null
    ActionCount?: IntFilter<"trackguitb"> | number
  }

  export type trackguitbOrderByWithRelationInput = {
    ID?: SortOrder
    RecordDate?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
    DialogID?: SortOrder
    PrePath?: SortOrderInput | SortOrder
    ControlID?: SortOrder
    Type?: SortOrder
    Param?: SortOrderInput | SortOrder
    ActionCount?: SortOrder
  }

  export type trackguitbWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: trackguitbWhereInput | trackguitbWhereInput[]
    OR?: trackguitbWhereInput[]
    NOT?: trackguitbWhereInput | trackguitbWhereInput[]
    RecordDate?: DateTimeFilter<"trackguitb"> | Date | string
    FromTime?: DateTimeFilter<"trackguitb"> | Date | string
    ToTime?: DateTimeFilter<"trackguitb"> | Date | string
    DialogID?: IntFilter<"trackguitb"> | number
    PrePath?: StringNullableFilter<"trackguitb"> | string | null
    ControlID?: IntFilter<"trackguitb"> | number
    Type?: IntFilter<"trackguitb"> | number
    Param?: StringNullableFilter<"trackguitb"> | string | null
    ActionCount?: IntFilter<"trackguitb"> | number
  }, "ID">

  export type trackguitbOrderByWithAggregationInput = {
    ID?: SortOrder
    RecordDate?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
    DialogID?: SortOrder
    PrePath?: SortOrderInput | SortOrder
    ControlID?: SortOrder
    Type?: SortOrder
    Param?: SortOrderInput | SortOrder
    ActionCount?: SortOrder
    _count?: trackguitbCountOrderByAggregateInput
    _avg?: trackguitbAvgOrderByAggregateInput
    _max?: trackguitbMaxOrderByAggregateInput
    _min?: trackguitbMinOrderByAggregateInput
    _sum?: trackguitbSumOrderByAggregateInput
  }

  export type trackguitbScalarWhereWithAggregatesInput = {
    AND?: trackguitbScalarWhereWithAggregatesInput | trackguitbScalarWhereWithAggregatesInput[]
    OR?: trackguitbScalarWhereWithAggregatesInput[]
    NOT?: trackguitbScalarWhereWithAggregatesInput | trackguitbScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"trackguitb"> | number
    RecordDate?: DateTimeWithAggregatesFilter<"trackguitb"> | Date | string
    FromTime?: DateTimeWithAggregatesFilter<"trackguitb"> | Date | string
    ToTime?: DateTimeWithAggregatesFilter<"trackguitb"> | Date | string
    DialogID?: IntWithAggregatesFilter<"trackguitb"> | number
    PrePath?: StringNullableWithAggregatesFilter<"trackguitb"> | string | null
    ControlID?: IntWithAggregatesFilter<"trackguitb"> | number
    Type?: IntWithAggregatesFilter<"trackguitb"> | number
    Param?: StringNullableWithAggregatesFilter<"trackguitb"> | string | null
    ActionCount?: IntWithAggregatesFilter<"trackguitb"> | number
  }

  export type transferdetailtbWhereInput = {
    AND?: transferdetailtbWhereInput | transferdetailtbWhereInput[]
    OR?: transferdetailtbWhereInput[]
    NOT?: transferdetailtbWhereInput | transferdetailtbWhereInput[]
    TransferDetailId?: IntFilter<"transferdetailtb"> | number
    VoucherId?: IntFilter<"transferdetailtb"> | number
    FromUserId?: IntFilter<"transferdetailtb"> | number
    ToUserId?: IntFilter<"transferdetailtb"> | number
    TransferDate?: DateTimeFilter<"transferdetailtb"> | Date | string
    TransferTime?: DateTimeFilter<"transferdetailtb"> | Date | string
  }

  export type transferdetailtbOrderByWithRelationInput = {
    TransferDetailId?: SortOrder
    VoucherId?: SortOrder
    FromUserId?: SortOrder
    ToUserId?: SortOrder
    TransferDate?: SortOrder
    TransferTime?: SortOrder
  }

  export type transferdetailtbWhereUniqueInput = Prisma.AtLeast<{
    TransferDetailId?: number
    AND?: transferdetailtbWhereInput | transferdetailtbWhereInput[]
    OR?: transferdetailtbWhereInput[]
    NOT?: transferdetailtbWhereInput | transferdetailtbWhereInput[]
    VoucherId?: IntFilter<"transferdetailtb"> | number
    FromUserId?: IntFilter<"transferdetailtb"> | number
    ToUserId?: IntFilter<"transferdetailtb"> | number
    TransferDate?: DateTimeFilter<"transferdetailtb"> | Date | string
    TransferTime?: DateTimeFilter<"transferdetailtb"> | Date | string
  }, "TransferDetailId">

  export type transferdetailtbOrderByWithAggregationInput = {
    TransferDetailId?: SortOrder
    VoucherId?: SortOrder
    FromUserId?: SortOrder
    ToUserId?: SortOrder
    TransferDate?: SortOrder
    TransferTime?: SortOrder
    _count?: transferdetailtbCountOrderByAggregateInput
    _avg?: transferdetailtbAvgOrderByAggregateInput
    _max?: transferdetailtbMaxOrderByAggregateInput
    _min?: transferdetailtbMinOrderByAggregateInput
    _sum?: transferdetailtbSumOrderByAggregateInput
  }

  export type transferdetailtbScalarWhereWithAggregatesInput = {
    AND?: transferdetailtbScalarWhereWithAggregatesInput | transferdetailtbScalarWhereWithAggregatesInput[]
    OR?: transferdetailtbScalarWhereWithAggregatesInput[]
    NOT?: transferdetailtbScalarWhereWithAggregatesInput | transferdetailtbScalarWhereWithAggregatesInput[]
    TransferDetailId?: IntWithAggregatesFilter<"transferdetailtb"> | number
    VoucherId?: IntWithAggregatesFilter<"transferdetailtb"> | number
    FromUserId?: IntWithAggregatesFilter<"transferdetailtb"> | number
    ToUserId?: IntWithAggregatesFilter<"transferdetailtb"> | number
    TransferDate?: DateTimeWithAggregatesFilter<"transferdetailtb"> | Date | string
    TransferTime?: DateTimeWithAggregatesFilter<"transferdetailtb"> | Date | string
  }

  export type usagetimetbWhereInput = {
    AND?: usagetimetbWhereInput | usagetimetbWhereInput[]
    OR?: usagetimetbWhereInput[]
    NOT?: usagetimetbWhereInput | usagetimetbWhereInput[]
    UsageTimeId?: IntFilter<"usagetimetb"> | number
    UsageTimeName?: StringNullableFilter<"usagetimetb"> | string | null
    FromAge?: IntNullableFilter<"usagetimetb"> | number | null
    ToAge?: IntNullableFilter<"usagetimetb"> | number | null
    UserType?: IntFilter<"usagetimetb"> | number
  }

  export type usagetimetbOrderByWithRelationInput = {
    UsageTimeId?: SortOrder
    UsageTimeName?: SortOrderInput | SortOrder
    FromAge?: SortOrderInput | SortOrder
    ToAge?: SortOrderInput | SortOrder
    UserType?: SortOrder
  }

  export type usagetimetbWhereUniqueInput = Prisma.AtLeast<{
    UsageTimeId?: number
    AND?: usagetimetbWhereInput | usagetimetbWhereInput[]
    OR?: usagetimetbWhereInput[]
    NOT?: usagetimetbWhereInput | usagetimetbWhereInput[]
    UsageTimeName?: StringNullableFilter<"usagetimetb"> | string | null
    FromAge?: IntNullableFilter<"usagetimetb"> | number | null
    ToAge?: IntNullableFilter<"usagetimetb"> | number | null
    UserType?: IntFilter<"usagetimetb"> | number
  }, "UsageTimeId">

  export type usagetimetbOrderByWithAggregationInput = {
    UsageTimeId?: SortOrder
    UsageTimeName?: SortOrderInput | SortOrder
    FromAge?: SortOrderInput | SortOrder
    ToAge?: SortOrderInput | SortOrder
    UserType?: SortOrder
    _count?: usagetimetbCountOrderByAggregateInput
    _avg?: usagetimetbAvgOrderByAggregateInput
    _max?: usagetimetbMaxOrderByAggregateInput
    _min?: usagetimetbMinOrderByAggregateInput
    _sum?: usagetimetbSumOrderByAggregateInput
  }

  export type usagetimetbScalarWhereWithAggregatesInput = {
    AND?: usagetimetbScalarWhereWithAggregatesInput | usagetimetbScalarWhereWithAggregatesInput[]
    OR?: usagetimetbScalarWhereWithAggregatesInput[]
    NOT?: usagetimetbScalarWhereWithAggregatesInput | usagetimetbScalarWhereWithAggregatesInput[]
    UsageTimeId?: IntWithAggregatesFilter<"usagetimetb"> | number
    UsageTimeName?: StringNullableWithAggregatesFilter<"usagetimetb"> | string | null
    FromAge?: IntNullableWithAggregatesFilter<"usagetimetb"> | number | null
    ToAge?: IntNullableWithAggregatesFilter<"usagetimetb"> | number | null
    UserType?: IntWithAggregatesFilter<"usagetimetb"> | number
  }

  export type usertbWhereInput = {
    AND?: usertbWhereInput | usertbWhereInput[]
    OR?: usertbWhereInput[]
    NOT?: usertbWhereInput | usertbWhereInput[]
    UserId?: IntFilter<"usertb"> | number
    FirstName?: StringNullableFilter<"usertb"> | string | null
    LastName?: StringNullableFilter<"usertb"> | string | null
    MiddleName?: StringNullableFilter<"usertb"> | string | null
    UserName?: StringFilter<"usertb"> | string
    Password?: StringFilter<"usertb"> | string
    ID?: StringFilter<"usertb"> | string
    Address?: StringFilter<"usertb"> | string
    Phone?: StringFilter<"usertb"> | string
    Email?: StringFilter<"usertb"> | string
    City?: StringFilter<"usertb"> | string
    State?: StringFilter<"usertb"> | string
    Zipcode?: StringFilter<"usertb"> | string
    Debit?: DecimalFilter<"usertb"> | Decimal | DecimalJsLike | number | string
    CreditLimit?: DecimalFilter<"usertb"> | Decimal | DecimalJsLike | number | string
    Active?: BoolFilter<"usertb"> | boolean
    RecordDate?: DateTimeFilter<"usertb"> | Date | string
    ExpiryDate?: DateTimeNullableFilter<"usertb"> | Date | string | null
    UserType?: IntFilter<"usertb"> | number
    Memo?: StringFilter<"usertb"> | string
    Birthdate?: DateTimeNullableFilter<"usertb"> | Date | string | null
    SSN1?: StringFilter<"usertb"> | string
    SSN2?: StringFilter<"usertb"> | string
    SSN3?: StringFilter<"usertb"> | string
    TimePaid?: IntFilter<"usertb"> | number
    TimeUsed?: IntFilter<"usertb"> | number
    MoneyPaid?: IntFilter<"usertb"> | number
    MoneyUsed?: IntFilter<"usertb"> | number
    RemainTime?: IntFilter<"usertb"> | number
    FreeTime?: IntFilter<"usertb"> | number
    TimeTransfer?: IntFilter<"usertb"> | number
    RemainMoney?: IntFilter<"usertb"> | number
    FreeMoney?: IntFilter<"usertb"> | number
    MoneyTransfer?: IntFilter<"usertb"> | number
    UsageTimeId?: IntFilter<"usertb"> | number
    PromotionTime?: IntFilter<"usertb"> | number
    PromotionMoney?: IntFilter<"usertb"> | number
    MachineGroupId?: IntFilter<"usertb"> | number
    MAC?: StringFilter<"usertb"> | string
    changepcdetailId?: IntFilter<"usertb"> | number
    MoneyUsedMin?: IntFilter<"usertb"> | number
    CType?: IntNullableFilter<"usertb"> | number | null
    Status?: IntNullableFilter<"usertb"> | number | null
    LastLoginDate?: DateTimeFilter<"usertb"> | Date | string
    PriceAppRentID?: IntFilter<"usertb"> | number
    EIType?: IntNullableFilter<"usertb"> | number | null
    pc_rptInfo?: StringNullableFilter<"usertb"> | string | null
  }

  export type usertbOrderByWithRelationInput = {
    UserId?: SortOrder
    FirstName?: SortOrderInput | SortOrder
    LastName?: SortOrderInput | SortOrder
    MiddleName?: SortOrderInput | SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    ID?: SortOrder
    Address?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Zipcode?: SortOrder
    Debit?: SortOrder
    CreditLimit?: SortOrder
    Active?: SortOrder
    RecordDate?: SortOrder
    ExpiryDate?: SortOrderInput | SortOrder
    UserType?: SortOrder
    Memo?: SortOrder
    Birthdate?: SortOrderInput | SortOrder
    SSN1?: SortOrder
    SSN2?: SortOrder
    SSN3?: SortOrder
    TimePaid?: SortOrder
    TimeUsed?: SortOrder
    MoneyPaid?: SortOrder
    MoneyUsed?: SortOrder
    RemainTime?: SortOrder
    FreeTime?: SortOrder
    TimeTransfer?: SortOrder
    RemainMoney?: SortOrder
    FreeMoney?: SortOrder
    MoneyTransfer?: SortOrder
    UsageTimeId?: SortOrder
    PromotionTime?: SortOrder
    PromotionMoney?: SortOrder
    MachineGroupId?: SortOrder
    MAC?: SortOrder
    changepcdetailId?: SortOrder
    MoneyUsedMin?: SortOrder
    CType?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    LastLoginDate?: SortOrder
    PriceAppRentID?: SortOrder
    EIType?: SortOrderInput | SortOrder
    pc_rptInfo?: SortOrderInput | SortOrder
  }

  export type usertbWhereUniqueInput = Prisma.AtLeast<{
    UserId?: number
    AND?: usertbWhereInput | usertbWhereInput[]
    OR?: usertbWhereInput[]
    NOT?: usertbWhereInput | usertbWhereInput[]
    FirstName?: StringNullableFilter<"usertb"> | string | null
    LastName?: StringNullableFilter<"usertb"> | string | null
    MiddleName?: StringNullableFilter<"usertb"> | string | null
    UserName?: StringFilter<"usertb"> | string
    Password?: StringFilter<"usertb"> | string
    ID?: StringFilter<"usertb"> | string
    Address?: StringFilter<"usertb"> | string
    Phone?: StringFilter<"usertb"> | string
    Email?: StringFilter<"usertb"> | string
    City?: StringFilter<"usertb"> | string
    State?: StringFilter<"usertb"> | string
    Zipcode?: StringFilter<"usertb"> | string
    Debit?: DecimalFilter<"usertb"> | Decimal | DecimalJsLike | number | string
    CreditLimit?: DecimalFilter<"usertb"> | Decimal | DecimalJsLike | number | string
    Active?: BoolFilter<"usertb"> | boolean
    RecordDate?: DateTimeFilter<"usertb"> | Date | string
    ExpiryDate?: DateTimeNullableFilter<"usertb"> | Date | string | null
    UserType?: IntFilter<"usertb"> | number
    Memo?: StringFilter<"usertb"> | string
    Birthdate?: DateTimeNullableFilter<"usertb"> | Date | string | null
    SSN1?: StringFilter<"usertb"> | string
    SSN2?: StringFilter<"usertb"> | string
    SSN3?: StringFilter<"usertb"> | string
    TimePaid?: IntFilter<"usertb"> | number
    TimeUsed?: IntFilter<"usertb"> | number
    MoneyPaid?: IntFilter<"usertb"> | number
    MoneyUsed?: IntFilter<"usertb"> | number
    RemainTime?: IntFilter<"usertb"> | number
    FreeTime?: IntFilter<"usertb"> | number
    TimeTransfer?: IntFilter<"usertb"> | number
    RemainMoney?: IntFilter<"usertb"> | number
    FreeMoney?: IntFilter<"usertb"> | number
    MoneyTransfer?: IntFilter<"usertb"> | number
    UsageTimeId?: IntFilter<"usertb"> | number
    PromotionTime?: IntFilter<"usertb"> | number
    PromotionMoney?: IntFilter<"usertb"> | number
    MachineGroupId?: IntFilter<"usertb"> | number
    MAC?: StringFilter<"usertb"> | string
    changepcdetailId?: IntFilter<"usertb"> | number
    MoneyUsedMin?: IntFilter<"usertb"> | number
    CType?: IntNullableFilter<"usertb"> | number | null
    Status?: IntNullableFilter<"usertb"> | number | null
    LastLoginDate?: DateTimeFilter<"usertb"> | Date | string
    PriceAppRentID?: IntFilter<"usertb"> | number
    EIType?: IntNullableFilter<"usertb"> | number | null
    pc_rptInfo?: StringNullableFilter<"usertb"> | string | null
  }, "UserId">

  export type usertbOrderByWithAggregationInput = {
    UserId?: SortOrder
    FirstName?: SortOrderInput | SortOrder
    LastName?: SortOrderInput | SortOrder
    MiddleName?: SortOrderInput | SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    ID?: SortOrder
    Address?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Zipcode?: SortOrder
    Debit?: SortOrder
    CreditLimit?: SortOrder
    Active?: SortOrder
    RecordDate?: SortOrder
    ExpiryDate?: SortOrderInput | SortOrder
    UserType?: SortOrder
    Memo?: SortOrder
    Birthdate?: SortOrderInput | SortOrder
    SSN1?: SortOrder
    SSN2?: SortOrder
    SSN3?: SortOrder
    TimePaid?: SortOrder
    TimeUsed?: SortOrder
    MoneyPaid?: SortOrder
    MoneyUsed?: SortOrder
    RemainTime?: SortOrder
    FreeTime?: SortOrder
    TimeTransfer?: SortOrder
    RemainMoney?: SortOrder
    FreeMoney?: SortOrder
    MoneyTransfer?: SortOrder
    UsageTimeId?: SortOrder
    PromotionTime?: SortOrder
    PromotionMoney?: SortOrder
    MachineGroupId?: SortOrder
    MAC?: SortOrder
    changepcdetailId?: SortOrder
    MoneyUsedMin?: SortOrder
    CType?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    LastLoginDate?: SortOrder
    PriceAppRentID?: SortOrder
    EIType?: SortOrderInput | SortOrder
    pc_rptInfo?: SortOrderInput | SortOrder
    _count?: usertbCountOrderByAggregateInput
    _avg?: usertbAvgOrderByAggregateInput
    _max?: usertbMaxOrderByAggregateInput
    _min?: usertbMinOrderByAggregateInput
    _sum?: usertbSumOrderByAggregateInput
  }

  export type usertbScalarWhereWithAggregatesInput = {
    AND?: usertbScalarWhereWithAggregatesInput | usertbScalarWhereWithAggregatesInput[]
    OR?: usertbScalarWhereWithAggregatesInput[]
    NOT?: usertbScalarWhereWithAggregatesInput | usertbScalarWhereWithAggregatesInput[]
    UserId?: IntWithAggregatesFilter<"usertb"> | number
    FirstName?: StringNullableWithAggregatesFilter<"usertb"> | string | null
    LastName?: StringNullableWithAggregatesFilter<"usertb"> | string | null
    MiddleName?: StringNullableWithAggregatesFilter<"usertb"> | string | null
    UserName?: StringWithAggregatesFilter<"usertb"> | string
    Password?: StringWithAggregatesFilter<"usertb"> | string
    ID?: StringWithAggregatesFilter<"usertb"> | string
    Address?: StringWithAggregatesFilter<"usertb"> | string
    Phone?: StringWithAggregatesFilter<"usertb"> | string
    Email?: StringWithAggregatesFilter<"usertb"> | string
    City?: StringWithAggregatesFilter<"usertb"> | string
    State?: StringWithAggregatesFilter<"usertb"> | string
    Zipcode?: StringWithAggregatesFilter<"usertb"> | string
    Debit?: DecimalWithAggregatesFilter<"usertb"> | Decimal | DecimalJsLike | number | string
    CreditLimit?: DecimalWithAggregatesFilter<"usertb"> | Decimal | DecimalJsLike | number | string
    Active?: BoolWithAggregatesFilter<"usertb"> | boolean
    RecordDate?: DateTimeWithAggregatesFilter<"usertb"> | Date | string
    ExpiryDate?: DateTimeNullableWithAggregatesFilter<"usertb"> | Date | string | null
    UserType?: IntWithAggregatesFilter<"usertb"> | number
    Memo?: StringWithAggregatesFilter<"usertb"> | string
    Birthdate?: DateTimeNullableWithAggregatesFilter<"usertb"> | Date | string | null
    SSN1?: StringWithAggregatesFilter<"usertb"> | string
    SSN2?: StringWithAggregatesFilter<"usertb"> | string
    SSN3?: StringWithAggregatesFilter<"usertb"> | string
    TimePaid?: IntWithAggregatesFilter<"usertb"> | number
    TimeUsed?: IntWithAggregatesFilter<"usertb"> | number
    MoneyPaid?: IntWithAggregatesFilter<"usertb"> | number
    MoneyUsed?: IntWithAggregatesFilter<"usertb"> | number
    RemainTime?: IntWithAggregatesFilter<"usertb"> | number
    FreeTime?: IntWithAggregatesFilter<"usertb"> | number
    TimeTransfer?: IntWithAggregatesFilter<"usertb"> | number
    RemainMoney?: IntWithAggregatesFilter<"usertb"> | number
    FreeMoney?: IntWithAggregatesFilter<"usertb"> | number
    MoneyTransfer?: IntWithAggregatesFilter<"usertb"> | number
    UsageTimeId?: IntWithAggregatesFilter<"usertb"> | number
    PromotionTime?: IntWithAggregatesFilter<"usertb"> | number
    PromotionMoney?: IntWithAggregatesFilter<"usertb"> | number
    MachineGroupId?: IntWithAggregatesFilter<"usertb"> | number
    MAC?: StringWithAggregatesFilter<"usertb"> | string
    changepcdetailId?: IntWithAggregatesFilter<"usertb"> | number
    MoneyUsedMin?: IntWithAggregatesFilter<"usertb"> | number
    CType?: IntNullableWithAggregatesFilter<"usertb"> | number | null
    Status?: IntNullableWithAggregatesFilter<"usertb"> | number | null
    LastLoginDate?: DateTimeWithAggregatesFilter<"usertb"> | Date | string
    PriceAppRentID?: IntWithAggregatesFilter<"usertb"> | number
    EIType?: IntNullableWithAggregatesFilter<"usertb"> | number | null
    pc_rptInfo?: StringNullableWithAggregatesFilter<"usertb"> | string | null
  }

  export type versiontbWhereInput = {
    AND?: versiontbWhereInput | versiontbWhereInput[]
    OR?: versiontbWhereInput[]
    NOT?: versiontbWhereInput | versiontbWhereInput[]
    ComputerName?: StringFilter<"versiontb"> | string
    Version?: StringFilter<"versiontb"> | string
    Type?: IntFilter<"versiontb"> | number
    ReleaseDate?: DateTimeFilter<"versiontb"> | Date | string
    LastUpdate?: DateTimeFilter<"versiontb"> | Date | string
    DPStatus?: IntNullableFilter<"versiontb"> | number | null
    DPType?: IntNullableFilter<"versiontb"> | number | null
    DPVersion?: StringFilter<"versiontb"> | string
  }

  export type versiontbOrderByWithRelationInput = {
    ComputerName?: SortOrder
    Version?: SortOrder
    Type?: SortOrder
    ReleaseDate?: SortOrder
    LastUpdate?: SortOrder
    DPStatus?: SortOrderInput | SortOrder
    DPType?: SortOrderInput | SortOrder
    DPVersion?: SortOrder
  }

  export type versiontbWhereUniqueInput = Prisma.AtLeast<{
    ComputerName?: string
    AND?: versiontbWhereInput | versiontbWhereInput[]
    OR?: versiontbWhereInput[]
    NOT?: versiontbWhereInput | versiontbWhereInput[]
    Version?: StringFilter<"versiontb"> | string
    Type?: IntFilter<"versiontb"> | number
    ReleaseDate?: DateTimeFilter<"versiontb"> | Date | string
    LastUpdate?: DateTimeFilter<"versiontb"> | Date | string
    DPStatus?: IntNullableFilter<"versiontb"> | number | null
    DPType?: IntNullableFilter<"versiontb"> | number | null
    DPVersion?: StringFilter<"versiontb"> | string
  }, "ComputerName">

  export type versiontbOrderByWithAggregationInput = {
    ComputerName?: SortOrder
    Version?: SortOrder
    Type?: SortOrder
    ReleaseDate?: SortOrder
    LastUpdate?: SortOrder
    DPStatus?: SortOrderInput | SortOrder
    DPType?: SortOrderInput | SortOrder
    DPVersion?: SortOrder
    _count?: versiontbCountOrderByAggregateInput
    _avg?: versiontbAvgOrderByAggregateInput
    _max?: versiontbMaxOrderByAggregateInput
    _min?: versiontbMinOrderByAggregateInput
    _sum?: versiontbSumOrderByAggregateInput
  }

  export type versiontbScalarWhereWithAggregatesInput = {
    AND?: versiontbScalarWhereWithAggregatesInput | versiontbScalarWhereWithAggregatesInput[]
    OR?: versiontbScalarWhereWithAggregatesInput[]
    NOT?: versiontbScalarWhereWithAggregatesInput | versiontbScalarWhereWithAggregatesInput[]
    ComputerName?: StringWithAggregatesFilter<"versiontb"> | string
    Version?: StringWithAggregatesFilter<"versiontb"> | string
    Type?: IntWithAggregatesFilter<"versiontb"> | number
    ReleaseDate?: DateTimeWithAggregatesFilter<"versiontb"> | Date | string
    LastUpdate?: DateTimeWithAggregatesFilter<"versiontb"> | Date | string
    DPStatus?: IntNullableWithAggregatesFilter<"versiontb"> | number | null
    DPType?: IntNullableWithAggregatesFilter<"versiontb"> | number | null
    DPVersion?: StringWithAggregatesFilter<"versiontb"> | string
  }

  export type wallettbWhereInput = {
    AND?: wallettbWhereInput | wallettbWhereInput[]
    OR?: wallettbWhereInput[]
    NOT?: wallettbWhereInput | wallettbWhereInput[]
    id?: BigIntFilter<"wallettb"> | bigint | number
    main?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    sub?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    sub1?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    sub2?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    userid?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    status?: IntNullableFilter<"wallettb"> | number | null
    ts?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    wsec?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    ssec?: StringNullableFilter<"wallettb"> | string | null
  }

  export type wallettbOrderByWithRelationInput = {
    id?: SortOrder
    main?: SortOrderInput | SortOrder
    sub?: SortOrderInput | SortOrder
    sub1?: SortOrderInput | SortOrder
    sub2?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    ts?: SortOrderInput | SortOrder
    wsec?: SortOrderInput | SortOrder
    ssec?: SortOrderInput | SortOrder
  }

  export type wallettbWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: wallettbWhereInput | wallettbWhereInput[]
    OR?: wallettbWhereInput[]
    NOT?: wallettbWhereInput | wallettbWhereInput[]
    main?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    sub?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    sub1?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    sub2?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    userid?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    status?: IntNullableFilter<"wallettb"> | number | null
    ts?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    wsec?: BigIntNullableFilter<"wallettb"> | bigint | number | null
    ssec?: StringNullableFilter<"wallettb"> | string | null
  }, "id">

  export type wallettbOrderByWithAggregationInput = {
    id?: SortOrder
    main?: SortOrderInput | SortOrder
    sub?: SortOrderInput | SortOrder
    sub1?: SortOrderInput | SortOrder
    sub2?: SortOrderInput | SortOrder
    userid?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    ts?: SortOrderInput | SortOrder
    wsec?: SortOrderInput | SortOrder
    ssec?: SortOrderInput | SortOrder
    _count?: wallettbCountOrderByAggregateInput
    _avg?: wallettbAvgOrderByAggregateInput
    _max?: wallettbMaxOrderByAggregateInput
    _min?: wallettbMinOrderByAggregateInput
    _sum?: wallettbSumOrderByAggregateInput
  }

  export type wallettbScalarWhereWithAggregatesInput = {
    AND?: wallettbScalarWhereWithAggregatesInput | wallettbScalarWhereWithAggregatesInput[]
    OR?: wallettbScalarWhereWithAggregatesInput[]
    NOT?: wallettbScalarWhereWithAggregatesInput | wallettbScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"wallettb"> | bigint | number
    main?: BigIntNullableWithAggregatesFilter<"wallettb"> | bigint | number | null
    sub?: BigIntNullableWithAggregatesFilter<"wallettb"> | bigint | number | null
    sub1?: BigIntNullableWithAggregatesFilter<"wallettb"> | bigint | number | null
    sub2?: BigIntNullableWithAggregatesFilter<"wallettb"> | bigint | number | null
    userid?: BigIntNullableWithAggregatesFilter<"wallettb"> | bigint | number | null
    status?: IntNullableWithAggregatesFilter<"wallettb"> | number | null
    ts?: BigIntNullableWithAggregatesFilter<"wallettb"> | bigint | number | null
    wsec?: BigIntNullableWithAggregatesFilter<"wallettb"> | bigint | number | null
    ssec?: StringNullableWithAggregatesFilter<"wallettb"> | string | null
  }

  export type webhistorytbWhereInput = {
    AND?: webhistorytbWhereInput | webhistorytbWhereInput[]
    OR?: webhistorytbWhereInput[]
    NOT?: webhistorytbWhereInput | webhistorytbWhereInput[]
    URLId?: IntFilter<"webhistorytb"> | number
    URL?: StringFilter<"webhistorytb"> | string
    RecordDate?: DateTimeFilter<"webhistorytb"> | Date | string
    UserId?: IntFilter<"webhistorytb"> | number
    Machine?: StringFilter<"webhistorytb"> | string
    Active?: IntFilter<"webhistorytb"> | number
    Session?: IntFilter<"webhistorytb"> | number
    AnonymousId?: IntFilter<"webhistorytb"> | number
    BrowserType?: BoolFilter<"webhistorytb"> | boolean
  }

  export type webhistorytbOrderByWithRelationInput = {
    URLId?: SortOrder
    URL?: SortOrder
    RecordDate?: SortOrder
    UserId?: SortOrder
    Machine?: SortOrder
    Active?: SortOrder
    Session?: SortOrder
    AnonymousId?: SortOrder
    BrowserType?: SortOrder
  }

  export type webhistorytbWhereUniqueInput = Prisma.AtLeast<{
    URLId?: number
    AND?: webhistorytbWhereInput | webhistorytbWhereInput[]
    OR?: webhistorytbWhereInput[]
    NOT?: webhistorytbWhereInput | webhistorytbWhereInput[]
    URL?: StringFilter<"webhistorytb"> | string
    RecordDate?: DateTimeFilter<"webhistorytb"> | Date | string
    UserId?: IntFilter<"webhistorytb"> | number
    Machine?: StringFilter<"webhistorytb"> | string
    Active?: IntFilter<"webhistorytb"> | number
    Session?: IntFilter<"webhistorytb"> | number
    AnonymousId?: IntFilter<"webhistorytb"> | number
    BrowserType?: BoolFilter<"webhistorytb"> | boolean
  }, "URLId">

  export type webhistorytbOrderByWithAggregationInput = {
    URLId?: SortOrder
    URL?: SortOrder
    RecordDate?: SortOrder
    UserId?: SortOrder
    Machine?: SortOrder
    Active?: SortOrder
    Session?: SortOrder
    AnonymousId?: SortOrder
    BrowserType?: SortOrder
    _count?: webhistorytbCountOrderByAggregateInput
    _avg?: webhistorytbAvgOrderByAggregateInput
    _max?: webhistorytbMaxOrderByAggregateInput
    _min?: webhistorytbMinOrderByAggregateInput
    _sum?: webhistorytbSumOrderByAggregateInput
  }

  export type webhistorytbScalarWhereWithAggregatesInput = {
    AND?: webhistorytbScalarWhereWithAggregatesInput | webhistorytbScalarWhereWithAggregatesInput[]
    OR?: webhistorytbScalarWhereWithAggregatesInput[]
    NOT?: webhistorytbScalarWhereWithAggregatesInput | webhistorytbScalarWhereWithAggregatesInput[]
    URLId?: IntWithAggregatesFilter<"webhistorytb"> | number
    URL?: StringWithAggregatesFilter<"webhistorytb"> | string
    RecordDate?: DateTimeWithAggregatesFilter<"webhistorytb"> | Date | string
    UserId?: IntWithAggregatesFilter<"webhistorytb"> | number
    Machine?: StringWithAggregatesFilter<"webhistorytb"> | string
    Active?: IntWithAggregatesFilter<"webhistorytb"> | number
    Session?: IntWithAggregatesFilter<"webhistorytb"> | number
    AnonymousId?: IntWithAggregatesFilter<"webhistorytb"> | number
    BrowserType?: BoolWithAggregatesFilter<"webhistorytb"> | boolean
  }

  export type accountingentrytbCreateInput = {
    CreateDate?: Date | string
    CreateTime?: Date | string
    StaffID?: number
    FromDate?: Date | string
    FromTime?: Date | string
    NumBalance?: number
    ImportQuantity?: number
    ImportTotalAmount?: Decimal | DecimalJsLike | number | string
    SaleQuantity?: number
    SaleTotalAmount?: Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: number
    NumInventoryReal?: number
    NumAdjust?: number
    Note?: string | null
    ServiceID?: number
  }

  export type accountingentrytbUncheckedCreateInput = {
    ID?: number
    CreateDate?: Date | string
    CreateTime?: Date | string
    StaffID?: number
    FromDate?: Date | string
    FromTime?: Date | string
    NumBalance?: number
    ImportQuantity?: number
    ImportTotalAmount?: Decimal | DecimalJsLike | number | string
    SaleQuantity?: number
    SaleTotalAmount?: Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: number
    NumInventoryReal?: number
    NumAdjust?: number
    Note?: string | null
    ServiceID?: number
  }

  export type accountingentrytbUpdateInput = {
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NumBalance?: IntFieldUpdateOperationsInput | number
    ImportQuantity?: IntFieldUpdateOperationsInput | number
    ImportTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SaleQuantity?: IntFieldUpdateOperationsInput | number
    SaleTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    NumInventoryReal?: IntFieldUpdateOperationsInput | number
    NumAdjust?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type accountingentrytbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NumBalance?: IntFieldUpdateOperationsInput | number
    ImportQuantity?: IntFieldUpdateOperationsInput | number
    ImportTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SaleQuantity?: IntFieldUpdateOperationsInput | number
    SaleTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    NumInventoryReal?: IntFieldUpdateOperationsInput | number
    NumAdjust?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type accountingentrytbCreateManyInput = {
    ID?: number
    CreateDate?: Date | string
    CreateTime?: Date | string
    StaffID?: number
    FromDate?: Date | string
    FromTime?: Date | string
    NumBalance?: number
    ImportQuantity?: number
    ImportTotalAmount?: Decimal | DecimalJsLike | number | string
    SaleQuantity?: number
    SaleTotalAmount?: Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: number
    NumInventoryReal?: number
    NumAdjust?: number
    Note?: string | null
    ServiceID?: number
  }

  export type accountingentrytbUpdateManyMutationInput = {
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NumBalance?: IntFieldUpdateOperationsInput | number
    ImportQuantity?: IntFieldUpdateOperationsInput | number
    ImportTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SaleQuantity?: IntFieldUpdateOperationsInput | number
    SaleTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    NumInventoryReal?: IntFieldUpdateOperationsInput | number
    NumAdjust?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type accountingentrytbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NumBalance?: IntFieldUpdateOperationsInput | number
    ImportQuantity?: IntFieldUpdateOperationsInput | number
    ImportTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    SaleQuantity?: IntFieldUpdateOperationsInput | number
    SaleTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    NumInventoryReal?: IntFieldUpdateOperationsInput | number
    NumAdjust?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type anonymoustbCreateInput = {
    Name?: string | null
    IDCard?: string | null
    Address?: string | null
    MachineID?: number | null
    Session?: number
    RecordDate: Date | string
  }

  export type anonymoustbUncheckedCreateInput = {
    ID?: number
    Name?: string | null
    IDCard?: string | null
    Address?: string | null
    MachineID?: number | null
    Session?: number
    RecordDate: Date | string
  }

  export type anonymoustbUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    IDCard?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    MachineID?: NullableIntFieldUpdateOperationsInput | number | null
    Session?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type anonymoustbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    IDCard?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    MachineID?: NullableIntFieldUpdateOperationsInput | number | null
    Session?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type anonymoustbCreateManyInput = {
    ID?: number
    Name?: string | null
    IDCard?: string | null
    Address?: string | null
    MachineID?: number | null
    Session?: number
    RecordDate: Date | string
  }

  export type anonymoustbUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    IDCard?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    MachineID?: NullableIntFieldUpdateOperationsInput | number | null
    Session?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type anonymoustbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    IDCard?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    MachineID?: NullableIntFieldUpdateOperationsInput | number | null
    Session?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type applicationrenttbCreateInput = {
    Name?: string
    Hash?: string
    AddBy?: number
    Status?: number
  }

  export type applicationrenttbUncheckedCreateInput = {
    ApplicationRentID?: number
    Name?: string
    Hash?: string
    AddBy?: number
    Status?: number
  }

  export type applicationrenttbUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Hash?: StringFieldUpdateOperationsInput | string
    AddBy?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type applicationrenttbUncheckedUpdateInput = {
    ApplicationRentID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Hash?: StringFieldUpdateOperationsInput | string
    AddBy?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type applicationrenttbCreateManyInput = {
    ApplicationRentID?: number
    Name?: string
    Hash?: string
    AddBy?: number
    Status?: number
  }

  export type applicationrenttbUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Hash?: StringFieldUpdateOperationsInput | string
    AddBy?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type applicationrenttbUncheckedUpdateManyInput = {
    ApplicationRentID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Hash?: StringFieldUpdateOperationsInput | string
    AddBy?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type applicationtbCreateInput = {
    ApplicationName: string
    Description?: string | null
    RestrictType?: number
    Hash?: string | null
    AppType?: number
    AddedBy?: number
  }

  export type applicationtbUncheckedCreateInput = {
    ApplicationId?: number
    ApplicationName: string
    Description?: string | null
    RestrictType?: number
    Hash?: string | null
    AppType?: number
    AddedBy?: number
  }

  export type applicationtbUpdateInput = {
    ApplicationName?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    RestrictType?: IntFieldUpdateOperationsInput | number
    Hash?: NullableStringFieldUpdateOperationsInput | string | null
    AppType?: IntFieldUpdateOperationsInput | number
    AddedBy?: IntFieldUpdateOperationsInput | number
  }

  export type applicationtbUncheckedUpdateInput = {
    ApplicationId?: IntFieldUpdateOperationsInput | number
    ApplicationName?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    RestrictType?: IntFieldUpdateOperationsInput | number
    Hash?: NullableStringFieldUpdateOperationsInput | string | null
    AppType?: IntFieldUpdateOperationsInput | number
    AddedBy?: IntFieldUpdateOperationsInput | number
  }

  export type applicationtbCreateManyInput = {
    ApplicationId?: number
    ApplicationName: string
    Description?: string | null
    RestrictType?: number
    Hash?: string | null
    AppType?: number
    AddedBy?: number
  }

  export type applicationtbUpdateManyMutationInput = {
    ApplicationName?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    RestrictType?: IntFieldUpdateOperationsInput | number
    Hash?: NullableStringFieldUpdateOperationsInput | string | null
    AppType?: IntFieldUpdateOperationsInput | number
    AddedBy?: IntFieldUpdateOperationsInput | number
  }

  export type applicationtbUncheckedUpdateManyInput = {
    ApplicationId?: IntFieldUpdateOperationsInput | number
    ApplicationName?: StringFieldUpdateOperationsInput | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    RestrictType?: IntFieldUpdateOperationsInput | number
    Hash?: NullableStringFieldUpdateOperationsInput | string | null
    AppType?: IntFieldUpdateOperationsInput | number
    AddedBy?: IntFieldUpdateOperationsInput | number
  }

  export type blacklisttbCreateInput = {
    URL: string
    Title?: string | null
    Description?: string | null
    RecordDate: Date | string
    Active?: number
    AddedBy?: number
  }

  export type blacklisttbUncheckedCreateInput = {
    URLId?: number
    URL: string
    Title?: string | null
    Description?: string | null
    RecordDate: Date | string
    Active?: number
    AddedBy?: number
  }

  export type blacklisttbUpdateInput = {
    URL?: StringFieldUpdateOperationsInput | string
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: IntFieldUpdateOperationsInput | number
    AddedBy?: IntFieldUpdateOperationsInput | number
  }

  export type blacklisttbUncheckedUpdateInput = {
    URLId?: IntFieldUpdateOperationsInput | number
    URL?: StringFieldUpdateOperationsInput | string
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: IntFieldUpdateOperationsInput | number
    AddedBy?: IntFieldUpdateOperationsInput | number
  }

  export type blacklisttbCreateManyInput = {
    URLId?: number
    URL: string
    Title?: string | null
    Description?: string | null
    RecordDate: Date | string
    Active?: number
    AddedBy?: number
  }

  export type blacklisttbUpdateManyMutationInput = {
    URL?: StringFieldUpdateOperationsInput | string
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: IntFieldUpdateOperationsInput | number
    AddedBy?: IntFieldUpdateOperationsInput | number
  }

  export type blacklisttbUncheckedUpdateManyInput = {
    URLId?: IntFieldUpdateOperationsInput | number
    URL?: StringFieldUpdateOperationsInput | string
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Active?: IntFieldUpdateOperationsInput | number
    AddedBy?: IntFieldUpdateOperationsInput | number
  }

  export type changepcdetailtbCreateInput = {
    VoucherId?: number
    FromMachineId?: number
    ToMachineId?: number
    TimeUsed?: number
    MoneyUsed?: number
    SessionId?: number
    ChangePCDate?: Date | string
    ChangePCTime?: Date | string
    BeginDateTime?: Date | string
    LogNote?: string
    MachineName?: string
    LogType?: number
  }

  export type changepcdetailtbUncheckedCreateInput = {
    ChangePCDetailId?: number
    VoucherId?: number
    FromMachineId?: number
    ToMachineId?: number
    TimeUsed?: number
    MoneyUsed?: number
    SessionId?: number
    ChangePCDate?: Date | string
    ChangePCTime?: Date | string
    BeginDateTime?: Date | string
    LogNote?: string
    MachineName?: string
    LogType?: number
  }

  export type changepcdetailtbUpdateInput = {
    VoucherId?: IntFieldUpdateOperationsInput | number
    FromMachineId?: IntFieldUpdateOperationsInput | number
    ToMachineId?: IntFieldUpdateOperationsInput | number
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    SessionId?: IntFieldUpdateOperationsInput | number
    ChangePCDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ChangePCTime?: DateTimeFieldUpdateOperationsInput | Date | string
    BeginDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    LogNote?: StringFieldUpdateOperationsInput | string
    MachineName?: StringFieldUpdateOperationsInput | string
    LogType?: IntFieldUpdateOperationsInput | number
  }

  export type changepcdetailtbUncheckedUpdateInput = {
    ChangePCDetailId?: IntFieldUpdateOperationsInput | number
    VoucherId?: IntFieldUpdateOperationsInput | number
    FromMachineId?: IntFieldUpdateOperationsInput | number
    ToMachineId?: IntFieldUpdateOperationsInput | number
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    SessionId?: IntFieldUpdateOperationsInput | number
    ChangePCDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ChangePCTime?: DateTimeFieldUpdateOperationsInput | Date | string
    BeginDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    LogNote?: StringFieldUpdateOperationsInput | string
    MachineName?: StringFieldUpdateOperationsInput | string
    LogType?: IntFieldUpdateOperationsInput | number
  }

  export type changepcdetailtbCreateManyInput = {
    ChangePCDetailId?: number
    VoucherId?: number
    FromMachineId?: number
    ToMachineId?: number
    TimeUsed?: number
    MoneyUsed?: number
    SessionId?: number
    ChangePCDate?: Date | string
    ChangePCTime?: Date | string
    BeginDateTime?: Date | string
    LogNote?: string
    MachineName?: string
    LogType?: number
  }

  export type changepcdetailtbUpdateManyMutationInput = {
    VoucherId?: IntFieldUpdateOperationsInput | number
    FromMachineId?: IntFieldUpdateOperationsInput | number
    ToMachineId?: IntFieldUpdateOperationsInput | number
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    SessionId?: IntFieldUpdateOperationsInput | number
    ChangePCDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ChangePCTime?: DateTimeFieldUpdateOperationsInput | Date | string
    BeginDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    LogNote?: StringFieldUpdateOperationsInput | string
    MachineName?: StringFieldUpdateOperationsInput | string
    LogType?: IntFieldUpdateOperationsInput | number
  }

  export type changepcdetailtbUncheckedUpdateManyInput = {
    ChangePCDetailId?: IntFieldUpdateOperationsInput | number
    VoucherId?: IntFieldUpdateOperationsInput | number
    FromMachineId?: IntFieldUpdateOperationsInput | number
    ToMachineId?: IntFieldUpdateOperationsInput | number
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    SessionId?: IntFieldUpdateOperationsInput | number
    ChangePCDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ChangePCTime?: DateTimeFieldUpdateOperationsInput | Date | string
    BeginDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    LogNote?: StringFieldUpdateOperationsInput | string
    MachineName?: StringFieldUpdateOperationsInput | string
    LogType?: IntFieldUpdateOperationsInput | number
  }

  export type clientatbCreateInput = {
    PubID?: number
    AID?: number
    DateA?: string
    STime?: number
    ETime?: number
    FName?: string
    FLink?: string
    Area?: string
    Panel?: number
    Row?: number
    Col?: number
    Method?: string
    CountS?: number
    CountC?: number
    RecordDate?: string
  }

  export type clientatbUncheckedCreateInput = {
    ID?: number
    PubID?: number
    AID?: number
    DateA?: string
    STime?: number
    ETime?: number
    FName?: string
    FLink?: string
    Area?: string
    Panel?: number
    Row?: number
    Col?: number
    Method?: string
    CountS?: number
    CountC?: number
    RecordDate?: string
  }

  export type clientatbUpdateInput = {
    PubID?: IntFieldUpdateOperationsInput | number
    AID?: IntFieldUpdateOperationsInput | number
    DateA?: StringFieldUpdateOperationsInput | string
    STime?: IntFieldUpdateOperationsInput | number
    ETime?: IntFieldUpdateOperationsInput | number
    FName?: StringFieldUpdateOperationsInput | string
    FLink?: StringFieldUpdateOperationsInput | string
    Area?: StringFieldUpdateOperationsInput | string
    Panel?: IntFieldUpdateOperationsInput | number
    Row?: IntFieldUpdateOperationsInput | number
    Col?: IntFieldUpdateOperationsInput | number
    Method?: StringFieldUpdateOperationsInput | string
    CountS?: IntFieldUpdateOperationsInput | number
    CountC?: IntFieldUpdateOperationsInput | number
    RecordDate?: StringFieldUpdateOperationsInput | string
  }

  export type clientatbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    PubID?: IntFieldUpdateOperationsInput | number
    AID?: IntFieldUpdateOperationsInput | number
    DateA?: StringFieldUpdateOperationsInput | string
    STime?: IntFieldUpdateOperationsInput | number
    ETime?: IntFieldUpdateOperationsInput | number
    FName?: StringFieldUpdateOperationsInput | string
    FLink?: StringFieldUpdateOperationsInput | string
    Area?: StringFieldUpdateOperationsInput | string
    Panel?: IntFieldUpdateOperationsInput | number
    Row?: IntFieldUpdateOperationsInput | number
    Col?: IntFieldUpdateOperationsInput | number
    Method?: StringFieldUpdateOperationsInput | string
    CountS?: IntFieldUpdateOperationsInput | number
    CountC?: IntFieldUpdateOperationsInput | number
    RecordDate?: StringFieldUpdateOperationsInput | string
  }

  export type clientatbCreateManyInput = {
    ID?: number
    PubID?: number
    AID?: number
    DateA?: string
    STime?: number
    ETime?: number
    FName?: string
    FLink?: string
    Area?: string
    Panel?: number
    Row?: number
    Col?: number
    Method?: string
    CountS?: number
    CountC?: number
    RecordDate?: string
  }

  export type clientatbUpdateManyMutationInput = {
    PubID?: IntFieldUpdateOperationsInput | number
    AID?: IntFieldUpdateOperationsInput | number
    DateA?: StringFieldUpdateOperationsInput | string
    STime?: IntFieldUpdateOperationsInput | number
    ETime?: IntFieldUpdateOperationsInput | number
    FName?: StringFieldUpdateOperationsInput | string
    FLink?: StringFieldUpdateOperationsInput | string
    Area?: StringFieldUpdateOperationsInput | string
    Panel?: IntFieldUpdateOperationsInput | number
    Row?: IntFieldUpdateOperationsInput | number
    Col?: IntFieldUpdateOperationsInput | number
    Method?: StringFieldUpdateOperationsInput | string
    CountS?: IntFieldUpdateOperationsInput | number
    CountC?: IntFieldUpdateOperationsInput | number
    RecordDate?: StringFieldUpdateOperationsInput | string
  }

  export type clientatbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    PubID?: IntFieldUpdateOperationsInput | number
    AID?: IntFieldUpdateOperationsInput | number
    DateA?: StringFieldUpdateOperationsInput | string
    STime?: IntFieldUpdateOperationsInput | number
    ETime?: IntFieldUpdateOperationsInput | number
    FName?: StringFieldUpdateOperationsInput | string
    FLink?: StringFieldUpdateOperationsInput | string
    Area?: StringFieldUpdateOperationsInput | string
    Panel?: IntFieldUpdateOperationsInput | number
    Row?: IntFieldUpdateOperationsInput | number
    Col?: IntFieldUpdateOperationsInput | number
    Method?: StringFieldUpdateOperationsInput | string
    CountS?: IntFieldUpdateOperationsInput | number
    CountC?: IntFieldUpdateOperationsInput | number
    RecordDate?: StringFieldUpdateOperationsInput | string
  }

  export type clientsystbCreateInput = {
    UserId?: number
    MAC?: string
    CPU?: string
    RAM?: string
    HD?: string
    OS?: string
    CardName?: string
    ChipType?: string
    VGAMem?: string
    NIC?: string
    FreeSpace?: string
    CPName?: string
    Active?: number
    NTFS?: string
    FAT?: string
    Mainboard?: string
    IP?: string
    LAN?: string
    RamFree?: string
    PageFile?: string
    TempCPU?: string
    LoadCPU?: string
    TempGPU?: string
    LoadGPU?: string
    LastUpdate?: Date | string
    PCName?: string | null
    NetInfo?: string | null
  }

  export type clientsystbUncheckedCreateInput = {
    ID?: number
    UserId?: number
    MAC?: string
    CPU?: string
    RAM?: string
    HD?: string
    OS?: string
    CardName?: string
    ChipType?: string
    VGAMem?: string
    NIC?: string
    FreeSpace?: string
    CPName?: string
    Active?: number
    NTFS?: string
    FAT?: string
    Mainboard?: string
    IP?: string
    LAN?: string
    RamFree?: string
    PageFile?: string
    TempCPU?: string
    LoadCPU?: string
    TempGPU?: string
    LoadGPU?: string
    LastUpdate?: Date | string
    PCName?: string | null
    NetInfo?: string | null
  }

  export type clientsystbUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    MAC?: StringFieldUpdateOperationsInput | string
    CPU?: StringFieldUpdateOperationsInput | string
    RAM?: StringFieldUpdateOperationsInput | string
    HD?: StringFieldUpdateOperationsInput | string
    OS?: StringFieldUpdateOperationsInput | string
    CardName?: StringFieldUpdateOperationsInput | string
    ChipType?: StringFieldUpdateOperationsInput | string
    VGAMem?: StringFieldUpdateOperationsInput | string
    NIC?: StringFieldUpdateOperationsInput | string
    FreeSpace?: StringFieldUpdateOperationsInput | string
    CPName?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    NTFS?: StringFieldUpdateOperationsInput | string
    FAT?: StringFieldUpdateOperationsInput | string
    Mainboard?: StringFieldUpdateOperationsInput | string
    IP?: StringFieldUpdateOperationsInput | string
    LAN?: StringFieldUpdateOperationsInput | string
    RamFree?: StringFieldUpdateOperationsInput | string
    PageFile?: StringFieldUpdateOperationsInput | string
    TempCPU?: StringFieldUpdateOperationsInput | string
    LoadCPU?: StringFieldUpdateOperationsInput | string
    TempGPU?: StringFieldUpdateOperationsInput | string
    LoadGPU?: StringFieldUpdateOperationsInput | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    PCName?: NullableStringFieldUpdateOperationsInput | string | null
    NetInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientsystbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    MAC?: StringFieldUpdateOperationsInput | string
    CPU?: StringFieldUpdateOperationsInput | string
    RAM?: StringFieldUpdateOperationsInput | string
    HD?: StringFieldUpdateOperationsInput | string
    OS?: StringFieldUpdateOperationsInput | string
    CardName?: StringFieldUpdateOperationsInput | string
    ChipType?: StringFieldUpdateOperationsInput | string
    VGAMem?: StringFieldUpdateOperationsInput | string
    NIC?: StringFieldUpdateOperationsInput | string
    FreeSpace?: StringFieldUpdateOperationsInput | string
    CPName?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    NTFS?: StringFieldUpdateOperationsInput | string
    FAT?: StringFieldUpdateOperationsInput | string
    Mainboard?: StringFieldUpdateOperationsInput | string
    IP?: StringFieldUpdateOperationsInput | string
    LAN?: StringFieldUpdateOperationsInput | string
    RamFree?: StringFieldUpdateOperationsInput | string
    PageFile?: StringFieldUpdateOperationsInput | string
    TempCPU?: StringFieldUpdateOperationsInput | string
    LoadCPU?: StringFieldUpdateOperationsInput | string
    TempGPU?: StringFieldUpdateOperationsInput | string
    LoadGPU?: StringFieldUpdateOperationsInput | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    PCName?: NullableStringFieldUpdateOperationsInput | string | null
    NetInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientsystbCreateManyInput = {
    ID?: number
    UserId?: number
    MAC?: string
    CPU?: string
    RAM?: string
    HD?: string
    OS?: string
    CardName?: string
    ChipType?: string
    VGAMem?: string
    NIC?: string
    FreeSpace?: string
    CPName?: string
    Active?: number
    NTFS?: string
    FAT?: string
    Mainboard?: string
    IP?: string
    LAN?: string
    RamFree?: string
    PageFile?: string
    TempCPU?: string
    LoadCPU?: string
    TempGPU?: string
    LoadGPU?: string
    LastUpdate?: Date | string
    PCName?: string | null
    NetInfo?: string | null
  }

  export type clientsystbUpdateManyMutationInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    MAC?: StringFieldUpdateOperationsInput | string
    CPU?: StringFieldUpdateOperationsInput | string
    RAM?: StringFieldUpdateOperationsInput | string
    HD?: StringFieldUpdateOperationsInput | string
    OS?: StringFieldUpdateOperationsInput | string
    CardName?: StringFieldUpdateOperationsInput | string
    ChipType?: StringFieldUpdateOperationsInput | string
    VGAMem?: StringFieldUpdateOperationsInput | string
    NIC?: StringFieldUpdateOperationsInput | string
    FreeSpace?: StringFieldUpdateOperationsInput | string
    CPName?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    NTFS?: StringFieldUpdateOperationsInput | string
    FAT?: StringFieldUpdateOperationsInput | string
    Mainboard?: StringFieldUpdateOperationsInput | string
    IP?: StringFieldUpdateOperationsInput | string
    LAN?: StringFieldUpdateOperationsInput | string
    RamFree?: StringFieldUpdateOperationsInput | string
    PageFile?: StringFieldUpdateOperationsInput | string
    TempCPU?: StringFieldUpdateOperationsInput | string
    LoadCPU?: StringFieldUpdateOperationsInput | string
    TempGPU?: StringFieldUpdateOperationsInput | string
    LoadGPU?: StringFieldUpdateOperationsInput | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    PCName?: NullableStringFieldUpdateOperationsInput | string | null
    NetInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientsystbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    MAC?: StringFieldUpdateOperationsInput | string
    CPU?: StringFieldUpdateOperationsInput | string
    RAM?: StringFieldUpdateOperationsInput | string
    HD?: StringFieldUpdateOperationsInput | string
    OS?: StringFieldUpdateOperationsInput | string
    CardName?: StringFieldUpdateOperationsInput | string
    ChipType?: StringFieldUpdateOperationsInput | string
    VGAMem?: StringFieldUpdateOperationsInput | string
    NIC?: StringFieldUpdateOperationsInput | string
    FreeSpace?: StringFieldUpdateOperationsInput | string
    CPName?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    NTFS?: StringFieldUpdateOperationsInput | string
    FAT?: StringFieldUpdateOperationsInput | string
    Mainboard?: StringFieldUpdateOperationsInput | string
    IP?: StringFieldUpdateOperationsInput | string
    LAN?: StringFieldUpdateOperationsInput | string
    RamFree?: StringFieldUpdateOperationsInput | string
    PageFile?: StringFieldUpdateOperationsInput | string
    TempCPU?: StringFieldUpdateOperationsInput | string
    LoadCPU?: StringFieldUpdateOperationsInput | string
    TempGPU?: StringFieldUpdateOperationsInput | string
    LoadGPU?: StringFieldUpdateOperationsInput | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    PCName?: NullableStringFieldUpdateOperationsInput | string | null
    NetInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type combodetailtbCreateInput = {
    UserID?: number
    ComboID?: number
    VoucherID?: number
    Accept?: number
    CreateDate?: Date | string
    CreateTime?: Date | string
    FromDate?: Date | string
    FromTime?: Date | string
    ToDate?: Date | string
    ToTime?: Date | string
    Zone?: string | null
    LoginTime?: Date | string
    Ownerid?: bigint | number | null
  }

  export type combodetailtbUncheckedCreateInput = {
    ComboDetailID?: number
    UserID?: number
    ComboID?: number
    VoucherID?: number
    Accept?: number
    CreateDate?: Date | string
    CreateTime?: Date | string
    FromDate?: Date | string
    FromTime?: Date | string
    ToDate?: Date | string
    ToTime?: Date | string
    Zone?: string | null
    LoginTime?: Date | string
    Ownerid?: bigint | number | null
  }

  export type combodetailtbUpdateInput = {
    UserID?: IntFieldUpdateOperationsInput | number
    ComboID?: IntFieldUpdateOperationsInput | number
    VoucherID?: IntFieldUpdateOperationsInput | number
    Accept?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    LoginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Ownerid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type combodetailtbUncheckedUpdateInput = {
    ComboDetailID?: IntFieldUpdateOperationsInput | number
    UserID?: IntFieldUpdateOperationsInput | number
    ComboID?: IntFieldUpdateOperationsInput | number
    VoucherID?: IntFieldUpdateOperationsInput | number
    Accept?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    LoginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Ownerid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type combodetailtbCreateManyInput = {
    ComboDetailID?: number
    UserID?: number
    ComboID?: number
    VoucherID?: number
    Accept?: number
    CreateDate?: Date | string
    CreateTime?: Date | string
    FromDate?: Date | string
    FromTime?: Date | string
    ToDate?: Date | string
    ToTime?: Date | string
    Zone?: string | null
    LoginTime?: Date | string
    Ownerid?: bigint | number | null
  }

  export type combodetailtbUpdateManyMutationInput = {
    UserID?: IntFieldUpdateOperationsInput | number
    ComboID?: IntFieldUpdateOperationsInput | number
    VoucherID?: IntFieldUpdateOperationsInput | number
    Accept?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    LoginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Ownerid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type combodetailtbUncheckedUpdateManyInput = {
    ComboDetailID?: IntFieldUpdateOperationsInput | number
    UserID?: IntFieldUpdateOperationsInput | number
    ComboID?: IntFieldUpdateOperationsInput | number
    VoucherID?: IntFieldUpdateOperationsInput | number
    Accept?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    FromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ToDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ToTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Zone?: NullableStringFieldUpdateOperationsInput | string | null
    LoginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Ownerid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type combodonatetbCreateInput = {
    ComboID?: number
    ServiceID?: number
    Quantity?: number
  }

  export type combodonatetbUncheckedCreateInput = {
    ComboDonateID?: number
    ComboID?: number
    ServiceID?: number
    Quantity?: number
  }

  export type combodonatetbUpdateInput = {
    ComboID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type combodonatetbUncheckedUpdateInput = {
    ComboDonateID?: IntFieldUpdateOperationsInput | number
    ComboID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type combodonatetbCreateManyInput = {
    ComboDonateID?: number
    ComboID?: number
    ServiceID?: number
    Quantity?: number
  }

  export type combodonatetbUpdateManyMutationInput = {
    ComboID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type combodonatetbUncheckedUpdateManyInput = {
    ComboDonateID?: IntFieldUpdateOperationsInput | number
    ComboID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type combotbCreateInput = {
    Name?: string
    Price?: Decimal | DecimalJsLike | number | string
    CreateDate?: Date | string
    CreateTime?: Date | string
    Type?: number
    PreAlias?: string
    IsStatus?: number
    OrderPosition?: number
    NumOfDay?: number
  }

  export type combotbUncheckedCreateInput = {
    ComboID?: number
    Name?: string
    Price?: Decimal | DecimalJsLike | number | string
    CreateDate?: Date | string
    CreateTime?: Date | string
    Type?: number
    PreAlias?: string
    IsStatus?: number
    OrderPosition?: number
    NumOfDay?: number
  }

  export type combotbUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    PreAlias?: StringFieldUpdateOperationsInput | string
    IsStatus?: IntFieldUpdateOperationsInput | number
    OrderPosition?: IntFieldUpdateOperationsInput | number
    NumOfDay?: IntFieldUpdateOperationsInput | number
  }

  export type combotbUncheckedUpdateInput = {
    ComboID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    PreAlias?: StringFieldUpdateOperationsInput | string
    IsStatus?: IntFieldUpdateOperationsInput | number
    OrderPosition?: IntFieldUpdateOperationsInput | number
    NumOfDay?: IntFieldUpdateOperationsInput | number
  }

  export type combotbCreateManyInput = {
    ComboID?: number
    Name?: string
    Price?: Decimal | DecimalJsLike | number | string
    CreateDate?: Date | string
    CreateTime?: Date | string
    Type?: number
    PreAlias?: string
    IsStatus?: number
    OrderPosition?: number
    NumOfDay?: number
  }

  export type combotbUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    PreAlias?: StringFieldUpdateOperationsInput | string
    IsStatus?: IntFieldUpdateOperationsInput | number
    OrderPosition?: IntFieldUpdateOperationsInput | number
    NumOfDay?: IntFieldUpdateOperationsInput | number
  }

  export type combotbUncheckedUpdateManyInput = {
    ComboID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    PreAlias?: StringFieldUpdateOperationsInput | string
    IsStatus?: IntFieldUpdateOperationsInput | number
    OrderPosition?: IntFieldUpdateOperationsInput | number
    NumOfDay?: IntFieldUpdateOperationsInput | number
  }

  export type combousagetbCreateInput = {
    ComboID?: number
    MachineGroupID?: number
    FromTime?: number
    ToTime?: number
  }

  export type combousagetbUncheckedCreateInput = {
    ComboUsageID?: number
    ComboID?: number
    MachineGroupID?: number
    FromTime?: number
    ToTime?: number
  }

  export type combousagetbUpdateInput = {
    ComboID?: IntFieldUpdateOperationsInput | number
    MachineGroupID?: IntFieldUpdateOperationsInput | number
    FromTime?: IntFieldUpdateOperationsInput | number
    ToTime?: IntFieldUpdateOperationsInput | number
  }

  export type combousagetbUncheckedUpdateInput = {
    ComboUsageID?: IntFieldUpdateOperationsInput | number
    ComboID?: IntFieldUpdateOperationsInput | number
    MachineGroupID?: IntFieldUpdateOperationsInput | number
    FromTime?: IntFieldUpdateOperationsInput | number
    ToTime?: IntFieldUpdateOperationsInput | number
  }

  export type combousagetbCreateManyInput = {
    ComboUsageID?: number
    ComboID?: number
    MachineGroupID?: number
    FromTime?: number
    ToTime?: number
  }

  export type combousagetbUpdateManyMutationInput = {
    ComboID?: IntFieldUpdateOperationsInput | number
    MachineGroupID?: IntFieldUpdateOperationsInput | number
    FromTime?: IntFieldUpdateOperationsInput | number
    ToTime?: IntFieldUpdateOperationsInput | number
  }

  export type combousagetbUncheckedUpdateManyInput = {
    ComboUsageID?: IntFieldUpdateOperationsInput | number
    ComboID?: IntFieldUpdateOperationsInput | number
    MachineGroupID?: IntFieldUpdateOperationsInput | number
    FromTime?: IntFieldUpdateOperationsInput | number
    ToTime?: IntFieldUpdateOperationsInput | number
  }

  export type convertunittbCreateInput = {
    ServiceID?: number
    UnitRootID?: number
    ConvertUnitID?: number
    Quantity?: number
  }

  export type convertunittbUncheckedCreateInput = {
    ID?: number
    ServiceID?: number
    UnitRootID?: number
    ConvertUnitID?: number
    Quantity?: number
  }

  export type convertunittbUpdateInput = {
    ServiceID?: IntFieldUpdateOperationsInput | number
    UnitRootID?: IntFieldUpdateOperationsInput | number
    ConvertUnitID?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type convertunittbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
    UnitRootID?: IntFieldUpdateOperationsInput | number
    ConvertUnitID?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type convertunittbCreateManyInput = {
    ID?: number
    ServiceID?: number
    UnitRootID?: number
    ConvertUnitID?: number
    Quantity?: number
  }

  export type convertunittbUpdateManyMutationInput = {
    ServiceID?: IntFieldUpdateOperationsInput | number
    UnitRootID?: IntFieldUpdateOperationsInput | number
    ConvertUnitID?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type convertunittbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
    UnitRootID?: IntFieldUpdateOperationsInput | number
    ConvertUnitID?: IntFieldUpdateOperationsInput | number
    Quantity?: IntFieldUpdateOperationsInput | number
  }

  export type dptbCreateInput = {
    ComputerName: string
    Status?: number
    Type?: number
    Version?: string
    LastUpdate?: Date | string
    FNetVersion?: string
    FNetReleaseDate?: Date | string
    DPB?: string
  }

  export type dptbUncheckedCreateInput = {
    ComputerName: string
    Status?: number
    Type?: number
    Version?: string
    LastUpdate?: Date | string
    FNetVersion?: string
    FNetReleaseDate?: Date | string
    DPB?: string
  }

  export type dptbUpdateInput = {
    ComputerName?: StringFieldUpdateOperationsInput | string
    Status?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    Version?: StringFieldUpdateOperationsInput | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    FNetVersion?: StringFieldUpdateOperationsInput | string
    FNetReleaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    DPB?: StringFieldUpdateOperationsInput | string
  }

  export type dptbUncheckedUpdateInput = {
    ComputerName?: StringFieldUpdateOperationsInput | string
    Status?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    Version?: StringFieldUpdateOperationsInput | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    FNetVersion?: StringFieldUpdateOperationsInput | string
    FNetReleaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    DPB?: StringFieldUpdateOperationsInput | string
  }

  export type dptbCreateManyInput = {
    ComputerName: string
    Status?: number
    Type?: number
    Version?: string
    LastUpdate?: Date | string
    FNetVersion?: string
    FNetReleaseDate?: Date | string
    DPB?: string
  }

  export type dptbUpdateManyMutationInput = {
    ComputerName?: StringFieldUpdateOperationsInput | string
    Status?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    Version?: StringFieldUpdateOperationsInput | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    FNetVersion?: StringFieldUpdateOperationsInput | string
    FNetReleaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    DPB?: StringFieldUpdateOperationsInput | string
  }

  export type dptbUncheckedUpdateManyInput = {
    ComputerName?: StringFieldUpdateOperationsInput | string
    Status?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    Version?: StringFieldUpdateOperationsInput | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    FNetVersion?: StringFieldUpdateOperationsInput | string
    FNetReleaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    DPB?: StringFieldUpdateOperationsInput | string
  }

  export type freetimedetailtbCreateInput = {
    UserId: number
    FreeTime?: number
    FreeMoney?: number
    Type?: number
    RecordDate: Date | string
    VoucherId?: number
  }

  export type freetimedetailtbUncheckedCreateInput = {
    FreeTimeDetailId?: number
    UserId: number
    FreeTime?: number
    FreeMoney?: number
    Type?: number
    RecordDate: Date | string
    VoucherId?: number
  }

  export type freetimedetailtbUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    FreeMoney?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    VoucherId?: IntFieldUpdateOperationsInput | number
  }

  export type freetimedetailtbUncheckedUpdateInput = {
    FreeTimeDetailId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    FreeMoney?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    VoucherId?: IntFieldUpdateOperationsInput | number
  }

  export type freetimedetailtbCreateManyInput = {
    FreeTimeDetailId?: number
    UserId: number
    FreeTime?: number
    FreeMoney?: number
    Type?: number
    RecordDate: Date | string
    VoucherId?: number
  }

  export type freetimedetailtbUpdateManyMutationInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    FreeMoney?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    VoucherId?: IntFieldUpdateOperationsInput | number
  }

  export type freetimedetailtbUncheckedUpdateManyInput = {
    FreeTimeDetailId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    FreeMoney?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    VoucherId?: IntFieldUpdateOperationsInput | number
  }

  export type functiontbCreateInput = {
    FunctionCode: string
    FunctionName?: string
    ParentFunction?: string
    LevelFunction?: number
    OrderOfLevel?: number
    Active?: number
  }

  export type functiontbUncheckedCreateInput = {
    FunctionCode: string
    FunctionName?: string
    ParentFunction?: string
    LevelFunction?: number
    OrderOfLevel?: number
    Active?: number
  }

  export type functiontbUpdateInput = {
    FunctionCode?: StringFieldUpdateOperationsInput | string
    FunctionName?: StringFieldUpdateOperationsInput | string
    ParentFunction?: StringFieldUpdateOperationsInput | string
    LevelFunction?: IntFieldUpdateOperationsInput | number
    OrderOfLevel?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type functiontbUncheckedUpdateInput = {
    FunctionCode?: StringFieldUpdateOperationsInput | string
    FunctionName?: StringFieldUpdateOperationsInput | string
    ParentFunction?: StringFieldUpdateOperationsInput | string
    LevelFunction?: IntFieldUpdateOperationsInput | number
    OrderOfLevel?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type functiontbCreateManyInput = {
    FunctionCode: string
    FunctionName?: string
    ParentFunction?: string
    LevelFunction?: number
    OrderOfLevel?: number
    Active?: number
  }

  export type functiontbUpdateManyMutationInput = {
    FunctionCode?: StringFieldUpdateOperationsInput | string
    FunctionName?: StringFieldUpdateOperationsInput | string
    ParentFunction?: StringFieldUpdateOperationsInput | string
    LevelFunction?: IntFieldUpdateOperationsInput | number
    OrderOfLevel?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type functiontbUncheckedUpdateManyInput = {
    FunctionCode?: StringFieldUpdateOperationsInput | string
    FunctionName?: StringFieldUpdateOperationsInput | string
    ParentFunction?: StringFieldUpdateOperationsInput | string
    LevelFunction?: IntFieldUpdateOperationsInput | number
    OrderOfLevel?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type gamefoldertbCreateInput = {
    MachineID?: number
    GameId?: number
    GamePath?: string
  }

  export type gamefoldertbUncheckedCreateInput = {
    ID?: number
    MachineID?: number
    GameId?: number
    GamePath?: string
  }

  export type gamefoldertbUpdateInput = {
    MachineID?: IntFieldUpdateOperationsInput | number
    GameId?: IntFieldUpdateOperationsInput | number
    GamePath?: StringFieldUpdateOperationsInput | string
  }

  export type gamefoldertbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    MachineID?: IntFieldUpdateOperationsInput | number
    GameId?: IntFieldUpdateOperationsInput | number
    GamePath?: StringFieldUpdateOperationsInput | string
  }

  export type gamefoldertbCreateManyInput = {
    ID?: number
    MachineID?: number
    GameId?: number
    GamePath?: string
  }

  export type gamefoldertbUpdateManyMutationInput = {
    MachineID?: IntFieldUpdateOperationsInput | number
    GameId?: IntFieldUpdateOperationsInput | number
    GamePath?: StringFieldUpdateOperationsInput | string
  }

  export type gamefoldertbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    MachineID?: IntFieldUpdateOperationsInput | number
    GameId?: IntFieldUpdateOperationsInput | number
    GamePath?: StringFieldUpdateOperationsInput | string
  }

  export type gamelisttbCreateInput = {
    GameAlias?: string
    GameName?: string
    GameLauncher?: string
    Active?: number
    Protocol?: string
    URL?: string
    Checksum?: string
    PublishDate?: Date | string
    TorrentFile?: string
    SetupFile?: string
    ShortcutPath?: string
    Type?: number
    Size?: string
    SetupType?: number
    ConfigFile?: string
    Checked?: number
  }

  export type gamelisttbUncheckedCreateInput = {
    GameId?: number
    GameAlias?: string
    GameName?: string
    GameLauncher?: string
    Active?: number
    Protocol?: string
    URL?: string
    Checksum?: string
    PublishDate?: Date | string
    TorrentFile?: string
    SetupFile?: string
    ShortcutPath?: string
    Type?: number
    Size?: string
    SetupType?: number
    ConfigFile?: string
    Checked?: number
  }

  export type gamelisttbUpdateInput = {
    GameAlias?: StringFieldUpdateOperationsInput | string
    GameName?: StringFieldUpdateOperationsInput | string
    GameLauncher?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    Protocol?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    Checksum?: StringFieldUpdateOperationsInput | string
    PublishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TorrentFile?: StringFieldUpdateOperationsInput | string
    SetupFile?: StringFieldUpdateOperationsInput | string
    ShortcutPath?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    Size?: StringFieldUpdateOperationsInput | string
    SetupType?: IntFieldUpdateOperationsInput | number
    ConfigFile?: StringFieldUpdateOperationsInput | string
    Checked?: IntFieldUpdateOperationsInput | number
  }

  export type gamelisttbUncheckedUpdateInput = {
    GameId?: IntFieldUpdateOperationsInput | number
    GameAlias?: StringFieldUpdateOperationsInput | string
    GameName?: StringFieldUpdateOperationsInput | string
    GameLauncher?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    Protocol?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    Checksum?: StringFieldUpdateOperationsInput | string
    PublishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TorrentFile?: StringFieldUpdateOperationsInput | string
    SetupFile?: StringFieldUpdateOperationsInput | string
    ShortcutPath?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    Size?: StringFieldUpdateOperationsInput | string
    SetupType?: IntFieldUpdateOperationsInput | number
    ConfigFile?: StringFieldUpdateOperationsInput | string
    Checked?: IntFieldUpdateOperationsInput | number
  }

  export type gamelisttbCreateManyInput = {
    GameId?: number
    GameAlias?: string
    GameName?: string
    GameLauncher?: string
    Active?: number
    Protocol?: string
    URL?: string
    Checksum?: string
    PublishDate?: Date | string
    TorrentFile?: string
    SetupFile?: string
    ShortcutPath?: string
    Type?: number
    Size?: string
    SetupType?: number
    ConfigFile?: string
    Checked?: number
  }

  export type gamelisttbUpdateManyMutationInput = {
    GameAlias?: StringFieldUpdateOperationsInput | string
    GameName?: StringFieldUpdateOperationsInput | string
    GameLauncher?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    Protocol?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    Checksum?: StringFieldUpdateOperationsInput | string
    PublishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TorrentFile?: StringFieldUpdateOperationsInput | string
    SetupFile?: StringFieldUpdateOperationsInput | string
    ShortcutPath?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    Size?: StringFieldUpdateOperationsInput | string
    SetupType?: IntFieldUpdateOperationsInput | number
    ConfigFile?: StringFieldUpdateOperationsInput | string
    Checked?: IntFieldUpdateOperationsInput | number
  }

  export type gamelisttbUncheckedUpdateManyInput = {
    GameId?: IntFieldUpdateOperationsInput | number
    GameAlias?: StringFieldUpdateOperationsInput | string
    GameName?: StringFieldUpdateOperationsInput | string
    GameLauncher?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    Protocol?: StringFieldUpdateOperationsInput | string
    URL?: StringFieldUpdateOperationsInput | string
    Checksum?: StringFieldUpdateOperationsInput | string
    PublishDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TorrentFile?: StringFieldUpdateOperationsInput | string
    SetupFile?: StringFieldUpdateOperationsInput | string
    ShortcutPath?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    Size?: StringFieldUpdateOperationsInput | string
    SetupType?: IntFieldUpdateOperationsInput | number
    ConfigFile?: StringFieldUpdateOperationsInput | string
    Checked?: IntFieldUpdateOperationsInput | number
  }

  export type hptbCreateInput = {
    MachineName?: string
    IEHP?: string
    FFHP?: string
    GCHP?: string
    LastUpdateDate: Date | string
  }

  export type hptbUncheckedCreateInput = {
    ID?: number
    MachineName?: string
    IEHP?: string
    FFHP?: string
    GCHP?: string
    LastUpdateDate: Date | string
  }

  export type hptbUpdateInput = {
    MachineName?: StringFieldUpdateOperationsInput | string
    IEHP?: StringFieldUpdateOperationsInput | string
    FFHP?: StringFieldUpdateOperationsInput | string
    GCHP?: StringFieldUpdateOperationsInput | string
    LastUpdateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hptbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    MachineName?: StringFieldUpdateOperationsInput | string
    IEHP?: StringFieldUpdateOperationsInput | string
    FFHP?: StringFieldUpdateOperationsInput | string
    GCHP?: StringFieldUpdateOperationsInput | string
    LastUpdateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hptbCreateManyInput = {
    ID?: number
    MachineName?: string
    IEHP?: string
    FFHP?: string
    GCHP?: string
    LastUpdateDate: Date | string
  }

  export type hptbUpdateManyMutationInput = {
    MachineName?: StringFieldUpdateOperationsInput | string
    IEHP?: StringFieldUpdateOperationsInput | string
    FFHP?: StringFieldUpdateOperationsInput | string
    GCHP?: StringFieldUpdateOperationsInput | string
    LastUpdateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type hptbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    MachineName?: StringFieldUpdateOperationsInput | string
    IEHP?: StringFieldUpdateOperationsInput | string
    FFHP?: StringFieldUpdateOperationsInput | string
    GCHP?: StringFieldUpdateOperationsInput | string
    LastUpdateDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type intoptiontbCreateInput = {
    OptionId: number
    OptionName: string
    Value: string
    Active: boolean
  }

  export type intoptiontbUncheckedCreateInput = {
    OptionId: number
    OptionName: string
    Value: string
    Active: boolean
  }

  export type intoptiontbUpdateInput = {
    OptionId?: IntFieldUpdateOperationsInput | number
    OptionName?: StringFieldUpdateOperationsInput | string
    Value?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type intoptiontbUncheckedUpdateInput = {
    OptionId?: IntFieldUpdateOperationsInput | number
    OptionName?: StringFieldUpdateOperationsInput | string
    Value?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type intoptiontbCreateManyInput = {
    OptionId: number
    OptionName: string
    Value: string
    Active: boolean
  }

  export type intoptiontbUpdateManyMutationInput = {
    OptionId?: IntFieldUpdateOperationsInput | number
    OptionName?: StringFieldUpdateOperationsInput | string
    Value?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type intoptiontbUncheckedUpdateManyInput = {
    OptionId?: IntFieldUpdateOperationsInput | number
    OptionName?: StringFieldUpdateOperationsInput | string
    Value?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type inventorytbCreateInput = {
    CreateDate?: Date | string
    CreateTime?: Date | string
    StaffID?: number
    Note?: string | null
    ServiceID?: number
    ImportQuantity?: number
    ImportPrice?: Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: Decimal | DecimalJsLike | number | string
  }

  export type inventorytbUncheckedCreateInput = {
    ID?: number
    CreateDate?: Date | string
    CreateTime?: Date | string
    StaffID?: number
    Note?: string | null
    ServiceID?: number
    ImportQuantity?: number
    ImportPrice?: Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: Decimal | DecimalJsLike | number | string
  }

  export type inventorytbUpdateInput = {
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
    ImportQuantity?: IntFieldUpdateOperationsInput | number
    ImportPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type inventorytbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
    ImportQuantity?: IntFieldUpdateOperationsInput | number
    ImportPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type inventorytbCreateManyInput = {
    ID?: number
    CreateDate?: Date | string
    CreateTime?: Date | string
    StaffID?: number
    Note?: string | null
    ServiceID?: number
    ImportQuantity?: number
    ImportPrice?: Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: Decimal | DecimalJsLike | number | string
  }

  export type inventorytbUpdateManyMutationInput = {
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
    ImportQuantity?: IntFieldUpdateOperationsInput | number
    ImportPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type inventorytbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
    ImportQuantity?: IntFieldUpdateOperationsInput | number
    ImportPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ImportTotalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type legalapptbCreateInput = {
    AppName: string
  }

  export type legalapptbUncheckedCreateInput = {
    AppName: string
  }

  export type legalapptbUpdateInput = {
    AppName?: StringFieldUpdateOperationsInput | string
  }

  export type legalapptbUncheckedUpdateInput = {
    AppName?: StringFieldUpdateOperationsInput | string
  }

  export type legalapptbCreateManyInput = {
    AppName: string
  }

  export type legalapptbUpdateManyMutationInput = {
    AppName?: StringFieldUpdateOperationsInput | string
  }

  export type legalapptbUncheckedUpdateManyInput = {
    AppName?: StringFieldUpdateOperationsInput | string
  }

  export type machinegrouptbCreateInput = {
    MachineGroupName: string
    PriceDefault?: number | null
    Active?: number | null
    Description?: string | null
  }

  export type machinegrouptbUncheckedCreateInput = {
    MachineGroupId?: number
    MachineGroupName: string
    PriceDefault?: number | null
    Active?: number | null
    Description?: string | null
  }

  export type machinegrouptbUpdateInput = {
    MachineGroupName?: StringFieldUpdateOperationsInput | string
    PriceDefault?: NullableIntFieldUpdateOperationsInput | number | null
    Active?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type machinegrouptbUncheckedUpdateInput = {
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    MachineGroupName?: StringFieldUpdateOperationsInput | string
    PriceDefault?: NullableIntFieldUpdateOperationsInput | number | null
    Active?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type machinegrouptbCreateManyInput = {
    MachineGroupId?: number
    MachineGroupName: string
    PriceDefault?: number | null
    Active?: number | null
    Description?: string | null
  }

  export type machinegrouptbUpdateManyMutationInput = {
    MachineGroupName?: StringFieldUpdateOperationsInput | string
    PriceDefault?: NullableIntFieldUpdateOperationsInput | number | null
    Active?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type machinegrouptbUncheckedUpdateManyInput = {
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    MachineGroupName?: StringFieldUpdateOperationsInput | string
    PriceDefault?: NullableIntFieldUpdateOperationsInput | number | null
    Active?: NullableIntFieldUpdateOperationsInput | number | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymenttbCreateInput = {
    UserId: number
    VoucherNo?: string | null
    VoucherDate?: Date | string
    VoucherTime?: Date | string
    ServeDate?: Date | string
    ServeTime?: Date | string
    Amount: Decimal | DecimalJsLike | number | string
    AutoAmount?: Decimal | DecimalJsLike | number | string
    TimeTotal: number
    Active?: boolean
    UserNote?: string
    Note: string
    ServicePaid?: boolean
    StaffId?: number
    MachineName?: string | null
    PaymentType?: number | null
    PaymentWaitId?: number
    zOid?: string | null
    zTid?: string | null
    zSig?: string | null
  }

  export type paymenttbUncheckedCreateInput = {
    VoucherId?: number
    UserId: number
    VoucherNo?: string | null
    VoucherDate?: Date | string
    VoucherTime?: Date | string
    ServeDate?: Date | string
    ServeTime?: Date | string
    Amount: Decimal | DecimalJsLike | number | string
    AutoAmount?: Decimal | DecimalJsLike | number | string
    TimeTotal: number
    Active?: boolean
    UserNote?: string
    Note: string
    ServicePaid?: boolean
    StaffId?: number
    MachineName?: string | null
    PaymentType?: number | null
    PaymentWaitId?: number
    zOid?: string | null
    zTid?: string | null
    zSig?: string | null
  }

  export type paymenttbUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    VoucherNo?: NullableStringFieldUpdateOperationsInput | string | null
    VoucherDate?: DateTimeFieldUpdateOperationsInput | Date | string
    VoucherTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ServeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ServeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    AutoAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TimeTotal?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    UserNote?: StringFieldUpdateOperationsInput | string
    Note?: StringFieldUpdateOperationsInput | string
    ServicePaid?: BoolFieldUpdateOperationsInput | boolean
    StaffId?: IntFieldUpdateOperationsInput | number
    MachineName?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentType?: NullableIntFieldUpdateOperationsInput | number | null
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    zOid?: NullableStringFieldUpdateOperationsInput | string | null
    zTid?: NullableStringFieldUpdateOperationsInput | string | null
    zSig?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymenttbUncheckedUpdateInput = {
    VoucherId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    VoucherNo?: NullableStringFieldUpdateOperationsInput | string | null
    VoucherDate?: DateTimeFieldUpdateOperationsInput | Date | string
    VoucherTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ServeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ServeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    AutoAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TimeTotal?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    UserNote?: StringFieldUpdateOperationsInput | string
    Note?: StringFieldUpdateOperationsInput | string
    ServicePaid?: BoolFieldUpdateOperationsInput | boolean
    StaffId?: IntFieldUpdateOperationsInput | number
    MachineName?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentType?: NullableIntFieldUpdateOperationsInput | number | null
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    zOid?: NullableStringFieldUpdateOperationsInput | string | null
    zTid?: NullableStringFieldUpdateOperationsInput | string | null
    zSig?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymenttbCreateManyInput = {
    VoucherId?: number
    UserId: number
    VoucherNo?: string | null
    VoucherDate?: Date | string
    VoucherTime?: Date | string
    ServeDate?: Date | string
    ServeTime?: Date | string
    Amount: Decimal | DecimalJsLike | number | string
    AutoAmount?: Decimal | DecimalJsLike | number | string
    TimeTotal: number
    Active?: boolean
    UserNote?: string
    Note: string
    ServicePaid?: boolean
    StaffId?: number
    MachineName?: string | null
    PaymentType?: number | null
    PaymentWaitId?: number
    zOid?: string | null
    zTid?: string | null
    zSig?: string | null
  }

  export type paymenttbUpdateManyMutationInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    VoucherNo?: NullableStringFieldUpdateOperationsInput | string | null
    VoucherDate?: DateTimeFieldUpdateOperationsInput | Date | string
    VoucherTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ServeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ServeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    AutoAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TimeTotal?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    UserNote?: StringFieldUpdateOperationsInput | string
    Note?: StringFieldUpdateOperationsInput | string
    ServicePaid?: BoolFieldUpdateOperationsInput | boolean
    StaffId?: IntFieldUpdateOperationsInput | number
    MachineName?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentType?: NullableIntFieldUpdateOperationsInput | number | null
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    zOid?: NullableStringFieldUpdateOperationsInput | string | null
    zTid?: NullableStringFieldUpdateOperationsInput | string | null
    zSig?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymenttbUncheckedUpdateManyInput = {
    VoucherId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    VoucherNo?: NullableStringFieldUpdateOperationsInput | string | null
    VoucherDate?: DateTimeFieldUpdateOperationsInput | Date | string
    VoucherTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ServeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ServeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    AutoAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TimeTotal?: IntFieldUpdateOperationsInput | number
    Active?: BoolFieldUpdateOperationsInput | boolean
    UserNote?: StringFieldUpdateOperationsInput | string
    Note?: StringFieldUpdateOperationsInput | string
    ServicePaid?: BoolFieldUpdateOperationsInput | boolean
    StaffId?: IntFieldUpdateOperationsInput | number
    MachineName?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentType?: NullableIntFieldUpdateOperationsInput | number | null
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    zOid?: NullableStringFieldUpdateOperationsInput | string | null
    zTid?: NullableStringFieldUpdateOperationsInput | string | null
    zSig?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentwaittbCreateInput = {
    MachineName?: string
    TotalTimeUsed?: number
    TotalTimeFee?: number
    BeginTime?: Date | string
    EndTime?: Date | string
    TimeFee?: Decimal | DecimalJsLike | number | string
    TimeUsed?: number
    RemainTime?: number
    TimePaid?: number
    FreeTime?: number
    ChangePCSessionId?: number
    AnonymId?: number
    PriceGroupId?: number
    MachineGroupId?: number
    Note?: string
    PriceAppRentID?: number
  }

  export type paymentwaittbUncheckedCreateInput = {
    PaymentWaitId?: number
    MachineName?: string
    TotalTimeUsed?: number
    TotalTimeFee?: number
    BeginTime?: Date | string
    EndTime?: Date | string
    TimeFee?: Decimal | DecimalJsLike | number | string
    TimeUsed?: number
    RemainTime?: number
    TimePaid?: number
    FreeTime?: number
    ChangePCSessionId?: number
    AnonymId?: number
    PriceGroupId?: number
    MachineGroupId?: number
    Note?: string
    PriceAppRentID?: number
  }

  export type paymentwaittbUpdateInput = {
    MachineName?: StringFieldUpdateOperationsInput | string
    TotalTimeUsed?: IntFieldUpdateOperationsInput | number
    TotalTimeFee?: IntFieldUpdateOperationsInput | number
    BeginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    EndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TimeUsed?: IntFieldUpdateOperationsInput | number
    RemainTime?: IntFieldUpdateOperationsInput | number
    TimePaid?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    ChangePCSessionId?: IntFieldUpdateOperationsInput | number
    AnonymId?: IntFieldUpdateOperationsInput | number
    PriceGroupId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
  }

  export type paymentwaittbUncheckedUpdateInput = {
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    MachineName?: StringFieldUpdateOperationsInput | string
    TotalTimeUsed?: IntFieldUpdateOperationsInput | number
    TotalTimeFee?: IntFieldUpdateOperationsInput | number
    BeginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    EndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TimeUsed?: IntFieldUpdateOperationsInput | number
    RemainTime?: IntFieldUpdateOperationsInput | number
    TimePaid?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    ChangePCSessionId?: IntFieldUpdateOperationsInput | number
    AnonymId?: IntFieldUpdateOperationsInput | number
    PriceGroupId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
  }

  export type paymentwaittbCreateManyInput = {
    PaymentWaitId?: number
    MachineName?: string
    TotalTimeUsed?: number
    TotalTimeFee?: number
    BeginTime?: Date | string
    EndTime?: Date | string
    TimeFee?: Decimal | DecimalJsLike | number | string
    TimeUsed?: number
    RemainTime?: number
    TimePaid?: number
    FreeTime?: number
    ChangePCSessionId?: number
    AnonymId?: number
    PriceGroupId?: number
    MachineGroupId?: number
    Note?: string
    PriceAppRentID?: number
  }

  export type paymentwaittbUpdateManyMutationInput = {
    MachineName?: StringFieldUpdateOperationsInput | string
    TotalTimeUsed?: IntFieldUpdateOperationsInput | number
    TotalTimeFee?: IntFieldUpdateOperationsInput | number
    BeginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    EndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TimeUsed?: IntFieldUpdateOperationsInput | number
    RemainTime?: IntFieldUpdateOperationsInput | number
    TimePaid?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    ChangePCSessionId?: IntFieldUpdateOperationsInput | number
    AnonymId?: IntFieldUpdateOperationsInput | number
    PriceGroupId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
  }

  export type paymentwaittbUncheckedUpdateManyInput = {
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    MachineName?: StringFieldUpdateOperationsInput | string
    TotalTimeUsed?: IntFieldUpdateOperationsInput | number
    TotalTimeFee?: IntFieldUpdateOperationsInput | number
    BeginTime?: DateTimeFieldUpdateOperationsInput | Date | string
    EndTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TimeUsed?: IntFieldUpdateOperationsInput | number
    RemainTime?: IntFieldUpdateOperationsInput | number
    TimePaid?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    ChangePCSessionId?: IntFieldUpdateOperationsInput | number
    AnonymId?: IntFieldUpdateOperationsInput | number
    PriceGroupId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
  }

  export type priceapprenttbCreateInput = {
    PriceID?: number
    MachineGroupID?: number
    Name?: string
    Price?: Decimal | DecimalJsLike | number | string
    Status?: number
  }

  export type priceapprenttbUncheckedCreateInput = {
    PriceAppRentID?: number
    PriceID?: number
    MachineGroupID?: number
    Name?: string
    Price?: Decimal | DecimalJsLike | number | string
    Status?: number
  }

  export type priceapprenttbUpdateInput = {
    PriceID?: IntFieldUpdateOperationsInput | number
    MachineGroupID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type priceapprenttbUncheckedUpdateInput = {
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    PriceID?: IntFieldUpdateOperationsInput | number
    MachineGroupID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type priceapprenttbCreateManyInput = {
    PriceAppRentID?: number
    PriceID?: number
    MachineGroupID?: number
    Name?: string
    Price?: Decimal | DecimalJsLike | number | string
    Status?: number
  }

  export type priceapprenttbUpdateManyMutationInput = {
    PriceID?: IntFieldUpdateOperationsInput | number
    MachineGroupID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type priceapprenttbUncheckedUpdateManyInput = {
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    PriceID?: IntFieldUpdateOperationsInput | number
    MachineGroupID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type priceapprentusetbCreateInput = {
    PriceAppRentID?: number
    ApplicationRentID?: number
  }

  export type priceapprentusetbUncheckedCreateInput = {
    PriceAppRentUseID?: number
    PriceAppRentID?: number
    ApplicationRentID?: number
  }

  export type priceapprentusetbUpdateInput = {
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    ApplicationRentID?: IntFieldUpdateOperationsInput | number
  }

  export type priceapprentusetbUncheckedUpdateInput = {
    PriceAppRentUseID?: IntFieldUpdateOperationsInput | number
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    ApplicationRentID?: IntFieldUpdateOperationsInput | number
  }

  export type priceapprentusetbCreateManyInput = {
    PriceAppRentUseID?: number
    PriceAppRentID?: number
    ApplicationRentID?: number
  }

  export type priceapprentusetbUpdateManyMutationInput = {
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    ApplicationRentID?: IntFieldUpdateOperationsInput | number
  }

  export type priceapprentusetbUncheckedUpdateManyInput = {
    PriceAppRentUseID?: IntFieldUpdateOperationsInput | number
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    ApplicationRentID?: IntFieldUpdateOperationsInput | number
  }

  export type pricedetailtbCreateInput = {
    PriceId: number
    MachineGroupId?: number | null
    Price?: Decimal | DecimalJsLike | number | string | null
    Promotion?: number | null
    PromotionTerm?: number | null
    FreeMoney?: number | null
    FreeTime?: number | null
    BeginTime?: number | null
    EndTime?: number | null
    Term?: number | null
    PromotionOrder?: number | null
    BeginDate?: Date | string | null
    EndDate?: Date | string | null
    DayOfWeekMask?: number
    PromotionType?: number
  }

  export type pricedetailtbUncheckedCreateInput = {
    PriceDetailId?: number
    PriceId: number
    MachineGroupId?: number | null
    Price?: Decimal | DecimalJsLike | number | string | null
    Promotion?: number | null
    PromotionTerm?: number | null
    FreeMoney?: number | null
    FreeTime?: number | null
    BeginTime?: number | null
    EndTime?: number | null
    Term?: number | null
    PromotionOrder?: number | null
    BeginDate?: Date | string | null
    EndDate?: Date | string | null
    DayOfWeekMask?: number
    PromotionType?: number
  }

  export type pricedetailtbUpdateInput = {
    PriceId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    Price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Promotion?: NullableIntFieldUpdateOperationsInput | number | null
    PromotionTerm?: NullableIntFieldUpdateOperationsInput | number | null
    FreeMoney?: NullableIntFieldUpdateOperationsInput | number | null
    FreeTime?: NullableIntFieldUpdateOperationsInput | number | null
    BeginTime?: NullableIntFieldUpdateOperationsInput | number | null
    EndTime?: NullableIntFieldUpdateOperationsInput | number | null
    Term?: NullableIntFieldUpdateOperationsInput | number | null
    PromotionOrder?: NullableIntFieldUpdateOperationsInput | number | null
    BeginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DayOfWeekMask?: IntFieldUpdateOperationsInput | number
    PromotionType?: IntFieldUpdateOperationsInput | number
  }

  export type pricedetailtbUncheckedUpdateInput = {
    PriceDetailId?: IntFieldUpdateOperationsInput | number
    PriceId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    Price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Promotion?: NullableIntFieldUpdateOperationsInput | number | null
    PromotionTerm?: NullableIntFieldUpdateOperationsInput | number | null
    FreeMoney?: NullableIntFieldUpdateOperationsInput | number | null
    FreeTime?: NullableIntFieldUpdateOperationsInput | number | null
    BeginTime?: NullableIntFieldUpdateOperationsInput | number | null
    EndTime?: NullableIntFieldUpdateOperationsInput | number | null
    Term?: NullableIntFieldUpdateOperationsInput | number | null
    PromotionOrder?: NullableIntFieldUpdateOperationsInput | number | null
    BeginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DayOfWeekMask?: IntFieldUpdateOperationsInput | number
    PromotionType?: IntFieldUpdateOperationsInput | number
  }

  export type pricedetailtbCreateManyInput = {
    PriceDetailId?: number
    PriceId: number
    MachineGroupId?: number | null
    Price?: Decimal | DecimalJsLike | number | string | null
    Promotion?: number | null
    PromotionTerm?: number | null
    FreeMoney?: number | null
    FreeTime?: number | null
    BeginTime?: number | null
    EndTime?: number | null
    Term?: number | null
    PromotionOrder?: number | null
    BeginDate?: Date | string | null
    EndDate?: Date | string | null
    DayOfWeekMask?: number
    PromotionType?: number
  }

  export type pricedetailtbUpdateManyMutationInput = {
    PriceId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    Price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Promotion?: NullableIntFieldUpdateOperationsInput | number | null
    PromotionTerm?: NullableIntFieldUpdateOperationsInput | number | null
    FreeMoney?: NullableIntFieldUpdateOperationsInput | number | null
    FreeTime?: NullableIntFieldUpdateOperationsInput | number | null
    BeginTime?: NullableIntFieldUpdateOperationsInput | number | null
    EndTime?: NullableIntFieldUpdateOperationsInput | number | null
    Term?: NullableIntFieldUpdateOperationsInput | number | null
    PromotionOrder?: NullableIntFieldUpdateOperationsInput | number | null
    BeginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DayOfWeekMask?: IntFieldUpdateOperationsInput | number
    PromotionType?: IntFieldUpdateOperationsInput | number
  }

  export type pricedetailtbUncheckedUpdateManyInput = {
    PriceDetailId?: IntFieldUpdateOperationsInput | number
    PriceId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: NullableIntFieldUpdateOperationsInput | number | null
    Price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    Promotion?: NullableIntFieldUpdateOperationsInput | number | null
    PromotionTerm?: NullableIntFieldUpdateOperationsInput | number | null
    FreeMoney?: NullableIntFieldUpdateOperationsInput | number | null
    FreeTime?: NullableIntFieldUpdateOperationsInput | number | null
    BeginTime?: NullableIntFieldUpdateOperationsInput | number | null
    EndTime?: NullableIntFieldUpdateOperationsInput | number | null
    Term?: NullableIntFieldUpdateOperationsInput | number | null
    PromotionOrder?: NullableIntFieldUpdateOperationsInput | number | null
    BeginDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DayOfWeekMask?: IntFieldUpdateOperationsInput | number
    PromotionType?: IntFieldUpdateOperationsInput | number
  }

  export type pricelisttbCreateInput = {
    PriceType: string
    Price: Decimal | DecimalJsLike | number | string
    Type?: number
    Active?: number | null
  }

  export type pricelisttbUncheckedCreateInput = {
    PriceId?: number
    PriceType: string
    Price: Decimal | DecimalJsLike | number | string
    Type?: number
    Active?: number | null
  }

  export type pricelisttbUpdateInput = {
    PriceType?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Type?: IntFieldUpdateOperationsInput | number
    Active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pricelisttbUncheckedUpdateInput = {
    PriceId?: IntFieldUpdateOperationsInput | number
    PriceType?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Type?: IntFieldUpdateOperationsInput | number
    Active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pricelisttbCreateManyInput = {
    PriceId?: number
    PriceType: string
    Price: Decimal | DecimalJsLike | number | string
    Type?: number
    Active?: number | null
  }

  export type pricelisttbUpdateManyMutationInput = {
    PriceType?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Type?: IntFieldUpdateOperationsInput | number
    Active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pricelisttbUncheckedUpdateManyInput = {
    PriceId?: IntFieldUpdateOperationsInput | number
    PriceType?: StringFieldUpdateOperationsInput | string
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Type?: IntFieldUpdateOperationsInput | number
    Active?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type pricemachinetbCreateInput = {
    PriceId: number
    MachineGroupId: number
    Price: Decimal | DecimalJsLike | number | string
  }

  export type pricemachinetbUncheckedCreateInput = {
    PriceMachineId?: number
    PriceId: number
    MachineGroupId: number
    Price: Decimal | DecimalJsLike | number | string
  }

  export type pricemachinetbUpdateInput = {
    PriceId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type pricemachinetbUncheckedUpdateInput = {
    PriceMachineId?: IntFieldUpdateOperationsInput | number
    PriceId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type pricemachinetbCreateManyInput = {
    PriceMachineId?: number
    PriceId: number
    MachineGroupId: number
    Price: Decimal | DecimalJsLike | number | string
  }

  export type pricemachinetbUpdateManyMutationInput = {
    PriceId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type pricemachinetbUncheckedUpdateManyInput = {
    PriceMachineId?: IntFieldUpdateOperationsInput | number
    PriceId?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    Price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type printertbCreateInput = {
    PrinterName?: string
    Type?: number
    Active?: number
  }

  export type printertbUncheckedCreateInput = {
    ID?: number
    PrinterName?: string
    Type?: number
    Active?: number
  }

  export type printertbUpdateInput = {
    PrinterName?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type printertbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    PrinterName?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type printertbCreateManyInput = {
    ID?: number
    PrinterName?: string
    Type?: number
    Active?: number
  }

  export type printertbUpdateManyMutationInput = {
    PrinterName?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type printertbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    PrinterName?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type printservicetbCreateInput = {
    PrinterID?: number
    ServiceID?: number
  }

  export type printservicetbUncheckedCreateInput = {
    ID?: number
    PrinterID?: number
    ServiceID?: number
  }

  export type printservicetbUpdateInput = {
    PrinterID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type printservicetbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    PrinterID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type printservicetbCreateManyInput = {
    ID?: number
    PrinterID?: number
    ServiceID?: number
  }

  export type printservicetbUpdateManyMutationInput = {
    PrinterID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type printservicetbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    PrinterID?: IntFieldUpdateOperationsInput | number
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type processtbCreateInput = {
    MachineName?: string
    ProcessName?: string
    FileLocation?: string
    FileDescription?: string
    Type?: number
    PreviousDate?: Date | string
    CurrentDate?: Date | string
  }

  export type processtbUncheckedCreateInput = {
    ID?: number
    MachineName?: string
    ProcessName?: string
    FileLocation?: string
    FileDescription?: string
    Type?: number
    PreviousDate?: Date | string
    CurrentDate?: Date | string
  }

  export type processtbUpdateInput = {
    MachineName?: StringFieldUpdateOperationsInput | string
    ProcessName?: StringFieldUpdateOperationsInput | string
    FileLocation?: StringFieldUpdateOperationsInput | string
    FileDescription?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    PreviousDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CurrentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type processtbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    MachineName?: StringFieldUpdateOperationsInput | string
    ProcessName?: StringFieldUpdateOperationsInput | string
    FileLocation?: StringFieldUpdateOperationsInput | string
    FileDescription?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    PreviousDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CurrentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type processtbCreateManyInput = {
    ID?: number
    MachineName?: string
    ProcessName?: string
    FileLocation?: string
    FileDescription?: string
    Type?: number
    PreviousDate?: Date | string
    CurrentDate?: Date | string
  }

  export type processtbUpdateManyMutationInput = {
    MachineName?: StringFieldUpdateOperationsInput | string
    ProcessName?: StringFieldUpdateOperationsInput | string
    FileLocation?: StringFieldUpdateOperationsInput | string
    FileDescription?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    PreviousDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CurrentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type processtbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    MachineName?: StringFieldUpdateOperationsInput | string
    ProcessName?: StringFieldUpdateOperationsInput | string
    FileLocation?: StringFieldUpdateOperationsInput | string
    FileDescription?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    PreviousDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CurrentDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rechargecarddetailtbCreateInput = {
    VoucherId: number
    StaffId: number
    CardValue: Decimal | DecimalJsLike | number | string
    CardDate: Date | string
    CardTime: Date | string
    CardQuantity: number
    CardAmount: Decimal | DecimalJsLike | number | string
    UserId?: number | null
    Accept?: boolean | null
  }

  export type rechargecarddetailtbUncheckedCreateInput = {
    CardDetailId?: number
    VoucherId: number
    StaffId: number
    CardValue: Decimal | DecimalJsLike | number | string
    CardDate: Date | string
    CardTime: Date | string
    CardQuantity: number
    CardAmount: Decimal | DecimalJsLike | number | string
    UserId?: number | null
    Accept?: boolean | null
  }

  export type rechargecarddetailtbUpdateInput = {
    VoucherId?: IntFieldUpdateOperationsInput | number
    StaffId?: IntFieldUpdateOperationsInput | number
    CardValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CardDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CardTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CardQuantity?: IntFieldUpdateOperationsInput | number
    CardAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    Accept?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type rechargecarddetailtbUncheckedUpdateInput = {
    CardDetailId?: IntFieldUpdateOperationsInput | number
    VoucherId?: IntFieldUpdateOperationsInput | number
    StaffId?: IntFieldUpdateOperationsInput | number
    CardValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CardDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CardTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CardQuantity?: IntFieldUpdateOperationsInput | number
    CardAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    Accept?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type rechargecarddetailtbCreateManyInput = {
    CardDetailId?: number
    VoucherId: number
    StaffId: number
    CardValue: Decimal | DecimalJsLike | number | string
    CardDate: Date | string
    CardTime: Date | string
    CardQuantity: number
    CardAmount: Decimal | DecimalJsLike | number | string
    UserId?: number | null
    Accept?: boolean | null
  }

  export type rechargecarddetailtbUpdateManyMutationInput = {
    VoucherId?: IntFieldUpdateOperationsInput | number
    StaffId?: IntFieldUpdateOperationsInput | number
    CardValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CardDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CardTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CardQuantity?: IntFieldUpdateOperationsInput | number
    CardAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    Accept?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type rechargecarddetailtbUncheckedUpdateManyInput = {
    CardDetailId?: IntFieldUpdateOperationsInput | number
    VoucherId?: IntFieldUpdateOperationsInput | number
    StaffId?: IntFieldUpdateOperationsInput | number
    CardValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CardDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CardTime?: DateTimeFieldUpdateOperationsInput | Date | string
    CardQuantity?: IntFieldUpdateOperationsInput | number
    CardAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    Accept?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type rechargecardtbCreateInput = {
    cardcode?: string | null
    CardValue: Decimal | DecimalJsLike | number | string
    ExpiryDate: Date | string
    CreateDate: Date | string
    CreateTime: Date | string
    ModifyDate?: Date | string | null
    ModifyTime?: Date | string | null
    Status?: boolean | null
    UserId?: number | null
    Note?: string | null
  }

  export type rechargecardtbUncheckedCreateInput = {
    CardId?: number
    cardcode?: string | null
    CardValue: Decimal | DecimalJsLike | number | string
    ExpiryDate: Date | string
    CreateDate: Date | string
    CreateTime: Date | string
    ModifyDate?: Date | string | null
    ModifyTime?: Date | string | null
    Status?: boolean | null
    UserId?: number | null
    Note?: string | null
  }

  export type rechargecardtbUpdateInput = {
    cardcode?: NullableStringFieldUpdateOperationsInput | string | null
    CardValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rechargecardtbUncheckedUpdateInput = {
    CardId?: IntFieldUpdateOperationsInput | number
    cardcode?: NullableStringFieldUpdateOperationsInput | string | null
    CardValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rechargecardtbCreateManyInput = {
    CardId?: number
    cardcode?: string | null
    CardValue: Decimal | DecimalJsLike | number | string
    ExpiryDate: Date | string
    CreateDate: Date | string
    CreateTime: Date | string
    ModifyDate?: Date | string | null
    ModifyTime?: Date | string | null
    Status?: boolean | null
    UserId?: number | null
    Note?: string | null
  }

  export type rechargecardtbUpdateManyMutationInput = {
    cardcode?: NullableStringFieldUpdateOperationsInput | string | null
    CardValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rechargecardtbUncheckedUpdateManyInput = {
    CardId?: IntFieldUpdateOperationsInput | number
    cardcode?: NullableStringFieldUpdateOperationsInput | string | null
    CardValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ExpiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ModifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ModifyTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reportdailyCreateInput = {
    ymd: number
    prefix: string
    mode: number
    f1?: number | null
    f2?: number | null
    f3?: number | null
    f4?: number | null
    f5?: number | null
    f6?: number | null
    f7?: number | null
    f8?: number | null
    f9?: number | null
    f10?: string | null
    f11?: string | null
    f12?: string | null
    f13?: string | null
    f14?: string | null
    f15?: number | null
    f16?: number | null
    f17?: number | null
    f18?: number | null
    f19?: number | null
    f20?: number | null
    ext?: string | null
    hash?: string | null
    create_date?: Date | string | null
    update_date?: Date | string | null
  }

  export type reportdailyUncheckedCreateInput = {
    ymd: number
    prefix: string
    mode: number
    f1?: number | null
    f2?: number | null
    f3?: number | null
    f4?: number | null
    f5?: number | null
    f6?: number | null
    f7?: number | null
    f8?: number | null
    f9?: number | null
    f10?: string | null
    f11?: string | null
    f12?: string | null
    f13?: string | null
    f14?: string | null
    f15?: number | null
    f16?: number | null
    f17?: number | null
    f18?: number | null
    f19?: number | null
    f20?: number | null
    ext?: string | null
    hash?: string | null
    create_date?: Date | string | null
    update_date?: Date | string | null
  }

  export type reportdailyUpdateInput = {
    ymd?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    f1?: NullableIntFieldUpdateOperationsInput | number | null
    f2?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    f4?: NullableIntFieldUpdateOperationsInput | number | null
    f5?: NullableIntFieldUpdateOperationsInput | number | null
    f6?: NullableIntFieldUpdateOperationsInput | number | null
    f7?: NullableIntFieldUpdateOperationsInput | number | null
    f8?: NullableIntFieldUpdateOperationsInput | number | null
    f9?: NullableIntFieldUpdateOperationsInput | number | null
    f10?: NullableStringFieldUpdateOperationsInput | string | null
    f11?: NullableStringFieldUpdateOperationsInput | string | null
    f12?: NullableStringFieldUpdateOperationsInput | string | null
    f13?: NullableStringFieldUpdateOperationsInput | string | null
    f14?: NullableStringFieldUpdateOperationsInput | string | null
    f15?: NullableFloatFieldUpdateOperationsInput | number | null
    f16?: NullableFloatFieldUpdateOperationsInput | number | null
    f17?: NullableFloatFieldUpdateOperationsInput | number | null
    f18?: NullableFloatFieldUpdateOperationsInput | number | null
    f19?: NullableFloatFieldUpdateOperationsInput | number | null
    f20?: NullableFloatFieldUpdateOperationsInput | number | null
    ext?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    create_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportdailyUncheckedUpdateInput = {
    ymd?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    f1?: NullableIntFieldUpdateOperationsInput | number | null
    f2?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    f4?: NullableIntFieldUpdateOperationsInput | number | null
    f5?: NullableIntFieldUpdateOperationsInput | number | null
    f6?: NullableIntFieldUpdateOperationsInput | number | null
    f7?: NullableIntFieldUpdateOperationsInput | number | null
    f8?: NullableIntFieldUpdateOperationsInput | number | null
    f9?: NullableIntFieldUpdateOperationsInput | number | null
    f10?: NullableStringFieldUpdateOperationsInput | string | null
    f11?: NullableStringFieldUpdateOperationsInput | string | null
    f12?: NullableStringFieldUpdateOperationsInput | string | null
    f13?: NullableStringFieldUpdateOperationsInput | string | null
    f14?: NullableStringFieldUpdateOperationsInput | string | null
    f15?: NullableFloatFieldUpdateOperationsInput | number | null
    f16?: NullableFloatFieldUpdateOperationsInput | number | null
    f17?: NullableFloatFieldUpdateOperationsInput | number | null
    f18?: NullableFloatFieldUpdateOperationsInput | number | null
    f19?: NullableFloatFieldUpdateOperationsInput | number | null
    f20?: NullableFloatFieldUpdateOperationsInput | number | null
    ext?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    create_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportdailyCreateManyInput = {
    ymd: number
    prefix: string
    mode: number
    f1?: number | null
    f2?: number | null
    f3?: number | null
    f4?: number | null
    f5?: number | null
    f6?: number | null
    f7?: number | null
    f8?: number | null
    f9?: number | null
    f10?: string | null
    f11?: string | null
    f12?: string | null
    f13?: string | null
    f14?: string | null
    f15?: number | null
    f16?: number | null
    f17?: number | null
    f18?: number | null
    f19?: number | null
    f20?: number | null
    ext?: string | null
    hash?: string | null
    create_date?: Date | string | null
    update_date?: Date | string | null
  }

  export type reportdailyUpdateManyMutationInput = {
    ymd?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    f1?: NullableIntFieldUpdateOperationsInput | number | null
    f2?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    f4?: NullableIntFieldUpdateOperationsInput | number | null
    f5?: NullableIntFieldUpdateOperationsInput | number | null
    f6?: NullableIntFieldUpdateOperationsInput | number | null
    f7?: NullableIntFieldUpdateOperationsInput | number | null
    f8?: NullableIntFieldUpdateOperationsInput | number | null
    f9?: NullableIntFieldUpdateOperationsInput | number | null
    f10?: NullableStringFieldUpdateOperationsInput | string | null
    f11?: NullableStringFieldUpdateOperationsInput | string | null
    f12?: NullableStringFieldUpdateOperationsInput | string | null
    f13?: NullableStringFieldUpdateOperationsInput | string | null
    f14?: NullableStringFieldUpdateOperationsInput | string | null
    f15?: NullableFloatFieldUpdateOperationsInput | number | null
    f16?: NullableFloatFieldUpdateOperationsInput | number | null
    f17?: NullableFloatFieldUpdateOperationsInput | number | null
    f18?: NullableFloatFieldUpdateOperationsInput | number | null
    f19?: NullableFloatFieldUpdateOperationsInput | number | null
    f20?: NullableFloatFieldUpdateOperationsInput | number | null
    ext?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    create_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportdailyUncheckedUpdateManyInput = {
    ymd?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    f1?: NullableIntFieldUpdateOperationsInput | number | null
    f2?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    f4?: NullableIntFieldUpdateOperationsInput | number | null
    f5?: NullableIntFieldUpdateOperationsInput | number | null
    f6?: NullableIntFieldUpdateOperationsInput | number | null
    f7?: NullableIntFieldUpdateOperationsInput | number | null
    f8?: NullableIntFieldUpdateOperationsInput | number | null
    f9?: NullableIntFieldUpdateOperationsInput | number | null
    f10?: NullableStringFieldUpdateOperationsInput | string | null
    f11?: NullableStringFieldUpdateOperationsInput | string | null
    f12?: NullableStringFieldUpdateOperationsInput | string | null
    f13?: NullableStringFieldUpdateOperationsInput | string | null
    f14?: NullableStringFieldUpdateOperationsInput | string | null
    f15?: NullableFloatFieldUpdateOperationsInput | number | null
    f16?: NullableFloatFieldUpdateOperationsInput | number | null
    f17?: NullableFloatFieldUpdateOperationsInput | number | null
    f18?: NullableFloatFieldUpdateOperationsInput | number | null
    f19?: NullableFloatFieldUpdateOperationsInput | number | null
    f20?: NullableFloatFieldUpdateOperationsInput | number | null
    ext?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    create_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportmonthlyCreateInput = {
    ymd: number
    prefix: string
    mode: number
    f1?: number | null
    f2?: number | null
    f3?: number | null
    f4?: number | null
    f5?: number | null
    f6?: number | null
    f7?: number | null
    f8?: number | null
    f9?: number | null
    f10?: string | null
    f11?: string | null
    f12?: string | null
    f13?: string | null
    f14?: string | null
    f15?: number | null
    f16?: number | null
    f17?: number | null
    f18?: number | null
    f19?: number | null
    f20?: number | null
    ext?: string | null
    hash?: string | null
    create_date?: Date | string | null
    update_date?: Date | string | null
  }

  export type reportmonthlyUncheckedCreateInput = {
    ymd: number
    prefix: string
    mode: number
    f1?: number | null
    f2?: number | null
    f3?: number | null
    f4?: number | null
    f5?: number | null
    f6?: number | null
    f7?: number | null
    f8?: number | null
    f9?: number | null
    f10?: string | null
    f11?: string | null
    f12?: string | null
    f13?: string | null
    f14?: string | null
    f15?: number | null
    f16?: number | null
    f17?: number | null
    f18?: number | null
    f19?: number | null
    f20?: number | null
    ext?: string | null
    hash?: string | null
    create_date?: Date | string | null
    update_date?: Date | string | null
  }

  export type reportmonthlyUpdateInput = {
    ymd?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    f1?: NullableIntFieldUpdateOperationsInput | number | null
    f2?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    f4?: NullableIntFieldUpdateOperationsInput | number | null
    f5?: NullableIntFieldUpdateOperationsInput | number | null
    f6?: NullableIntFieldUpdateOperationsInput | number | null
    f7?: NullableIntFieldUpdateOperationsInput | number | null
    f8?: NullableIntFieldUpdateOperationsInput | number | null
    f9?: NullableIntFieldUpdateOperationsInput | number | null
    f10?: NullableStringFieldUpdateOperationsInput | string | null
    f11?: NullableStringFieldUpdateOperationsInput | string | null
    f12?: NullableStringFieldUpdateOperationsInput | string | null
    f13?: NullableStringFieldUpdateOperationsInput | string | null
    f14?: NullableStringFieldUpdateOperationsInput | string | null
    f15?: NullableFloatFieldUpdateOperationsInput | number | null
    f16?: NullableFloatFieldUpdateOperationsInput | number | null
    f17?: NullableFloatFieldUpdateOperationsInput | number | null
    f18?: NullableFloatFieldUpdateOperationsInput | number | null
    f19?: NullableFloatFieldUpdateOperationsInput | number | null
    f20?: NullableFloatFieldUpdateOperationsInput | number | null
    ext?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    create_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportmonthlyUncheckedUpdateInput = {
    ymd?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    f1?: NullableIntFieldUpdateOperationsInput | number | null
    f2?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    f4?: NullableIntFieldUpdateOperationsInput | number | null
    f5?: NullableIntFieldUpdateOperationsInput | number | null
    f6?: NullableIntFieldUpdateOperationsInput | number | null
    f7?: NullableIntFieldUpdateOperationsInput | number | null
    f8?: NullableIntFieldUpdateOperationsInput | number | null
    f9?: NullableIntFieldUpdateOperationsInput | number | null
    f10?: NullableStringFieldUpdateOperationsInput | string | null
    f11?: NullableStringFieldUpdateOperationsInput | string | null
    f12?: NullableStringFieldUpdateOperationsInput | string | null
    f13?: NullableStringFieldUpdateOperationsInput | string | null
    f14?: NullableStringFieldUpdateOperationsInput | string | null
    f15?: NullableFloatFieldUpdateOperationsInput | number | null
    f16?: NullableFloatFieldUpdateOperationsInput | number | null
    f17?: NullableFloatFieldUpdateOperationsInput | number | null
    f18?: NullableFloatFieldUpdateOperationsInput | number | null
    f19?: NullableFloatFieldUpdateOperationsInput | number | null
    f20?: NullableFloatFieldUpdateOperationsInput | number | null
    ext?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    create_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportmonthlyCreateManyInput = {
    ymd: number
    prefix: string
    mode: number
    f1?: number | null
    f2?: number | null
    f3?: number | null
    f4?: number | null
    f5?: number | null
    f6?: number | null
    f7?: number | null
    f8?: number | null
    f9?: number | null
    f10?: string | null
    f11?: string | null
    f12?: string | null
    f13?: string | null
    f14?: string | null
    f15?: number | null
    f16?: number | null
    f17?: number | null
    f18?: number | null
    f19?: number | null
    f20?: number | null
    ext?: string | null
    hash?: string | null
    create_date?: Date | string | null
    update_date?: Date | string | null
  }

  export type reportmonthlyUpdateManyMutationInput = {
    ymd?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    f1?: NullableIntFieldUpdateOperationsInput | number | null
    f2?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    f4?: NullableIntFieldUpdateOperationsInput | number | null
    f5?: NullableIntFieldUpdateOperationsInput | number | null
    f6?: NullableIntFieldUpdateOperationsInput | number | null
    f7?: NullableIntFieldUpdateOperationsInput | number | null
    f8?: NullableIntFieldUpdateOperationsInput | number | null
    f9?: NullableIntFieldUpdateOperationsInput | number | null
    f10?: NullableStringFieldUpdateOperationsInput | string | null
    f11?: NullableStringFieldUpdateOperationsInput | string | null
    f12?: NullableStringFieldUpdateOperationsInput | string | null
    f13?: NullableStringFieldUpdateOperationsInput | string | null
    f14?: NullableStringFieldUpdateOperationsInput | string | null
    f15?: NullableFloatFieldUpdateOperationsInput | number | null
    f16?: NullableFloatFieldUpdateOperationsInput | number | null
    f17?: NullableFloatFieldUpdateOperationsInput | number | null
    f18?: NullableFloatFieldUpdateOperationsInput | number | null
    f19?: NullableFloatFieldUpdateOperationsInput | number | null
    f20?: NullableFloatFieldUpdateOperationsInput | number | null
    ext?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    create_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reportmonthlyUncheckedUpdateManyInput = {
    ymd?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    mode?: IntFieldUpdateOperationsInput | number
    f1?: NullableIntFieldUpdateOperationsInput | number | null
    f2?: NullableIntFieldUpdateOperationsInput | number | null
    f3?: NullableIntFieldUpdateOperationsInput | number | null
    f4?: NullableIntFieldUpdateOperationsInput | number | null
    f5?: NullableIntFieldUpdateOperationsInput | number | null
    f6?: NullableIntFieldUpdateOperationsInput | number | null
    f7?: NullableIntFieldUpdateOperationsInput | number | null
    f8?: NullableIntFieldUpdateOperationsInput | number | null
    f9?: NullableIntFieldUpdateOperationsInput | number | null
    f10?: NullableStringFieldUpdateOperationsInput | string | null
    f11?: NullableStringFieldUpdateOperationsInput | string | null
    f12?: NullableStringFieldUpdateOperationsInput | string | null
    f13?: NullableStringFieldUpdateOperationsInput | string | null
    f14?: NullableStringFieldUpdateOperationsInput | string | null
    f15?: NullableFloatFieldUpdateOperationsInput | number | null
    f16?: NullableFloatFieldUpdateOperationsInput | number | null
    f17?: NullableFloatFieldUpdateOperationsInput | number | null
    f18?: NullableFloatFieldUpdateOperationsInput | number | null
    f19?: NullableFloatFieldUpdateOperationsInput | number | null
    f20?: NullableFloatFieldUpdateOperationsInput | number | null
    ext?: NullableStringFieldUpdateOperationsInput | string | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    create_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    update_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type righttbCreateInput = {
    UserId: number
    FunctionCode?: string
  }

  export type righttbUncheckedCreateInput = {
    RightId?: number
    UserId: number
    FunctionCode?: string
  }

  export type righttbUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    FunctionCode?: StringFieldUpdateOperationsInput | string
  }

  export type righttbUncheckedUpdateInput = {
    RightId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    FunctionCode?: StringFieldUpdateOperationsInput | string
  }

  export type righttbCreateManyInput = {
    RightId?: number
    UserId: number
    FunctionCode?: string
  }

  export type righttbUpdateManyMutationInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    FunctionCode?: StringFieldUpdateOperationsInput | string
  }

  export type righttbUncheckedUpdateManyInput = {
    RightId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    FunctionCode?: StringFieldUpdateOperationsInput | string
  }

  export type serverlogtbCreateInput = {
    Status: string
    RecordDate: Date | string
    RecordTime: Date | string
    Period?: number
    Note?: string | null
  }

  export type serverlogtbUncheckedCreateInput = {
    ServerLogId?: number
    Status: string
    RecordDate: Date | string
    RecordTime: Date | string
    Period?: number
    Note?: string | null
  }

  export type serverlogtbUpdateInput = {
    Status?: StringFieldUpdateOperationsInput | string
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RecordTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Period?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serverlogtbUncheckedUpdateInput = {
    ServerLogId?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RecordTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Period?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serverlogtbCreateManyInput = {
    ServerLogId?: number
    Status: string
    RecordDate: Date | string
    RecordTime: Date | string
    Period?: number
    Note?: string | null
  }

  export type serverlogtbUpdateManyMutationInput = {
    Status?: StringFieldUpdateOperationsInput | string
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RecordTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Period?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serverlogtbUncheckedUpdateManyInput = {
    ServerLogId?: IntFieldUpdateOperationsInput | number
    Status?: StringFieldUpdateOperationsInput | string
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RecordTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Period?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicedetailtbCreateInput = {
    UserId: number
    ServiceId: number
    ServiceDate: Date | string
    ServiceTime: Date | string
    ServiceQuantity: number
    ServiceAmount: Decimal | DecimalJsLike | number | string
    ServicePaid?: boolean
    Accept?: boolean
    VoucherId?: number | null
    StaffId?: number
    PaymentWaitId?: number
    iCafeHash?: string | null
    iCafeUsr?: string | null
  }

  export type servicedetailtbUncheckedCreateInput = {
    ServiceDetailId?: number
    UserId: number
    ServiceId: number
    ServiceDate: Date | string
    ServiceTime: Date | string
    ServiceQuantity: number
    ServiceAmount: Decimal | DecimalJsLike | number | string
    ServicePaid?: boolean
    Accept?: boolean
    VoucherId?: number | null
    StaffId?: number
    PaymentWaitId?: number
    iCafeHash?: string | null
    iCafeUsr?: string | null
  }

  export type servicedetailtbUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    ServiceId?: IntFieldUpdateOperationsInput | number
    ServiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ServiceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ServiceQuantity?: IntFieldUpdateOperationsInput | number
    ServiceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ServicePaid?: BoolFieldUpdateOperationsInput | boolean
    Accept?: BoolFieldUpdateOperationsInput | boolean
    VoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    StaffId?: IntFieldUpdateOperationsInput | number
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    iCafeHash?: NullableStringFieldUpdateOperationsInput | string | null
    iCafeUsr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicedetailtbUncheckedUpdateInput = {
    ServiceDetailId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    ServiceId?: IntFieldUpdateOperationsInput | number
    ServiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ServiceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ServiceQuantity?: IntFieldUpdateOperationsInput | number
    ServiceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ServicePaid?: BoolFieldUpdateOperationsInput | boolean
    Accept?: BoolFieldUpdateOperationsInput | boolean
    VoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    StaffId?: IntFieldUpdateOperationsInput | number
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    iCafeHash?: NullableStringFieldUpdateOperationsInput | string | null
    iCafeUsr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicedetailtbCreateManyInput = {
    ServiceDetailId?: number
    UserId: number
    ServiceId: number
    ServiceDate: Date | string
    ServiceTime: Date | string
    ServiceQuantity: number
    ServiceAmount: Decimal | DecimalJsLike | number | string
    ServicePaid?: boolean
    Accept?: boolean
    VoucherId?: number | null
    StaffId?: number
    PaymentWaitId?: number
    iCafeHash?: string | null
    iCafeUsr?: string | null
  }

  export type servicedetailtbUpdateManyMutationInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    ServiceId?: IntFieldUpdateOperationsInput | number
    ServiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ServiceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ServiceQuantity?: IntFieldUpdateOperationsInput | number
    ServiceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ServicePaid?: BoolFieldUpdateOperationsInput | boolean
    Accept?: BoolFieldUpdateOperationsInput | boolean
    VoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    StaffId?: IntFieldUpdateOperationsInput | number
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    iCafeHash?: NullableStringFieldUpdateOperationsInput | string | null
    iCafeUsr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicedetailtbUncheckedUpdateManyInput = {
    ServiceDetailId?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    ServiceId?: IntFieldUpdateOperationsInput | number
    ServiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ServiceTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ServiceQuantity?: IntFieldUpdateOperationsInput | number
    ServiceAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ServicePaid?: BoolFieldUpdateOperationsInput | boolean
    Accept?: BoolFieldUpdateOperationsInput | boolean
    VoucherId?: NullableIntFieldUpdateOperationsInput | number | null
    StaffId?: IntFieldUpdateOperationsInput | number
    PaymentWaitId?: IntFieldUpdateOperationsInput | number
    iCafeHash?: NullableStringFieldUpdateOperationsInput | string | null
    iCafeUsr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicegiftsbagCreateInput = {
    recId?: bigint | number
    recUuid: string
    userId?: string | null
    userName?: string | null
    createDate?: Date | string | null
    expDate?: Date | string | null
    sourceType?: number | null
    serviceId?: number | null
    serviceName?: string | null
    servicePrice?: number | null
    serviceImg?: string | null
    status?: number | null
    requestDate?: Date | string | null
    acceptDate?: Date | string | null
    sign?: string | null
    staffId?: number | null
    staffName?: string | null
    transId?: string | null
    serialId?: string | null
    ymd?: number | null
    totalDay?: number | null
    groupId?: number | null
  }

  export type servicegiftsbagUncheckedCreateInput = {
    recId?: bigint | number
    recUuid: string
    userId?: string | null
    userName?: string | null
    createDate?: Date | string | null
    expDate?: Date | string | null
    sourceType?: number | null
    serviceId?: number | null
    serviceName?: string | null
    servicePrice?: number | null
    serviceImg?: string | null
    status?: number | null
    requestDate?: Date | string | null
    acceptDate?: Date | string | null
    sign?: string | null
    staffId?: number | null
    staffName?: string | null
    transId?: string | null
    serialId?: string | null
    ymd?: number | null
    totalDay?: number | null
    groupId?: number | null
  }

  export type servicegiftsbagUpdateInput = {
    recId?: BigIntFieldUpdateOperationsInput | bigint | number
    recUuid?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceType?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    servicePrice?: NullableIntFieldUpdateOperationsInput | number | null
    serviceImg?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    staffName?: NullableStringFieldUpdateOperationsInput | string | null
    transId?: NullableStringFieldUpdateOperationsInput | string | null
    serialId?: NullableStringFieldUpdateOperationsInput | string | null
    ymd?: NullableIntFieldUpdateOperationsInput | number | null
    totalDay?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicegiftsbagUncheckedUpdateInput = {
    recId?: BigIntFieldUpdateOperationsInput | bigint | number
    recUuid?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceType?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    servicePrice?: NullableIntFieldUpdateOperationsInput | number | null
    serviceImg?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    staffName?: NullableStringFieldUpdateOperationsInput | string | null
    transId?: NullableStringFieldUpdateOperationsInput | string | null
    serialId?: NullableStringFieldUpdateOperationsInput | string | null
    ymd?: NullableIntFieldUpdateOperationsInput | number | null
    totalDay?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicegiftsbagCreateManyInput = {
    recId?: bigint | number
    recUuid: string
    userId?: string | null
    userName?: string | null
    createDate?: Date | string | null
    expDate?: Date | string | null
    sourceType?: number | null
    serviceId?: number | null
    serviceName?: string | null
    servicePrice?: number | null
    serviceImg?: string | null
    status?: number | null
    requestDate?: Date | string | null
    acceptDate?: Date | string | null
    sign?: string | null
    staffId?: number | null
    staffName?: string | null
    transId?: string | null
    serialId?: string | null
    ymd?: number | null
    totalDay?: number | null
    groupId?: number | null
  }

  export type servicegiftsbagUpdateManyMutationInput = {
    recId?: BigIntFieldUpdateOperationsInput | bigint | number
    recUuid?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceType?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    servicePrice?: NullableIntFieldUpdateOperationsInput | number | null
    serviceImg?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    staffName?: NullableStringFieldUpdateOperationsInput | string | null
    transId?: NullableStringFieldUpdateOperationsInput | string | null
    serialId?: NullableStringFieldUpdateOperationsInput | string | null
    ymd?: NullableIntFieldUpdateOperationsInput | number | null
    totalDay?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicegiftsbagUncheckedUpdateManyInput = {
    recId?: BigIntFieldUpdateOperationsInput | bigint | number
    recUuid?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourceType?: NullableIntFieldUpdateOperationsInput | number | null
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceName?: NullableStringFieldUpdateOperationsInput | string | null
    servicePrice?: NullableIntFieldUpdateOperationsInput | number | null
    serviceImg?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    requestDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    staffName?: NullableStringFieldUpdateOperationsInput | string | null
    transId?: NullableStringFieldUpdateOperationsInput | string | null
    serialId?: NullableStringFieldUpdateOperationsInput | string | null
    ymd?: NullableIntFieldUpdateOperationsInput | number | null
    totalDay?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicegrouptbCreateInput = {
    ServiceGroupName?: string
    IsOrder?: number
    Active?: number | null
    TypeID?: number
  }

  export type servicegrouptbUncheckedCreateInput = {
    ID?: number
    ServiceGroupName?: string
    IsOrder?: number
    Active?: number | null
    TypeID?: number
  }

  export type servicegrouptbUpdateInput = {
    ServiceGroupName?: StringFieldUpdateOperationsInput | string
    IsOrder?: IntFieldUpdateOperationsInput | number
    Active?: NullableIntFieldUpdateOperationsInput | number | null
    TypeID?: IntFieldUpdateOperationsInput | number
  }

  export type servicegrouptbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ServiceGroupName?: StringFieldUpdateOperationsInput | string
    IsOrder?: IntFieldUpdateOperationsInput | number
    Active?: NullableIntFieldUpdateOperationsInput | number | null
    TypeID?: IntFieldUpdateOperationsInput | number
  }

  export type servicegrouptbCreateManyInput = {
    ID?: number
    ServiceGroupName?: string
    IsOrder?: number
    Active?: number | null
    TypeID?: number
  }

  export type servicegrouptbUpdateManyMutationInput = {
    ServiceGroupName?: StringFieldUpdateOperationsInput | string
    IsOrder?: IntFieldUpdateOperationsInput | number
    Active?: NullableIntFieldUpdateOperationsInput | number | null
    TypeID?: IntFieldUpdateOperationsInput | number
  }

  export type servicegrouptbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ServiceGroupName?: StringFieldUpdateOperationsInput | string
    IsOrder?: IntFieldUpdateOperationsInput | number
    Active?: NullableIntFieldUpdateOperationsInput | number | null
    TypeID?: IntFieldUpdateOperationsInput | number
  }

  export type serviceinfologtbCreateInput = {
    logId?: number
    serviceId?: number | null
    prefix: string
    info?: string | null
    status?: number | null
    createDate?: Date | string | null
    mode?: number | null
    hash?: string | null
  }

  export type serviceinfologtbUncheckedCreateInput = {
    logId?: number
    serviceId?: number | null
    prefix: string
    info?: string | null
    status?: number | null
    createDate?: Date | string | null
    mode?: number | null
    hash?: string | null
  }

  export type serviceinfologtbUpdateInput = {
    logId?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: StringFieldUpdateOperationsInput | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mode?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceinfologtbUncheckedUpdateInput = {
    logId?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: StringFieldUpdateOperationsInput | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mode?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceinfologtbCreateManyInput = {
    logId?: number
    serviceId?: number | null
    prefix: string
    info?: string | null
    status?: number | null
    createDate?: Date | string | null
    mode?: number | null
    hash?: string | null
  }

  export type serviceinfologtbUpdateManyMutationInput = {
    logId?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: StringFieldUpdateOperationsInput | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mode?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceinfologtbUncheckedUpdateManyInput = {
    logId?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableIntFieldUpdateOperationsInput | number | null
    prefix?: StringFieldUpdateOperationsInput | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mode?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceinfotbCreateInput = {
    serviceId?: number
    prefix: string
    info?: string | null
    status?: number | null
    createDate?: Date | string | null
    mode?: number | null
    hash?: string | null
  }

  export type serviceinfotbUncheckedCreateInput = {
    serviceId?: number
    prefix: string
    info?: string | null
    status?: number | null
    createDate?: Date | string | null
    mode?: number | null
    hash?: string | null
  }

  export type serviceinfotbUpdateInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mode?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceinfotbUncheckedUpdateInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mode?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceinfotbCreateManyInput = {
    serviceId?: number
    prefix: string
    info?: string | null
    status?: number | null
    createDate?: Date | string | null
    mode?: number | null
    hash?: string | null
  }

  export type serviceinfotbUpdateManyMutationInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mode?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type serviceinfotbUncheckedUpdateManyInput = {
    serviceId?: IntFieldUpdateOperationsInput | number
    prefix?: StringFieldUpdateOperationsInput | string
    info?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mode?: NullableIntFieldUpdateOperationsInput | number | null
    hash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type servicetbCreateInput = {
    ServiceName: string
    ServicePrice: Decimal | DecimalJsLike | number | string
    Unit?: string
    Active?: boolean
    InventoryManagement?: boolean
    Inventory?: number
    WarningInventory?: number
    ServiceGroupID?: number
    NumInventoryExpected?: number
    UnitID?: number
    SuggestID?: number
    ServiceImg?: string | null
    ServiceDate?: Date | string | null
  }

  export type servicetbUncheckedCreateInput = {
    ServiceId?: number
    ServiceName: string
    ServicePrice: Decimal | DecimalJsLike | number | string
    Unit?: string
    Active?: boolean
    InventoryManagement?: boolean
    Inventory?: number
    WarningInventory?: number
    ServiceGroupID?: number
    NumInventoryExpected?: number
    UnitID?: number
    SuggestID?: number
    ServiceImg?: string | null
    ServiceDate?: Date | string | null
  }

  export type servicetbUpdateInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    ServicePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Unit?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    InventoryManagement?: BoolFieldUpdateOperationsInput | boolean
    Inventory?: IntFieldUpdateOperationsInput | number
    WarningInventory?: IntFieldUpdateOperationsInput | number
    ServiceGroupID?: IntFieldUpdateOperationsInput | number
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    UnitID?: IntFieldUpdateOperationsInput | number
    SuggestID?: IntFieldUpdateOperationsInput | number
    ServiceImg?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type servicetbUncheckedUpdateInput = {
    ServiceId?: IntFieldUpdateOperationsInput | number
    ServiceName?: StringFieldUpdateOperationsInput | string
    ServicePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Unit?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    InventoryManagement?: BoolFieldUpdateOperationsInput | boolean
    Inventory?: IntFieldUpdateOperationsInput | number
    WarningInventory?: IntFieldUpdateOperationsInput | number
    ServiceGroupID?: IntFieldUpdateOperationsInput | number
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    UnitID?: IntFieldUpdateOperationsInput | number
    SuggestID?: IntFieldUpdateOperationsInput | number
    ServiceImg?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type servicetbCreateManyInput = {
    ServiceId?: number
    ServiceName: string
    ServicePrice: Decimal | DecimalJsLike | number | string
    Unit?: string
    Active?: boolean
    InventoryManagement?: boolean
    Inventory?: number
    WarningInventory?: number
    ServiceGroupID?: number
    NumInventoryExpected?: number
    UnitID?: number
    SuggestID?: number
    ServiceImg?: string | null
    ServiceDate?: Date | string | null
  }

  export type servicetbUpdateManyMutationInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    ServicePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Unit?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    InventoryManagement?: BoolFieldUpdateOperationsInput | boolean
    Inventory?: IntFieldUpdateOperationsInput | number
    WarningInventory?: IntFieldUpdateOperationsInput | number
    ServiceGroupID?: IntFieldUpdateOperationsInput | number
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    UnitID?: IntFieldUpdateOperationsInput | number
    SuggestID?: IntFieldUpdateOperationsInput | number
    ServiceImg?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type servicetbUncheckedUpdateManyInput = {
    ServiceId?: IntFieldUpdateOperationsInput | number
    ServiceName?: StringFieldUpdateOperationsInput | string
    ServicePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Unit?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    InventoryManagement?: BoolFieldUpdateOperationsInput | boolean
    Inventory?: IntFieldUpdateOperationsInput | number
    WarningInventory?: IntFieldUpdateOperationsInput | number
    ServiceGroupID?: IntFieldUpdateOperationsInput | number
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    UnitID?: IntFieldUpdateOperationsInput | number
    SuggestID?: IntFieldUpdateOperationsInput | number
    ServiceImg?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type serviceunittbCreateInput = {
    Unit?: string
    IsActive?: boolean
  }

  export type serviceunittbUncheckedCreateInput = {
    ID?: number
    Unit?: string
    IsActive?: boolean
  }

  export type serviceunittbUpdateInput = {
    Unit?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type serviceunittbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Unit?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type serviceunittbCreateManyInput = {
    ID?: number
    Unit?: string
    IsActive?: boolean
  }

  export type serviceunittbUpdateManyMutationInput = {
    Unit?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type serviceunittbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Unit?: StringFieldUpdateOperationsInput | string
    IsActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type servicevisitCreateInput = {
    uid: string
    vstotal?: number | null
    vsdetail?: string | null
    ym: number
    last_update?: Date | string | null
    sign?: string | null
    ssid?: string | null
    reset?: number | null
  }

  export type servicevisitUncheckedCreateInput = {
    uid: string
    vstotal?: number | null
    vsdetail?: string | null
    ym: number
    last_update?: Date | string | null
    sign?: string | null
    ssid?: string | null
    reset?: number | null
  }

  export type servicevisitUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    vstotal?: NullableIntFieldUpdateOperationsInput | number | null
    vsdetail?: NullableStringFieldUpdateOperationsInput | string | null
    ym?: IntFieldUpdateOperationsInput | number
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    reset?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicevisitUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    vstotal?: NullableIntFieldUpdateOperationsInput | number | null
    vsdetail?: NullableStringFieldUpdateOperationsInput | string | null
    ym?: IntFieldUpdateOperationsInput | number
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    reset?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicevisitCreateManyInput = {
    uid: string
    vstotal?: number | null
    vsdetail?: string | null
    ym: number
    last_update?: Date | string | null
    sign?: string | null
    ssid?: string | null
    reset?: number | null
  }

  export type servicevisitUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    vstotal?: NullableIntFieldUpdateOperationsInput | number | null
    vsdetail?: NullableStringFieldUpdateOperationsInput | string | null
    ym?: IntFieldUpdateOperationsInput | number
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    reset?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type servicevisitUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    vstotal?: NullableIntFieldUpdateOperationsInput | number | null
    vsdetail?: NullableStringFieldUpdateOperationsInput | string | null
    ym?: IntFieldUpdateOperationsInput | number
    last_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    reset?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type settingtbCreateInput = {
    SettingId: number
    Value: number
    Data: string
    Active: boolean
  }

  export type settingtbUncheckedCreateInput = {
    SettingId: number
    Value: number
    Data: string
    Active: boolean
  }

  export type settingtbUpdateInput = {
    SettingId?: IntFieldUpdateOperationsInput | number
    Value?: IntFieldUpdateOperationsInput | number
    Data?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type settingtbUncheckedUpdateInput = {
    SettingId?: IntFieldUpdateOperationsInput | number
    Value?: IntFieldUpdateOperationsInput | number
    Data?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type settingtbCreateManyInput = {
    SettingId: number
    Value: number
    Data: string
    Active: boolean
  }

  export type settingtbUpdateManyMutationInput = {
    SettingId?: IntFieldUpdateOperationsInput | number
    Value?: IntFieldUpdateOperationsInput | number
    Data?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type settingtbUncheckedUpdateManyInput = {
    SettingId?: IntFieldUpdateOperationsInput | number
    Value?: IntFieldUpdateOperationsInput | number
    Data?: StringFieldUpdateOperationsInput | string
    Active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type softwaretbCreateInput = {
    UserId?: number
    Name?: string
    Version?: string
    MAC?: string
    Active?: number
  }

  export type softwaretbUncheckedCreateInput = {
    ID?: number
    UserId?: number
    Name?: string
    Version?: string
    MAC?: string
    Active?: number
  }

  export type softwaretbUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type softwaretbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type softwaretbCreateManyInput = {
    ID?: number
    UserId?: number
    Name?: string
    Version?: string
    MAC?: string
    Active?: number
  }

  export type softwaretbUpdateManyMutationInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type softwaretbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserId?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    MAC?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type specappdetailtbCreateInput = {
    MachineName?: string
    AppName?: string
    Shortcut?: string
    InstallName?: string
    InstallVersion?: string
    InstallLocation?: string
    LastUpdateDate: Date | string
    Sent?: boolean
    AppRun?: boolean
    SubRun?: boolean
    SubRun2?: boolean
  }

  export type specappdetailtbUncheckedCreateInput = {
    ID?: number
    MachineName?: string
    AppName?: string
    Shortcut?: string
    InstallName?: string
    InstallVersion?: string
    InstallLocation?: string
    LastUpdateDate: Date | string
    Sent?: boolean
    AppRun?: boolean
    SubRun?: boolean
    SubRun2?: boolean
  }

  export type specappdetailtbUpdateInput = {
    MachineName?: StringFieldUpdateOperationsInput | string
    AppName?: StringFieldUpdateOperationsInput | string
    Shortcut?: StringFieldUpdateOperationsInput | string
    InstallName?: StringFieldUpdateOperationsInput | string
    InstallVersion?: StringFieldUpdateOperationsInput | string
    InstallLocation?: StringFieldUpdateOperationsInput | string
    LastUpdateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Sent?: BoolFieldUpdateOperationsInput | boolean
    AppRun?: BoolFieldUpdateOperationsInput | boolean
    SubRun?: BoolFieldUpdateOperationsInput | boolean
    SubRun2?: BoolFieldUpdateOperationsInput | boolean
  }

  export type specappdetailtbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    MachineName?: StringFieldUpdateOperationsInput | string
    AppName?: StringFieldUpdateOperationsInput | string
    Shortcut?: StringFieldUpdateOperationsInput | string
    InstallName?: StringFieldUpdateOperationsInput | string
    InstallVersion?: StringFieldUpdateOperationsInput | string
    InstallLocation?: StringFieldUpdateOperationsInput | string
    LastUpdateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Sent?: BoolFieldUpdateOperationsInput | boolean
    AppRun?: BoolFieldUpdateOperationsInput | boolean
    SubRun?: BoolFieldUpdateOperationsInput | boolean
    SubRun2?: BoolFieldUpdateOperationsInput | boolean
  }

  export type specappdetailtbCreateManyInput = {
    ID?: number
    MachineName?: string
    AppName?: string
    Shortcut?: string
    InstallName?: string
    InstallVersion?: string
    InstallLocation?: string
    LastUpdateDate: Date | string
    Sent?: boolean
    AppRun?: boolean
    SubRun?: boolean
    SubRun2?: boolean
  }

  export type specappdetailtbUpdateManyMutationInput = {
    MachineName?: StringFieldUpdateOperationsInput | string
    AppName?: StringFieldUpdateOperationsInput | string
    Shortcut?: StringFieldUpdateOperationsInput | string
    InstallName?: StringFieldUpdateOperationsInput | string
    InstallVersion?: StringFieldUpdateOperationsInput | string
    InstallLocation?: StringFieldUpdateOperationsInput | string
    LastUpdateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Sent?: BoolFieldUpdateOperationsInput | boolean
    AppRun?: BoolFieldUpdateOperationsInput | boolean
    SubRun?: BoolFieldUpdateOperationsInput | boolean
    SubRun2?: BoolFieldUpdateOperationsInput | boolean
  }

  export type specappdetailtbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    MachineName?: StringFieldUpdateOperationsInput | string
    AppName?: StringFieldUpdateOperationsInput | string
    Shortcut?: StringFieldUpdateOperationsInput | string
    InstallName?: StringFieldUpdateOperationsInput | string
    InstallVersion?: StringFieldUpdateOperationsInput | string
    InstallLocation?: StringFieldUpdateOperationsInput | string
    LastUpdateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Sent?: BoolFieldUpdateOperationsInput | boolean
    AppRun?: BoolFieldUpdateOperationsInput | boolean
    SubRun?: BoolFieldUpdateOperationsInput | boolean
    SubRun2?: BoolFieldUpdateOperationsInput | boolean
  }

  export type standardservicetbCreateInput = {
    StandardServiceName?: string
    StandardServiceGroupID?: number
    Active?: number
  }

  export type standardservicetbUncheckedCreateInput = {
    StandardServiceId?: number
    StandardServiceName?: string
    StandardServiceGroupID?: number
    Active?: number
  }

  export type standardservicetbUpdateInput = {
    StandardServiceName?: StringFieldUpdateOperationsInput | string
    StandardServiceGroupID?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type standardservicetbUncheckedUpdateInput = {
    StandardServiceId?: IntFieldUpdateOperationsInput | number
    StandardServiceName?: StringFieldUpdateOperationsInput | string
    StandardServiceGroupID?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type standardservicetbCreateManyInput = {
    StandardServiceId?: number
    StandardServiceName?: string
    StandardServiceGroupID?: number
    Active?: number
  }

  export type standardservicetbUpdateManyMutationInput = {
    StandardServiceName?: StringFieldUpdateOperationsInput | string
    StandardServiceGroupID?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type standardservicetbUncheckedUpdateManyInput = {
    StandardServiceId?: IntFieldUpdateOperationsInput | number
    StandardServiceName?: StringFieldUpdateOperationsInput | string
    StandardServiceGroupID?: IntFieldUpdateOperationsInput | number
    Active?: IntFieldUpdateOperationsInput | number
  }

  export type stocktakingtbCreateInput = {
    CreateDate?: Date | string
    CreateTime?: Date | string
    StaffID?: number
    NumInventoryExpected?: number
    NumInventoryReal?: number
    NumAdjust?: number
    NumPreAdjust?: number
    Note?: string | null
    ServiceID?: number
  }

  export type stocktakingtbUncheckedCreateInput = {
    ID?: number
    CreateDate?: Date | string
    CreateTime?: Date | string
    StaffID?: number
    NumInventoryExpected?: number
    NumInventoryReal?: number
    NumAdjust?: number
    NumPreAdjust?: number
    Note?: string | null
    ServiceID?: number
  }

  export type stocktakingtbUpdateInput = {
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    NumInventoryReal?: IntFieldUpdateOperationsInput | number
    NumAdjust?: IntFieldUpdateOperationsInput | number
    NumPreAdjust?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type stocktakingtbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    NumInventoryReal?: IntFieldUpdateOperationsInput | number
    NumAdjust?: IntFieldUpdateOperationsInput | number
    NumPreAdjust?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type stocktakingtbCreateManyInput = {
    ID?: number
    CreateDate?: Date | string
    CreateTime?: Date | string
    StaffID?: number
    NumInventoryExpected?: number
    NumInventoryReal?: number
    NumAdjust?: number
    NumPreAdjust?: number
    Note?: string | null
    ServiceID?: number
  }

  export type stocktakingtbUpdateManyMutationInput = {
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    NumInventoryReal?: IntFieldUpdateOperationsInput | number
    NumAdjust?: IntFieldUpdateOperationsInput | number
    NumPreAdjust?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type stocktakingtbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreateDate?: DateTimeFieldUpdateOperationsInput | Date | string
    CreateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    StaffID?: IntFieldUpdateOperationsInput | number
    NumInventoryExpected?: IntFieldUpdateOperationsInput | number
    NumInventoryReal?: IntFieldUpdateOperationsInput | number
    NumAdjust?: IntFieldUpdateOperationsInput | number
    NumPreAdjust?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    ServiceID?: IntFieldUpdateOperationsInput | number
  }

  export type supportsCreateInput = {
    supportId?: number
    supportTitle: string
    supportImage?: string | null
    suportCode?: number | null
    supportHash?: string | null
    status?: number | null
    order?: number | null
    supportCat?: string | null
    totalClick?: number | null
    ssId?: string | null
    createDate?: Date | string | null
    modifyDate?: Date | string | null
  }

  export type supportsUncheckedCreateInput = {
    supportId?: number
    supportTitle: string
    supportImage?: string | null
    suportCode?: number | null
    supportHash?: string | null
    status?: number | null
    order?: number | null
    supportCat?: string | null
    totalClick?: number | null
    ssId?: string | null
    createDate?: Date | string | null
    modifyDate?: Date | string | null
  }

  export type supportsUpdateInput = {
    supportId?: IntFieldUpdateOperationsInput | number
    supportTitle?: StringFieldUpdateOperationsInput | string
    supportImage?: NullableStringFieldUpdateOperationsInput | string | null
    suportCode?: NullableIntFieldUpdateOperationsInput | number | null
    supportHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    supportCat?: NullableStringFieldUpdateOperationsInput | string | null
    totalClick?: NullableIntFieldUpdateOperationsInput | number | null
    ssId?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supportsUncheckedUpdateInput = {
    supportId?: IntFieldUpdateOperationsInput | number
    supportTitle?: StringFieldUpdateOperationsInput | string
    supportImage?: NullableStringFieldUpdateOperationsInput | string | null
    suportCode?: NullableIntFieldUpdateOperationsInput | number | null
    supportHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    supportCat?: NullableStringFieldUpdateOperationsInput | string | null
    totalClick?: NullableIntFieldUpdateOperationsInput | number | null
    ssId?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supportsCreateManyInput = {
    supportId?: number
    supportTitle: string
    supportImage?: string | null
    suportCode?: number | null
    supportHash?: string | null
    status?: number | null
    order?: number | null
    supportCat?: string | null
    totalClick?: number | null
    ssId?: string | null
    createDate?: Date | string | null
    modifyDate?: Date | string | null
  }

  export type supportsUpdateManyMutationInput = {
    supportId?: IntFieldUpdateOperationsInput | number
    supportTitle?: StringFieldUpdateOperationsInput | string
    supportImage?: NullableStringFieldUpdateOperationsInput | string | null
    suportCode?: NullableIntFieldUpdateOperationsInput | number | null
    supportHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    supportCat?: NullableStringFieldUpdateOperationsInput | string | null
    totalClick?: NullableIntFieldUpdateOperationsInput | number | null
    ssId?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type supportsUncheckedUpdateManyInput = {
    supportId?: IntFieldUpdateOperationsInput | number
    supportTitle?: StringFieldUpdateOperationsInput | string
    supportImage?: NullableStringFieldUpdateOperationsInput | string | null
    suportCode?: NullableIntFieldUpdateOperationsInput | number | null
    supportHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    supportCat?: NullableStringFieldUpdateOperationsInput | string | null
    totalClick?: NullableIntFieldUpdateOperationsInput | number | null
    ssId?: NullableStringFieldUpdateOperationsInput | string | null
    createDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modifyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type systemfunctiontbCreateInput = {
    ResourceID?: number
    Status?: number
  }

  export type systemfunctiontbUncheckedCreateInput = {
    ResourceID?: number
    Status?: number
  }

  export type systemfunctiontbUpdateInput = {
    ResourceID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type systemfunctiontbUncheckedUpdateInput = {
    ResourceID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type systemfunctiontbCreateManyInput = {
    ResourceID?: number
    Status?: number
  }

  export type systemfunctiontbUpdateManyMutationInput = {
    ResourceID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type systemfunctiontbUncheckedUpdateManyInput = {
    ResourceID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
  }

  export type systemlogtbCreateInput = {
    UserId?: number | null
    MachineName: string
    IPAddress: string
    EnterDate: Date | string
    EnterTime: Date | string
    EndDate?: Date | string | null
    EndTime?: Date | string | null
    Status: number
    Note: string
    TimeUsed: number
    MoneyUsed?: number
    PriceAppRentID?: number
    AppRentMoneyUsed?: number
  }

  export type systemlogtbUncheckedCreateInput = {
    SystemLogId?: number
    UserId?: number | null
    MachineName: string
    IPAddress: string
    EnterDate: Date | string
    EnterTime: Date | string
    EndDate?: Date | string | null
    EndTime?: Date | string | null
    Status: number
    Note: string
    TimeUsed: number
    MoneyUsed?: number
    PriceAppRentID?: number
    AppRentMoneyUsed?: number
  }

  export type systemlogtbUpdateInput = {
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    MachineName?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    EnterDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EnterTime?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    AppRentMoneyUsed?: IntFieldUpdateOperationsInput | number
  }

  export type systemlogtbUncheckedUpdateInput = {
    SystemLogId?: IntFieldUpdateOperationsInput | number
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    MachineName?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    EnterDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EnterTime?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    AppRentMoneyUsed?: IntFieldUpdateOperationsInput | number
  }

  export type systemlogtbCreateManyInput = {
    SystemLogId?: number
    UserId?: number | null
    MachineName: string
    IPAddress: string
    EnterDate: Date | string
    EnterTime: Date | string
    EndDate?: Date | string | null
    EndTime?: Date | string | null
    Status: number
    Note: string
    TimeUsed: number
    MoneyUsed?: number
    PriceAppRentID?: number
    AppRentMoneyUsed?: number
  }

  export type systemlogtbUpdateManyMutationInput = {
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    MachineName?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    EnterDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EnterTime?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    AppRentMoneyUsed?: IntFieldUpdateOperationsInput | number
  }

  export type systemlogtbUncheckedUpdateManyInput = {
    SystemLogId?: IntFieldUpdateOperationsInput | number
    UserId?: NullableIntFieldUpdateOperationsInput | number | null
    MachineName?: StringFieldUpdateOperationsInput | string
    IPAddress?: StringFieldUpdateOperationsInput | string
    EnterDate?: DateTimeFieldUpdateOperationsInput | Date | string
    EnterTime?: DateTimeFieldUpdateOperationsInput | Date | string
    EndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    EndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Status?: IntFieldUpdateOperationsInput | number
    Note?: StringFieldUpdateOperationsInput | string
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    AppRentMoneyUsed?: IntFieldUpdateOperationsInput | number
  }

  export type trackappdetailtbCreateInput = {
    AppName: string
    UserName: string
    TrackingDate: Date | string
    TrackingTime: Date | string
    TimeTotal: number
    AppSession?: boolean
    Sent?: boolean
    Machine?: string
    SessionId?: number
    ETT?: string
  }

  export type trackappdetailtbUncheckedCreateInput = {
    TrackAppDetailId?: number
    AppName: string
    UserName: string
    TrackingDate: Date | string
    TrackingTime: Date | string
    TimeTotal: number
    AppSession?: boolean
    Sent?: boolean
    Machine?: string
    SessionId?: number
    ETT?: string
  }

  export type trackappdetailtbUpdateInput = {
    AppName?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    TrackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TrackingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeTotal?: IntFieldUpdateOperationsInput | number
    AppSession?: BoolFieldUpdateOperationsInput | boolean
    Sent?: BoolFieldUpdateOperationsInput | boolean
    Machine?: StringFieldUpdateOperationsInput | string
    SessionId?: IntFieldUpdateOperationsInput | number
    ETT?: StringFieldUpdateOperationsInput | string
  }

  export type trackappdetailtbUncheckedUpdateInput = {
    TrackAppDetailId?: IntFieldUpdateOperationsInput | number
    AppName?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    TrackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TrackingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeTotal?: IntFieldUpdateOperationsInput | number
    AppSession?: BoolFieldUpdateOperationsInput | boolean
    Sent?: BoolFieldUpdateOperationsInput | boolean
    Machine?: StringFieldUpdateOperationsInput | string
    SessionId?: IntFieldUpdateOperationsInput | number
    ETT?: StringFieldUpdateOperationsInput | string
  }

  export type trackappdetailtbCreateManyInput = {
    TrackAppDetailId?: number
    AppName: string
    UserName: string
    TrackingDate: Date | string
    TrackingTime: Date | string
    TimeTotal: number
    AppSession?: boolean
    Sent?: boolean
    Machine?: string
    SessionId?: number
    ETT?: string
  }

  export type trackappdetailtbUpdateManyMutationInput = {
    AppName?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    TrackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TrackingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeTotal?: IntFieldUpdateOperationsInput | number
    AppSession?: BoolFieldUpdateOperationsInput | boolean
    Sent?: BoolFieldUpdateOperationsInput | boolean
    Machine?: StringFieldUpdateOperationsInput | string
    SessionId?: IntFieldUpdateOperationsInput | number
    ETT?: StringFieldUpdateOperationsInput | string
  }

  export type trackappdetailtbUncheckedUpdateManyInput = {
    TrackAppDetailId?: IntFieldUpdateOperationsInput | number
    AppName?: StringFieldUpdateOperationsInput | string
    UserName?: StringFieldUpdateOperationsInput | string
    TrackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TrackingTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeTotal?: IntFieldUpdateOperationsInput | number
    AppSession?: BoolFieldUpdateOperationsInput | boolean
    Sent?: BoolFieldUpdateOperationsInput | boolean
    Machine?: StringFieldUpdateOperationsInput | string
    SessionId?: IntFieldUpdateOperationsInput | number
    ETT?: StringFieldUpdateOperationsInput | string
  }

  export type trackapptbCreateInput = {
    AppName: string
    TrackingType: number
  }

  export type trackapptbUncheckedCreateInput = {
    AppName: string
    TrackingType: number
  }

  export type trackapptbUpdateInput = {
    AppName?: StringFieldUpdateOperationsInput | string
    TrackingType?: IntFieldUpdateOperationsInput | number
  }

  export type trackapptbUncheckedUpdateInput = {
    AppName?: StringFieldUpdateOperationsInput | string
    TrackingType?: IntFieldUpdateOperationsInput | number
  }

  export type trackapptbCreateManyInput = {
    AppName: string
    TrackingType: number
  }

  export type trackapptbUpdateManyMutationInput = {
    AppName?: StringFieldUpdateOperationsInput | string
    TrackingType?: IntFieldUpdateOperationsInput | number
  }

  export type trackapptbUncheckedUpdateManyInput = {
    AppName?: StringFieldUpdateOperationsInput | string
    TrackingType?: IntFieldUpdateOperationsInput | number
  }

  export type trackguitbCreateInput = {
    RecordDate: Date | string
    FromTime: Date | string
    ToTime: Date | string
    DialogID: number
    PrePath?: string | null
    ControlID: number
    Type: number
    Param?: string | null
    ActionCount: number
  }

  export type trackguitbUncheckedCreateInput = {
    ID?: number
    RecordDate: Date | string
    FromTime: Date | string
    ToTime: Date | string
    DialogID: number
    PrePath?: string | null
    ControlID: number
    Type: number
    Param?: string | null
    ActionCount: number
  }

  export type trackguitbUpdateInput = {
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ToTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DialogID?: IntFieldUpdateOperationsInput | number
    PrePath?: NullableStringFieldUpdateOperationsInput | string | null
    ControlID?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    Param?: NullableStringFieldUpdateOperationsInput | string | null
    ActionCount?: IntFieldUpdateOperationsInput | number
  }

  export type trackguitbUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ToTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DialogID?: IntFieldUpdateOperationsInput | number
    PrePath?: NullableStringFieldUpdateOperationsInput | string | null
    ControlID?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    Param?: NullableStringFieldUpdateOperationsInput | string | null
    ActionCount?: IntFieldUpdateOperationsInput | number
  }

  export type trackguitbCreateManyInput = {
    ID?: number
    RecordDate: Date | string
    FromTime: Date | string
    ToTime: Date | string
    DialogID: number
    PrePath?: string | null
    ControlID: number
    Type: number
    Param?: string | null
    ActionCount: number
  }

  export type trackguitbUpdateManyMutationInput = {
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ToTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DialogID?: IntFieldUpdateOperationsInput | number
    PrePath?: NullableStringFieldUpdateOperationsInput | string | null
    ControlID?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    Param?: NullableStringFieldUpdateOperationsInput | string | null
    ActionCount?: IntFieldUpdateOperationsInput | number
  }

  export type trackguitbUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FromTime?: DateTimeFieldUpdateOperationsInput | Date | string
    ToTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DialogID?: IntFieldUpdateOperationsInput | number
    PrePath?: NullableStringFieldUpdateOperationsInput | string | null
    ControlID?: IntFieldUpdateOperationsInput | number
    Type?: IntFieldUpdateOperationsInput | number
    Param?: NullableStringFieldUpdateOperationsInput | string | null
    ActionCount?: IntFieldUpdateOperationsInput | number
  }

  export type transferdetailtbCreateInput = {
    VoucherId: number
    FromUserId: number
    ToUserId: number
    TransferDate: Date | string
    TransferTime: Date | string
  }

  export type transferdetailtbUncheckedCreateInput = {
    TransferDetailId?: number
    VoucherId: number
    FromUserId: number
    ToUserId: number
    TransferDate: Date | string
    TransferTime: Date | string
  }

  export type transferdetailtbUpdateInput = {
    VoucherId?: IntFieldUpdateOperationsInput | number
    FromUserId?: IntFieldUpdateOperationsInput | number
    ToUserId?: IntFieldUpdateOperationsInput | number
    TransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TransferTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transferdetailtbUncheckedUpdateInput = {
    TransferDetailId?: IntFieldUpdateOperationsInput | number
    VoucherId?: IntFieldUpdateOperationsInput | number
    FromUserId?: IntFieldUpdateOperationsInput | number
    ToUserId?: IntFieldUpdateOperationsInput | number
    TransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TransferTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transferdetailtbCreateManyInput = {
    TransferDetailId?: number
    VoucherId: number
    FromUserId: number
    ToUserId: number
    TransferDate: Date | string
    TransferTime: Date | string
  }

  export type transferdetailtbUpdateManyMutationInput = {
    VoucherId?: IntFieldUpdateOperationsInput | number
    FromUserId?: IntFieldUpdateOperationsInput | number
    ToUserId?: IntFieldUpdateOperationsInput | number
    TransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TransferTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transferdetailtbUncheckedUpdateManyInput = {
    TransferDetailId?: IntFieldUpdateOperationsInput | number
    VoucherId?: IntFieldUpdateOperationsInput | number
    FromUserId?: IntFieldUpdateOperationsInput | number
    ToUserId?: IntFieldUpdateOperationsInput | number
    TransferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    TransferTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usagetimetbCreateInput = {
    UsageTimeName?: string | null
    FromAge?: number | null
    ToAge?: number | null
    UserType?: number
  }

  export type usagetimetbUncheckedCreateInput = {
    UsageTimeId?: number
    UsageTimeName?: string | null
    FromAge?: number | null
    ToAge?: number | null
    UserType?: number
  }

  export type usagetimetbUpdateInput = {
    UsageTimeName?: NullableStringFieldUpdateOperationsInput | string | null
    FromAge?: NullableIntFieldUpdateOperationsInput | number | null
    ToAge?: NullableIntFieldUpdateOperationsInput | number | null
    UserType?: IntFieldUpdateOperationsInput | number
  }

  export type usagetimetbUncheckedUpdateInput = {
    UsageTimeId?: IntFieldUpdateOperationsInput | number
    UsageTimeName?: NullableStringFieldUpdateOperationsInput | string | null
    FromAge?: NullableIntFieldUpdateOperationsInput | number | null
    ToAge?: NullableIntFieldUpdateOperationsInput | number | null
    UserType?: IntFieldUpdateOperationsInput | number
  }

  export type usagetimetbCreateManyInput = {
    UsageTimeId?: number
    UsageTimeName?: string | null
    FromAge?: number | null
    ToAge?: number | null
    UserType?: number
  }

  export type usagetimetbUpdateManyMutationInput = {
    UsageTimeName?: NullableStringFieldUpdateOperationsInput | string | null
    FromAge?: NullableIntFieldUpdateOperationsInput | number | null
    ToAge?: NullableIntFieldUpdateOperationsInput | number | null
    UserType?: IntFieldUpdateOperationsInput | number
  }

  export type usagetimetbUncheckedUpdateManyInput = {
    UsageTimeId?: IntFieldUpdateOperationsInput | number
    UsageTimeName?: NullableStringFieldUpdateOperationsInput | string | null
    FromAge?: NullableIntFieldUpdateOperationsInput | number | null
    ToAge?: NullableIntFieldUpdateOperationsInput | number | null
    UserType?: IntFieldUpdateOperationsInput | number
  }

  export type usertbCreateInput = {
    FirstName?: string | null
    LastName?: string | null
    MiddleName?: string | null
    UserName: string
    Password: string
    ID: string
    Address: string
    Phone: string
    Email: string
    City: string
    State: string
    Zipcode: string
    Debit: Decimal | DecimalJsLike | number | string
    CreditLimit: Decimal | DecimalJsLike | number | string
    Active: boolean
    RecordDate: Date | string
    ExpiryDate?: Date | string | null
    UserType: number
    Memo: string
    Birthdate?: Date | string | null
    SSN1: string
    SSN2: string
    SSN3: string
    TimePaid: number
    TimeUsed: number
    MoneyPaid?: number
    MoneyUsed?: number
    RemainTime: number
    FreeTime: number
    TimeTransfer: number
    RemainMoney?: number
    FreeMoney?: number
    MoneyTransfer?: number
    UsageTimeId: number
    PromotionTime: number
    PromotionMoney?: number
    MachineGroupId?: number
    MAC?: string
    changepcdetailId?: number
    MoneyUsedMin?: number
    CType?: number | null
    Status?: number | null
    LastLoginDate?: Date | string
    PriceAppRentID?: number
    EIType?: number | null
    pc_rptInfo?: string | null
  }

  export type usertbUncheckedCreateInput = {
    UserId?: number
    FirstName?: string | null
    LastName?: string | null
    MiddleName?: string | null
    UserName: string
    Password: string
    ID: string
    Address: string
    Phone: string
    Email: string
    City: string
    State: string
    Zipcode: string
    Debit: Decimal | DecimalJsLike | number | string
    CreditLimit: Decimal | DecimalJsLike | number | string
    Active: boolean
    RecordDate: Date | string
    ExpiryDate?: Date | string | null
    UserType: number
    Memo: string
    Birthdate?: Date | string | null
    SSN1: string
    SSN2: string
    SSN3: string
    TimePaid: number
    TimeUsed: number
    MoneyPaid?: number
    MoneyUsed?: number
    RemainTime: number
    FreeTime: number
    TimeTransfer: number
    RemainMoney?: number
    FreeMoney?: number
    MoneyTransfer?: number
    UsageTimeId: number
    PromotionTime: number
    PromotionMoney?: number
    MachineGroupId?: number
    MAC?: string
    changepcdetailId?: number
    MoneyUsedMin?: number
    CType?: number | null
    Status?: number | null
    LastLoginDate?: Date | string
    PriceAppRentID?: number
    EIType?: number | null
    pc_rptInfo?: string | null
  }

  export type usertbUpdateInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zipcode?: StringFieldUpdateOperationsInput | string
    Debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserType?: IntFieldUpdateOperationsInput | number
    Memo?: StringFieldUpdateOperationsInput | string
    Birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SSN1?: StringFieldUpdateOperationsInput | string
    SSN2?: StringFieldUpdateOperationsInput | string
    SSN3?: StringFieldUpdateOperationsInput | string
    TimePaid?: IntFieldUpdateOperationsInput | number
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyPaid?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    RemainTime?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    TimeTransfer?: IntFieldUpdateOperationsInput | number
    RemainMoney?: IntFieldUpdateOperationsInput | number
    FreeMoney?: IntFieldUpdateOperationsInput | number
    MoneyTransfer?: IntFieldUpdateOperationsInput | number
    UsageTimeId?: IntFieldUpdateOperationsInput | number
    PromotionTime?: IntFieldUpdateOperationsInput | number
    PromotionMoney?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    MAC?: StringFieldUpdateOperationsInput | string
    changepcdetailId?: IntFieldUpdateOperationsInput | number
    MoneyUsedMin?: IntFieldUpdateOperationsInput | number
    CType?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    LastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    EIType?: NullableIntFieldUpdateOperationsInput | number | null
    pc_rptInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usertbUncheckedUpdateInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zipcode?: StringFieldUpdateOperationsInput | string
    Debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserType?: IntFieldUpdateOperationsInput | number
    Memo?: StringFieldUpdateOperationsInput | string
    Birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SSN1?: StringFieldUpdateOperationsInput | string
    SSN2?: StringFieldUpdateOperationsInput | string
    SSN3?: StringFieldUpdateOperationsInput | string
    TimePaid?: IntFieldUpdateOperationsInput | number
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyPaid?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    RemainTime?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    TimeTransfer?: IntFieldUpdateOperationsInput | number
    RemainMoney?: IntFieldUpdateOperationsInput | number
    FreeMoney?: IntFieldUpdateOperationsInput | number
    MoneyTransfer?: IntFieldUpdateOperationsInput | number
    UsageTimeId?: IntFieldUpdateOperationsInput | number
    PromotionTime?: IntFieldUpdateOperationsInput | number
    PromotionMoney?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    MAC?: StringFieldUpdateOperationsInput | string
    changepcdetailId?: IntFieldUpdateOperationsInput | number
    MoneyUsedMin?: IntFieldUpdateOperationsInput | number
    CType?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    LastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    EIType?: NullableIntFieldUpdateOperationsInput | number | null
    pc_rptInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usertbCreateManyInput = {
    UserId?: number
    FirstName?: string | null
    LastName?: string | null
    MiddleName?: string | null
    UserName: string
    Password: string
    ID: string
    Address: string
    Phone: string
    Email: string
    City: string
    State: string
    Zipcode: string
    Debit: Decimal | DecimalJsLike | number | string
    CreditLimit: Decimal | DecimalJsLike | number | string
    Active: boolean
    RecordDate: Date | string
    ExpiryDate?: Date | string | null
    UserType: number
    Memo: string
    Birthdate?: Date | string | null
    SSN1: string
    SSN2: string
    SSN3: string
    TimePaid: number
    TimeUsed: number
    MoneyPaid?: number
    MoneyUsed?: number
    RemainTime: number
    FreeTime: number
    TimeTransfer: number
    RemainMoney?: number
    FreeMoney?: number
    MoneyTransfer?: number
    UsageTimeId: number
    PromotionTime: number
    PromotionMoney?: number
    MachineGroupId?: number
    MAC?: string
    changepcdetailId?: number
    MoneyUsedMin?: number
    CType?: number | null
    Status?: number | null
    LastLoginDate?: Date | string
    PriceAppRentID?: number
    EIType?: number | null
    pc_rptInfo?: string | null
  }

  export type usertbUpdateManyMutationInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zipcode?: StringFieldUpdateOperationsInput | string
    Debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserType?: IntFieldUpdateOperationsInput | number
    Memo?: StringFieldUpdateOperationsInput | string
    Birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SSN1?: StringFieldUpdateOperationsInput | string
    SSN2?: StringFieldUpdateOperationsInput | string
    SSN3?: StringFieldUpdateOperationsInput | string
    TimePaid?: IntFieldUpdateOperationsInput | number
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyPaid?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    RemainTime?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    TimeTransfer?: IntFieldUpdateOperationsInput | number
    RemainMoney?: IntFieldUpdateOperationsInput | number
    FreeMoney?: IntFieldUpdateOperationsInput | number
    MoneyTransfer?: IntFieldUpdateOperationsInput | number
    UsageTimeId?: IntFieldUpdateOperationsInput | number
    PromotionTime?: IntFieldUpdateOperationsInput | number
    PromotionMoney?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    MAC?: StringFieldUpdateOperationsInput | string
    changepcdetailId?: IntFieldUpdateOperationsInput | number
    MoneyUsedMin?: IntFieldUpdateOperationsInput | number
    CType?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    LastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    EIType?: NullableIntFieldUpdateOperationsInput | number | null
    pc_rptInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usertbUncheckedUpdateManyInput = {
    UserId?: IntFieldUpdateOperationsInput | number
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MiddleName?: NullableStringFieldUpdateOperationsInput | string | null
    UserName?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
    Address?: StringFieldUpdateOperationsInput | string
    Phone?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    City?: StringFieldUpdateOperationsInput | string
    State?: StringFieldUpdateOperationsInput | string
    Zipcode?: StringFieldUpdateOperationsInput | string
    Debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreditLimit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    Active?: BoolFieldUpdateOperationsInput | boolean
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    ExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserType?: IntFieldUpdateOperationsInput | number
    Memo?: StringFieldUpdateOperationsInput | string
    Birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    SSN1?: StringFieldUpdateOperationsInput | string
    SSN2?: StringFieldUpdateOperationsInput | string
    SSN3?: StringFieldUpdateOperationsInput | string
    TimePaid?: IntFieldUpdateOperationsInput | number
    TimeUsed?: IntFieldUpdateOperationsInput | number
    MoneyPaid?: IntFieldUpdateOperationsInput | number
    MoneyUsed?: IntFieldUpdateOperationsInput | number
    RemainTime?: IntFieldUpdateOperationsInput | number
    FreeTime?: IntFieldUpdateOperationsInput | number
    TimeTransfer?: IntFieldUpdateOperationsInput | number
    RemainMoney?: IntFieldUpdateOperationsInput | number
    FreeMoney?: IntFieldUpdateOperationsInput | number
    MoneyTransfer?: IntFieldUpdateOperationsInput | number
    UsageTimeId?: IntFieldUpdateOperationsInput | number
    PromotionTime?: IntFieldUpdateOperationsInput | number
    PromotionMoney?: IntFieldUpdateOperationsInput | number
    MachineGroupId?: IntFieldUpdateOperationsInput | number
    MAC?: StringFieldUpdateOperationsInput | string
    changepcdetailId?: IntFieldUpdateOperationsInput | number
    MoneyUsedMin?: IntFieldUpdateOperationsInput | number
    CType?: NullableIntFieldUpdateOperationsInput | number | null
    Status?: NullableIntFieldUpdateOperationsInput | number | null
    LastLoginDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PriceAppRentID?: IntFieldUpdateOperationsInput | number
    EIType?: NullableIntFieldUpdateOperationsInput | number | null
    pc_rptInfo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type versiontbCreateInput = {
    ComputerName: string
    Version: string
    Type: number
    ReleaseDate?: Date | string
    LastUpdate?: Date | string
    DPStatus?: number | null
    DPType?: number | null
    DPVersion?: string
  }

  export type versiontbUncheckedCreateInput = {
    ComputerName: string
    Version: string
    Type: number
    ReleaseDate?: Date | string
    LastUpdate?: Date | string
    DPStatus?: number | null
    DPType?: number | null
    DPVersion?: string
  }

  export type versiontbUpdateInput = {
    ComputerName?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    ReleaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    DPStatus?: NullableIntFieldUpdateOperationsInput | number | null
    DPType?: NullableIntFieldUpdateOperationsInput | number | null
    DPVersion?: StringFieldUpdateOperationsInput | string
  }

  export type versiontbUncheckedUpdateInput = {
    ComputerName?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    ReleaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    DPStatus?: NullableIntFieldUpdateOperationsInput | number | null
    DPType?: NullableIntFieldUpdateOperationsInput | number | null
    DPVersion?: StringFieldUpdateOperationsInput | string
  }

  export type versiontbCreateManyInput = {
    ComputerName: string
    Version: string
    Type: number
    ReleaseDate?: Date | string
    LastUpdate?: Date | string
    DPStatus?: number | null
    DPType?: number | null
    DPVersion?: string
  }

  export type versiontbUpdateManyMutationInput = {
    ComputerName?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    ReleaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    DPStatus?: NullableIntFieldUpdateOperationsInput | number | null
    DPType?: NullableIntFieldUpdateOperationsInput | number | null
    DPVersion?: StringFieldUpdateOperationsInput | string
  }

  export type versiontbUncheckedUpdateManyInput = {
    ComputerName?: StringFieldUpdateOperationsInput | string
    Version?: StringFieldUpdateOperationsInput | string
    Type?: IntFieldUpdateOperationsInput | number
    ReleaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    LastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    DPStatus?: NullableIntFieldUpdateOperationsInput | number | null
    DPType?: NullableIntFieldUpdateOperationsInput | number | null
    DPVersion?: StringFieldUpdateOperationsInput | string
  }

  export type wallettbCreateInput = {
    id?: bigint | number
    main?: bigint | number | null
    sub?: bigint | number | null
    sub1?: bigint | number | null
    sub2?: bigint | number | null
    userid?: bigint | number | null
    status?: number | null
    ts?: bigint | number | null
    wsec?: bigint | number | null
    ssec?: string | null
  }

  export type wallettbUncheckedCreateInput = {
    id?: bigint | number
    main?: bigint | number | null
    sub?: bigint | number | null
    sub1?: bigint | number | null
    sub2?: bigint | number | null
    userid?: bigint | number | null
    status?: number | null
    ts?: bigint | number | null
    wsec?: bigint | number | null
    ssec?: string | null
  }

  export type wallettbUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ts?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    wsec?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ssec?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wallettbUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ts?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    wsec?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ssec?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wallettbCreateManyInput = {
    id?: bigint | number
    main?: bigint | number | null
    sub?: bigint | number | null
    sub1?: bigint | number | null
    sub2?: bigint | number | null
    userid?: bigint | number | null
    status?: number | null
    ts?: bigint | number | null
    wsec?: bigint | number | null
    ssec?: string | null
  }

  export type wallettbUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ts?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    wsec?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ssec?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type wallettbUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    main?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub1?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    sub2?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    userid?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    ts?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    wsec?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ssec?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type webhistorytbCreateInput = {
    URL: string
    RecordDate: Date | string
    UserId: number
    Machine: string
    Active?: number
    Session?: number
    AnonymousId?: number
    BrowserType?: boolean
  }

  export type webhistorytbUncheckedCreateInput = {
    URLId?: number
    URL: string
    RecordDate: Date | string
    UserId: number
    Machine: string
    Active?: number
    Session?: number
    AnonymousId?: number
    BrowserType?: boolean
  }

  export type webhistorytbUpdateInput = {
    URL?: StringFieldUpdateOperationsInput | string
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
    Machine?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    Session?: IntFieldUpdateOperationsInput | number
    AnonymousId?: IntFieldUpdateOperationsInput | number
    BrowserType?: BoolFieldUpdateOperationsInput | boolean
  }

  export type webhistorytbUncheckedUpdateInput = {
    URLId?: IntFieldUpdateOperationsInput | number
    URL?: StringFieldUpdateOperationsInput | string
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
    Machine?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    Session?: IntFieldUpdateOperationsInput | number
    AnonymousId?: IntFieldUpdateOperationsInput | number
    BrowserType?: BoolFieldUpdateOperationsInput | boolean
  }

  export type webhistorytbCreateManyInput = {
    URLId?: number
    URL: string
    RecordDate: Date | string
    UserId: number
    Machine: string
    Active?: number
    Session?: number
    AnonymousId?: number
    BrowserType?: boolean
  }

  export type webhistorytbUpdateManyMutationInput = {
    URL?: StringFieldUpdateOperationsInput | string
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
    Machine?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    Session?: IntFieldUpdateOperationsInput | number
    AnonymousId?: IntFieldUpdateOperationsInput | number
    BrowserType?: BoolFieldUpdateOperationsInput | boolean
  }

  export type webhistorytbUncheckedUpdateManyInput = {
    URLId?: IntFieldUpdateOperationsInput | number
    URL?: StringFieldUpdateOperationsInput | string
    RecordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UserId?: IntFieldUpdateOperationsInput | number
    Machine?: StringFieldUpdateOperationsInput | string
    Active?: IntFieldUpdateOperationsInput | number
    Session?: IntFieldUpdateOperationsInput | number
    AnonymousId?: IntFieldUpdateOperationsInput | number
    BrowserType?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type accountingentrytbCountOrderByAggregateInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    NumBalance?: SortOrder
    ImportQuantity?: SortOrder
    ImportTotalAmount?: SortOrder
    SaleQuantity?: SortOrder
    SaleTotalAmount?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    Note?: SortOrder
    ServiceID?: SortOrder
  }

  export type accountingentrytbAvgOrderByAggregateInput = {
    ID?: SortOrder
    StaffID?: SortOrder
    NumBalance?: SortOrder
    ImportQuantity?: SortOrder
    ImportTotalAmount?: SortOrder
    SaleQuantity?: SortOrder
    SaleTotalAmount?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    ServiceID?: SortOrder
  }

  export type accountingentrytbMaxOrderByAggregateInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    NumBalance?: SortOrder
    ImportQuantity?: SortOrder
    ImportTotalAmount?: SortOrder
    SaleQuantity?: SortOrder
    SaleTotalAmount?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    Note?: SortOrder
    ServiceID?: SortOrder
  }

  export type accountingentrytbMinOrderByAggregateInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    NumBalance?: SortOrder
    ImportQuantity?: SortOrder
    ImportTotalAmount?: SortOrder
    SaleQuantity?: SortOrder
    SaleTotalAmount?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    Note?: SortOrder
    ServiceID?: SortOrder
  }

  export type accountingentrytbSumOrderByAggregateInput = {
    ID?: SortOrder
    StaffID?: SortOrder
    NumBalance?: SortOrder
    ImportQuantity?: SortOrder
    ImportTotalAmount?: SortOrder
    SaleQuantity?: SortOrder
    SaleTotalAmount?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    ServiceID?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type anonymoustbCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    IDCard?: SortOrder
    Address?: SortOrder
    MachineID?: SortOrder
    Session?: SortOrder
    RecordDate?: SortOrder
  }

  export type anonymoustbAvgOrderByAggregateInput = {
    ID?: SortOrder
    MachineID?: SortOrder
    Session?: SortOrder
  }

  export type anonymoustbMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    IDCard?: SortOrder
    Address?: SortOrder
    MachineID?: SortOrder
    Session?: SortOrder
    RecordDate?: SortOrder
  }

  export type anonymoustbMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    IDCard?: SortOrder
    Address?: SortOrder
    MachineID?: SortOrder
    Session?: SortOrder
    RecordDate?: SortOrder
  }

  export type anonymoustbSumOrderByAggregateInput = {
    ID?: SortOrder
    MachineID?: SortOrder
    Session?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type applicationrenttbCountOrderByAggregateInput = {
    ApplicationRentID?: SortOrder
    Name?: SortOrder
    Hash?: SortOrder
    AddBy?: SortOrder
    Status?: SortOrder
  }

  export type applicationrenttbAvgOrderByAggregateInput = {
    ApplicationRentID?: SortOrder
    AddBy?: SortOrder
    Status?: SortOrder
  }

  export type applicationrenttbMaxOrderByAggregateInput = {
    ApplicationRentID?: SortOrder
    Name?: SortOrder
    Hash?: SortOrder
    AddBy?: SortOrder
    Status?: SortOrder
  }

  export type applicationrenttbMinOrderByAggregateInput = {
    ApplicationRentID?: SortOrder
    Name?: SortOrder
    Hash?: SortOrder
    AddBy?: SortOrder
    Status?: SortOrder
  }

  export type applicationrenttbSumOrderByAggregateInput = {
    ApplicationRentID?: SortOrder
    AddBy?: SortOrder
    Status?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type applicationtbCountOrderByAggregateInput = {
    ApplicationId?: SortOrder
    ApplicationName?: SortOrder
    Description?: SortOrder
    RestrictType?: SortOrder
    Hash?: SortOrder
    AppType?: SortOrder
    AddedBy?: SortOrder
  }

  export type applicationtbAvgOrderByAggregateInput = {
    ApplicationId?: SortOrder
    RestrictType?: SortOrder
    AppType?: SortOrder
    AddedBy?: SortOrder
  }

  export type applicationtbMaxOrderByAggregateInput = {
    ApplicationId?: SortOrder
    ApplicationName?: SortOrder
    Description?: SortOrder
    RestrictType?: SortOrder
    Hash?: SortOrder
    AppType?: SortOrder
    AddedBy?: SortOrder
  }

  export type applicationtbMinOrderByAggregateInput = {
    ApplicationId?: SortOrder
    ApplicationName?: SortOrder
    Description?: SortOrder
    RestrictType?: SortOrder
    Hash?: SortOrder
    AppType?: SortOrder
    AddedBy?: SortOrder
  }

  export type applicationtbSumOrderByAggregateInput = {
    ApplicationId?: SortOrder
    RestrictType?: SortOrder
    AppType?: SortOrder
    AddedBy?: SortOrder
  }

  export type blacklisttbCountOrderByAggregateInput = {
    URLId?: SortOrder
    URL?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    RecordDate?: SortOrder
    Active?: SortOrder
    AddedBy?: SortOrder
  }

  export type blacklisttbAvgOrderByAggregateInput = {
    URLId?: SortOrder
    Active?: SortOrder
    AddedBy?: SortOrder
  }

  export type blacklisttbMaxOrderByAggregateInput = {
    URLId?: SortOrder
    URL?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    RecordDate?: SortOrder
    Active?: SortOrder
    AddedBy?: SortOrder
  }

  export type blacklisttbMinOrderByAggregateInput = {
    URLId?: SortOrder
    URL?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    RecordDate?: SortOrder
    Active?: SortOrder
    AddedBy?: SortOrder
  }

  export type blacklisttbSumOrderByAggregateInput = {
    URLId?: SortOrder
    Active?: SortOrder
    AddedBy?: SortOrder
  }

  export type changepcdetailtbCountOrderByAggregateInput = {
    ChangePCDetailId?: SortOrder
    VoucherId?: SortOrder
    FromMachineId?: SortOrder
    ToMachineId?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    SessionId?: SortOrder
    ChangePCDate?: SortOrder
    ChangePCTime?: SortOrder
    BeginDateTime?: SortOrder
    LogNote?: SortOrder
    MachineName?: SortOrder
    LogType?: SortOrder
  }

  export type changepcdetailtbAvgOrderByAggregateInput = {
    ChangePCDetailId?: SortOrder
    VoucherId?: SortOrder
    FromMachineId?: SortOrder
    ToMachineId?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    SessionId?: SortOrder
    LogType?: SortOrder
  }

  export type changepcdetailtbMaxOrderByAggregateInput = {
    ChangePCDetailId?: SortOrder
    VoucherId?: SortOrder
    FromMachineId?: SortOrder
    ToMachineId?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    SessionId?: SortOrder
    ChangePCDate?: SortOrder
    ChangePCTime?: SortOrder
    BeginDateTime?: SortOrder
    LogNote?: SortOrder
    MachineName?: SortOrder
    LogType?: SortOrder
  }

  export type changepcdetailtbMinOrderByAggregateInput = {
    ChangePCDetailId?: SortOrder
    VoucherId?: SortOrder
    FromMachineId?: SortOrder
    ToMachineId?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    SessionId?: SortOrder
    ChangePCDate?: SortOrder
    ChangePCTime?: SortOrder
    BeginDateTime?: SortOrder
    LogNote?: SortOrder
    MachineName?: SortOrder
    LogType?: SortOrder
  }

  export type changepcdetailtbSumOrderByAggregateInput = {
    ChangePCDetailId?: SortOrder
    VoucherId?: SortOrder
    FromMachineId?: SortOrder
    ToMachineId?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    SessionId?: SortOrder
    LogType?: SortOrder
  }

  export type clientatbCountOrderByAggregateInput = {
    ID?: SortOrder
    PubID?: SortOrder
    AID?: SortOrder
    DateA?: SortOrder
    STime?: SortOrder
    ETime?: SortOrder
    FName?: SortOrder
    FLink?: SortOrder
    Area?: SortOrder
    Panel?: SortOrder
    Row?: SortOrder
    Col?: SortOrder
    Method?: SortOrder
    CountS?: SortOrder
    CountC?: SortOrder
    RecordDate?: SortOrder
  }

  export type clientatbAvgOrderByAggregateInput = {
    ID?: SortOrder
    PubID?: SortOrder
    AID?: SortOrder
    STime?: SortOrder
    ETime?: SortOrder
    Panel?: SortOrder
    Row?: SortOrder
    Col?: SortOrder
    CountS?: SortOrder
    CountC?: SortOrder
  }

  export type clientatbMaxOrderByAggregateInput = {
    ID?: SortOrder
    PubID?: SortOrder
    AID?: SortOrder
    DateA?: SortOrder
    STime?: SortOrder
    ETime?: SortOrder
    FName?: SortOrder
    FLink?: SortOrder
    Area?: SortOrder
    Panel?: SortOrder
    Row?: SortOrder
    Col?: SortOrder
    Method?: SortOrder
    CountS?: SortOrder
    CountC?: SortOrder
    RecordDate?: SortOrder
  }

  export type clientatbMinOrderByAggregateInput = {
    ID?: SortOrder
    PubID?: SortOrder
    AID?: SortOrder
    DateA?: SortOrder
    STime?: SortOrder
    ETime?: SortOrder
    FName?: SortOrder
    FLink?: SortOrder
    Area?: SortOrder
    Panel?: SortOrder
    Row?: SortOrder
    Col?: SortOrder
    Method?: SortOrder
    CountS?: SortOrder
    CountC?: SortOrder
    RecordDate?: SortOrder
  }

  export type clientatbSumOrderByAggregateInput = {
    ID?: SortOrder
    PubID?: SortOrder
    AID?: SortOrder
    STime?: SortOrder
    ETime?: SortOrder
    Panel?: SortOrder
    Row?: SortOrder
    Col?: SortOrder
    CountS?: SortOrder
    CountC?: SortOrder
  }

  export type clientsystbCountOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    MAC?: SortOrder
    CPU?: SortOrder
    RAM?: SortOrder
    HD?: SortOrder
    OS?: SortOrder
    CardName?: SortOrder
    ChipType?: SortOrder
    VGAMem?: SortOrder
    NIC?: SortOrder
    FreeSpace?: SortOrder
    CPName?: SortOrder
    Active?: SortOrder
    NTFS?: SortOrder
    FAT?: SortOrder
    Mainboard?: SortOrder
    IP?: SortOrder
    LAN?: SortOrder
    RamFree?: SortOrder
    PageFile?: SortOrder
    TempCPU?: SortOrder
    LoadCPU?: SortOrder
    TempGPU?: SortOrder
    LoadGPU?: SortOrder
    LastUpdate?: SortOrder
    PCName?: SortOrder
    NetInfo?: SortOrder
  }

  export type clientsystbAvgOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    Active?: SortOrder
  }

  export type clientsystbMaxOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    MAC?: SortOrder
    CPU?: SortOrder
    RAM?: SortOrder
    HD?: SortOrder
    OS?: SortOrder
    CardName?: SortOrder
    ChipType?: SortOrder
    VGAMem?: SortOrder
    NIC?: SortOrder
    FreeSpace?: SortOrder
    CPName?: SortOrder
    Active?: SortOrder
    NTFS?: SortOrder
    FAT?: SortOrder
    Mainboard?: SortOrder
    IP?: SortOrder
    LAN?: SortOrder
    RamFree?: SortOrder
    PageFile?: SortOrder
    TempCPU?: SortOrder
    LoadCPU?: SortOrder
    TempGPU?: SortOrder
    LoadGPU?: SortOrder
    LastUpdate?: SortOrder
    PCName?: SortOrder
    NetInfo?: SortOrder
  }

  export type clientsystbMinOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    MAC?: SortOrder
    CPU?: SortOrder
    RAM?: SortOrder
    HD?: SortOrder
    OS?: SortOrder
    CardName?: SortOrder
    ChipType?: SortOrder
    VGAMem?: SortOrder
    NIC?: SortOrder
    FreeSpace?: SortOrder
    CPName?: SortOrder
    Active?: SortOrder
    NTFS?: SortOrder
    FAT?: SortOrder
    Mainboard?: SortOrder
    IP?: SortOrder
    LAN?: SortOrder
    RamFree?: SortOrder
    PageFile?: SortOrder
    TempCPU?: SortOrder
    LoadCPU?: SortOrder
    TempGPU?: SortOrder
    LoadGPU?: SortOrder
    LastUpdate?: SortOrder
    PCName?: SortOrder
    NetInfo?: SortOrder
  }

  export type clientsystbSumOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    Active?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type combodetailtbCountOrderByAggregateInput = {
    ComboDetailID?: SortOrder
    UserID?: SortOrder
    ComboID?: SortOrder
    VoucherID?: SortOrder
    Accept?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    ToDate?: SortOrder
    ToTime?: SortOrder
    Zone?: SortOrder
    LoginTime?: SortOrder
    Ownerid?: SortOrder
  }

  export type combodetailtbAvgOrderByAggregateInput = {
    ComboDetailID?: SortOrder
    UserID?: SortOrder
    ComboID?: SortOrder
    VoucherID?: SortOrder
    Accept?: SortOrder
    Ownerid?: SortOrder
  }

  export type combodetailtbMaxOrderByAggregateInput = {
    ComboDetailID?: SortOrder
    UserID?: SortOrder
    ComboID?: SortOrder
    VoucherID?: SortOrder
    Accept?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    ToDate?: SortOrder
    ToTime?: SortOrder
    Zone?: SortOrder
    LoginTime?: SortOrder
    Ownerid?: SortOrder
  }

  export type combodetailtbMinOrderByAggregateInput = {
    ComboDetailID?: SortOrder
    UserID?: SortOrder
    ComboID?: SortOrder
    VoucherID?: SortOrder
    Accept?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    FromDate?: SortOrder
    FromTime?: SortOrder
    ToDate?: SortOrder
    ToTime?: SortOrder
    Zone?: SortOrder
    LoginTime?: SortOrder
    Ownerid?: SortOrder
  }

  export type combodetailtbSumOrderByAggregateInput = {
    ComboDetailID?: SortOrder
    UserID?: SortOrder
    ComboID?: SortOrder
    VoucherID?: SortOrder
    Accept?: SortOrder
    Ownerid?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type combodonatetbCountOrderByAggregateInput = {
    ComboDonateID?: SortOrder
    ComboID?: SortOrder
    ServiceID?: SortOrder
    Quantity?: SortOrder
  }

  export type combodonatetbAvgOrderByAggregateInput = {
    ComboDonateID?: SortOrder
    ComboID?: SortOrder
    ServiceID?: SortOrder
    Quantity?: SortOrder
  }

  export type combodonatetbMaxOrderByAggregateInput = {
    ComboDonateID?: SortOrder
    ComboID?: SortOrder
    ServiceID?: SortOrder
    Quantity?: SortOrder
  }

  export type combodonatetbMinOrderByAggregateInput = {
    ComboDonateID?: SortOrder
    ComboID?: SortOrder
    ServiceID?: SortOrder
    Quantity?: SortOrder
  }

  export type combodonatetbSumOrderByAggregateInput = {
    ComboDonateID?: SortOrder
    ComboID?: SortOrder
    ServiceID?: SortOrder
    Quantity?: SortOrder
  }

  export type combotbCountOrderByAggregateInput = {
    ComboID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    Type?: SortOrder
    PreAlias?: SortOrder
    IsStatus?: SortOrder
    OrderPosition?: SortOrder
    NumOfDay?: SortOrder
  }

  export type combotbAvgOrderByAggregateInput = {
    ComboID?: SortOrder
    Price?: SortOrder
    Type?: SortOrder
    IsStatus?: SortOrder
    OrderPosition?: SortOrder
    NumOfDay?: SortOrder
  }

  export type combotbMaxOrderByAggregateInput = {
    ComboID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    Type?: SortOrder
    PreAlias?: SortOrder
    IsStatus?: SortOrder
    OrderPosition?: SortOrder
    NumOfDay?: SortOrder
  }

  export type combotbMinOrderByAggregateInput = {
    ComboID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    Type?: SortOrder
    PreAlias?: SortOrder
    IsStatus?: SortOrder
    OrderPosition?: SortOrder
    NumOfDay?: SortOrder
  }

  export type combotbSumOrderByAggregateInput = {
    ComboID?: SortOrder
    Price?: SortOrder
    Type?: SortOrder
    IsStatus?: SortOrder
    OrderPosition?: SortOrder
    NumOfDay?: SortOrder
  }

  export type combousagetbCountOrderByAggregateInput = {
    ComboUsageID?: SortOrder
    ComboID?: SortOrder
    MachineGroupID?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
  }

  export type combousagetbAvgOrderByAggregateInput = {
    ComboUsageID?: SortOrder
    ComboID?: SortOrder
    MachineGroupID?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
  }

  export type combousagetbMaxOrderByAggregateInput = {
    ComboUsageID?: SortOrder
    ComboID?: SortOrder
    MachineGroupID?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
  }

  export type combousagetbMinOrderByAggregateInput = {
    ComboUsageID?: SortOrder
    ComboID?: SortOrder
    MachineGroupID?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
  }

  export type combousagetbSumOrderByAggregateInput = {
    ComboUsageID?: SortOrder
    ComboID?: SortOrder
    MachineGroupID?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
  }

  export type convertunittbCountOrderByAggregateInput = {
    ID?: SortOrder
    ServiceID?: SortOrder
    UnitRootID?: SortOrder
    ConvertUnitID?: SortOrder
    Quantity?: SortOrder
  }

  export type convertunittbAvgOrderByAggregateInput = {
    ID?: SortOrder
    ServiceID?: SortOrder
    UnitRootID?: SortOrder
    ConvertUnitID?: SortOrder
    Quantity?: SortOrder
  }

  export type convertunittbMaxOrderByAggregateInput = {
    ID?: SortOrder
    ServiceID?: SortOrder
    UnitRootID?: SortOrder
    ConvertUnitID?: SortOrder
    Quantity?: SortOrder
  }

  export type convertunittbMinOrderByAggregateInput = {
    ID?: SortOrder
    ServiceID?: SortOrder
    UnitRootID?: SortOrder
    ConvertUnitID?: SortOrder
    Quantity?: SortOrder
  }

  export type convertunittbSumOrderByAggregateInput = {
    ID?: SortOrder
    ServiceID?: SortOrder
    UnitRootID?: SortOrder
    ConvertUnitID?: SortOrder
    Quantity?: SortOrder
  }

  export type dptbCountOrderByAggregateInput = {
    ComputerName?: SortOrder
    Status?: SortOrder
    Type?: SortOrder
    Version?: SortOrder
    LastUpdate?: SortOrder
    FNetVersion?: SortOrder
    FNetReleaseDate?: SortOrder
    DPB?: SortOrder
  }

  export type dptbAvgOrderByAggregateInput = {
    Status?: SortOrder
    Type?: SortOrder
  }

  export type dptbMaxOrderByAggregateInput = {
    ComputerName?: SortOrder
    Status?: SortOrder
    Type?: SortOrder
    Version?: SortOrder
    LastUpdate?: SortOrder
    FNetVersion?: SortOrder
    FNetReleaseDate?: SortOrder
    DPB?: SortOrder
  }

  export type dptbMinOrderByAggregateInput = {
    ComputerName?: SortOrder
    Status?: SortOrder
    Type?: SortOrder
    Version?: SortOrder
    LastUpdate?: SortOrder
    FNetVersion?: SortOrder
    FNetReleaseDate?: SortOrder
    DPB?: SortOrder
  }

  export type dptbSumOrderByAggregateInput = {
    Status?: SortOrder
    Type?: SortOrder
  }

  export type freetimedetailtbCountOrderByAggregateInput = {
    FreeTimeDetailId?: SortOrder
    UserId?: SortOrder
    FreeTime?: SortOrder
    FreeMoney?: SortOrder
    Type?: SortOrder
    RecordDate?: SortOrder
    VoucherId?: SortOrder
  }

  export type freetimedetailtbAvgOrderByAggregateInput = {
    FreeTimeDetailId?: SortOrder
    UserId?: SortOrder
    FreeTime?: SortOrder
    FreeMoney?: SortOrder
    Type?: SortOrder
    VoucherId?: SortOrder
  }

  export type freetimedetailtbMaxOrderByAggregateInput = {
    FreeTimeDetailId?: SortOrder
    UserId?: SortOrder
    FreeTime?: SortOrder
    FreeMoney?: SortOrder
    Type?: SortOrder
    RecordDate?: SortOrder
    VoucherId?: SortOrder
  }

  export type freetimedetailtbMinOrderByAggregateInput = {
    FreeTimeDetailId?: SortOrder
    UserId?: SortOrder
    FreeTime?: SortOrder
    FreeMoney?: SortOrder
    Type?: SortOrder
    RecordDate?: SortOrder
    VoucherId?: SortOrder
  }

  export type freetimedetailtbSumOrderByAggregateInput = {
    FreeTimeDetailId?: SortOrder
    UserId?: SortOrder
    FreeTime?: SortOrder
    FreeMoney?: SortOrder
    Type?: SortOrder
    VoucherId?: SortOrder
  }

  export type functiontbCountOrderByAggregateInput = {
    FunctionCode?: SortOrder
    FunctionName?: SortOrder
    ParentFunction?: SortOrder
    LevelFunction?: SortOrder
    OrderOfLevel?: SortOrder
    Active?: SortOrder
  }

  export type functiontbAvgOrderByAggregateInput = {
    LevelFunction?: SortOrder
    OrderOfLevel?: SortOrder
    Active?: SortOrder
  }

  export type functiontbMaxOrderByAggregateInput = {
    FunctionCode?: SortOrder
    FunctionName?: SortOrder
    ParentFunction?: SortOrder
    LevelFunction?: SortOrder
    OrderOfLevel?: SortOrder
    Active?: SortOrder
  }

  export type functiontbMinOrderByAggregateInput = {
    FunctionCode?: SortOrder
    FunctionName?: SortOrder
    ParentFunction?: SortOrder
    LevelFunction?: SortOrder
    OrderOfLevel?: SortOrder
    Active?: SortOrder
  }

  export type functiontbSumOrderByAggregateInput = {
    LevelFunction?: SortOrder
    OrderOfLevel?: SortOrder
    Active?: SortOrder
  }

  export type gamefoldertbCountOrderByAggregateInput = {
    ID?: SortOrder
    MachineID?: SortOrder
    GameId?: SortOrder
    GamePath?: SortOrder
  }

  export type gamefoldertbAvgOrderByAggregateInput = {
    ID?: SortOrder
    MachineID?: SortOrder
    GameId?: SortOrder
  }

  export type gamefoldertbMaxOrderByAggregateInput = {
    ID?: SortOrder
    MachineID?: SortOrder
    GameId?: SortOrder
    GamePath?: SortOrder
  }

  export type gamefoldertbMinOrderByAggregateInput = {
    ID?: SortOrder
    MachineID?: SortOrder
    GameId?: SortOrder
    GamePath?: SortOrder
  }

  export type gamefoldertbSumOrderByAggregateInput = {
    ID?: SortOrder
    MachineID?: SortOrder
    GameId?: SortOrder
  }

  export type gamelisttbCountOrderByAggregateInput = {
    GameId?: SortOrder
    GameAlias?: SortOrder
    GameName?: SortOrder
    GameLauncher?: SortOrder
    Active?: SortOrder
    Protocol?: SortOrder
    URL?: SortOrder
    Checksum?: SortOrder
    PublishDate?: SortOrder
    TorrentFile?: SortOrder
    SetupFile?: SortOrder
    ShortcutPath?: SortOrder
    Type?: SortOrder
    Size?: SortOrder
    SetupType?: SortOrder
    ConfigFile?: SortOrder
    Checked?: SortOrder
  }

  export type gamelisttbAvgOrderByAggregateInput = {
    GameId?: SortOrder
    Active?: SortOrder
    Type?: SortOrder
    SetupType?: SortOrder
    Checked?: SortOrder
  }

  export type gamelisttbMaxOrderByAggregateInput = {
    GameId?: SortOrder
    GameAlias?: SortOrder
    GameName?: SortOrder
    GameLauncher?: SortOrder
    Active?: SortOrder
    Protocol?: SortOrder
    URL?: SortOrder
    Checksum?: SortOrder
    PublishDate?: SortOrder
    TorrentFile?: SortOrder
    SetupFile?: SortOrder
    ShortcutPath?: SortOrder
    Type?: SortOrder
    Size?: SortOrder
    SetupType?: SortOrder
    ConfigFile?: SortOrder
    Checked?: SortOrder
  }

  export type gamelisttbMinOrderByAggregateInput = {
    GameId?: SortOrder
    GameAlias?: SortOrder
    GameName?: SortOrder
    GameLauncher?: SortOrder
    Active?: SortOrder
    Protocol?: SortOrder
    URL?: SortOrder
    Checksum?: SortOrder
    PublishDate?: SortOrder
    TorrentFile?: SortOrder
    SetupFile?: SortOrder
    ShortcutPath?: SortOrder
    Type?: SortOrder
    Size?: SortOrder
    SetupType?: SortOrder
    ConfigFile?: SortOrder
    Checked?: SortOrder
  }

  export type gamelisttbSumOrderByAggregateInput = {
    GameId?: SortOrder
    Active?: SortOrder
    Type?: SortOrder
    SetupType?: SortOrder
    Checked?: SortOrder
  }

  export type hptbCountOrderByAggregateInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    IEHP?: SortOrder
    FFHP?: SortOrder
    GCHP?: SortOrder
    LastUpdateDate?: SortOrder
  }

  export type hptbAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type hptbMaxOrderByAggregateInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    IEHP?: SortOrder
    FFHP?: SortOrder
    GCHP?: SortOrder
    LastUpdateDate?: SortOrder
  }

  export type hptbMinOrderByAggregateInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    IEHP?: SortOrder
    FFHP?: SortOrder
    GCHP?: SortOrder
    LastUpdateDate?: SortOrder
  }

  export type hptbSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type intoptiontbCountOrderByAggregateInput = {
    OptionId?: SortOrder
    OptionName?: SortOrder
    Value?: SortOrder
    Active?: SortOrder
  }

  export type intoptiontbAvgOrderByAggregateInput = {
    OptionId?: SortOrder
  }

  export type intoptiontbMaxOrderByAggregateInput = {
    OptionId?: SortOrder
    OptionName?: SortOrder
    Value?: SortOrder
    Active?: SortOrder
  }

  export type intoptiontbMinOrderByAggregateInput = {
    OptionId?: SortOrder
    OptionName?: SortOrder
    Value?: SortOrder
    Active?: SortOrder
  }

  export type intoptiontbSumOrderByAggregateInput = {
    OptionId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type inventorytbCountOrderByAggregateInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    Note?: SortOrder
    ServiceID?: SortOrder
    ImportQuantity?: SortOrder
    ImportPrice?: SortOrder
    ImportTotalAmount?: SortOrder
  }

  export type inventorytbAvgOrderByAggregateInput = {
    ID?: SortOrder
    StaffID?: SortOrder
    ServiceID?: SortOrder
    ImportQuantity?: SortOrder
    ImportPrice?: SortOrder
    ImportTotalAmount?: SortOrder
  }

  export type inventorytbMaxOrderByAggregateInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    Note?: SortOrder
    ServiceID?: SortOrder
    ImportQuantity?: SortOrder
    ImportPrice?: SortOrder
    ImportTotalAmount?: SortOrder
  }

  export type inventorytbMinOrderByAggregateInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    Note?: SortOrder
    ServiceID?: SortOrder
    ImportQuantity?: SortOrder
    ImportPrice?: SortOrder
    ImportTotalAmount?: SortOrder
  }

  export type inventorytbSumOrderByAggregateInput = {
    ID?: SortOrder
    StaffID?: SortOrder
    ServiceID?: SortOrder
    ImportQuantity?: SortOrder
    ImportPrice?: SortOrder
    ImportTotalAmount?: SortOrder
  }

  export type legalapptbCountOrderByAggregateInput = {
    AppName?: SortOrder
  }

  export type legalapptbMaxOrderByAggregateInput = {
    AppName?: SortOrder
  }

  export type legalapptbMinOrderByAggregateInput = {
    AppName?: SortOrder
  }

  export type machinegrouptbCountOrderByAggregateInput = {
    MachineGroupId?: SortOrder
    MachineGroupName?: SortOrder
    PriceDefault?: SortOrder
    Active?: SortOrder
    Description?: SortOrder
  }

  export type machinegrouptbAvgOrderByAggregateInput = {
    MachineGroupId?: SortOrder
    PriceDefault?: SortOrder
    Active?: SortOrder
  }

  export type machinegrouptbMaxOrderByAggregateInput = {
    MachineGroupId?: SortOrder
    MachineGroupName?: SortOrder
    PriceDefault?: SortOrder
    Active?: SortOrder
    Description?: SortOrder
  }

  export type machinegrouptbMinOrderByAggregateInput = {
    MachineGroupId?: SortOrder
    MachineGroupName?: SortOrder
    PriceDefault?: SortOrder
    Active?: SortOrder
    Description?: SortOrder
  }

  export type machinegrouptbSumOrderByAggregateInput = {
    MachineGroupId?: SortOrder
    PriceDefault?: SortOrder
    Active?: SortOrder
  }

  export type paymenttbCountOrderByAggregateInput = {
    VoucherId?: SortOrder
    UserId?: SortOrder
    VoucherNo?: SortOrder
    VoucherDate?: SortOrder
    VoucherTime?: SortOrder
    ServeDate?: SortOrder
    ServeTime?: SortOrder
    Amount?: SortOrder
    AutoAmount?: SortOrder
    TimeTotal?: SortOrder
    Active?: SortOrder
    UserNote?: SortOrder
    Note?: SortOrder
    ServicePaid?: SortOrder
    StaffId?: SortOrder
    MachineName?: SortOrder
    PaymentType?: SortOrder
    PaymentWaitId?: SortOrder
    zOid?: SortOrder
    zTid?: SortOrder
    zSig?: SortOrder
  }

  export type paymenttbAvgOrderByAggregateInput = {
    VoucherId?: SortOrder
    UserId?: SortOrder
    Amount?: SortOrder
    AutoAmount?: SortOrder
    TimeTotal?: SortOrder
    StaffId?: SortOrder
    PaymentType?: SortOrder
    PaymentWaitId?: SortOrder
  }

  export type paymenttbMaxOrderByAggregateInput = {
    VoucherId?: SortOrder
    UserId?: SortOrder
    VoucherNo?: SortOrder
    VoucherDate?: SortOrder
    VoucherTime?: SortOrder
    ServeDate?: SortOrder
    ServeTime?: SortOrder
    Amount?: SortOrder
    AutoAmount?: SortOrder
    TimeTotal?: SortOrder
    Active?: SortOrder
    UserNote?: SortOrder
    Note?: SortOrder
    ServicePaid?: SortOrder
    StaffId?: SortOrder
    MachineName?: SortOrder
    PaymentType?: SortOrder
    PaymentWaitId?: SortOrder
    zOid?: SortOrder
    zTid?: SortOrder
    zSig?: SortOrder
  }

  export type paymenttbMinOrderByAggregateInput = {
    VoucherId?: SortOrder
    UserId?: SortOrder
    VoucherNo?: SortOrder
    VoucherDate?: SortOrder
    VoucherTime?: SortOrder
    ServeDate?: SortOrder
    ServeTime?: SortOrder
    Amount?: SortOrder
    AutoAmount?: SortOrder
    TimeTotal?: SortOrder
    Active?: SortOrder
    UserNote?: SortOrder
    Note?: SortOrder
    ServicePaid?: SortOrder
    StaffId?: SortOrder
    MachineName?: SortOrder
    PaymentType?: SortOrder
    PaymentWaitId?: SortOrder
    zOid?: SortOrder
    zTid?: SortOrder
    zSig?: SortOrder
  }

  export type paymenttbSumOrderByAggregateInput = {
    VoucherId?: SortOrder
    UserId?: SortOrder
    Amount?: SortOrder
    AutoAmount?: SortOrder
    TimeTotal?: SortOrder
    StaffId?: SortOrder
    PaymentType?: SortOrder
    PaymentWaitId?: SortOrder
  }

  export type paymentwaittbCountOrderByAggregateInput = {
    PaymentWaitId?: SortOrder
    MachineName?: SortOrder
    TotalTimeUsed?: SortOrder
    TotalTimeFee?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    TimeFee?: SortOrder
    TimeUsed?: SortOrder
    RemainTime?: SortOrder
    TimePaid?: SortOrder
    FreeTime?: SortOrder
    ChangePCSessionId?: SortOrder
    AnonymId?: SortOrder
    PriceGroupId?: SortOrder
    MachineGroupId?: SortOrder
    Note?: SortOrder
    PriceAppRentID?: SortOrder
  }

  export type paymentwaittbAvgOrderByAggregateInput = {
    PaymentWaitId?: SortOrder
    TotalTimeUsed?: SortOrder
    TotalTimeFee?: SortOrder
    TimeFee?: SortOrder
    TimeUsed?: SortOrder
    RemainTime?: SortOrder
    TimePaid?: SortOrder
    FreeTime?: SortOrder
    ChangePCSessionId?: SortOrder
    AnonymId?: SortOrder
    PriceGroupId?: SortOrder
    MachineGroupId?: SortOrder
    PriceAppRentID?: SortOrder
  }

  export type paymentwaittbMaxOrderByAggregateInput = {
    PaymentWaitId?: SortOrder
    MachineName?: SortOrder
    TotalTimeUsed?: SortOrder
    TotalTimeFee?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    TimeFee?: SortOrder
    TimeUsed?: SortOrder
    RemainTime?: SortOrder
    TimePaid?: SortOrder
    FreeTime?: SortOrder
    ChangePCSessionId?: SortOrder
    AnonymId?: SortOrder
    PriceGroupId?: SortOrder
    MachineGroupId?: SortOrder
    Note?: SortOrder
    PriceAppRentID?: SortOrder
  }

  export type paymentwaittbMinOrderByAggregateInput = {
    PaymentWaitId?: SortOrder
    MachineName?: SortOrder
    TotalTimeUsed?: SortOrder
    TotalTimeFee?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    TimeFee?: SortOrder
    TimeUsed?: SortOrder
    RemainTime?: SortOrder
    TimePaid?: SortOrder
    FreeTime?: SortOrder
    ChangePCSessionId?: SortOrder
    AnonymId?: SortOrder
    PriceGroupId?: SortOrder
    MachineGroupId?: SortOrder
    Note?: SortOrder
    PriceAppRentID?: SortOrder
  }

  export type paymentwaittbSumOrderByAggregateInput = {
    PaymentWaitId?: SortOrder
    TotalTimeUsed?: SortOrder
    TotalTimeFee?: SortOrder
    TimeFee?: SortOrder
    TimeUsed?: SortOrder
    RemainTime?: SortOrder
    TimePaid?: SortOrder
    FreeTime?: SortOrder
    ChangePCSessionId?: SortOrder
    AnonymId?: SortOrder
    PriceGroupId?: SortOrder
    MachineGroupId?: SortOrder
    PriceAppRentID?: SortOrder
  }

  export type priceapprenttbCountOrderByAggregateInput = {
    PriceAppRentID?: SortOrder
    PriceID?: SortOrder
    MachineGroupID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    Status?: SortOrder
  }

  export type priceapprenttbAvgOrderByAggregateInput = {
    PriceAppRentID?: SortOrder
    PriceID?: SortOrder
    MachineGroupID?: SortOrder
    Price?: SortOrder
    Status?: SortOrder
  }

  export type priceapprenttbMaxOrderByAggregateInput = {
    PriceAppRentID?: SortOrder
    PriceID?: SortOrder
    MachineGroupID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    Status?: SortOrder
  }

  export type priceapprenttbMinOrderByAggregateInput = {
    PriceAppRentID?: SortOrder
    PriceID?: SortOrder
    MachineGroupID?: SortOrder
    Name?: SortOrder
    Price?: SortOrder
    Status?: SortOrder
  }

  export type priceapprenttbSumOrderByAggregateInput = {
    PriceAppRentID?: SortOrder
    PriceID?: SortOrder
    MachineGroupID?: SortOrder
    Price?: SortOrder
    Status?: SortOrder
  }

  export type priceapprentusetbCountOrderByAggregateInput = {
    PriceAppRentUseID?: SortOrder
    PriceAppRentID?: SortOrder
    ApplicationRentID?: SortOrder
  }

  export type priceapprentusetbAvgOrderByAggregateInput = {
    PriceAppRentUseID?: SortOrder
    PriceAppRentID?: SortOrder
    ApplicationRentID?: SortOrder
  }

  export type priceapprentusetbMaxOrderByAggregateInput = {
    PriceAppRentUseID?: SortOrder
    PriceAppRentID?: SortOrder
    ApplicationRentID?: SortOrder
  }

  export type priceapprentusetbMinOrderByAggregateInput = {
    PriceAppRentUseID?: SortOrder
    PriceAppRentID?: SortOrder
    ApplicationRentID?: SortOrder
  }

  export type priceapprentusetbSumOrderByAggregateInput = {
    PriceAppRentUseID?: SortOrder
    PriceAppRentID?: SortOrder
    ApplicationRentID?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type pricedetailtbCountOrderByAggregateInput = {
    PriceDetailId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
    Promotion?: SortOrder
    PromotionTerm?: SortOrder
    FreeMoney?: SortOrder
    FreeTime?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    Term?: SortOrder
    PromotionOrder?: SortOrder
    BeginDate?: SortOrder
    EndDate?: SortOrder
    DayOfWeekMask?: SortOrder
    PromotionType?: SortOrder
  }

  export type pricedetailtbAvgOrderByAggregateInput = {
    PriceDetailId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
    Promotion?: SortOrder
    PromotionTerm?: SortOrder
    FreeMoney?: SortOrder
    FreeTime?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    Term?: SortOrder
    PromotionOrder?: SortOrder
    DayOfWeekMask?: SortOrder
    PromotionType?: SortOrder
  }

  export type pricedetailtbMaxOrderByAggregateInput = {
    PriceDetailId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
    Promotion?: SortOrder
    PromotionTerm?: SortOrder
    FreeMoney?: SortOrder
    FreeTime?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    Term?: SortOrder
    PromotionOrder?: SortOrder
    BeginDate?: SortOrder
    EndDate?: SortOrder
    DayOfWeekMask?: SortOrder
    PromotionType?: SortOrder
  }

  export type pricedetailtbMinOrderByAggregateInput = {
    PriceDetailId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
    Promotion?: SortOrder
    PromotionTerm?: SortOrder
    FreeMoney?: SortOrder
    FreeTime?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    Term?: SortOrder
    PromotionOrder?: SortOrder
    BeginDate?: SortOrder
    EndDate?: SortOrder
    DayOfWeekMask?: SortOrder
    PromotionType?: SortOrder
  }

  export type pricedetailtbSumOrderByAggregateInput = {
    PriceDetailId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
    Promotion?: SortOrder
    PromotionTerm?: SortOrder
    FreeMoney?: SortOrder
    FreeTime?: SortOrder
    BeginTime?: SortOrder
    EndTime?: SortOrder
    Term?: SortOrder
    PromotionOrder?: SortOrder
    DayOfWeekMask?: SortOrder
    PromotionType?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type pricelisttbCountOrderByAggregateInput = {
    PriceId?: SortOrder
    PriceType?: SortOrder
    Price?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type pricelisttbAvgOrderByAggregateInput = {
    PriceId?: SortOrder
    Price?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type pricelisttbMaxOrderByAggregateInput = {
    PriceId?: SortOrder
    PriceType?: SortOrder
    Price?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type pricelisttbMinOrderByAggregateInput = {
    PriceId?: SortOrder
    PriceType?: SortOrder
    Price?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type pricelisttbSumOrderByAggregateInput = {
    PriceId?: SortOrder
    Price?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type pricemachinetbCountOrderByAggregateInput = {
    PriceMachineId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
  }

  export type pricemachinetbAvgOrderByAggregateInput = {
    PriceMachineId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
  }

  export type pricemachinetbMaxOrderByAggregateInput = {
    PriceMachineId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
  }

  export type pricemachinetbMinOrderByAggregateInput = {
    PriceMachineId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
  }

  export type pricemachinetbSumOrderByAggregateInput = {
    PriceMachineId?: SortOrder
    PriceId?: SortOrder
    MachineGroupId?: SortOrder
    Price?: SortOrder
  }

  export type printertbCountOrderByAggregateInput = {
    ID?: SortOrder
    PrinterName?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type printertbAvgOrderByAggregateInput = {
    ID?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type printertbMaxOrderByAggregateInput = {
    ID?: SortOrder
    PrinterName?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type printertbMinOrderByAggregateInput = {
    ID?: SortOrder
    PrinterName?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type printertbSumOrderByAggregateInput = {
    ID?: SortOrder
    Type?: SortOrder
    Active?: SortOrder
  }

  export type printservicetbCountOrderByAggregateInput = {
    ID?: SortOrder
    PrinterID?: SortOrder
    ServiceID?: SortOrder
  }

  export type printservicetbAvgOrderByAggregateInput = {
    ID?: SortOrder
    PrinterID?: SortOrder
    ServiceID?: SortOrder
  }

  export type printservicetbMaxOrderByAggregateInput = {
    ID?: SortOrder
    PrinterID?: SortOrder
    ServiceID?: SortOrder
  }

  export type printservicetbMinOrderByAggregateInput = {
    ID?: SortOrder
    PrinterID?: SortOrder
    ServiceID?: SortOrder
  }

  export type printservicetbSumOrderByAggregateInput = {
    ID?: SortOrder
    PrinterID?: SortOrder
    ServiceID?: SortOrder
  }

  export type processtbCountOrderByAggregateInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    ProcessName?: SortOrder
    FileLocation?: SortOrder
    FileDescription?: SortOrder
    Type?: SortOrder
    PreviousDate?: SortOrder
    CurrentDate?: SortOrder
  }

  export type processtbAvgOrderByAggregateInput = {
    ID?: SortOrder
    Type?: SortOrder
  }

  export type processtbMaxOrderByAggregateInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    ProcessName?: SortOrder
    FileLocation?: SortOrder
    FileDescription?: SortOrder
    Type?: SortOrder
    PreviousDate?: SortOrder
    CurrentDate?: SortOrder
  }

  export type processtbMinOrderByAggregateInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    ProcessName?: SortOrder
    FileLocation?: SortOrder
    FileDescription?: SortOrder
    Type?: SortOrder
    PreviousDate?: SortOrder
    CurrentDate?: SortOrder
  }

  export type processtbSumOrderByAggregateInput = {
    ID?: SortOrder
    Type?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type rechargecarddetailtbCountOrderByAggregateInput = {
    CardDetailId?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    CardValue?: SortOrder
    CardDate?: SortOrder
    CardTime?: SortOrder
    CardQuantity?: SortOrder
    CardAmount?: SortOrder
    UserId?: SortOrder
    Accept?: SortOrder
  }

  export type rechargecarddetailtbAvgOrderByAggregateInput = {
    CardDetailId?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    CardValue?: SortOrder
    CardQuantity?: SortOrder
    CardAmount?: SortOrder
    UserId?: SortOrder
  }

  export type rechargecarddetailtbMaxOrderByAggregateInput = {
    CardDetailId?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    CardValue?: SortOrder
    CardDate?: SortOrder
    CardTime?: SortOrder
    CardQuantity?: SortOrder
    CardAmount?: SortOrder
    UserId?: SortOrder
    Accept?: SortOrder
  }

  export type rechargecarddetailtbMinOrderByAggregateInput = {
    CardDetailId?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    CardValue?: SortOrder
    CardDate?: SortOrder
    CardTime?: SortOrder
    CardQuantity?: SortOrder
    CardAmount?: SortOrder
    UserId?: SortOrder
    Accept?: SortOrder
  }

  export type rechargecarddetailtbSumOrderByAggregateInput = {
    CardDetailId?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    CardValue?: SortOrder
    CardQuantity?: SortOrder
    CardAmount?: SortOrder
    UserId?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type rechargecardtbCountOrderByAggregateInput = {
    CardId?: SortOrder
    cardcode?: SortOrder
    CardValue?: SortOrder
    ExpiryDate?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    ModifyDate?: SortOrder
    ModifyTime?: SortOrder
    Status?: SortOrder
    UserId?: SortOrder
    Note?: SortOrder
  }

  export type rechargecardtbAvgOrderByAggregateInput = {
    CardId?: SortOrder
    CardValue?: SortOrder
    UserId?: SortOrder
  }

  export type rechargecardtbMaxOrderByAggregateInput = {
    CardId?: SortOrder
    cardcode?: SortOrder
    CardValue?: SortOrder
    ExpiryDate?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    ModifyDate?: SortOrder
    ModifyTime?: SortOrder
    Status?: SortOrder
    UserId?: SortOrder
    Note?: SortOrder
  }

  export type rechargecardtbMinOrderByAggregateInput = {
    CardId?: SortOrder
    cardcode?: SortOrder
    CardValue?: SortOrder
    ExpiryDate?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    ModifyDate?: SortOrder
    ModifyTime?: SortOrder
    Status?: SortOrder
    UserId?: SortOrder
    Note?: SortOrder
  }

  export type rechargecardtbSumOrderByAggregateInput = {
    CardId?: SortOrder
    CardValue?: SortOrder
    UserId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type reportdailyYmdPrefixModeCompoundUniqueInput = {
    ymd: number
    prefix: string
    mode: number
  }

  export type reportdailyCountOrderByAggregateInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f10?: SortOrder
    f11?: SortOrder
    f12?: SortOrder
    f13?: SortOrder
    f14?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
    ext?: SortOrder
    hash?: SortOrder
    create_date?: SortOrder
    update_date?: SortOrder
  }

  export type reportdailyAvgOrderByAggregateInput = {
    ymd?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
  }

  export type reportdailyMaxOrderByAggregateInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f10?: SortOrder
    f11?: SortOrder
    f12?: SortOrder
    f13?: SortOrder
    f14?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
    ext?: SortOrder
    hash?: SortOrder
    create_date?: SortOrder
    update_date?: SortOrder
  }

  export type reportdailyMinOrderByAggregateInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f10?: SortOrder
    f11?: SortOrder
    f12?: SortOrder
    f13?: SortOrder
    f14?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
    ext?: SortOrder
    hash?: SortOrder
    create_date?: SortOrder
    update_date?: SortOrder
  }

  export type reportdailySumOrderByAggregateInput = {
    ymd?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type reportmonthlyYmdPrefixModeCompoundUniqueInput = {
    ymd: number
    prefix: string
    mode: number
  }

  export type reportmonthlyCountOrderByAggregateInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f10?: SortOrder
    f11?: SortOrder
    f12?: SortOrder
    f13?: SortOrder
    f14?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
    ext?: SortOrder
    hash?: SortOrder
    create_date?: SortOrder
    update_date?: SortOrder
  }

  export type reportmonthlyAvgOrderByAggregateInput = {
    ymd?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
  }

  export type reportmonthlyMaxOrderByAggregateInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f10?: SortOrder
    f11?: SortOrder
    f12?: SortOrder
    f13?: SortOrder
    f14?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
    ext?: SortOrder
    hash?: SortOrder
    create_date?: SortOrder
    update_date?: SortOrder
  }

  export type reportmonthlyMinOrderByAggregateInput = {
    ymd?: SortOrder
    prefix?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f10?: SortOrder
    f11?: SortOrder
    f12?: SortOrder
    f13?: SortOrder
    f14?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
    ext?: SortOrder
    hash?: SortOrder
    create_date?: SortOrder
    update_date?: SortOrder
  }

  export type reportmonthlySumOrderByAggregateInput = {
    ymd?: SortOrder
    mode?: SortOrder
    f1?: SortOrder
    f2?: SortOrder
    f3?: SortOrder
    f4?: SortOrder
    f5?: SortOrder
    f6?: SortOrder
    f7?: SortOrder
    f8?: SortOrder
    f9?: SortOrder
    f15?: SortOrder
    f16?: SortOrder
    f17?: SortOrder
    f18?: SortOrder
    f19?: SortOrder
    f20?: SortOrder
  }

  export type righttbUserIdFunctionCodeCompoundUniqueInput = {
    UserId: number
    FunctionCode: string
  }

  export type righttbCountOrderByAggregateInput = {
    RightId?: SortOrder
    UserId?: SortOrder
    FunctionCode?: SortOrder
  }

  export type righttbAvgOrderByAggregateInput = {
    RightId?: SortOrder
    UserId?: SortOrder
  }

  export type righttbMaxOrderByAggregateInput = {
    RightId?: SortOrder
    UserId?: SortOrder
    FunctionCode?: SortOrder
  }

  export type righttbMinOrderByAggregateInput = {
    RightId?: SortOrder
    UserId?: SortOrder
    FunctionCode?: SortOrder
  }

  export type righttbSumOrderByAggregateInput = {
    RightId?: SortOrder
    UserId?: SortOrder
  }

  export type serverlogtbCountOrderByAggregateInput = {
    ServerLogId?: SortOrder
    Status?: SortOrder
    RecordDate?: SortOrder
    RecordTime?: SortOrder
    Period?: SortOrder
    Note?: SortOrder
  }

  export type serverlogtbAvgOrderByAggregateInput = {
    ServerLogId?: SortOrder
    Period?: SortOrder
  }

  export type serverlogtbMaxOrderByAggregateInput = {
    ServerLogId?: SortOrder
    Status?: SortOrder
    RecordDate?: SortOrder
    RecordTime?: SortOrder
    Period?: SortOrder
    Note?: SortOrder
  }

  export type serverlogtbMinOrderByAggregateInput = {
    ServerLogId?: SortOrder
    Status?: SortOrder
    RecordDate?: SortOrder
    RecordTime?: SortOrder
    Period?: SortOrder
    Note?: SortOrder
  }

  export type serverlogtbSumOrderByAggregateInput = {
    ServerLogId?: SortOrder
    Period?: SortOrder
  }

  export type servicedetailtbCountOrderByAggregateInput = {
    ServiceDetailId?: SortOrder
    UserId?: SortOrder
    ServiceId?: SortOrder
    ServiceDate?: SortOrder
    ServiceTime?: SortOrder
    ServiceQuantity?: SortOrder
    ServiceAmount?: SortOrder
    ServicePaid?: SortOrder
    Accept?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    PaymentWaitId?: SortOrder
    iCafeHash?: SortOrder
    iCafeUsr?: SortOrder
  }

  export type servicedetailtbAvgOrderByAggregateInput = {
    ServiceDetailId?: SortOrder
    UserId?: SortOrder
    ServiceId?: SortOrder
    ServiceQuantity?: SortOrder
    ServiceAmount?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    PaymentWaitId?: SortOrder
  }

  export type servicedetailtbMaxOrderByAggregateInput = {
    ServiceDetailId?: SortOrder
    UserId?: SortOrder
    ServiceId?: SortOrder
    ServiceDate?: SortOrder
    ServiceTime?: SortOrder
    ServiceQuantity?: SortOrder
    ServiceAmount?: SortOrder
    ServicePaid?: SortOrder
    Accept?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    PaymentWaitId?: SortOrder
    iCafeHash?: SortOrder
    iCafeUsr?: SortOrder
  }

  export type servicedetailtbMinOrderByAggregateInput = {
    ServiceDetailId?: SortOrder
    UserId?: SortOrder
    ServiceId?: SortOrder
    ServiceDate?: SortOrder
    ServiceTime?: SortOrder
    ServiceQuantity?: SortOrder
    ServiceAmount?: SortOrder
    ServicePaid?: SortOrder
    Accept?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    PaymentWaitId?: SortOrder
    iCafeHash?: SortOrder
    iCafeUsr?: SortOrder
  }

  export type servicedetailtbSumOrderByAggregateInput = {
    ServiceDetailId?: SortOrder
    UserId?: SortOrder
    ServiceId?: SortOrder
    ServiceQuantity?: SortOrder
    ServiceAmount?: SortOrder
    VoucherId?: SortOrder
    StaffId?: SortOrder
    PaymentWaitId?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type servicegiftsbagCountOrderByAggregateInput = {
    recId?: SortOrder
    recUuid?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    createDate?: SortOrder
    expDate?: SortOrder
    sourceType?: SortOrder
    serviceId?: SortOrder
    serviceName?: SortOrder
    servicePrice?: SortOrder
    serviceImg?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    acceptDate?: SortOrder
    sign?: SortOrder
    staffId?: SortOrder
    staffName?: SortOrder
    transId?: SortOrder
    serialId?: SortOrder
    ymd?: SortOrder
    totalDay?: SortOrder
    groupId?: SortOrder
  }

  export type servicegiftsbagAvgOrderByAggregateInput = {
    recId?: SortOrder
    sourceType?: SortOrder
    serviceId?: SortOrder
    servicePrice?: SortOrder
    status?: SortOrder
    staffId?: SortOrder
    ymd?: SortOrder
    totalDay?: SortOrder
    groupId?: SortOrder
  }

  export type servicegiftsbagMaxOrderByAggregateInput = {
    recId?: SortOrder
    recUuid?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    createDate?: SortOrder
    expDate?: SortOrder
    sourceType?: SortOrder
    serviceId?: SortOrder
    serviceName?: SortOrder
    servicePrice?: SortOrder
    serviceImg?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    acceptDate?: SortOrder
    sign?: SortOrder
    staffId?: SortOrder
    staffName?: SortOrder
    transId?: SortOrder
    serialId?: SortOrder
    ymd?: SortOrder
    totalDay?: SortOrder
    groupId?: SortOrder
  }

  export type servicegiftsbagMinOrderByAggregateInput = {
    recId?: SortOrder
    recUuid?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    createDate?: SortOrder
    expDate?: SortOrder
    sourceType?: SortOrder
    serviceId?: SortOrder
    serviceName?: SortOrder
    servicePrice?: SortOrder
    serviceImg?: SortOrder
    status?: SortOrder
    requestDate?: SortOrder
    acceptDate?: SortOrder
    sign?: SortOrder
    staffId?: SortOrder
    staffName?: SortOrder
    transId?: SortOrder
    serialId?: SortOrder
    ymd?: SortOrder
    totalDay?: SortOrder
    groupId?: SortOrder
  }

  export type servicegiftsbagSumOrderByAggregateInput = {
    recId?: SortOrder
    sourceType?: SortOrder
    serviceId?: SortOrder
    servicePrice?: SortOrder
    status?: SortOrder
    staffId?: SortOrder
    ymd?: SortOrder
    totalDay?: SortOrder
    groupId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type servicegrouptbCountOrderByAggregateInput = {
    ID?: SortOrder
    ServiceGroupName?: SortOrder
    IsOrder?: SortOrder
    Active?: SortOrder
    TypeID?: SortOrder
  }

  export type servicegrouptbAvgOrderByAggregateInput = {
    ID?: SortOrder
    IsOrder?: SortOrder
    Active?: SortOrder
    TypeID?: SortOrder
  }

  export type servicegrouptbMaxOrderByAggregateInput = {
    ID?: SortOrder
    ServiceGroupName?: SortOrder
    IsOrder?: SortOrder
    Active?: SortOrder
    TypeID?: SortOrder
  }

  export type servicegrouptbMinOrderByAggregateInput = {
    ID?: SortOrder
    ServiceGroupName?: SortOrder
    IsOrder?: SortOrder
    Active?: SortOrder
    TypeID?: SortOrder
  }

  export type servicegrouptbSumOrderByAggregateInput = {
    ID?: SortOrder
    IsOrder?: SortOrder
    Active?: SortOrder
    TypeID?: SortOrder
  }

  export type serviceinfologtbCountOrderByAggregateInput = {
    logId?: SortOrder
    serviceId?: SortOrder
    prefix?: SortOrder
    info?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    mode?: SortOrder
    hash?: SortOrder
  }

  export type serviceinfologtbAvgOrderByAggregateInput = {
    logId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    mode?: SortOrder
  }

  export type serviceinfologtbMaxOrderByAggregateInput = {
    logId?: SortOrder
    serviceId?: SortOrder
    prefix?: SortOrder
    info?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    mode?: SortOrder
    hash?: SortOrder
  }

  export type serviceinfologtbMinOrderByAggregateInput = {
    logId?: SortOrder
    serviceId?: SortOrder
    prefix?: SortOrder
    info?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    mode?: SortOrder
    hash?: SortOrder
  }

  export type serviceinfologtbSumOrderByAggregateInput = {
    logId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    mode?: SortOrder
  }

  export type serviceinfotbCountOrderByAggregateInput = {
    serviceId?: SortOrder
    prefix?: SortOrder
    info?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    mode?: SortOrder
    hash?: SortOrder
  }

  export type serviceinfotbAvgOrderByAggregateInput = {
    serviceId?: SortOrder
    status?: SortOrder
    mode?: SortOrder
  }

  export type serviceinfotbMaxOrderByAggregateInput = {
    serviceId?: SortOrder
    prefix?: SortOrder
    info?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    mode?: SortOrder
    hash?: SortOrder
  }

  export type serviceinfotbMinOrderByAggregateInput = {
    serviceId?: SortOrder
    prefix?: SortOrder
    info?: SortOrder
    status?: SortOrder
    createDate?: SortOrder
    mode?: SortOrder
    hash?: SortOrder
  }

  export type serviceinfotbSumOrderByAggregateInput = {
    serviceId?: SortOrder
    status?: SortOrder
    mode?: SortOrder
  }

  export type servicetbCountOrderByAggregateInput = {
    ServiceId?: SortOrder
    ServiceName?: SortOrder
    ServicePrice?: SortOrder
    Unit?: SortOrder
    Active?: SortOrder
    InventoryManagement?: SortOrder
    Inventory?: SortOrder
    WarningInventory?: SortOrder
    ServiceGroupID?: SortOrder
    NumInventoryExpected?: SortOrder
    UnitID?: SortOrder
    SuggestID?: SortOrder
    ServiceImg?: SortOrder
    ServiceDate?: SortOrder
  }

  export type servicetbAvgOrderByAggregateInput = {
    ServiceId?: SortOrder
    ServicePrice?: SortOrder
    Inventory?: SortOrder
    WarningInventory?: SortOrder
    ServiceGroupID?: SortOrder
    NumInventoryExpected?: SortOrder
    UnitID?: SortOrder
    SuggestID?: SortOrder
  }

  export type servicetbMaxOrderByAggregateInput = {
    ServiceId?: SortOrder
    ServiceName?: SortOrder
    ServicePrice?: SortOrder
    Unit?: SortOrder
    Active?: SortOrder
    InventoryManagement?: SortOrder
    Inventory?: SortOrder
    WarningInventory?: SortOrder
    ServiceGroupID?: SortOrder
    NumInventoryExpected?: SortOrder
    UnitID?: SortOrder
    SuggestID?: SortOrder
    ServiceImg?: SortOrder
    ServiceDate?: SortOrder
  }

  export type servicetbMinOrderByAggregateInput = {
    ServiceId?: SortOrder
    ServiceName?: SortOrder
    ServicePrice?: SortOrder
    Unit?: SortOrder
    Active?: SortOrder
    InventoryManagement?: SortOrder
    Inventory?: SortOrder
    WarningInventory?: SortOrder
    ServiceGroupID?: SortOrder
    NumInventoryExpected?: SortOrder
    UnitID?: SortOrder
    SuggestID?: SortOrder
    ServiceImg?: SortOrder
    ServiceDate?: SortOrder
  }

  export type servicetbSumOrderByAggregateInput = {
    ServiceId?: SortOrder
    ServicePrice?: SortOrder
    Inventory?: SortOrder
    WarningInventory?: SortOrder
    ServiceGroupID?: SortOrder
    NumInventoryExpected?: SortOrder
    UnitID?: SortOrder
    SuggestID?: SortOrder
  }

  export type serviceunittbCountOrderByAggregateInput = {
    ID?: SortOrder
    Unit?: SortOrder
    IsActive?: SortOrder
  }

  export type serviceunittbAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type serviceunittbMaxOrderByAggregateInput = {
    ID?: SortOrder
    Unit?: SortOrder
    IsActive?: SortOrder
  }

  export type serviceunittbMinOrderByAggregateInput = {
    ID?: SortOrder
    Unit?: SortOrder
    IsActive?: SortOrder
  }

  export type serviceunittbSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type servicevisitUidYmCompoundUniqueInput = {
    uid: string
    ym: number
  }

  export type servicevisitCountOrderByAggregateInput = {
    uid?: SortOrder
    vstotal?: SortOrder
    vsdetail?: SortOrder
    ym?: SortOrder
    last_update?: SortOrder
    sign?: SortOrder
    ssid?: SortOrder
    reset?: SortOrder
  }

  export type servicevisitAvgOrderByAggregateInput = {
    vstotal?: SortOrder
    ym?: SortOrder
    reset?: SortOrder
  }

  export type servicevisitMaxOrderByAggregateInput = {
    uid?: SortOrder
    vstotal?: SortOrder
    vsdetail?: SortOrder
    ym?: SortOrder
    last_update?: SortOrder
    sign?: SortOrder
    ssid?: SortOrder
    reset?: SortOrder
  }

  export type servicevisitMinOrderByAggregateInput = {
    uid?: SortOrder
    vstotal?: SortOrder
    vsdetail?: SortOrder
    ym?: SortOrder
    last_update?: SortOrder
    sign?: SortOrder
    ssid?: SortOrder
    reset?: SortOrder
  }

  export type servicevisitSumOrderByAggregateInput = {
    vstotal?: SortOrder
    ym?: SortOrder
    reset?: SortOrder
  }

  export type settingtbCountOrderByAggregateInput = {
    SettingId?: SortOrder
    Value?: SortOrder
    Data?: SortOrder
    Active?: SortOrder
  }

  export type settingtbAvgOrderByAggregateInput = {
    SettingId?: SortOrder
    Value?: SortOrder
  }

  export type settingtbMaxOrderByAggregateInput = {
    SettingId?: SortOrder
    Value?: SortOrder
    Data?: SortOrder
    Active?: SortOrder
  }

  export type settingtbMinOrderByAggregateInput = {
    SettingId?: SortOrder
    Value?: SortOrder
    Data?: SortOrder
    Active?: SortOrder
  }

  export type settingtbSumOrderByAggregateInput = {
    SettingId?: SortOrder
    Value?: SortOrder
  }

  export type softwaretbCountOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    Name?: SortOrder
    Version?: SortOrder
    MAC?: SortOrder
    Active?: SortOrder
  }

  export type softwaretbAvgOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    Active?: SortOrder
  }

  export type softwaretbMaxOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    Name?: SortOrder
    Version?: SortOrder
    MAC?: SortOrder
    Active?: SortOrder
  }

  export type softwaretbMinOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    Name?: SortOrder
    Version?: SortOrder
    MAC?: SortOrder
    Active?: SortOrder
  }

  export type softwaretbSumOrderByAggregateInput = {
    ID?: SortOrder
    UserId?: SortOrder
    Active?: SortOrder
  }

  export type specappdetailtbCountOrderByAggregateInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    AppName?: SortOrder
    Shortcut?: SortOrder
    InstallName?: SortOrder
    InstallVersion?: SortOrder
    InstallLocation?: SortOrder
    LastUpdateDate?: SortOrder
    Sent?: SortOrder
    AppRun?: SortOrder
    SubRun?: SortOrder
    SubRun2?: SortOrder
  }

  export type specappdetailtbAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type specappdetailtbMaxOrderByAggregateInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    AppName?: SortOrder
    Shortcut?: SortOrder
    InstallName?: SortOrder
    InstallVersion?: SortOrder
    InstallLocation?: SortOrder
    LastUpdateDate?: SortOrder
    Sent?: SortOrder
    AppRun?: SortOrder
    SubRun?: SortOrder
    SubRun2?: SortOrder
  }

  export type specappdetailtbMinOrderByAggregateInput = {
    ID?: SortOrder
    MachineName?: SortOrder
    AppName?: SortOrder
    Shortcut?: SortOrder
    InstallName?: SortOrder
    InstallVersion?: SortOrder
    InstallLocation?: SortOrder
    LastUpdateDate?: SortOrder
    Sent?: SortOrder
    AppRun?: SortOrder
    SubRun?: SortOrder
    SubRun2?: SortOrder
  }

  export type specappdetailtbSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type standardservicetbCountOrderByAggregateInput = {
    StandardServiceId?: SortOrder
    StandardServiceName?: SortOrder
    StandardServiceGroupID?: SortOrder
    Active?: SortOrder
  }

  export type standardservicetbAvgOrderByAggregateInput = {
    StandardServiceId?: SortOrder
    StandardServiceGroupID?: SortOrder
    Active?: SortOrder
  }

  export type standardservicetbMaxOrderByAggregateInput = {
    StandardServiceId?: SortOrder
    StandardServiceName?: SortOrder
    StandardServiceGroupID?: SortOrder
    Active?: SortOrder
  }

  export type standardservicetbMinOrderByAggregateInput = {
    StandardServiceId?: SortOrder
    StandardServiceName?: SortOrder
    StandardServiceGroupID?: SortOrder
    Active?: SortOrder
  }

  export type standardservicetbSumOrderByAggregateInput = {
    StandardServiceId?: SortOrder
    StandardServiceGroupID?: SortOrder
    Active?: SortOrder
  }

  export type stocktakingtbCountOrderByAggregateInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    NumPreAdjust?: SortOrder
    Note?: SortOrder
    ServiceID?: SortOrder
  }

  export type stocktakingtbAvgOrderByAggregateInput = {
    ID?: SortOrder
    StaffID?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    NumPreAdjust?: SortOrder
    ServiceID?: SortOrder
  }

  export type stocktakingtbMaxOrderByAggregateInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    NumPreAdjust?: SortOrder
    Note?: SortOrder
    ServiceID?: SortOrder
  }

  export type stocktakingtbMinOrderByAggregateInput = {
    ID?: SortOrder
    CreateDate?: SortOrder
    CreateTime?: SortOrder
    StaffID?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    NumPreAdjust?: SortOrder
    Note?: SortOrder
    ServiceID?: SortOrder
  }

  export type stocktakingtbSumOrderByAggregateInput = {
    ID?: SortOrder
    StaffID?: SortOrder
    NumInventoryExpected?: SortOrder
    NumInventoryReal?: SortOrder
    NumAdjust?: SortOrder
    NumPreAdjust?: SortOrder
    ServiceID?: SortOrder
  }

  export type supportsCountOrderByAggregateInput = {
    supportId?: SortOrder
    supportTitle?: SortOrder
    supportImage?: SortOrder
    suportCode?: SortOrder
    supportHash?: SortOrder
    status?: SortOrder
    order?: SortOrder
    supportCat?: SortOrder
    totalClick?: SortOrder
    ssId?: SortOrder
    createDate?: SortOrder
    modifyDate?: SortOrder
  }

  export type supportsAvgOrderByAggregateInput = {
    supportId?: SortOrder
    suportCode?: SortOrder
    status?: SortOrder
    order?: SortOrder
    totalClick?: SortOrder
  }

  export type supportsMaxOrderByAggregateInput = {
    supportId?: SortOrder
    supportTitle?: SortOrder
    supportImage?: SortOrder
    suportCode?: SortOrder
    supportHash?: SortOrder
    status?: SortOrder
    order?: SortOrder
    supportCat?: SortOrder
    totalClick?: SortOrder
    ssId?: SortOrder
    createDate?: SortOrder
    modifyDate?: SortOrder
  }

  export type supportsMinOrderByAggregateInput = {
    supportId?: SortOrder
    supportTitle?: SortOrder
    supportImage?: SortOrder
    suportCode?: SortOrder
    supportHash?: SortOrder
    status?: SortOrder
    order?: SortOrder
    supportCat?: SortOrder
    totalClick?: SortOrder
    ssId?: SortOrder
    createDate?: SortOrder
    modifyDate?: SortOrder
  }

  export type supportsSumOrderByAggregateInput = {
    supportId?: SortOrder
    suportCode?: SortOrder
    status?: SortOrder
    order?: SortOrder
    totalClick?: SortOrder
  }

  export type systemfunctiontbCountOrderByAggregateInput = {
    ResourceID?: SortOrder
    Status?: SortOrder
  }

  export type systemfunctiontbAvgOrderByAggregateInput = {
    ResourceID?: SortOrder
    Status?: SortOrder
  }

  export type systemfunctiontbMaxOrderByAggregateInput = {
    ResourceID?: SortOrder
    Status?: SortOrder
  }

  export type systemfunctiontbMinOrderByAggregateInput = {
    ResourceID?: SortOrder
    Status?: SortOrder
  }

  export type systemfunctiontbSumOrderByAggregateInput = {
    ResourceID?: SortOrder
    Status?: SortOrder
  }

  export type systemlogtbCountOrderByAggregateInput = {
    SystemLogId?: SortOrder
    UserId?: SortOrder
    MachineName?: SortOrder
    IPAddress?: SortOrder
    EnterDate?: SortOrder
    EnterTime?: SortOrder
    EndDate?: SortOrder
    EndTime?: SortOrder
    Status?: SortOrder
    Note?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    PriceAppRentID?: SortOrder
    AppRentMoneyUsed?: SortOrder
  }

  export type systemlogtbAvgOrderByAggregateInput = {
    SystemLogId?: SortOrder
    UserId?: SortOrder
    Status?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    PriceAppRentID?: SortOrder
    AppRentMoneyUsed?: SortOrder
  }

  export type systemlogtbMaxOrderByAggregateInput = {
    SystemLogId?: SortOrder
    UserId?: SortOrder
    MachineName?: SortOrder
    IPAddress?: SortOrder
    EnterDate?: SortOrder
    EnterTime?: SortOrder
    EndDate?: SortOrder
    EndTime?: SortOrder
    Status?: SortOrder
    Note?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    PriceAppRentID?: SortOrder
    AppRentMoneyUsed?: SortOrder
  }

  export type systemlogtbMinOrderByAggregateInput = {
    SystemLogId?: SortOrder
    UserId?: SortOrder
    MachineName?: SortOrder
    IPAddress?: SortOrder
    EnterDate?: SortOrder
    EnterTime?: SortOrder
    EndDate?: SortOrder
    EndTime?: SortOrder
    Status?: SortOrder
    Note?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    PriceAppRentID?: SortOrder
    AppRentMoneyUsed?: SortOrder
  }

  export type systemlogtbSumOrderByAggregateInput = {
    SystemLogId?: SortOrder
    UserId?: SortOrder
    Status?: SortOrder
    TimeUsed?: SortOrder
    MoneyUsed?: SortOrder
    PriceAppRentID?: SortOrder
    AppRentMoneyUsed?: SortOrder
  }

  export type trackappdetailtbCountOrderByAggregateInput = {
    TrackAppDetailId?: SortOrder
    AppName?: SortOrder
    UserName?: SortOrder
    TrackingDate?: SortOrder
    TrackingTime?: SortOrder
    TimeTotal?: SortOrder
    AppSession?: SortOrder
    Sent?: SortOrder
    Machine?: SortOrder
    SessionId?: SortOrder
    ETT?: SortOrder
  }

  export type trackappdetailtbAvgOrderByAggregateInput = {
    TrackAppDetailId?: SortOrder
    TimeTotal?: SortOrder
    SessionId?: SortOrder
  }

  export type trackappdetailtbMaxOrderByAggregateInput = {
    TrackAppDetailId?: SortOrder
    AppName?: SortOrder
    UserName?: SortOrder
    TrackingDate?: SortOrder
    TrackingTime?: SortOrder
    TimeTotal?: SortOrder
    AppSession?: SortOrder
    Sent?: SortOrder
    Machine?: SortOrder
    SessionId?: SortOrder
    ETT?: SortOrder
  }

  export type trackappdetailtbMinOrderByAggregateInput = {
    TrackAppDetailId?: SortOrder
    AppName?: SortOrder
    UserName?: SortOrder
    TrackingDate?: SortOrder
    TrackingTime?: SortOrder
    TimeTotal?: SortOrder
    AppSession?: SortOrder
    Sent?: SortOrder
    Machine?: SortOrder
    SessionId?: SortOrder
    ETT?: SortOrder
  }

  export type trackappdetailtbSumOrderByAggregateInput = {
    TrackAppDetailId?: SortOrder
    TimeTotal?: SortOrder
    SessionId?: SortOrder
  }

  export type trackapptbCountOrderByAggregateInput = {
    AppName?: SortOrder
    TrackingType?: SortOrder
  }

  export type trackapptbAvgOrderByAggregateInput = {
    TrackingType?: SortOrder
  }

  export type trackapptbMaxOrderByAggregateInput = {
    AppName?: SortOrder
    TrackingType?: SortOrder
  }

  export type trackapptbMinOrderByAggregateInput = {
    AppName?: SortOrder
    TrackingType?: SortOrder
  }

  export type trackapptbSumOrderByAggregateInput = {
    TrackingType?: SortOrder
  }

  export type trackguitbCountOrderByAggregateInput = {
    ID?: SortOrder
    RecordDate?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
    DialogID?: SortOrder
    PrePath?: SortOrder
    ControlID?: SortOrder
    Type?: SortOrder
    Param?: SortOrder
    ActionCount?: SortOrder
  }

  export type trackguitbAvgOrderByAggregateInput = {
    ID?: SortOrder
    DialogID?: SortOrder
    ControlID?: SortOrder
    Type?: SortOrder
    ActionCount?: SortOrder
  }

  export type trackguitbMaxOrderByAggregateInput = {
    ID?: SortOrder
    RecordDate?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
    DialogID?: SortOrder
    PrePath?: SortOrder
    ControlID?: SortOrder
    Type?: SortOrder
    Param?: SortOrder
    ActionCount?: SortOrder
  }

  export type trackguitbMinOrderByAggregateInput = {
    ID?: SortOrder
    RecordDate?: SortOrder
    FromTime?: SortOrder
    ToTime?: SortOrder
    DialogID?: SortOrder
    PrePath?: SortOrder
    ControlID?: SortOrder
    Type?: SortOrder
    Param?: SortOrder
    ActionCount?: SortOrder
  }

  export type trackguitbSumOrderByAggregateInput = {
    ID?: SortOrder
    DialogID?: SortOrder
    ControlID?: SortOrder
    Type?: SortOrder
    ActionCount?: SortOrder
  }

  export type transferdetailtbCountOrderByAggregateInput = {
    TransferDetailId?: SortOrder
    VoucherId?: SortOrder
    FromUserId?: SortOrder
    ToUserId?: SortOrder
    TransferDate?: SortOrder
    TransferTime?: SortOrder
  }

  export type transferdetailtbAvgOrderByAggregateInput = {
    TransferDetailId?: SortOrder
    VoucherId?: SortOrder
    FromUserId?: SortOrder
    ToUserId?: SortOrder
  }

  export type transferdetailtbMaxOrderByAggregateInput = {
    TransferDetailId?: SortOrder
    VoucherId?: SortOrder
    FromUserId?: SortOrder
    ToUserId?: SortOrder
    TransferDate?: SortOrder
    TransferTime?: SortOrder
  }

  export type transferdetailtbMinOrderByAggregateInput = {
    TransferDetailId?: SortOrder
    VoucherId?: SortOrder
    FromUserId?: SortOrder
    ToUserId?: SortOrder
    TransferDate?: SortOrder
    TransferTime?: SortOrder
  }

  export type transferdetailtbSumOrderByAggregateInput = {
    TransferDetailId?: SortOrder
    VoucherId?: SortOrder
    FromUserId?: SortOrder
    ToUserId?: SortOrder
  }

  export type usagetimetbCountOrderByAggregateInput = {
    UsageTimeId?: SortOrder
    UsageTimeName?: SortOrder
    FromAge?: SortOrder
    ToAge?: SortOrder
    UserType?: SortOrder
  }

  export type usagetimetbAvgOrderByAggregateInput = {
    UsageTimeId?: SortOrder
    FromAge?: SortOrder
    ToAge?: SortOrder
    UserType?: SortOrder
  }

  export type usagetimetbMaxOrderByAggregateInput = {
    UsageTimeId?: SortOrder
    UsageTimeName?: SortOrder
    FromAge?: SortOrder
    ToAge?: SortOrder
    UserType?: SortOrder
  }

  export type usagetimetbMinOrderByAggregateInput = {
    UsageTimeId?: SortOrder
    UsageTimeName?: SortOrder
    FromAge?: SortOrder
    ToAge?: SortOrder
    UserType?: SortOrder
  }

  export type usagetimetbSumOrderByAggregateInput = {
    UsageTimeId?: SortOrder
    FromAge?: SortOrder
    ToAge?: SortOrder
    UserType?: SortOrder
  }

  export type usertbCountOrderByAggregateInput = {
    UserId?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    MiddleName?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    ID?: SortOrder
    Address?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Zipcode?: SortOrder
    Debit?: SortOrder
    CreditLimit?: SortOrder
    Active?: SortOrder
    RecordDate?: SortOrder
    ExpiryDate?: SortOrder
    UserType?: SortOrder
    Memo?: SortOrder
    Birthdate?: SortOrder
    SSN1?: SortOrder
    SSN2?: SortOrder
    SSN3?: SortOrder
    TimePaid?: SortOrder
    TimeUsed?: SortOrder
    MoneyPaid?: SortOrder
    MoneyUsed?: SortOrder
    RemainTime?: SortOrder
    FreeTime?: SortOrder
    TimeTransfer?: SortOrder
    RemainMoney?: SortOrder
    FreeMoney?: SortOrder
    MoneyTransfer?: SortOrder
    UsageTimeId?: SortOrder
    PromotionTime?: SortOrder
    PromotionMoney?: SortOrder
    MachineGroupId?: SortOrder
    MAC?: SortOrder
    changepcdetailId?: SortOrder
    MoneyUsedMin?: SortOrder
    CType?: SortOrder
    Status?: SortOrder
    LastLoginDate?: SortOrder
    PriceAppRentID?: SortOrder
    EIType?: SortOrder
    pc_rptInfo?: SortOrder
  }

  export type usertbAvgOrderByAggregateInput = {
    UserId?: SortOrder
    Debit?: SortOrder
    CreditLimit?: SortOrder
    UserType?: SortOrder
    TimePaid?: SortOrder
    TimeUsed?: SortOrder
    MoneyPaid?: SortOrder
    MoneyUsed?: SortOrder
    RemainTime?: SortOrder
    FreeTime?: SortOrder
    TimeTransfer?: SortOrder
    RemainMoney?: SortOrder
    FreeMoney?: SortOrder
    MoneyTransfer?: SortOrder
    UsageTimeId?: SortOrder
    PromotionTime?: SortOrder
    PromotionMoney?: SortOrder
    MachineGroupId?: SortOrder
    changepcdetailId?: SortOrder
    MoneyUsedMin?: SortOrder
    CType?: SortOrder
    Status?: SortOrder
    PriceAppRentID?: SortOrder
    EIType?: SortOrder
  }

  export type usertbMaxOrderByAggregateInput = {
    UserId?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    MiddleName?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    ID?: SortOrder
    Address?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Zipcode?: SortOrder
    Debit?: SortOrder
    CreditLimit?: SortOrder
    Active?: SortOrder
    RecordDate?: SortOrder
    ExpiryDate?: SortOrder
    UserType?: SortOrder
    Memo?: SortOrder
    Birthdate?: SortOrder
    SSN1?: SortOrder
    SSN2?: SortOrder
    SSN3?: SortOrder
    TimePaid?: SortOrder
    TimeUsed?: SortOrder
    MoneyPaid?: SortOrder
    MoneyUsed?: SortOrder
    RemainTime?: SortOrder
    FreeTime?: SortOrder
    TimeTransfer?: SortOrder
    RemainMoney?: SortOrder
    FreeMoney?: SortOrder
    MoneyTransfer?: SortOrder
    UsageTimeId?: SortOrder
    PromotionTime?: SortOrder
    PromotionMoney?: SortOrder
    MachineGroupId?: SortOrder
    MAC?: SortOrder
    changepcdetailId?: SortOrder
    MoneyUsedMin?: SortOrder
    CType?: SortOrder
    Status?: SortOrder
    LastLoginDate?: SortOrder
    PriceAppRentID?: SortOrder
    EIType?: SortOrder
    pc_rptInfo?: SortOrder
  }

  export type usertbMinOrderByAggregateInput = {
    UserId?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    MiddleName?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    ID?: SortOrder
    Address?: SortOrder
    Phone?: SortOrder
    Email?: SortOrder
    City?: SortOrder
    State?: SortOrder
    Zipcode?: SortOrder
    Debit?: SortOrder
    CreditLimit?: SortOrder
    Active?: SortOrder
    RecordDate?: SortOrder
    ExpiryDate?: SortOrder
    UserType?: SortOrder
    Memo?: SortOrder
    Birthdate?: SortOrder
    SSN1?: SortOrder
    SSN2?: SortOrder
    SSN3?: SortOrder
    TimePaid?: SortOrder
    TimeUsed?: SortOrder
    MoneyPaid?: SortOrder
    MoneyUsed?: SortOrder
    RemainTime?: SortOrder
    FreeTime?: SortOrder
    TimeTransfer?: SortOrder
    RemainMoney?: SortOrder
    FreeMoney?: SortOrder
    MoneyTransfer?: SortOrder
    UsageTimeId?: SortOrder
    PromotionTime?: SortOrder
    PromotionMoney?: SortOrder
    MachineGroupId?: SortOrder
    MAC?: SortOrder
    changepcdetailId?: SortOrder
    MoneyUsedMin?: SortOrder
    CType?: SortOrder
    Status?: SortOrder
    LastLoginDate?: SortOrder
    PriceAppRentID?: SortOrder
    EIType?: SortOrder
    pc_rptInfo?: SortOrder
  }

  export type usertbSumOrderByAggregateInput = {
    UserId?: SortOrder
    Debit?: SortOrder
    CreditLimit?: SortOrder
    UserType?: SortOrder
    TimePaid?: SortOrder
    TimeUsed?: SortOrder
    MoneyPaid?: SortOrder
    MoneyUsed?: SortOrder
    RemainTime?: SortOrder
    FreeTime?: SortOrder
    TimeTransfer?: SortOrder
    RemainMoney?: SortOrder
    FreeMoney?: SortOrder
    MoneyTransfer?: SortOrder
    UsageTimeId?: SortOrder
    PromotionTime?: SortOrder
    PromotionMoney?: SortOrder
    MachineGroupId?: SortOrder
    changepcdetailId?: SortOrder
    MoneyUsedMin?: SortOrder
    CType?: SortOrder
    Status?: SortOrder
    PriceAppRentID?: SortOrder
    EIType?: SortOrder
  }

  export type versiontbCountOrderByAggregateInput = {
    ComputerName?: SortOrder
    Version?: SortOrder
    Type?: SortOrder
    ReleaseDate?: SortOrder
    LastUpdate?: SortOrder
    DPStatus?: SortOrder
    DPType?: SortOrder
    DPVersion?: SortOrder
  }

  export type versiontbAvgOrderByAggregateInput = {
    Type?: SortOrder
    DPStatus?: SortOrder
    DPType?: SortOrder
  }

  export type versiontbMaxOrderByAggregateInput = {
    ComputerName?: SortOrder
    Version?: SortOrder
    Type?: SortOrder
    ReleaseDate?: SortOrder
    LastUpdate?: SortOrder
    DPStatus?: SortOrder
    DPType?: SortOrder
    DPVersion?: SortOrder
  }

  export type versiontbMinOrderByAggregateInput = {
    ComputerName?: SortOrder
    Version?: SortOrder
    Type?: SortOrder
    ReleaseDate?: SortOrder
    LastUpdate?: SortOrder
    DPStatus?: SortOrder
    DPType?: SortOrder
    DPVersion?: SortOrder
  }

  export type versiontbSumOrderByAggregateInput = {
    Type?: SortOrder
    DPStatus?: SortOrder
    DPType?: SortOrder
  }

  export type wallettbCountOrderByAggregateInput = {
    id?: SortOrder
    main?: SortOrder
    sub?: SortOrder
    sub1?: SortOrder
    sub2?: SortOrder
    userid?: SortOrder
    status?: SortOrder
    ts?: SortOrder
    wsec?: SortOrder
    ssec?: SortOrder
  }

  export type wallettbAvgOrderByAggregateInput = {
    id?: SortOrder
    main?: SortOrder
    sub?: SortOrder
    sub1?: SortOrder
    sub2?: SortOrder
    userid?: SortOrder
    status?: SortOrder
    ts?: SortOrder
    wsec?: SortOrder
  }

  export type wallettbMaxOrderByAggregateInput = {
    id?: SortOrder
    main?: SortOrder
    sub?: SortOrder
    sub1?: SortOrder
    sub2?: SortOrder
    userid?: SortOrder
    status?: SortOrder
    ts?: SortOrder
    wsec?: SortOrder
    ssec?: SortOrder
  }

  export type wallettbMinOrderByAggregateInput = {
    id?: SortOrder
    main?: SortOrder
    sub?: SortOrder
    sub1?: SortOrder
    sub2?: SortOrder
    userid?: SortOrder
    status?: SortOrder
    ts?: SortOrder
    wsec?: SortOrder
    ssec?: SortOrder
  }

  export type wallettbSumOrderByAggregateInput = {
    id?: SortOrder
    main?: SortOrder
    sub?: SortOrder
    sub1?: SortOrder
    sub2?: SortOrder
    userid?: SortOrder
    status?: SortOrder
    ts?: SortOrder
    wsec?: SortOrder
  }

  export type webhistorytbCountOrderByAggregateInput = {
    URLId?: SortOrder
    URL?: SortOrder
    RecordDate?: SortOrder
    UserId?: SortOrder
    Machine?: SortOrder
    Active?: SortOrder
    Session?: SortOrder
    AnonymousId?: SortOrder
    BrowserType?: SortOrder
  }

  export type webhistorytbAvgOrderByAggregateInput = {
    URLId?: SortOrder
    UserId?: SortOrder
    Active?: SortOrder
    Session?: SortOrder
    AnonymousId?: SortOrder
  }

  export type webhistorytbMaxOrderByAggregateInput = {
    URLId?: SortOrder
    URL?: SortOrder
    RecordDate?: SortOrder
    UserId?: SortOrder
    Machine?: SortOrder
    Active?: SortOrder
    Session?: SortOrder
    AnonymousId?: SortOrder
    BrowserType?: SortOrder
  }

  export type webhistorytbMinOrderByAggregateInput = {
    URLId?: SortOrder
    URL?: SortOrder
    RecordDate?: SortOrder
    UserId?: SortOrder
    Machine?: SortOrder
    Active?: SortOrder
    Session?: SortOrder
    AnonymousId?: SortOrder
    BrowserType?: SortOrder
  }

  export type webhistorytbSumOrderByAggregateInput = {
    URLId?: SortOrder
    UserId?: SortOrder
    Active?: SortOrder
    Session?: SortOrder
    AnonymousId?: SortOrder
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use accountingentrytbDefaultArgs instead
     */
    export type accountingentrytbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = accountingentrytbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use anonymoustbDefaultArgs instead
     */
    export type anonymoustbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = anonymoustbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use applicationrenttbDefaultArgs instead
     */
    export type applicationrenttbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = applicationrenttbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use applicationtbDefaultArgs instead
     */
    export type applicationtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = applicationtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use blacklisttbDefaultArgs instead
     */
    export type blacklisttbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = blacklisttbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use changepcdetailtbDefaultArgs instead
     */
    export type changepcdetailtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = changepcdetailtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clientatbDefaultArgs instead
     */
    export type clientatbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clientatbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clientsystbDefaultArgs instead
     */
    export type clientsystbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clientsystbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use combodetailtbDefaultArgs instead
     */
    export type combodetailtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = combodetailtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use combodonatetbDefaultArgs instead
     */
    export type combodonatetbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = combodonatetbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use combotbDefaultArgs instead
     */
    export type combotbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = combotbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use combousagetbDefaultArgs instead
     */
    export type combousagetbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = combousagetbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use convertunittbDefaultArgs instead
     */
    export type convertunittbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = convertunittbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use dptbDefaultArgs instead
     */
    export type dptbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = dptbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use freetimedetailtbDefaultArgs instead
     */
    export type freetimedetailtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = freetimedetailtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use functiontbDefaultArgs instead
     */
    export type functiontbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = functiontbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use gamefoldertbDefaultArgs instead
     */
    export type gamefoldertbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = gamefoldertbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use gamelisttbDefaultArgs instead
     */
    export type gamelisttbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = gamelisttbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use hptbDefaultArgs instead
     */
    export type hptbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = hptbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use intoptiontbDefaultArgs instead
     */
    export type intoptiontbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = intoptiontbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inventorytbDefaultArgs instead
     */
    export type inventorytbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = inventorytbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use legalapptbDefaultArgs instead
     */
    export type legalapptbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = legalapptbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use machinegrouptbDefaultArgs instead
     */
    export type machinegrouptbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = machinegrouptbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use paymenttbDefaultArgs instead
     */
    export type paymenttbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = paymenttbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use paymentwaittbDefaultArgs instead
     */
    export type paymentwaittbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = paymentwaittbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use priceapprenttbDefaultArgs instead
     */
    export type priceapprenttbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = priceapprenttbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use priceapprentusetbDefaultArgs instead
     */
    export type priceapprentusetbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = priceapprentusetbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pricedetailtbDefaultArgs instead
     */
    export type pricedetailtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pricedetailtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pricelisttbDefaultArgs instead
     */
    export type pricelisttbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pricelisttbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pricemachinetbDefaultArgs instead
     */
    export type pricemachinetbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pricemachinetbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use printertbDefaultArgs instead
     */
    export type printertbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = printertbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use printservicetbDefaultArgs instead
     */
    export type printservicetbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = printservicetbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use processtbDefaultArgs instead
     */
    export type processtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = processtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rechargecarddetailtbDefaultArgs instead
     */
    export type rechargecarddetailtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rechargecarddetailtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rechargecardtbDefaultArgs instead
     */
    export type rechargecardtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rechargecardtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reportdailyDefaultArgs instead
     */
    export type reportdailyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reportdailyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reportmonthlyDefaultArgs instead
     */
    export type reportmonthlyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reportmonthlyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use righttbDefaultArgs instead
     */
    export type righttbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = righttbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serverlogtbDefaultArgs instead
     */
    export type serverlogtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serverlogtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use servicedetailtbDefaultArgs instead
     */
    export type servicedetailtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = servicedetailtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use servicegiftsbagDefaultArgs instead
     */
    export type servicegiftsbagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = servicegiftsbagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use servicegrouptbDefaultArgs instead
     */
    export type servicegrouptbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = servicegrouptbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serviceinfologtbDefaultArgs instead
     */
    export type serviceinfologtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serviceinfologtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serviceinfotbDefaultArgs instead
     */
    export type serviceinfotbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serviceinfotbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use servicetbDefaultArgs instead
     */
    export type servicetbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = servicetbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use serviceunittbDefaultArgs instead
     */
    export type serviceunittbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = serviceunittbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use servicevisitDefaultArgs instead
     */
    export type servicevisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = servicevisitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use settingtbDefaultArgs instead
     */
    export type settingtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = settingtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use softwaretbDefaultArgs instead
     */
    export type softwaretbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = softwaretbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use specappdetailtbDefaultArgs instead
     */
    export type specappdetailtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = specappdetailtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use standardservicetbDefaultArgs instead
     */
    export type standardservicetbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = standardservicetbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use stocktakingtbDefaultArgs instead
     */
    export type stocktakingtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = stocktakingtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use supportsDefaultArgs instead
     */
    export type supportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = supportsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use systemfunctiontbDefaultArgs instead
     */
    export type systemfunctiontbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = systemfunctiontbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use systemlogtbDefaultArgs instead
     */
    export type systemlogtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = systemlogtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use trackappdetailtbDefaultArgs instead
     */
    export type trackappdetailtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = trackappdetailtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use trackapptbDefaultArgs instead
     */
    export type trackapptbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = trackapptbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use trackguitbDefaultArgs instead
     */
    export type trackguitbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = trackguitbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use transferdetailtbDefaultArgs instead
     */
    export type transferdetailtbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = transferdetailtbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usagetimetbDefaultArgs instead
     */
    export type usagetimetbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usagetimetbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usertbDefaultArgs instead
     */
    export type usertbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usertbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use versiontbDefaultArgs instead
     */
    export type versiontbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = versiontbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use wallettbDefaultArgs instead
     */
    export type wallettbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = wallettbDefaultArgs<ExtArgs>
    /**
     * @deprecated Use webhistorytbDefaultArgs instead
     */
    export type webhistorytbArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = webhistorytbDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}